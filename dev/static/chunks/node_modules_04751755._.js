(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
            case REACT_VIEW_TRANSITION_TYPE:
                return "ViewTransition";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
        isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        if (trackActualOwner) {
            var previousStackTraceLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = 10;
            var debugStackDEV = Error("react-stack-top-frame");
            Error.stackTraceLimit = previousStackTraceLimit;
        } else debugStackDEV = unknownOwnerDebugStack;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStackDEV, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    assign: null,
    searchParamsToUrlQuery: null,
    urlQueryToSearchParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    assign: function() {
        return assign;
    },
    searchParamsToUrlQuery: function() {
        return searchParamsToUrlQuery;
    },
    urlQueryToSearchParams: function() {
        return urlQueryToSearchParams;
    }
});
function searchParamsToUrlQuery(searchParams) {
    const query = {};
    for (const [key, value] of searchParams.entries()){
        const existing = query[key];
        if (typeof existing === 'undefined') {
            query[key] = value;
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            query[key] = [
                existing,
                value
            ];
        }
    }
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
        return String(param);
    } else {
        return '';
    }
}
function urlQueryToSearchParams(query) {
    const searchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query)){
        if (Array.isArray(value)) {
            for (const item of value){
                searchParams.append(key, stringifyUrlQueryParam(item));
            }
        } else {
            searchParams.set(key, stringifyUrlQueryParam(value));
        }
    }
    return searchParams;
}
function assign(target, ...searchParamsList) {
    for (const searchParams of searchParamsList){
        for (const key of searchParams.keys()){
            target.delete(key);
        }
        for (const [key, value] of searchParams.entries()){
            target.append(key, value);
        }
    }
    return target;
} //# sourceMappingURL=querystring.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatUrl: null,
    formatWithValidation: null,
    urlObjectKeys: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatUrl: function() {
        return formatUrl;
    },
    formatWithValidation: function() {
        return formatWithValidation;
    },
    urlObjectKeys: function() {
        return urlObjectKeys;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _querystring = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)"));
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    let { auth, hostname } = urlObj;
    let protocol = urlObj.protocol || '';
    let pathname = urlObj.pathname || '';
    let hash = urlObj.hash || '';
    let query = urlObj.query || '';
    let host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);
        if (urlObj.port) {
            host += ':' + urlObj.port;
        }
    }
    if (query && typeof query === 'object') {
        query = String(_querystring.urlQueryToSearchParams(query));
    }
    let search = urlObj.search || query && `?${query}` || '';
    if (protocol && !protocol.endsWith(':')) protocol += ':';
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }
    if (hash && hash[0] !== '#') hash = '#' + hash;
    if (search && search[0] !== '?') search = '?' + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace('#', '%23');
    return `${protocol}${host}${pathname}${search}${hash}`;
}
const urlObjectKeys = [
    'auth',
    'hash',
    'host',
    'hostname',
    'href',
    'path',
    'pathname',
    'port',
    'protocol',
    'query',
    'search',
    'slashes'
];
function formatWithValidation(url) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (url !== null && typeof url === 'object') {
            Object.keys(url).forEach((key)=>{
                if (!urlObjectKeys.includes(key)) {
                    console.warn(`Unknown key passed via urlObject into url.format: ${key}`);
                }
            });
        }
    }
    return formatUrl(url);
} //# sourceMappingURL=format-url.js.map
}),
"[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(null);
    const cleanupB = (0, _react.useRef)(null);
    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.
    // (this happens often if the user doesn't pass a ref to Link/Form/Image)
    // But this can cause us to leak a cleanup-ref into user code (previously via `<Link legacyBehavior>`),
    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs
    // (because it hasn't been updated for React 19)
    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.
    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.
    return (0, _react.useCallback)((current)=>{
        if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
                cleanupA.current = null;
                cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
                cleanupB.current = null;
                cleanupFnB();
            }
        } else {
            if (refA) {
                cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
                cleanupB.current = applyRef(refB, current);
            }
        }
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}),
"[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DecodeError: null,
    MiddlewareNotFoundError: null,
    MissingStaticPage: null,
    NormalizeError: null,
    PageNotFoundError: null,
    SP: null,
    ST: null,
    WEB_VITALS: null,
    execOnce: null,
    getDisplayName: null,
    getLocationOrigin: null,
    getURL: null,
    isAbsoluteUrl: null,
    isResSent: null,
    loadGetInitialProps: null,
    normalizeRepeatedSlashes: null,
    stringifyError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DecodeError: function() {
        return DecodeError;
    },
    MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
    },
    MissingStaticPage: function() {
        return MissingStaticPage;
    },
    NormalizeError: function() {
        return NormalizeError;
    },
    PageNotFoundError: function() {
        return PageNotFoundError;
    },
    SP: function() {
        return SP;
    },
    ST: function() {
        return ST;
    },
    WEB_VITALS: function() {
        return WEB_VITALS;
    },
    execOnce: function() {
        return execOnce;
    },
    getDisplayName: function() {
        return getDisplayName;
    },
    getLocationOrigin: function() {
        return getLocationOrigin;
    },
    getURL: function() {
        return getURL;
    },
    isAbsoluteUrl: function() {
        return isAbsoluteUrl;
    },
    isResSent: function() {
        return isResSent;
    },
    loadGetInitialProps: function() {
        return loadGetInitialProps;
    },
    normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
    },
    stringifyError: function() {
        return stringifyError;
    }
});
const WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
function execOnce(fn) {
    let used = false;
    let result;
    return (...args)=>{
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol, hostname, port } = window.location;
    return `${protocol}//${hostname}${port ? ':' + port : ''}`;
}
function getURL() {
    const { href } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split('?');
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '');
}
async function loadGetInitialProps(App, ctx) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (App.prototype?.getInitialProps) {
            const message = `"${getDisplayName(App)}.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;
            throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            });
        }
    }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = `"${getDisplayName(App)}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn(`${getDisplayName(App)} returned an empty object from \`getInitialProps\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);
        }
    }
    return props;
}
const SP = typeof performance !== 'undefined';
const ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every((method)=>typeof performance[method] === 'function');
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = 'ENOENT';
        this.name = 'PageNotFoundError';
        this.message = `Cannot find module for page: ${page}`;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = `Failed to load static file for page: ${page} ${message}`;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = 'ENOENT';
        this.message = `Cannot find the middleware module`;
    }
}
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isLocalURL", {
    enumerable: true,
    get: function() {
        return isLocalURL;
    }
});
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)");
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)");
function isLocalURL(url) {
    // prevent a hydration mismatch on href for url with anchor refs
    if (!(0, _utils.isAbsoluteUrl)(url)) return true;
    try {
        // absolute urls can be local if they are on the same origin
        const locationOrigin = (0, _utils.getLocationOrigin)();
        const resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);
    } catch (_) {
        return false;
    }
} //# sourceMappingURL=is-local-url.js.map
}),
"[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "errorOnce", {
    enumerable: true,
    get: function() {
        return errorOnce;
    }
});
let errorOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const errors = new Set();
    errorOnce = (msg)=>{
        if (!errors.has(msg)) {
            console.error(msg);
        }
        errors.add(msg);
    };
} //# sourceMappingURL=error-once.js.map
}),
"[project]/node_modules/next/dist/client/app-dir/link.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    useLinkStatus: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    /**
 * A React component that extends the HTML `<a>` element to provide
 * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)
 * and client-side navigation. This is the primary way to navigate between routes in Next.js.
 *
 * @remarks
 * - Prefetching is only enabled in production.
 *
 * @see https://nextjs.org/docs/app/api-reference/components/link
 */ default: function() {
        return LinkComponent;
    },
    useLinkStatus: function() {
        return useLinkStatus;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _formaturl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)");
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)");
const _islocalurl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-client] (ecmascript)");
const _types = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)");
const _erroronce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-client] (ecmascript)");
function isModifiedEvent(event) {
    const eventTarget = event.currentTarget;
    const target = eventTarget.getAttribute('target');
    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
    event.nativeEvent && event.nativeEvent.which === 2;
}
function linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {
    if (typeof window !== 'undefined') {
        const { nodeName } = e.currentTarget;
        // anchors inside an svg have a lowercase nodeName
        const isAnchorNodeName = nodeName.toUpperCase() === 'A';
        if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {
            // ignore click for browser’s default behavior
            return;
        }
        if (!(0, _islocalurl.isLocalURL)(href)) {
            if (replace) {
                // browser default behavior does not replace the history state
                // so we need to do it manually
                e.preventDefault();
                location.replace(href);
            }
            // ignore click for browser’s default behavior
            return;
        }
        e.preventDefault();
        if (onNavigate) {
            let isDefaultPrevented = false;
            onNavigate({
                preventDefault: ()=>{
                    isDefaultPrevented = true;
                }
            });
            if (isDefaultPrevented) {
                return;
            }
        }
        const { dispatchNavigateAction } = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)");
        _react.default.startTransition(()=>{
            dispatchNavigateAction(as || href, replace ? 'replace' : 'push', scroll ?? true, linkInstanceRef.current);
        });
    }
}
function formatStringOrUrl(urlObjOrString) {
    if (typeof urlObjOrString === 'string') {
        return urlObjOrString;
    }
    return (0, _formaturl.formatUrl)(urlObjOrString);
}
function LinkComponent(props) {
    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);
    let children;
    const linkInstanceRef = (0, _react.useRef)(null);
    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;
    children = childrenProp;
    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {
        children = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            children: children
        });
    }
    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);
    const prefetchEnabled = prefetchProp !== false;
    const fetchStrategy = prefetchProp !== false ? getFetchStrategyFromPrefetchProp(prefetchProp) : _types.FetchStrategy.PPR;
    if ("TURBOPACK compile-time truthy", 1) {
        function createPropError(args) {
            return Object.defineProperty(new Error(`Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.` + (typeof window !== 'undefined' ? "\nOpen your browser's console to view the Component stack trace." : '')), "__NEXT_ERROR_CODE", {
                value: "E319",
                enumerable: false,
                configurable: true
            });
        }
        // TypeScript trick for type-guarding:
        const requiredPropsGuard = {
            href: true
        };
        const requiredProps = Object.keys(requiredPropsGuard);
        requiredProps.forEach((key)=>{
            if (key === 'href') {
                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: props[key] === null ? 'null' : typeof props[key]
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                const _ = key;
            }
        });
        // TypeScript trick for type-guarding:
        const optionalPropsGuard = {
            as: true,
            replace: true,
            scroll: true,
            shallow: true,
            passHref: true,
            prefetch: true,
            unstable_dynamicOnHover: true,
            onClick: true,
            onMouseEnter: true,
            onTouchStart: true,
            legacyBehavior: true,
            onNavigate: true
        };
        const optionalProps = Object.keys(optionalPropsGuard);
        optionalProps.forEach((key)=>{
            const valType = typeof props[key];
            if (key === 'as') {
                if (props[key] && valType !== 'string' && valType !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: valType
                    });
                }
            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {
                if (props[key] && valType !== 'function') {
                    throw createPropError({
                        key,
                        expected: '`function`',
                        actual: valType
                    });
                }
            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {
                if (props[key] != null && valType !== 'boolean') {
                    throw createPropError({
                        key,
                        expected: '`boolean`',
                        actual: valType
                    });
                }
            } else if (key === 'prefetch') {
                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto') {
                    throw createPropError({
                        key,
                        expected: '`boolean | "auto"`',
                        actual: valType
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                const _ = key;
            }
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (props.locale) {
            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');
        }
        if (!asProp) {
            let href;
            if (typeof hrefProp === 'string') {
                href = hrefProp;
            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {
                href = hrefProp.pathname;
            }
            if (href) {
                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));
                if (hasDynamicSegment) {
                    throw Object.defineProperty(new Error(`Dynamic href \`${href}\` found in <Link> while using the \`/app\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`), "__NEXT_ERROR_CODE", {
                        value: "E267",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
    const { href, as } = _react.default.useMemo({
        "LinkComponent.useMemo": ()=>{
            const resolvedHref = formatStringOrUrl(hrefProp);
            return {
                href: resolvedHref,
                as: asProp ? formatStringOrUrl(asProp) : resolvedHref
            };
        }
    }["LinkComponent.useMemo"], [
        hrefProp,
        asProp
    ]);
    // This will return the first child, if multiple are provided it will throw an error
    let child;
    if (legacyBehavior) {
        if (children?.$$typeof === Symbol.for('react.lazy')) {
            throw Object.defineProperty(new Error(`\`<Link legacyBehavior>\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \`<a>\` tag.`), "__NEXT_ERROR_CODE", {
                value: "E863",
                enumerable: false,
                configurable: true
            });
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (onClick) {
                console.warn(`"onClick" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onClick be set on the child of next/link`);
            }
            if (onMouseEnterProp) {
                console.warn(`"onMouseEnter" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`);
            }
            try {
                child = _react.default.Children.only(children);
            } catch (err) {
                if (!children) {
                    throw Object.defineProperty(new Error(`No children were passed to <Link> with \`href\` of \`${hrefProp}\` but one child is required https://nextjs.org/docs/messages/link-no-children`), "__NEXT_ERROR_CODE", {
                        value: "E320",
                        enumerable: false,
                        configurable: true
                    });
                }
                throw Object.defineProperty(new Error(`Multiple children were passed to <Link> with \`href\` of \`${hrefProp}\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + (typeof window !== 'undefined' ? " \nOpen your browser's console to view the Component stack trace." : '')), "__NEXT_ERROR_CODE", {
                    value: "E266",
                    enumerable: false,
                    configurable: true
                });
            }
        } else //TURBOPACK unreachable
        ;
    } else {
        if ("TURBOPACK compile-time truthy", 1) {
            if (children?.type === 'a') {
                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), "__NEXT_ERROR_CODE", {
                    value: "E209",
                    enumerable: false,
                    configurable: true
                });
            }
        }
    }
    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;
    // Use a callback ref to attach an IntersectionObserver to the anchor tag on
    // mount. In the future we will also use this to keep track of all the
    // currently mounted <Link> instances, e.g. so we can re-prefetch them after
    // a revalidation or refresh.
    const observeLinkVisibilityOnMount = _react.default.useCallback({
        "LinkComponent.useCallback[observeLinkVisibilityOnMount]": (element)=>{
            if (router !== null) {
                linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus);
            }
            return ({
                "LinkComponent.useCallback[observeLinkVisibilityOnMount]": ()=>{
                    if (linkInstanceRef.current) {
                        (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);
                        linkInstanceRef.current = null;
                    }
                    (0, _links.unmountPrefetchableInstance)(element);
                }
            })["LinkComponent.useCallback[observeLinkVisibilityOnMount]"];
        }
    }["LinkComponent.useCallback[observeLinkVisibilityOnMount]"], [
        prefetchEnabled,
        href,
        router,
        fetchStrategy,
        setOptimisticLinkStatus
    ]);
    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);
    const childProps = {
        ref: mergedRef,
        onClick (e) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (!e) {
                    throw Object.defineProperty(new Error(`Component rendered inside next/link has to pass click event to "onClick" prop.`), "__NEXT_ERROR_CODE", {
                        value: "E312",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
            if (!legacyBehavior && typeof onClick === 'function') {
                onClick(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {
                child.props.onClick(e);
            }
            if (!router) {
                return;
            }
            if (e.defaultPrevented) {
                return;
            }
            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);
        },
        onMouseEnter (e) {
            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {
                onMouseEnterProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {
                child.props.onMouseEnter(e);
            }
            if (!router) {
                return;
            }
            if ("TURBOPACK compile-time truthy", 1) {
                return;
            }
            //TURBOPACK unreachable
            ;
            const upgradeToDynamicPrefetch = undefined;
        },
        onTouchStart: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : function onTouchStart(e) {
            if (!legacyBehavior && typeof onTouchStartProp === 'function') {
                onTouchStartProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {
                child.props.onTouchStart(e);
            }
            if (!router) {
                return;
            }
            if (!prefetchEnabled) {
                return;
            }
            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;
            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);
        }
    };
    // If the url is absolute, we can bypass the logic to prepend the basePath.
    if ((0, _utils.isAbsoluteUrl)(as)) {
        childProps.href = as;
    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {
        childProps.href = (0, _addbasepath.addBasePath)(as);
    }
    let link;
    if (legacyBehavior) {
        if ("TURBOPACK compile-time truthy", 1) {
            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\n\n' + 'npx @next/codemod@latest new-link .\n\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');
        }
        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);
    } else {
        link = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            ...restProps,
            ...childProps,
            children: children
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {
        value: linkStatus,
        children: link
    });
}
const LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);
const useLinkStatus = ()=>{
    return (0, _react.useContext)(LinkStatusContext);
};
function getFetchStrategyFromPrefetchProp(prefetchProp) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return prefetchProp === null || prefetchProp === 'auto' ? _types.FetchStrategy.PPR : // (although invalid values should've been filtered out by prop validation in dev)
        _types.FetchStrategy.Full;
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=link.js.map
}),
"[project]/node_modules/next/navigation.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)");
}),
"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/buffer") + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}),
"[project]/node_modules/next/dist/compiled/client-only/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[project]/node_modules/pure-rand/lib/esm/generator/RandomGenerator.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generateN",
    ()=>generateN,
    "skipN",
    ()=>skipN,
    "unsafeGenerateN",
    ()=>unsafeGenerateN,
    "unsafeSkipN",
    ()=>unsafeSkipN
]);
function unsafeGenerateN(rng, num) {
    var out = [];
    for(var idx = 0; idx != num; ++idx){
        out.push(rng.unsafeNext());
    }
    return out;
}
function generateN(rng, num) {
    var nextRng = rng.clone();
    var out = unsafeGenerateN(nextRng, num);
    return [
        out,
        nextRng
    ];
}
function unsafeSkipN(rng, num) {
    for(var idx = 0; idx != num; ++idx){
        rng.unsafeNext();
    }
}
function skipN(rng, num) {
    var nextRng = rng.clone();
    unsafeSkipN(nextRng, num);
    return nextRng;
}
}),
"[project]/node_modules/pure-rand/lib/esm/generator/LinearCongruential.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "congruential32",
    ()=>congruential32
]);
var MULTIPLIER = 0x000343fd;
var INCREMENT = 0x00269ec3;
var MASK = 0xffffffff;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function(seed) {
    return seed * MULTIPLIER + INCREMENT & MASK;
};
var computeValueFromNextSeed = function(nextseed) {
    return (nextseed & MASK_2) >> 16;
};
var LinearCongruential32 = function() {
    function LinearCongruential32(seed) {
        this.seed = seed;
    }
    LinearCongruential32.prototype.clone = function() {
        return new LinearCongruential32(this.seed);
    };
    LinearCongruential32.prototype.next = function() {
        var nextRng = new LinearCongruential32(this.seed);
        var out = nextRng.unsafeNext();
        return [
            out,
            nextRng
        ];
    };
    LinearCongruential32.prototype.unsafeNext = function() {
        var s1 = computeNextSeed(this.seed);
        var v1 = computeValueFromNextSeed(s1);
        var s2 = computeNextSeed(s1);
        var v2 = computeValueFromNextSeed(s2);
        this.seed = computeNextSeed(s2);
        var v3 = computeValueFromNextSeed(this.seed);
        var vnext = v3 + (v2 + (v1 << 15) << 15);
        return vnext | 0;
    };
    LinearCongruential32.prototype.getState = function() {
        return [
            this.seed
        ];
    };
    return LinearCongruential32;
}();
function fromState(state) {
    var valid = state.length === 1;
    if (!valid) {
        throw new Error('The state must have been produced by a congruential32 RandomGenerator');
    }
    return new LinearCongruential32(state[0]);
}
var congruential32 = Object.assign(function(seed) {
    return new LinearCongruential32(seed);
}, {
    fromState: fromState
});
}),
"[project]/node_modules/pure-rand/lib/esm/generator/MersenneTwister.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __read = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var MersenneTwister = function() {
    function MersenneTwister(states, index) {
        this.states = states;
        this.index = index;
    }
    MersenneTwister.twist = function(prev) {
        var mt = prev.slice();
        for(var idx = 0; idx !== MersenneTwister.N - MersenneTwister.M; ++idx){
            var y_1 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister.A;
        }
        for(var idx = MersenneTwister.N - MersenneTwister.M; idx !== MersenneTwister.N - 1; ++idx){
            var y_2 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M - MersenneTwister.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister.A;
        }
        var y = (mt[MersenneTwister.N - 1] & MersenneTwister.MASK_UPPER) + (mt[0] & MersenneTwister.MASK_LOWER);
        mt[MersenneTwister.N - 1] = mt[MersenneTwister.M - 1] ^ y >>> 1 ^ -(y & 1) & MersenneTwister.A;
        return mt;
    };
    MersenneTwister.seeded = function(seed) {
        var out = Array(MersenneTwister.N);
        out[0] = seed;
        for(var idx = 1; idx !== MersenneTwister.N; ++idx){
            var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
            out[idx] = Math.imul(MersenneTwister.F, xored) + idx | 0;
        }
        return out;
    };
    MersenneTwister.from = function(seed) {
        return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(seed)), 0);
    };
    MersenneTwister.prototype.clone = function() {
        return new MersenneTwister(this.states, this.index);
    };
    MersenneTwister.prototype.next = function() {
        var nextRng = new MersenneTwister(this.states, this.index);
        var out = nextRng.unsafeNext();
        return [
            out,
            nextRng
        ];
    };
    MersenneTwister.prototype.unsafeNext = function() {
        var y = this.states[this.index];
        y ^= this.states[this.index] >>> MersenneTwister.U;
        y ^= y << MersenneTwister.S & MersenneTwister.B;
        y ^= y << MersenneTwister.T & MersenneTwister.C;
        y ^= y >>> MersenneTwister.L;
        if (++this.index >= MersenneTwister.N) {
            this.states = MersenneTwister.twist(this.states);
            this.index = 0;
        }
        return y;
    };
    MersenneTwister.prototype.getState = function() {
        return __spreadArray([
            this.index
        ], __read(this.states), false);
    };
    MersenneTwister.fromState = function(state) {
        var valid = state.length === MersenneTwister.N + 1 && state[0] >= 0 && state[0] < MersenneTwister.N;
        if (!valid) {
            throw new Error('The state must have been produced by a mersenne RandomGenerator');
        }
        return new MersenneTwister(state.slice(1), state[0]);
    };
    MersenneTwister.N = 624;
    MersenneTwister.M = 397;
    MersenneTwister.R = 31;
    MersenneTwister.A = 0x9908b0df;
    MersenneTwister.F = 1812433253;
    MersenneTwister.U = 11;
    MersenneTwister.S = 7;
    MersenneTwister.B = 0x9d2c5680;
    MersenneTwister.T = 15;
    MersenneTwister.C = 0xefc60000;
    MersenneTwister.L = 18;
    MersenneTwister.MASK_LOWER = Math.pow(2, MersenneTwister.R) - 1;
    MersenneTwister.MASK_UPPER = Math.pow(2, MersenneTwister.R);
    return MersenneTwister;
}();
function fromState(state) {
    return MersenneTwister.fromState(state);
}
const __TURBOPACK__default__export__ = Object.assign(function(seed) {
    return MersenneTwister.from(seed);
}, {
    fromState: fromState
});
}),
"[project]/node_modules/pure-rand/lib/esm/generator/XorShift.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "xorshift128plus",
    ()=>xorshift128plus
]);
var XorShift128Plus = function() {
    function XorShift128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XorShift128Plus.prototype.clone = function() {
        return new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XorShift128Plus.prototype.next = function() {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [
            out,
            nextRng
        ];
    };
    XorShift128Plus.prototype.unsafeNext = function() {
        var a0 = this.s00 ^ this.s00 << 23;
        var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
        var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
        var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
        var out = this.s00 + this.s10 | 0;
        this.s01 = this.s11;
        this.s00 = this.s10;
        this.s11 = b1;
        this.s10 = b0;
        return out;
    };
    XorShift128Plus.prototype.jump = function() {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XorShift128Plus.prototype.unsafeJump = function() {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [
            0x635d2dff,
            0x8a5cd789,
            0x5c472f96,
            0x121fd215
        ];
        for(var i = 0; i !== 4; ++i){
            for(var mask = 1; mask; mask <<= 1){
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    XorShift128Plus.prototype.getState = function() {
        return [
            this.s01,
            this.s00,
            this.s11,
            this.s10
        ];
    };
    return XorShift128Plus;
}();
function fromState(state) {
    var valid = state.length === 4;
    if (!valid) {
        throw new Error('The state must have been produced by a xorshift128plus RandomGenerator');
    }
    return new XorShift128Plus(state[0], state[1], state[2], state[3]);
}
var xorshift128plus = Object.assign(function(seed) {
    return new XorShift128Plus(-1, ~seed, seed | 0, 0);
}, {
    fromState: fromState
});
}),
"[project]/node_modules/pure-rand/lib/esm/generator/XoroShiro.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "xoroshiro128plus",
    ()=>xoroshiro128plus
]);
var XoroShiro128Plus = function() {
    function XoroShiro128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XoroShiro128Plus.prototype.clone = function() {
        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XoroShiro128Plus.prototype.next = function() {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [
            out,
            nextRng
        ];
    };
    XoroShiro128Plus.prototype.unsafeNext = function() {
        var out = this.s00 + this.s10 | 0;
        var a0 = this.s10 ^ this.s00;
        var a1 = this.s11 ^ this.s01;
        var s00 = this.s00;
        var s01 = this.s01;
        this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
        this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
        this.s10 = a1 << 5 ^ a0 >>> 27;
        this.s11 = a0 << 5 ^ a1 >>> 27;
        return out;
    };
    XoroShiro128Plus.prototype.jump = function() {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XoroShiro128Plus.prototype.unsafeJump = function() {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [
            0xd8f554a5,
            0xdf900294,
            0x4b3201fc,
            0x170865df
        ];
        for(var i = 0; i !== 4; ++i){
            for(var mask = 1; mask; mask <<= 1){
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    XoroShiro128Plus.prototype.getState = function() {
        return [
            this.s01,
            this.s00,
            this.s11,
            this.s10
        ];
    };
    return XoroShiro128Plus;
}();
function fromState(state) {
    var valid = state.length === 4;
    if (!valid) {
        throw new Error('The state must have been produced by a xoroshiro128plus RandomGenerator');
    }
    return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
var xoroshiro128plus = Object.assign(function(seed) {
    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, {
    fromState: fromState
});
}),
"[project]/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addArrayIntToNew",
    ()=>addArrayIntToNew,
    "addOneToPositiveArrayInt",
    ()=>addOneToPositiveArrayInt,
    "fromNumberToArrayInt64",
    ()=>fromNumberToArrayInt64,
    "substractArrayInt64",
    ()=>substractArrayInt64,
    "substractArrayIntToNew",
    ()=>substractArrayIntToNew,
    "trimArrayIntInplace",
    ()=>trimArrayIntInplace
]);
function addArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return substractArrayIntToNew(arrayIntA, {
            sign: -arrayIntB.sign,
            data: arrayIntB.data
        });
    }
    var data = [];
    var reminder = 0;
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    for(var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB){
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA + vB + reminder;
        data.push(current >>> 0);
        reminder = ~~(current / 0x100000000);
    }
    if (reminder !== 0) {
        data.push(reminder);
    }
    return {
        sign: arrayIntA.sign,
        data: data.reverse()
    };
}
function addOneToPositiveArrayInt(arrayInt) {
    arrayInt.sign = 1;
    var data = arrayInt.data;
    for(var index = data.length - 1; index >= 0; --index){
        if (data[index] === 0xffffffff) {
            data[index] = 0;
        } else {
            data[index] += 1;
            return arrayInt;
        }
    }
    data.unshift(1);
    return arrayInt;
}
function isStrictlySmaller(dataA, dataB) {
    var maxLength = Math.max(dataA.length, dataB.length);
    for(var index = 0; index < maxLength; ++index){
        var indexA = index + dataA.length - maxLength;
        var indexB = index + dataB.length - maxLength;
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        if (vA < vB) return true;
        if (vA > vB) return false;
    }
    return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return addArrayIntToNew(arrayIntA, {
            sign: -arrayIntB.sign,
            data: arrayIntB.data
        });
    }
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    if (isStrictlySmaller(dataA, dataB)) {
        var out = substractArrayIntToNew(arrayIntB, arrayIntA);
        out.sign = -out.sign;
        return out;
    }
    var data = [];
    var reminder = 0;
    for(var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB){
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA - vB - reminder;
        data.push(current >>> 0);
        reminder = current < 0 ? 1 : 0;
    }
    return {
        sign: arrayIntA.sign,
        data: data.reverse()
    };
}
function trimArrayIntInplace(arrayInt) {
    var data = arrayInt.data;
    var firstNonZero = 0;
    for(; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero){}
    if (firstNonZero === data.length) {
        arrayInt.sign = 1;
        arrayInt.data = [
            0
        ];
        return arrayInt;
    }
    data.splice(0, firstNonZero);
    return arrayInt;
}
function fromNumberToArrayInt64(out, n) {
    if (n < 0) {
        var posN = -n;
        out.sign = -1;
        out.data[0] = ~~(posN / 0x100000000);
        out.data[1] = posN >>> 0;
    } else {
        out.sign = 1;
        out.data[0] = ~~(n / 0x100000000);
        out.data[1] = n >>> 0;
    }
    return out;
}
function substractArrayInt64(out, arrayIntA, arrayIntB) {
    var lowA = arrayIntA.data[1];
    var highA = arrayIntA.data[0];
    var signA = arrayIntA.sign;
    var lowB = arrayIntB.data[1];
    var highB = arrayIntB.data[0];
    var signB = arrayIntB.sign;
    out.sign = 1;
    if (signA === 1 && signB === -1) {
        var low_1 = lowA + lowB;
        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);
        out.data[0] = high >>> 0;
        out.data[1] = low_1 >>> 0;
        return out;
    }
    var lowFirst = lowA;
    var highFirst = highA;
    var lowSecond = lowB;
    var highSecond = highB;
    if (signA === -1) {
        lowFirst = lowB;
        highFirst = highB;
        lowSecond = lowA;
        highSecond = highA;
    }
    var reminderLow = 0;
    var low = lowFirst - lowSecond;
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    out.data[0] = highFirst - highSecond - reminderLow;
    out.data[1] = low;
    return out;
}
}),
"[project]/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unsafeUniformIntDistributionInternal",
    ()=>unsafeUniformIntDistributionInternal
]);
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
    var MaxAllowed = rangeSize > 2 ? ~~(0x100000000 / rangeSize) * rangeSize : 0x100000000;
    var deltaV = rng.unsafeNext() + 0x80000000;
    while(deltaV >= MaxAllowed){
        deltaV = rng.unsafeNext() + 0x80000000;
    }
    return deltaV % rangeSize;
}
}),
"[project]/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unsafeUniformArrayIntDistributionInternal",
    ()=>unsafeUniformArrayIntDistributionInternal
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$UnsafeUniformIntDistributionInternal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js [app-client] (ecmascript)");
;
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
    var rangeLength = rangeSize.length;
    while(true){
        for(var index = 0; index !== rangeLength; ++index){
            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;
            var g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$UnsafeUniformIntDistributionInternal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformIntDistributionInternal"])(indexRangeSize, rng);
            out[index] = g;
        }
        for(var index = 0; index !== rangeLength; ++index){
            var current = out[index];
            var currentInRange = rangeSize[index];
            if (current < currentInRange) {
                return out;
            } else if (current > currentInRange) {
                break;
            }
        }
    }
}
}),
"[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unsafeUniformArrayIntDistribution",
    ()=>unsafeUniformArrayIntDistribution
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$UnsafeUniformArrayIntDistributionInternal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js [app-client] (ecmascript)");
;
;
function unsafeUniformArrayIntDistribution(from, to, rng) {
    var rangeSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trimArrayIntInplace"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addOneToPositiveArrayInt"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["substractArrayIntToNew"])(to, from)));
    var emptyArrayIntData = rangeSize.data.slice(0);
    var g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$UnsafeUniformArrayIntDistributionInternal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformArrayIntDistributionInternal"])(emptyArrayIntData, rangeSize.data, rng);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trimArrayIntInplace"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addArrayIntToNew"])({
        sign: 1,
        data: g
    }, from));
}
}),
"[project]/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "uniformArrayIntDistribution",
    ()=>uniformArrayIntDistribution
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformArrayIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js [app-client] (ecmascript)");
;
function uniformArrayIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformArrayIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformArrayIntDistribution"])(from, to, nextRng),
            nextRng
        ];
    }
    return function(rng) {
        var nextRng = rng.clone();
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformArrayIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformArrayIntDistribution"])(from, to, nextRng),
            nextRng
        ];
    };
}
;
}),
"[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unsafeUniformBigIntDistribution",
    ()=>unsafeUniformBigIntDistribution
]);
var SBigInt = typeof BigInt !== 'undefined' ? BigInt : undefined;
function unsafeUniformBigIntDistribution(from, to, rng) {
    var diff = to - from + SBigInt(1);
    var MinRng = SBigInt(-0x80000000);
    var NumValues = SBigInt(0x100000000);
    var FinalNumValues = NumValues;
    var NumIterations = 1;
    while(FinalNumValues < diff){
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff;
    while(true){
        var value = SBigInt(0);
        for(var num = 0; num !== NumIterations; ++num){
            var out = rng.unsafeNext();
            value = NumValues * value + (SBigInt(out) - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value % diff;
            return inDiff + from;
        }
    }
}
}),
"[project]/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "uniformBigIntDistribution",
    ()=>uniformBigIntDistribution
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformBigIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js [app-client] (ecmascript)");
;
function uniformBigIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformBigIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformBigIntDistribution"])(from, to, nextRng),
            nextRng
        ];
    }
    return function(rng) {
        var nextRng = rng.clone();
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformBigIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformBigIntDistribution"])(from, to, nextRng),
            nextRng
        ];
    };
}
;
}),
"[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unsafeUniformIntDistribution",
    ()=>unsafeUniformIntDistribution
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$UnsafeUniformIntDistributionInternal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$UnsafeUniformArrayIntDistributionInternal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js [app-client] (ecmascript)");
;
;
;
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = {
    sign: 1,
    data: [
        0,
        0
    ]
};
var sharedB = {
    sign: 1,
    data: [
        0,
        0
    ]
};
var sharedC = {
    sign: 1,
    data: [
        0,
        0
    ]
};
var sharedData = [
    0,
    0
];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
    var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromNumberToArrayInt64"])(sharedC, rangeSize) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["substractArrayInt64"])(sharedC, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromNumberToArrayInt64"])(sharedA, to), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$ArrayInt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromNumberToArrayInt64"])(sharedB, from));
    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {
        rangeSizeArrayIntValue.data[0] += 1;
        rangeSizeArrayIntValue.data[1] = 0;
    } else {
        rangeSizeArrayIntValue.data[1] += 1;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$UnsafeUniformArrayIntDistributionInternal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformArrayIntDistributionInternal"])(sharedData, rangeSizeArrayIntValue.data, rng);
    return sharedData[0] * 0x100000000 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
    var rangeSize = to - from;
    if (rangeSize <= 0xffffffff) {
        var g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$internals$2f$UnsafeUniformIntDistributionInternal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformIntDistributionInternal"])(rangeSize + 1, rng);
        return g + from;
    }
    return uniformLargeIntInternal(from, to, rangeSize, rng);
}
}),
"[project]/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "uniformIntDistribution",
    ()=>uniformIntDistribution
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js [app-client] (ecmascript)");
;
function uniformIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformIntDistribution"])(from, to, nextRng),
            nextRng
        ];
    }
    return function(rng) {
        var nextRng = rng.clone();
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformIntDistribution"])(from, to, nextRng),
            nextRng
        ];
    };
}
;
}),
"[project]/node_modules/pure-rand/lib/esm/pure-rand-default.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__commitHash",
    ()=>__commitHash,
    "__type",
    ()=>__type,
    "__version",
    ()=>__version
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$RandomGenerator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/RandomGenerator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$LinearCongruential$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/LinearCongruential.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$MersenneTwister$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/MersenneTwister.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$XorShift$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/XorShift.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$XoroShiro$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/XoroShiro.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UniformArrayIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UniformBigIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UniformIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformArrayIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformBigIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
var __type = 'module';
var __version = '6.1.0';
var __commitHash = 'a413dd2b721516be2ef29adffb515c5ae67bfbad';
;
}),
"[project]/node_modules/pure-rand/lib/esm/pure-rand-default.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__commitHash",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$pure$2d$rand$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["__commitHash"],
    "__type",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$pure$2d$rand$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["__type"],
    "__version",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$pure$2d$rand$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["__version"],
    "congruential32",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$LinearCongruential$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["congruential32"],
    "generateN",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$RandomGenerator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateN"],
    "mersenne",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$MersenneTwister$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    "skipN",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$RandomGenerator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipN"],
    "uniformArrayIntDistribution",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UniformArrayIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uniformArrayIntDistribution"],
    "uniformBigIntDistribution",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UniformBigIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uniformBigIntDistribution"],
    "uniformIntDistribution",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UniformIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uniformIntDistribution"],
    "unsafeGenerateN",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$RandomGenerator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeGenerateN"],
    "unsafeSkipN",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$RandomGenerator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeSkipN"],
    "unsafeUniformArrayIntDistribution",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformArrayIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformArrayIntDistribution"],
    "unsafeUniformBigIntDistribution",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformBigIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformBigIntDistribution"],
    "unsafeUniformIntDistribution",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeUniformIntDistribution"],
    "xoroshiro128plus",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$XoroShiro$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["xoroshiro128plus"],
    "xorshift128plus",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$XorShift$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["xorshift128plus"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$pure$2d$rand$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/pure-rand-default.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$RandomGenerator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/RandomGenerator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$LinearCongruential$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/LinearCongruential.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$MersenneTwister$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/MersenneTwister.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$XorShift$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/XorShift.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$generator$2f$XoroShiro$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/generator/XoroShiro.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UniformArrayIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UniformBigIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UniformIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformArrayIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformBigIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$distribution$2f$UnsafeUniformIntDistribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js [app-client] (ecmascript)");
}),
"[project]/node_modules/pure-rand/lib/esm/pure-rand.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$pure$2d$rand$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/pure-rand-default.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$pure$2d$rand$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pure-rand/lib/esm/pure-rand-default.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pure$2d$rand$2f$lib$2f$esm$2f$pure$2d$rand$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__;
;
}),
"[project]/node_modules/@lucid-evolution/core-utils/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/core-utils.ts
__turbopack_context__.s([
    "fromHex",
    ()=>fromHex,
    "fromText",
    ()=>fromText,
    "isBytes",
    ()=>isBytes,
    "sleep",
    ()=>sleep,
    "toHex",
    ()=>toHex,
    "toText",
    ()=>toText
]);
function assert_bytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
var asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
var hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
function fromHex(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
function toHex(bytes) {
    assert_bytes(bytes);
    let hex = "";
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
function toText(hex) {
    return new TextDecoder().decode(fromHex(hex)).toString();
}
function fromText(text) {
    return toHex(new TextEncoder().encode(text));
}
var sleep = (ms = 1e3)=>new Promise((r)=>setTimeout(r, ms));
;
}),
"[project]/node_modules/@lucid-evolution/plutus/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "Constr",
    ()=>Constr,
    "Data",
    ()=>Data,
    "SLOT_CONFIG_NETWORK",
    ()=>SLOT_CONFIG_NETWORK,
    "slotToBeginUnixTime",
    ()=>slotToBeginUnixTime,
    "unixTimeToEnclosingSlot",
    ()=>unixTimeToEnclosingSlot
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@sinclair/typebox/build/esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sinclair/typebox/build/esm/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/core-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@anastasia-labs/cardano-multiplatform-lib-browser/cardano_multiplatform_lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@anastasia-labs/cardano-multiplatform-lib-browser/cardano_multiplatform_lib_bg.js [app-client] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to2, from2, except, desc)=>{
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
        for (let key of __getOwnPropNames(from2))if (!__hasOwnProp.call(to2, key) && key !== except) __defProp(to2, key, {
            get: ()=>from2[key],
            enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable
        });
    }
    return to2;
};
var __reExport = (target, mod, secondTarget)=>(__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Constr: ()=>Constr,
    Data: ()=>Data,
    SLOT_CONFIG_NETWORK: ()=>SLOT_CONFIG_NETWORK,
    slotToBeginUnixTime: ()=>slotToBeginUnixTime,
    unixTimeToEnclosingSlot: ()=>unixTimeToEnclosingSlot
});
// src/data.ts
var data_exports = {};
__export(data_exports, {
    Constr: ()=>Constr,
    Data: ()=>Data
});
__reExport(data_exports, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__);
;
;
;
;
var Constr = class {
    index;
    fields;
    constructor(index, fields){
        this.index = index;
        this.fields = fields;
    }
};
var Data = {
    // Types
    // Note: Recursive types are not supported (yet)
    Integer: function(options) {
        const integer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Unsafe({
            dataType: "integer"
        });
        if (options) {
            Object.entries(options).forEach(([key, value])=>{
                integer[key] = value;
            });
        }
        return integer;
    },
    Bytes: function(options) {
        const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Unsafe({
            dataType: "bytes"
        });
        if (options) {
            Object.entries(options).forEach(([key, value])=>{
                bytes[key] = value;
            });
        }
        return bytes;
    },
    Boolean: function() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Unsafe({
            anyOf: [
                {
                    title: "False",
                    dataType: "constructor",
                    index: 0,
                    fields: []
                },
                {
                    title: "True",
                    dataType: "constructor",
                    index: 1,
                    fields: []
                }
            ]
        });
    },
    Any: function() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Unsafe({
            description: "Any Data."
        });
    },
    Array: function(items, options) {
        const array = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Array(items);
        replaceProperties(array, {
            dataType: "list",
            items
        });
        if (options) {
            Object.entries(options).forEach(([key, value])=>{
                array[key] = value;
            });
        }
        return array;
    },
    Map: function(keys, values, options) {
        const map = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Unsafe({
            dataType: "map",
            keys,
            values
        });
        if (options) {
            Object.entries(options).forEach(([key, value])=>{
                map[key] = value;
            });
        }
        return map;
    },
    /**
   * Object applies by default a PlutusData Constr with index 0.\
   * Set 'hasConstr' to false to serialize Object as PlutusData List.
   */ Object: function(properties, options) {
        const object = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Object(properties);
        replaceProperties(object, {
            anyOf: [
                {
                    dataType: "constructor",
                    index: 0,
                    // Will be replaced when using Data.Enum
                    fields: Object.entries(properties).map(([title, p])=>({
                            ...p,
                            title
                        }))
                }
            ]
        });
        object.anyOf[0].hasConstr = typeof options?.hasConstr === "undefined" || options.hasConstr;
        return object;
    },
    Enum: function(items) {
        const union = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Union(items);
        replaceProperties(union, {
            anyOf: items.map((item, index)=>item.anyOf[0].fields.length === 0 ? {
                    ...item.anyOf[0],
                    index
                } : {
                    dataType: "constructor",
                    title: (()=>{
                        const title = item.anyOf[0].fields[0].title;
                        if (title.charAt(0) !== title.charAt(0).toUpperCase()) {
                            throw new Error(`Enum '${title}' needs to start with an uppercase letter.`);
                        }
                        return item.anyOf[0].fields[0].title;
                    })(),
                    index,
                    fields: item.anyOf[0].fields[0].items || item.anyOf[0].fields[0].anyOf[0].fields
                })
        });
        return union;
    },
    /**
   * Tuple is by default a PlutusData List.\
   * Set 'hasConstr' to true to apply a PlutusData Constr with index 0.
   */ Tuple: function(items, options) {
        const tuple = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Tuple(items);
        replaceProperties(tuple, {
            dataType: "list",
            items
        });
        if (options) {
            Object.entries(options).forEach(([key, value])=>{
                tuple[key] = value;
            });
        }
        return tuple;
    },
    Literal: function(title) {
        if (title.charAt(0) !== title.charAt(0).toUpperCase()) {
            throw new Error(`Enum '${title}' needs to start with an uppercase letter.`);
        }
        const literal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Literal(title);
        replaceProperties(literal, {
            anyOf: [
                {
                    dataType: "constructor",
                    title,
                    index: 0,
                    // Will be replaced in Data.Enum
                    fields: []
                }
            ]
        });
        return literal;
    },
    Nullable: function(item) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sinclair$2f$typebox$2f$build$2f$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Type.Unsafe({
            anyOf: [
                {
                    title: "Some",
                    description: "An optional value.",
                    dataType: "constructor",
                    index: 0,
                    fields: [
                        item
                    ]
                },
                {
                    title: "None",
                    description: "Nothing.",
                    dataType: "constructor",
                    index: 1,
                    fields: []
                }
            ]
        });
    },
    /**
   * Convert PlutusData to Cbor encoded data.\
   * Or apply a shape and convert the provided data struct to Cbor encoded data.
   */ to,
    /** Convert Cbor encoded data to PlutusData */ from,
    /**
   * Note Constr cannot be used here.\
   * Strings prefixed with '0x' are not UTF-8 encoded.
   */ fromJson,
    /**
   * Note Constr cannot be used here, also only bytes/integers as Json keys.\
   */ toJson,
    void: function() {
        return "d87980";
    },
    castFrom,
    castTo
};
function to(data, type, options = {}) {
    const { canonical = false } = options;
    function serialize(data2) {
        try {
            if (typeof data2 === "bigint") {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_integer(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigInteger"].from_str(data2.toString()));
            } else if (typeof data2 === "string") {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_bytes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(data2));
            } else if (data2 instanceof Constr) {
                const { index, fields } = data2;
                const plutusList = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusDataList"].new();
                fields.forEach((field)=>plutusList.add(serialize(field)));
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_constr_plutus_data(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConstrPlutusData"].new(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigInteger"].from_str(index.toString()).as_u64(), plutusList));
            } else if (data2 instanceof Array) {
                const plutusList = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusDataList"].new();
                data2.forEach((arg)=>plutusList.add(serialize(arg)));
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_list(plutusList);
            } else if (data2 instanceof Map) {
                const plutusMap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusMap"].new();
                for (const [key, value] of data2.entries()){
                    plutusMap.set(serialize(key), serialize(value));
                }
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_map(plutusMap);
            }
            throw new Error("Unsupported type");
        } catch (error) {
            throw new Error("Could not serialize the data: " + error);
        }
    }
    const d = type ? castTo(data, type) : data;
    return canonical ? serialize(d).to_canonical_cbor_hex() : serialize(d).to_cardano_node_format().to_cbor_hex();
}
function from(raw, type) {
    function deserialize(data2) {
        if (data2.kind() === 0) {
            const constr = data2.as_constr_plutus_data();
            const l = constr.fields();
            const desL = [];
            for(let i = 0; i < l.len(); i++){
                desL.push(deserialize(l.get(i)));
            }
            return new Constr(parseInt(constr.alternative().toString()), desL);
        } else if (data2.kind() === 1) {
            const m = data2.as_map();
            const desM = /* @__PURE__ */ new Map();
            const keys = m.keys();
            for(let i = 0; i < keys.len(); i++){
                desM.set(deserialize(keys.get(i)), deserialize(m.get(keys.get(i))));
            }
            return desM;
        } else if (data2.kind() === 2) {
            const l = data2.as_list();
            const desL = [];
            for(let i = 0; i < l.len(); i++){
                desL.push(deserialize(l.get(i)));
            }
            return desL;
        } else if (data2.kind() === 3) {
            return BigInt(data2.as_integer().to_str());
        } else if (data2.kind() === 4) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(data2.as_bytes());
        }
        throw new Error("Unsupported type");
    }
    const data = deserialize(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].from_cbor_hex(raw));
    return type ? castFrom(data, type) : data;
}
function fromJson(json) {
    function toData(json2) {
        if (typeof json2 === "string") {
            return json2.startsWith("0x") ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(json2.slice(2))) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromText"])(json2);
        }
        if (typeof json2 === "number") return BigInt(json2);
        if (typeof json2 === "bigint") return json2;
        if (json2 instanceof Array) return json2.map((v)=>toData(v));
        if (json2 instanceof Object) {
            const tempMap = /* @__PURE__ */ new Map();
            Object.entries(json2).forEach(([key, value])=>{
                tempMap.set(toData(key), toData(value));
            });
            return tempMap;
        }
        throw new Error("Unsupported type");
    }
    return toData(json);
}
function toJson(plutusData) {
    function fromData(data) {
        if (typeof data === "bigint" || typeof data === "number" || typeof data === "string" && !isNaN(parseInt(data)) && data.slice(-1) === "n") {
            const bigint = typeof data === "string" ? BigInt(data.slice(0, -1)) : data;
            return parseInt(bigint.toString());
        }
        if (typeof data === "string") {
            try {
                return new TextDecoder(void 0, {
                    fatal: true
                }).decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(data));
            } catch (_) {
                return "0x" + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(data));
            }
        }
        if (data instanceof Array) return data.map((v)=>fromData(v));
        if (data instanceof Map) {
            const tempJson = {};
            data.forEach((value, key)=>{
                const convertedKey = fromData(key);
                if (typeof convertedKey !== "string" && typeof convertedKey !== "number") {
                    throw new Error("Unsupported type (Note: Only bytes or integers can be keys of a JSON object)");
                }
                tempJson[convertedKey] = fromData(value);
            });
            return tempJson;
        }
        throw new Error("Unsupported type (Note: Constructor cannot be converted to JSON)");
    }
    return fromData(plutusData);
}
function castFrom(data, type) {
    const shape = type;
    if (!shape) throw new Error("Could not type cast data.");
    const shapeType = (shape.anyOf ? "enum" : "") || shape.dataType;
    switch(shapeType){
        case "integer":
            {
                if (typeof data !== "bigint") {
                    throw new Error("Could not type cast to integer.");
                }
                integerConstraints(data, shape);
                return data;
            }
        case "bytes":
            {
                if (typeof data !== "string") {
                    throw new Error("Could not type cast to bytes.");
                }
                bytesConstraints(data, shape);
                return data;
            }
        case "constructor":
            {
                if (isVoid(shape)) {
                    if (!(data instanceof Constr) || data.index !== 0 || data.fields.length !== 0) {
                        throw new Error("Could not type cast to void.");
                    }
                    return void 0;
                } else if (data instanceof Constr && data.index === shape.index && (shape.hasConstr || shape.hasConstr === void 0)) {
                    const fields = {};
                    if (shape.fields.length !== data.fields.length) {
                        throw new Error("Could not type cast to object. Fields do not match.");
                    }
                    shape.fields.forEach((field, fieldIndex)=>{
                        const title = field.title || "wrapper";
                        if (/[A-Z]/.test(title[0])) {
                            throw new Error("Could not type cast to object. Object properties need to start with a lowercase letter.");
                        }
                        fields[title] = castFrom(data.fields[fieldIndex], field);
                    });
                    return fields;
                } else if (data instanceof Array && !shape.hasConstr && shape.hasConstr !== void 0) {
                    const fields = {};
                    if (shape.fields.length !== data.length) {
                        throw new Error("Could not ype cast to object. Fields do not match.");
                    }
                    shape.fields.forEach((field, fieldIndex)=>{
                        const title = field.title || "wrapper";
                        if (/[A-Z]/.test(title[0])) {
                            throw new Error("Could not type cast to object. Object properties need to start with a lowercase letter.");
                        }
                        fields[title] = castFrom(data[fieldIndex], field);
                    });
                    return fields;
                }
                throw new Error("Could not type cast to object.");
            }
        case "enum":
            {
                if (shape.anyOf.length === 1) {
                    return castFrom(data, shape.anyOf[0]);
                }
                if (!(data instanceof Constr)) {
                    throw new Error("Could not type cast to enum.");
                }
                const enumShape = shape.anyOf.find((entry)=>entry.index === data.index);
                if (!enumShape || enumShape.fields.length !== data.fields.length) {
                    throw new Error("Could not type cast to enum.");
                }
                if (isBoolean(shape)) {
                    if (data.fields.length !== 0) {
                        throw new Error("Could not type cast to boolean.");
                    }
                    switch(data.index){
                        case 0:
                            return false;
                        case 1:
                            return true;
                    }
                    throw new Error("Could not type cast to boolean.");
                } else if (isNullable(shape)) {
                    switch(data.index){
                        case 0:
                            {
                                if (data.fields.length !== 1) {
                                    throw new Error("Could not type cast to nullable object.");
                                }
                                return castFrom(data.fields[0], shape.anyOf[0].fields[0]);
                            }
                        case 1:
                            {
                                if (data.fields.length !== 0) {
                                    throw new Error("Could not type cast to nullable object.");
                                }
                                return null;
                            }
                    }
                    throw new Error("Could not type cast to nullable object.");
                }
                switch(enumShape.dataType){
                    case "constructor":
                        {
                            if (enumShape.fields.length === 0) {
                                if (/[A-Z]/.test(enumShape.title[0])) {
                                    return enumShape.title;
                                }
                                throw new Error("Could not type cast to enum.");
                            } else {
                                if (!/[A-Z]/.test(enumShape.title)) {
                                    throw new Error("Could not type cast to enum. Enums need to start with an uppercase letter.");
                                }
                                if (enumShape.fields.length !== data.fields.length) {
                                    throw new Error("Could not type cast to enum.");
                                }
                                const args = enumShape.fields[0].title ? Object.fromEntries(enumShape.fields.map((field, index)=>[
                                        field.title,
                                        castFrom(data.fields[index], field)
                                    ])) : enumShape.fields.map((field, index)=>castFrom(data.fields[index], field));
                                return {
                                    [enumShape.title]: args
                                };
                            }
                        }
                }
                throw new Error("Could not type cast to enum.");
            }
        case "list":
            {
                if (shape.items instanceof Array) {
                    if (data instanceof Constr && data.index === 0 && shape.hasConstr) {
                        return data.fields.map((field, index)=>castFrom(field, shape.items[index]));
                    } else if (data instanceof Array && !shape.hasConstr) {
                        return data.map((field, index)=>castFrom(field, shape.items[index]));
                    }
                    throw new Error("Could not type cast to tuple.");
                } else {
                    if (!(data instanceof Array)) {
                        throw new Error("Could not type cast to array.");
                    }
                    listConstraints(data, shape);
                    return data.map((field)=>castFrom(field, shape.items));
                }
            }
        case "map":
            {
                if (!(data instanceof Map)) {
                    throw new Error("Could not type cast to map.");
                }
                mapConstraints(data, shape);
                const map = /* @__PURE__ */ new Map();
                for (const [key, value] of data.entries()){
                    map.set(castFrom(key, shape.keys), castFrom(value, shape.values));
                }
                return map;
            }
        case void 0:
            {
                return data;
            }
    }
    throw new Error("Could not type cast data.");
}
function castTo(struct, type) {
    const shape = type;
    if (!shape) throw new Error("Could not type cast struct.");
    const shapeType = (shape.anyOf ? "enum" : "") || shape.dataType;
    switch(shapeType){
        case "integer":
            {
                if (typeof struct !== "bigint") {
                    throw new Error("Could not type cast to integer.");
                }
                integerConstraints(struct, shape);
                return struct;
            }
        case "bytes":
            {
                if (typeof struct !== "string") {
                    throw new Error("Could not type cast to bytes.");
                }
                bytesConstraints(struct, shape);
                return struct;
            }
        case "constructor":
            {
                if (isVoid(shape)) {
                    if (struct !== void 0) {
                        throw new Error("Could not type cast to void.");
                    }
                    return new Constr(0, []);
                } else if (typeof struct !== "object" || struct === null || shape.fields.length !== Object.keys(struct).length) {
                    throw new Error("Could not type cast to constructor.");
                }
                const fields = shape.fields.map((field)=>castTo(struct[field.title || "wrapper"], field));
                return shape.hasConstr || shape.hasConstr === void 0 ? new Constr(shape.index, fields) : fields;
            }
        case "enum":
            {
                if (shape.anyOf.length === 1) {
                    return castTo(struct, shape.anyOf[0]);
                }
                if (isBoolean(shape)) {
                    if (typeof struct !== "boolean") {
                        throw new Error("Could not type cast to boolean.");
                    }
                    return new Constr(struct ? 1 : 0, []);
                } else if (isNullable(shape)) {
                    if (struct === null) return new Constr(1, []);
                    else {
                        const fields = shape.anyOf[0].fields;
                        if (fields.length !== 1) {
                            throw new Error("Could not type cast to nullable object.");
                        }
                        return new Constr(0, [
                            castTo(struct, fields[0])
                        ]);
                    }
                }
                switch(typeof struct){
                    case "string":
                        {
                            if (!/[A-Z]/.test(struct[0])) {
                                throw new Error("Could not type cast to enum. Enum needs to start with an uppercase letter.");
                            }
                            const enumIndex = shape.anyOf.findIndex((s)=>s.dataType === "constructor" && s.fields.length === 0 && s.title === struct);
                            if (enumIndex === -1) throw new Error("Could not type cast to enum.");
                            return new Constr(enumIndex, []);
                        }
                    case "object":
                        {
                            if (struct === null) throw new Error("Could not type cast to enum.");
                            const structTitle = Object.keys(struct)[0];
                            if (!/[A-Z]/.test(structTitle)) {
                                throw new Error("Could not type cast to enum. Enum needs to start with an uppercase letter.");
                            }
                            const enumEntry = shape.anyOf.find((s)=>s.dataType === "constructor" && s.title === structTitle);
                            if (!enumEntry) throw new Error("Could not type cast to enum.");
                            const args = struct[structTitle];
                            return new Constr(enumEntry.index, // check if named args
                            args instanceof Array ? args.map((item, index)=>castTo(item, enumEntry.fields[index])) : enumEntry.fields.map((entry)=>{
                                const [_, item] = Object.entries(args).find(([title])=>title === entry.title);
                                return castTo(item, entry);
                            }));
                        }
                }
                throw new Error("Could not type cast to enum.");
            }
        case "list":
            {
                if (!(struct instanceof Array)) {
                    throw new Error("Could not type cast to array/tuple.");
                }
                if (shape.items instanceof Array) {
                    const fields = struct.map((item, index)=>castTo(item, shape.items[index]));
                    return shape.hasConstr ? new Constr(0, fields) : fields;
                } else {
                    listConstraints(struct, shape);
                    return struct.map((item)=>castTo(item, shape.items));
                }
            }
        case "map":
            {
                if (!(struct instanceof Map)) {
                    throw new Error("Could not type cast to map.");
                }
                mapConstraints(struct, shape);
                const map = /* @__PURE__ */ new Map();
                for (const [key, value] of struct.entries()){
                    map.set(castTo(key, shape.keys), castTo(value, shape.values));
                }
                return map;
            }
        case void 0:
            {
                return struct;
            }
    }
    throw new Error("Could not type cast struct.");
}
function integerConstraints(integer, shape) {
    if (shape.minimum && integer < BigInt(shape.minimum)) {
        throw new Error(`Integer ${integer} is below the minimum ${shape.minimum}.`);
    }
    if (shape.maximum && integer > BigInt(shape.maximum)) {
        throw new Error(`Integer ${integer} is above the maxiumum ${shape.maximum}.`);
    }
    if (shape.exclusiveMinimum && integer <= BigInt(shape.exclusiveMinimum)) {
        throw new Error(`Integer ${integer} is below the exclusive minimum ${shape.exclusiveMinimum}.`);
    }
    if (shape.exclusiveMaximum && integer >= BigInt(shape.exclusiveMaximum)) {
        throw new Error(`Integer ${integer} is above the exclusive maximum ${shape.exclusiveMaximum}.`);
    }
}
function bytesConstraints(bytes, shape) {
    if (shape.enum && !shape.enum.some((keyword)=>keyword === bytes)) throw new Error(`None of the keywords match with '${bytes}'.`);
    if (shape.minLength && bytes.length / 2 < shape.minLength) {
        throw new Error(`Bytes need to have a length of at least ${shape.minLength} bytes.`);
    }
    if (shape.maxLength && bytes.length / 2 > shape.maxLength) {
        throw new Error(`Bytes can have a length of at most ${shape.minLength} bytes.`);
    }
}
function listConstraints(list, shape) {
    if (shape.minItems && list.length < shape.minItems) {
        throw new Error(`Array needs to contain at least ${shape.minItems} items.`);
    }
    if (shape.maxItems && list.length > shape.maxItems) {
        throw new Error(`Array can contain at most ${shape.maxItems} items.`);
    }
    if (shape.uniqueItems && new Set(list).size !== list.length) {
        throw new Error("Array constains duplicates.");
    }
}
function mapConstraints(map, shape) {
    if (shape.minItems && map.size < shape.minItems) {
        throw new Error(`Map needs to contain at least ${shape.minItems} items.`);
    }
    if (shape.maxItems && map.size > shape.maxItems) {
        throw new Error(`Map can contain at most ${shape.maxItems} items.`);
    }
}
function isBoolean(shape) {
    return shape.anyOf && shape.anyOf[0]?.title === "False" && shape.anyOf[1]?.title === "True";
}
function isVoid(shape) {
    return shape.index === 0 && shape.fields.length === 0;
}
function isNullable(shape) {
    return shape.anyOf && shape.anyOf[0]?.title === "Some" && shape.anyOf[1]?.title === "None";
}
function replaceProperties(object, properties) {
    Object.keys(object).forEach((key)=>{
        delete object[key];
    });
    Object.assign(object, properties);
}
// src/index.ts
__reExport(src_exports, data_exports);
// src/time.ts
var SLOT_CONFIG_NETWORK = {
    Mainnet: {
        zeroTime: 1596059091e3,
        zeroSlot: 4492800,
        slotLength: 1e3
    },
    // Starting at Shelley era
    Preview: {
        zeroTime: 1666656e6,
        zeroSlot: 0,
        slotLength: 1e3
    },
    // Starting at Shelley era
    Preprod: {
        zeroTime: 16540416e5 + 1728e6,
        zeroSlot: 86400,
        slotLength: 1e3
    },
    // Starting at Shelley era
    /** Customizable slot config (Initialized with 0 values). */ Custom: {
        zeroTime: 0,
        zeroSlot: 0,
        slotLength: 0
    }
};
function slotToBeginUnixTime(slot, slotConfig) {
    const msAfterBegin = (slot - slotConfig.zeroSlot) * slotConfig.slotLength;
    return slotConfig.zeroTime + msAfterBegin;
}
function unixTimeToEnclosingSlot(unixTime, slotConfig) {
    const timePassed = unixTime - slotConfig.zeroTime;
    const slotsPassed = Math.floor(timePassed / slotConfig.slotLength);
    return slotsPassed + slotConfig.zeroSlot;
}
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/isUint8Array.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isUint8Array = void 0;
function isUint8Array(stuff) {
    return stuff instanceof Uint8Array;
}
exports.isUint8Array = isUint8Array;
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/utf8.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toUtf8 = exports.fromUtf8 = void 0;
function fromUtf8(string, units) {
    if (units === void 0) {
        units = Infinity;
    }
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
            // valid bmp char, but last char was a lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
            throw new Error('Invalid code point');
        }
    }
    return new Uint8Array(bytes);
}
exports.fromUtf8 = fromUtf8;
function toUtf8(buf, start, end) {
    if (start === void 0) {
        start = 0;
    }
    if (end === void 0) {
        end = Infinity;
    }
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte = void 0, thirdByte = void 0, fourthByte = void 0, tempCodePoint = void 0;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
exports.toUtf8 = toUtf8;
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    }
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/hex.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromHex = exports.toHex = void 0;
var isUint8Array_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/isUint8Array.js [app-client] (ecmascript)");
function toHex(buff) {
    if (!(0, isUint8Array_1.isUint8Array)(buff)) throw new TypeError('toHex expects an `Uint8Array`;');
    var strArr = new Array(buff.length);
    buff.forEach(function(b, i) {
        return strArr[i] = b.toString(16).padStart(2, '0');
    });
    return strArr.join('');
}
exports.toHex = toHex;
var hexChars = Object.freeze(Array.from("0123456789abcdef"));
function isLowerCaseHex(str) {
    return Array.from(str).every(function(ch) {
        return hexChars.includes(ch);
    });
}
function fromHex(str) {
    if (typeof str !== "string") throw new TypeError('fromHex expects an hexadecimal string;');
    str = str.toLowerCase();
    str = str.length % 2 === 0 ? str : '0' + str;
    var len = str.length / 2;
    var arr = new Array(len);
    for(var i = 0; i < len; i++){
        var i2 = i * 2;
        var byte = str.substring(i2, i2 + 2);
        if (!isLowerCaseHex(byte)) throw new TypeError('fromHex expects an hexadecimal string; input was: ' + str);
        arr[i] = parseInt("0x" + byte);
    }
    return new Uint8Array(arr);
}
exports.fromHex = fromHex;
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/ascii.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromAscii = exports.toAscii = void 0;
function toAscii(buf, start, end) {
    if (start === void 0) {
        start = 0;
    }
    if (end === void 0) {
        end = Infinity;
    }
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i] & 0x7f);
    }
    return ret;
}
exports.toAscii = toAscii;
function fromAscii(str) {
    var len = str.length;
    var byteArray = new Array(len);
    for(var i = 0; i < str.length; ++i){
        byteArray[i] = str.charCodeAt(i) & 0xff;
    }
    return new Uint8Array(byteArray);
}
exports.fromAscii = fromAscii;
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/errors.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ERR_OUT_OF_RANGE = exports.ERR_INVALID_ARG_TYPE = exports.ERR_BUFFER_OUT_OF_BOUNDS = void 0;
function addNumericalSeparator(val) {
    var res = '';
    var i = val.length;
    var start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = "_".concat(val.slice(i - 3, i)).concat(res);
    }
    return "".concat(val.slice(0, i)).concat(res);
}
function E(sym, getMessage, Base) {
    return function(_super) {
        __extends(Uint8ArrayError, _super);
        function Uint8ArrayError() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++){
                args[_i] = arguments[_i];
            }
            var _this = _super.call(this) || this;
            Object.defineProperty(_this, 'message', {
                value: getMessage.apply(_this, args),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            _this.name = "".concat(_this.name, " [").concat(sym, "]");
            // Access the stack to generate the error message including the error code
            // from the name.
            _this.stack; // eslint-disable-line no-unused-expressions
            return _this;
        }
        Object.defineProperty(Uint8ArrayError.prototype, "code", {
            get: function() {
                return sym;
            },
            set: function(value) {
                Object.defineProperty(this, 'code', {
                    configurable: true,
                    enumerable: true,
                    value: value,
                    writable: true
                });
            },
            enumerable: false,
            configurable: true
        });
        Uint8ArrayError.prototype.toString = function() {
            return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
        };
        return Uint8ArrayError;
    }(Base);
}
exports.ERR_BUFFER_OUT_OF_BOUNDS = E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) {
        return "".concat(name, " is outside of buffer bounds");
    }
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
exports.ERR_INVALID_ARG_TYPE = E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(typeof actual);
}, TypeError);
exports.ERR_OUT_OF_RANGE = E('ERR_OUT_OF_RANGE', function(str, range, input) {
    var msg = "The value of \"".concat(str, "\" is out of range.");
    var received = input;
    if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
        received = addNumericalSeparator(String(input));
    } else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(1) << BigInt(32) || input < -(BigInt(1) << BigInt(32))) {
            received = addNumericalSeparator(received);
        }
        received += 'n';
    }
    msg += " It must be ".concat(range, ". Received ").concat(received);
    return msg;
}, RangeError);
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/_asserts.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkBounds = exports.assertInBound = exports.assertNum = exports.asserValidOffset = void 0;
var errors = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/errors.js [app-client] (ecmascript)"));
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function asserValidOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
exports.asserValidOffset = asserValidOffset;
function assertNum(n) {
    if (typeof n !== "number") throw new Error("expected a number");
}
exports.assertNum = assertNum;
function assertInBound(value, length, type) {
    if (Math.floor(value) !== value) {
        assertNum(value);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
}
exports.assertInBound = assertInBound;
function checkBounds(buf, offset, byteLength) {
    assertNum(offset);
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        assertInBound(offset, buf.length - (byteLength + 1));
    }
}
exports.checkBounds = checkBounds;
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/readUint.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readFloat64BE = exports.readFloat32BE = exports.readIntLE = exports.readBigUInt64BE = exports.readBigUInt64LE = exports.readUInt32BE = exports.readUint32BE = exports.readUInt32LE = exports.readUint32LE = exports.readUInt16BE = exports.readUint16BE = exports.readUInt16LE = exports.readUint16LE = exports.readUInt8 = exports.readUint8 = void 0;
var _asserts_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/_asserts.js [app-client] (ecmascript)");
exports.readUint8 = readUInt8;
function readUInt8(buff, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    offset = offset >>> 0;
    if (!noAssert) (0, _asserts_1.asserValidOffset)(offset, 1, buff.length);
    return buff[offset];
}
exports.readUInt8 = readUInt8;
exports.readUint16LE = readUInt16LE;
function readUInt16LE(buff, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    offset = offset >>> 0;
    if (!noAssert) (0, _asserts_1.asserValidOffset)(offset, 2, buff.length);
    return buff[offset] | buff[offset + 1] << 8;
}
exports.readUInt16LE = readUInt16LE;
exports.readUint16BE = readUInt16BE;
function readUInt16BE(buff, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    offset = offset >>> 0;
    if (!noAssert) (0, _asserts_1.asserValidOffset)(offset, 2, buff.length);
    return buff[offset] << 8 | buff[offset + 1];
}
exports.readUInt16BE = readUInt16BE;
exports.readUint32LE = readUInt32LE;
function readUInt32LE(buff, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    offset = offset >>> 0;
    if (!noAssert) (0, _asserts_1.asserValidOffset)(offset, 4, buff.length);
    return (buff[offset] | buff[offset + 1] << 8 | buff[offset + 2] << 16) + buff[offset + 3] * 0x1000000;
}
exports.readUInt32LE = readUInt32LE;
exports.readUint32BE = readUInt32BE;
function readUInt32BE(buff, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    offset = offset >>> 0;
    if (!noAssert) (0, _asserts_1.asserValidOffset)(offset, 4, buff.length);
    return buff[offset] * 0x1000000 + (buff[offset + 1] << 16 | buff[offset + 2] << 8 | buff[offset + 3]);
}
exports.readUInt32BE = readUInt32BE;
function readBigUInt64LE(buff, offset) {
    offset = offset >>> 0;
    (0, _asserts_1.assertNum)(offset);
    var first = buff[offset];
    var last = buff[offset + 7];
    if (first === undefined || last === undefined) {
        (0, _asserts_1.assertInBound)(offset, buff.length - 8);
    }
    var lo = first + buff[++offset] * Math.pow(2, 8) + buff[++offset] * Math.pow(2, 16) + buff[++offset] * Math.pow(2, 24);
    var hi = buff[++offset] + buff[++offset] * Math.pow(2, 8) + buff[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
}
exports.readBigUInt64LE = readBigUInt64LE;
function readBigUInt64BE(buff, offset) {
    offset = offset >>> 0;
    (0, _asserts_1.assertNum)(offset);
    var first = buff[offset];
    var last = buff[offset + 7];
    if (first === undefined || last === undefined) {
        (0, _asserts_1.assertInBound)(offset, buff.length - 8);
    }
    var hi = first * Math.pow(2, 24) + buff[++offset] * Math.pow(2, 16) + buff[++offset] * Math.pow(2, 8) + buff[++offset];
    var lo = buff[++offset] * Math.pow(2, 24) + buff[++offset] * Math.pow(2, 16) + buff[++offset] * Math.pow(2, 8) + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
}
exports.readBigUInt64BE = readBigUInt64BE;
function readIntLE(buff, offset, byteLength, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) (0, _asserts_1.asserValidOffset)(offset, byteLength, buff.length);
    var val = buff[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100)){
        val += buff[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
}
exports.readIntLE = readIntLE;
function readFloat32BE(buf, offset) {
    var buff = new ArrayBuffer(4);
    var asFloat32 = new Float32Array(buff);
    var asUint8 = new Uint8Array(buff);
    for(var i = offset; i < offset + 4; i++){
        asUint8[i - offset] = buf[i];
    }
    return asFloat32[0];
}
exports.readFloat32BE = readFloat32BE;
function readFloat64BE(buf, offset) {
    var buff = new ArrayBuffer(8);
    var asFloat64 = new Float64Array(buff);
    var asUint8 = new Uint8Array(buff);
    for(var i = offset; i < offset + 8; i++){
        asUint8[i - offset] = buf[i];
    }
    return asFloat64[0];
}
exports.readFloat64BE = readFloat64BE;
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/writeUint.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.writeFloat64BE = exports.writeBigUInt64BE = exports.writeBigUInt64LE = exports.writeUInt32BE = exports.writeUint32BE = exports.writeUInt32LE = exports.writeUint32LE = exports.writeUInt16BE = exports.writeUint16BE = exports.writeUInt16LE = exports.writeUint16LE = exports.writeUInt8 = exports.writeUint8 = exports.writeUIntBE = exports.writeUintBE = exports.writeUIntLE = exports.writeUintLE = void 0;
var _asserts_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/_asserts.js [app-client] (ecmascript)");
var errors = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/errors.js [app-client] (ecmascript)"));
function checkInt(buf, value, offset, ext, max, min) {
    if (!(buf instanceof Uint8Array)) throw new TypeError('"buffer" argument must be an Uint8Array instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        var n = typeof min === 'bigint' ? 'n' : '';
        var range = void 0;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
            } else {
                range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
            }
        } else {
            range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
        }
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    (0, _asserts_1.checkBounds)(buf, offset, byteLength);
}
exports.writeUintLE = writeUIntLE;
function writeUIntLE(buff, value, offset, byteLength, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(buff, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    buff[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        buff[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
}
exports.writeUIntLE = writeUIntLE;
exports.writeUintBE = writeUIntBE;
function writeUIntBE(buff, value, offset, byteLength, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(buff, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    buff[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        buff[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
}
exports.writeUIntBE = writeUIntBE;
exports.writeUint8 = writeUInt8;
function writeUInt8(buff, value, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(buff, value, offset, 1, 0xff, 0);
    buff[offset] = value & 0xff;
    return offset + 1;
}
exports.writeUInt8 = writeUInt8;
exports.writeUint16LE = writeUInt16LE;
function writeUInt16LE(buff, value, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(buff, value, offset, 2, 0xffff, 0);
    buff[offset] = value & 0xff;
    buff[offset + 1] = value >>> 8;
    return offset + 2;
}
exports.writeUInt16LE = writeUInt16LE;
exports.writeUint16BE = writeUInt16BE;
function writeUInt16BE(buff, value, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(buff, value, offset, 2, 0xffff, 0);
    buff[offset] = value >>> 8;
    buff[offset + 1] = value & 0xff;
    return offset + 2;
}
exports.writeUInt16BE = writeUInt16BE;
exports.writeUint32LE = writeUInt32LE;
function writeUInt32LE(buff, value, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(buff, value, offset, 4, 0xffffffff, 0);
    buff[offset + 3] = value >>> 24;
    buff[offset + 2] = value >>> 16;
    buff[offset + 1] = value >>> 8;
    buff[offset] = value & 0xff;
    return offset + 4;
}
exports.writeUInt32LE = writeUInt32LE;
exports.writeUint32BE = writeUInt32BE;
function writeUInt32BE(buff, value, offset, noAssert) {
    if (noAssert === void 0) {
        noAssert = false;
    }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(buff, value, offset, 4, 0xffffffff, 0);
    buff[offset] = value >>> 24;
    buff[offset + 1] = value >>> 16;
    buff[offset + 2] = value >>> 8;
    buff[offset + 3] = value & 0xff;
    return offset + 4;
}
exports.writeUInt32BE = writeUInt32BE;
function writeBigUInt64LE(buf, value, offset) {
    var min = BigInt(0);
    var max = BigInt('0xffffffffffffffff');
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
exports.writeBigUInt64LE = writeBigUInt64LE;
function writeBigUInt64BE(buf, value, offset) {
    var min = BigInt(0);
    var max = BigInt('0xffffffffffffffff');
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
exports.writeBigUInt64BE = writeBigUInt64BE;
function writeFloat64BE(buf, value, offset) {
    var buff = new ArrayBuffer(8);
    var asFloatArr = new Float64Array(buff);
    asFloatArr[0] = value;
    var asUint8 = new Uint8Array(buff);
    for(var i = 0; i < 8; i++){
        buf[offset + i] = asUint8[i];
    }
    return offset + 8;
}
exports.writeFloat64BE = writeFloat64BE;
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/utils/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uint8ArrayEq = exports.lexCompare = void 0;
function lexCompare(a, b) {
    var min = a.length < b.length ? a : b;
    var minLen = min.length;
    for(var i = 0; i < minLen; i++){
        var _a = a.at(i);
        var _b = b.at(i);
        if (_a === undefined) return -1 /* Ord.LT */ ;
        if (_b === undefined) return 1 /* Ord.GT */ ;
        if (_a < _b) return -1 /* Ord.LT */ ;
        if (_a > _b) return 1 /* Ord.GT */ ;
    // if( _a === _b ) continue;
    }
    return a.length === b.length ? 0 /* Ord.EQ */  : a.length < b.length ? -1 /* Ord.LT */  : 1 /* Ord.GT */ ;
}
exports.lexCompare = lexCompare;
function uint8ArrayEq(a, b) {
    return a.length === b.length && a.every(function(n, i) {
        return n === b[i];
    });
}
exports.uint8ArrayEq = uint8ArrayEq;
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/concat.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.concatUint8Array = void 0;
function concatUint8Array() {
    var chunks = [];
    for(var _i = 0; _i < arguments.length; _i++){
        chunks[_i] = arguments[_i];
    }
    // if(!Array.isArray(chunks)) return new Uint8Array([]);
    if (!chunks.every(function(chunk) {
        return chunk instanceof Uint8Array;
    })) return new Uint8Array([]);
    if (chunks.length <= 0) return new Uint8Array([]);
    if (chunks.length === 1) return Uint8Array.prototype.slice.call(chunks[0]);
    var len = chunks.reduce(function(acc, chunk) {
        return acc + chunk.length;
    }, 0);
    var result = new Uint8Array(len);
    var offset = 0;
    var nChunks = chunks.length;
    for(var i = 0, chunk = void 0; i < nChunks;){
        chunk = chunks[i++];
        result.set(chunk, offset);
        offset += chunk.length;
    }
    return result;
}
exports.concatUint8Array = concatUint8Array;
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/base64.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromBase64 = exports.toBase64 = void 0;
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for(var i = 0; i < chars.length; i++){
    lookup[chars.charCodeAt(i)] = i;
}
function toBase64(bytes) {
    var i, len = bytes.length, base64 = '';
    for(i = 0; i < len; i += 3){
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
}
exports.toBase64 = toBase64;
;
function fromBase64(base64) {
    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    var bytes = new Uint8Array(bufferLength);
    for(i = 0; i < len; i += 4){
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return bytes;
}
exports.fromBase64 = fromBase64;
;
}),
"[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/isUint8Array.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/utf8.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/hex.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/ascii.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/readUint.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/writeUint.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/utils/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/concat.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/base64.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/bitstream/dist/utils/assert.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assert = void 0;
function assert(condition, errorMessage, addInfos) {
    var args = [];
    for(var _i = 3; _i < arguments.length; _i++){
        args[_i - 3] = arguments[_i];
    }
    if (condition) return;
    args.length > 0 && console.error.apply(console, __spreadArray([], __read(args), false));
    addInfos && console.error(addInfos);
    if (errorMessage instanceof Error) {
        throw errorMessage;
    }
    ;
    throw new Error(errorMessage);
}
exports.assert = assert;
}),
"[project]/node_modules/@harmoniclabs/bitstream/dist/utils/stuff.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.minBytesRequired = exports.getNOfUsedBits = exports.getNLastBits = exports.getNLastBitsInt = exports.andMaskOfLength = exports.andMaskOfLengthInt = exports.getFirstByte = void 0;
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bitstream/dist/utils/assert.js [app-client] (ecmascript)");
/**
 * @deprecated not sure it has ever made sense to have it
 * @returns a number in range ```[ 0 , 255 ]``` ( ```[ 0b0000_0000, 0b1111_1111 ]``` ) based on the first byte
 */ function getFirstByte(bits) {
    return Number("0x".concat(bits.toString(16).slice(0, 2)));
}
exports.getFirstByte = getFirstByte;
/**
 * @deprecated use ```andMaskOfLength``` instead
 */ function andMaskOfLengthInt(n) {
    n = Math.round(Math.abs(n));
    // operatons used are valid on singed number
    if (n >= 30) {
        return andMaskOfLength(BigInt(n));
    }
    return BigInt((1 << n) - 1);
}
exports.andMaskOfLengthInt = andMaskOfLengthInt;
/**
 * returns a ```bigint``` of that as the last ```n``` bits setted to ones;
 *
 * example
 * ```ts
 * getMaskOfLength( 7 ) === Bigint( 0b0111_1111 ); // true
 * ```
 */ function andMaskOfLength(n) {
    return BigInt((BigInt(1) << n) - BigInt(1));
}
exports.andMaskOfLength = andMaskOfLength;
/**
 * @deprecated use ```getNLastBits``` instead
 */ function getNLastBitsInt(fromNuber, nBits) {
    (0, assert_1.assert)(typeof fromNuber === "number" && typeof nBits === "number", "can use getNLastBitsInt on number instances only");
    return Number(BigInt(fromNuber) & andMaskOfLength(BigInt(nBits)));
}
exports.getNLastBitsInt = getNLastBitsInt;
function getNLastBits(fromNuber, nBits) {
    return fromNuber & andMaskOfLength(nBits);
}
exports.getNLastBits = getNLastBits;
/**
 * @returns the number of bits from the first setted to ```1``` on the left up until the end
 */ function getNOfUsedBits(bits) {
    if (bits === BigInt(0)) return 0;
    return bits.toString(2).length;
}
exports.getNOfUsedBits = getNOfUsedBits;
function minBytesRequired(bigint) {
    if (bigint < BigInt(0)) throw new Error("minBytesRequired works for positives integers only");
    var fullByteOnes = BigInt(255);
    var mask = fullByteOnes;
    var bytesRequired = 1;
    while(bigint !== (bigint & mask)){
        mask = mask << BigInt(8) | fullByteOnes;
        bytesRequired++;
    }
    return bytesRequired;
}
exports.minBytesRequired = minBytesRequired;
}),
"[project]/node_modules/@harmoniclabs/bitstream/dist/utils/BigIntUtils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bitstream/dist/utils/assert.js [app-client] (ecmascript)");
/**
 * @static
 */ var BigIntUtils = function() {
    function BigIntUtils() {}
    ;
    /**
     * same as ```Math.abs``` but for bigints
     */ BigIntUtils.abs = function(n) {
        return n < BigInt(0) ? -n : n;
    };
    /**
     * @returns {bigint} a ```bigint``` between ```0``` and ```Number.MAX_SAFE_INTEGER``` so that is safe to convert to Number for whatever reason
     */ BigIntUtils.random = function() {
        return BigInt(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
    };
    BigIntUtils.max = function() {
        var nums = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nums[_i] = arguments[_i];
        }
        return nums.reduce(function(a, b) {
            return a > b ? a : b;
        });
    };
    BigIntUtils.min = function() {
        var nums = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nums[_i] = arguments[_i];
        }
        return nums.reduce(function(a, b) {
            return a < b ? a : b;
        });
    };
    BigIntUtils.log2 = function(num) {
        if (num === BigInt(0)) return BigInt(0);
        if (num < BigInt(0)) return -BigIntUtils.log2(BigIntUtils.abs(num));
        var n = BigInt(num);
        var result = BigInt(0);
        while(n >>= BigInt(1))result++;
        return result;
    };
    /**
     * uses the bytes of the buffer to construct a BigInteger
     * > **IMPORTANT** the bytes are considered in Little Endian order; use ```BigIntUtils.fromBuffer``` for Big Endian
     */ BigIntUtils.fromBufferLE = function(buffer) {
        return BigIntUtils.fromBuffer(// need to copy so that it doesn't reverses the original buffer
        Uint8Array.from(buffer).reverse());
    };
    /**
     * converts a Uint8Array to a ```bigint```
     * Big-Endian default
     */ BigIntUtils.fromBuffer = function(buffer) {
        (0, assert_1.assert)((0, uint8array_utils_1.isUint8Array)(buffer), "expected buffer as input, while constructing a bigint instance using BigIntUtils.fromBufferBE");
        var hexBuff = (0, uint8array_utils_1.toHex)(buffer);
        if (hexBuff.length === 0) {
            return BigInt(0);
        }
        return BigInt("0x".concat(hexBuff));
    };
    /**
     * converts a ```bigint``` to a ```Uint8Array``` of length ```nBytes``` given as second argument
     *
     * if ```nBytes``` is not specified the Uint8Array takes only the bytes needed
     * @param bigint
     * @param nBytes
     * @returns
     */ BigIntUtils.toBuffer = function(bigint, nBytes) {
        if (nBytes === void 0) {
            nBytes = undefined;
        }
        (0, assert_1.assert)(bigint >= BigInt(0), "cannot convert negative bigint to buffer");
        if (bigint == BigInt(0)) {
            if (nBytes === undefined) {
                return Uint8Array.from([]);
            }
            return new Uint8Array(nBytes);
        }
        var buffHexString = bigint.toString(16);
        buffHexString = buffHexString.length % 2 === 0 ? buffHexString : '0' + buffHexString;
        if (nBytes !== undefined) {
            (0, assert_1.assert)(Math.round(Math.abs(nBytes)) === nBytes, "cannot construct a buffer of length " + nBytes + ", while using BigIntUtils.toBufferOfNBytesBE");
            // pads with zeroes so that the final length is of nBytes*2 (2 hex digits per byte)
            // String.prototype.padStart docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
            buffHexString = buffHexString.padStart(nBytes * 2, "00");
            if (buffHexString.length > nBytes * 2) {
                console.warn("required buffer size is smaller than the one used effectively by the given bigint, truncating the initial bytes as overflow");
                buffHexString = buffHexString.slice(buffHexString.length - nBytes * 2);
            }
        }
        return (0, uint8array_utils_1.fromHex)(buffHexString);
    };
    return BigIntUtils;
}();
exports.default = BigIntUtils;
}),
"[project]/node_modules/@harmoniclabs/bitstream/dist/utils/isBinary.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isBinary = void 0;
function isBinary(str) {
    if (typeof str !== "string") return false;
    for(var i = 0; i < str.length; i++){
        var ch = str[i];
        if (!(ch === "0" || ch === "1")) return false;
    }
    return true;
}
exports.isBinary = isBinary;
}),
"[project]/node_modules/@harmoniclabs/bitstream/dist/BitStream.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BitStreamIterator = exports.BitStream = exports.forceInByteOffset = exports.isInByteOffset = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var stuff_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bitstream/dist/utils/stuff.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bitstream/dist/utils/assert.js [app-client] (ecmascript)");
var BigIntUtils_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/bitstream/dist/utils/BigIntUtils.js [app-client] (ecmascript)"));
var isBinary_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bitstream/dist/utils/isBinary.js [app-client] (ecmascript)");
function isInByteOffset(offset) {
    return offset === 0 || offset === 1 || offset === 2 || offset === 3 || offset === 4 || offset === 5 || offset === 6 || offset === 7;
}
exports.isInByteOffset = isInByteOffset;
function forceInByteOffset(offset) {
    return Math.round(Math.abs(offset)) % 8;
}
exports.forceInByteOffset = forceInByteOffset;
var BitStream = function() {
    function BitStream(bytes, nInitialZeroes) {
        if (nInitialZeroes === void 0) {
            nInitialZeroes = 0;
        }
        var _this = this;
        /**
         * allows to use ```BitStream```s in ```for..of``` loops
         *
         * e.g.:
         * ```ts
         * for( let bit of bitStream )
         * {
         *    // ```bit``` si an object of type ```Bit```
         * }
         * ```
         */ this[_a] = function() {
            return new BitStreamIterator(_this);
        };
        // case empty BitStream
        // aka. new BitStream() || new BitStream( undefined )
        if (bytes === undefined) {
            this._bits = BigInt(-1);
            this._nInitialZeroes = 0;
            return;
        }
        // nInitialZeroes has to be an integer
        (0, assert_1.assert)(Math.round(Math.abs(nInitialZeroes)) === nInitialZeroes, "invalid numebr of nInitialZeroes passed, expected non-negative integer, got: " + nInitialZeroes.toString());
        // construct form bigint
        if (typeof bytes == "bigint") {
            this._nInitialZeroes = nInitialZeroes;
            // silently adapts the input if negative in produciton
            this._bits = BigIntUtils_1.default.abs(bytes);
            return;
        }
        // construct form Uint8Array
        // assert got Uint8Array instance as input
        (0, assert_1.assert)((0, uint8array_utils_1.isUint8Array)(bytes), "expected a Uint8Array instance", {
            got: bytes,
            nativeType: typeof bytes
        });
        if (bytes.length === 0) {
            this._bits = BigInt(-1);
            this._nInitialZeroes = 0;
            return;
        }
        var nZeroesAsEndPadding = forceInByteOffset(nInitialZeroes);
        var firstNonZeroByte = 0;
        var allZeroesBytes = 0;
        while(allZeroesBytes < bytes.length){
            firstNonZeroByte = (0, uint8array_utils_1.readUint8)(bytes, allZeroesBytes);
            if (firstNonZeroByte > 0) break;
            allZeroesBytes++;
        }
        if (allZeroesBytes === bytes.length) {
            this._bits = BigInt(-1);
            this._nInitialZeroes = 8 * allZeroesBytes;
            return;
        }
        this._nInitialZeroes = 8 * allZeroesBytes + (8 - (0, stuff_1.getNOfUsedBits)(BigInt(firstNonZeroByte)));
        (0, assert_1.assert)(this._nInitialZeroes >= 0, "this._nInitialZeroes was setted badly in a BitStream creation using a Uint8Array as input.");
        this._bits = BigIntUtils_1.default.fromBuffer(bytes);
        if (nZeroesAsEndPadding !== 0) {
            this._bits = this.bits << BigInt(nZeroesAsEndPadding);
        }
    }
    BitStream.isStrictInstance = function(value) {
        return Object.getPrototypeOf(value) === BitStream.prototype;
    };
    Object.defineProperty(BitStream.prototype, "bits", {
        /**
         * **IMPORTANT**
         *
         * this property returns the raw bigint stored in the instance
         *
         * this means that if the instance represents an empty ```BitStream``` ,
         * or one composed by an undefinite series of zeroes, you'll likely get an different result than the expected one
         *
         * for a more appropriate result you should use the ```asBigInt``` method
         *
         * example:
         * ```ts
         * const myBitStream = new BitStream();
         *
         * myBitStream.bits // -> -1n
         * myBitStream.asBigInt().bigint // -> 0n
         *
         * ```
         *
         */ get: function() {
            return this._bits;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitStream.prototype, "nInitialZeroes", {
        get: function() {
            return this._nInitialZeroes;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitStream.prototype, "length", {
        get: function() {
            if (this.isEmpty()) return 0;
            return this._nInitialZeroes + (0, stuff_1.getNOfUsedBits)(this._bits);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitStream.prototype, "lengthInBytes", {
        get: function() {
            return BitStream.getMinBytesForLength(this.length);
        },
        enumerable: false,
        configurable: true
    });
    BitStream.prototype.isEmpty = function() {
        return this._bits < BigInt(0) && this.nInitialZeroes <= 0;
    };
    BitStream.prototype.isAllZeroes = function() {
        return this._bits <= BigInt(0) && this.nInitialZeroes >= 0;
    };
    BitStream.fromBinStr = function(binStr) {
        (0, assert_1.assert)((0, isBinary_1.isBinary)(binStr), "expected an instance of the 'BinsryString' class; got: " + binStr.toString());
        var firstOneAt = binStr.indexOf('1');
        if (firstOneAt < 0) {
            return new BitStream(BigInt(0), binStr.length);
        }
        return new BitStream(BigInt("0b".concat(binStr.slice(firstOneAt))), firstOneAt);
    };
    BitStream.prototype.toBinStr = function() {
        var _b = this.asBigInt(), bigint = _b.bigint, nInitialZeroes = _b.nInitialZeroes;
        return "0".repeat(nInitialZeroes) + bigint.toString(2);
    };
    BitStream.getMinBytesForLength = function(length) {
        length = Math.round(Math.abs(length));
        // even one bit requires a new byte,
        // that's why ceil
        return Math.ceil(length / 8);
    };
    BitStream.prototype.getNBitsMissingToByte = function() {
        var lengthMod8 = this.length % 8;
        if (lengthMod8 === 0) return 0; // would have returned 8 (8 - 0) otherwise
        return 8 - lengthMod8;
    };
    BitStream.prototype.at = function(index) {
        if (index >= this.length || index < 0) throw RangeError("cannot access bit at index " + index.toString());
        if (index < this.nInitialZeroes) return 0;
        index = Math.round(index);
        return Boolean(this.bits & BigInt(1 << this.length - index - 1)) ? 1 : 0;
    };
    /**
     *
     * @returns {object}
     *      with a @property {Uint8Array} bigint containing the bigint
     *      and a @property {InByteOffset} nInitialZeroes
     *      containing a non-negative integer
     *      indicating how many (non-tracked in the bigint) zeroes are present in the ```BitStream```
     */ BitStream.prototype.asBigInt = function() {
        if (this.isEmpty()) return {
            bigint: BigInt(0),
            nInitialZeroes: 0
        };
        if (this.isAllZeroes()) return {
            bigint: BigInt(0),
            nInitialZeroes: this.nInitialZeroes
        };
        return {
            bigint: this.bits,
            nInitialZeroes: this.nInitialZeroes
        };
    };
    /**
     *
     * @returns {object}
     *      with a @property {Uint8Array} buffer containing the buffer
     *      and a @property {InByteOffset} nZeroesAsEndPadding
     *      containing a number between 7 and 1 both included,
     *      indicating how many of the end bits should be ignored
     */ BitStream.prototype.toBuffer = function() {
        if (this.isEmpty()) return {
            buffer: Uint8Array.from([]),
            nZeroesAsEndPadding: 0
        };
        if (this.isAllZeroes()) return {
            buffer: this.nInitialZeroes <= 0 ? Uint8Array.from([]) : (0, uint8array_utils_1.fromHex)("00".repeat(Math.ceil(this.nInitialZeroes / 8))),
            nZeroesAsEndPadding: this._nInitialZeroes % 8 === 0 ? 0 : 8 - forceInByteOffset(this._nInitialZeroes)
        };
        // we don't want to modify our own bits
        var bits = this.bits;
        // Array is provided with usefull operation
        // unshift
        // push
        // at the moment doesnt contain any initial zero
        var bitsArr = Array.from(BigIntUtils_1.default.toBuffer(bits));
        var firstNonZeroByte = bitsArr[0];
        // add whole bytes of zeroes at the beginning if needed
        if (this.nInitialZeroes >= 8) {
            bitsArr.unshift.apply(bitsArr, __spreadArray([], __read(Array(// number of whole bytes as zeroes
            Math.floor(this.nInitialZeroes / 8)).fill(0)), false));
        }
        if (firstNonZeroByte === undefined) {
            console.error(firstNonZeroByte);
            console.log("toBuffer called on: ", this);
            console.log("this.isEmpty(): ".concat(this.isEmpty()), "this.isAllZeroes(): ".concat(this.isAllZeroes()));
        }
        // remaining zeroes bits
        var supposedInByteInitialZeroes = this.nInitialZeroes % 8;
        var effectiveInByteInitialZeroes = 8 - (0, stuff_1.getNOfUsedBits)(BigInt(firstNonZeroByte !== null && firstNonZeroByte !== void 0 ? firstNonZeroByte : 0));
        (0, assert_1.assert)(effectiveInByteInitialZeroes >= 0 && effectiveInByteInitialZeroes <= 7 && Math.round(effectiveInByteInitialZeroes) == effectiveInByteInitialZeroes, "unexpected numebr of effectiveInByteInitialZeroes; should be 'InByteOffset'; got: " + effectiveInByteInitialZeroes.toString());
        if (// no bits (whole bytes only)
        // supposedInByteInitialZeroes === 0  ||
        // supposedInByteInitialZeroes already tracked
        supposedInByteInitialZeroes === effectiveInByteInitialZeroes) {
            return {
                buffer: Uint8Array.from(bitsArr),
                nZeroesAsEndPadding: 0
            };
        }
        /*
        
        example:
        if( 5 < 7 ) means
        the first (non-zero) byte is like `0b0000_0111`
        whereas it should be              `0b0000_0001`

        if that's the case we shift right by 2 ( 7 - 5 )
        */ if (effectiveInByteInitialZeroes < supposedInByteInitialZeroes) {
            // shiftr carrying the bits
            var shiftBy_1 = supposedInByteInitialZeroes - effectiveInByteInitialZeroes;
            var lostBits = 0;
            var prevLostBits = 0;
            for(var i = //skip the bytes manually setted to zero before (line 245)
            Math.floor(this.nInitialZeroes / 8); i < bitsArr.length; i++){
                prevLostBits = Number((0, stuff_1.getNLastBits)(BigInt(bitsArr[i]), BigInt(shiftBy_1)));
                bitsArr[i] = bitsArr[i] >>> shiftBy_1 | lostBits;
                lostBits = prevLostBits << 8 - shiftBy_1;
            }
            // add one final byte containing bits tha would have be lost
            bitsArr.push(lostBits);
            return {
                buffer: Uint8Array.from(bitsArr),
                nZeroesAsEndPadding: 8 - shiftBy_1
            };
        }
        /*
        otherwhise it means
        effectiveInByteInitialZeroes > supposedInByteInitialZeroes

        so the situation is like:

        first (non-zero) byte `0b0000_0001`
        whereas it should be  `0b0000_0111`

        so we are supposed to shif left by "effectiveInByteInitialZeroes - supposedInByteInitialZeroes" (in this case 2)
        */ var shiftBy = effectiveInByteInitialZeroes - supposedInByteInitialZeroes;
        /**
         * this is quick and dirty, we are basically re-doin what did before
         * @fixme should be moved above to remove code duplication
         */ var shiftedlBitsArr = Array.from(// let bigint do the dirty work
        BigIntUtils_1.default.toBuffer(bits << BigInt(shiftBy)));
        // add whole bytes of zeroes at the beginning if needed
        if (this.nInitialZeroes >= 8) {
            shiftedlBitsArr.unshift.apply(shiftedlBitsArr, __spreadArray([], __read(Array(// number of whole bytes as zeroes
            Math.floor(this.nInitialZeroes / 8)).fill(0)), false));
        }
        return {
            buffer: Uint8Array.from(shiftedlBitsArr),
            nZeroesAsEndPadding: shiftBy
        };
    };
    /**
     * @param byOffset number of bits to move to
     * @returns {bigint} lost bits as big integer
     */ BitStream.prototype.shiftr = function(byOffset) {
        var lostBits = (0, stuff_1.getNLastBits)(this._bits, byOffset);
        this._bits = this.bits >> byOffset;
        return lostBits;
    };
    BitStream.prototype.shiftl = function(byOffset) {
        this._bits = this.bits << byOffset;
    };
    BitStream.prototype.append = function(other) {
        if (other.isEmpty()) {
            return;
        }
        if (this.isEmpty()) {
            this._bits = other.bits;
            this._nInitialZeroes = other.nInitialZeroes;
            return;
        }
        if (this.isAllZeroes()) {
            this._bits = other.bits;
            this._nInitialZeroes = this._nInitialZeroes + other.nInitialZeroes;
            return;
        }
        if (other.isAllZeroes()) {
            this._bits = this._bits << BigInt(other.nInitialZeroes);
            return;
        }
        // make some space
        this._bits = this.bits << BigInt(other.length);
        // other.length keeps track also of possible initial zeroes
        // so those have been added when shifting
        this._bits = this.bits | other.bits;
    };
    BitStream.prototype.clone = function() {
        if (this.isEmpty()) return new BitStream();
        return new BitStream(this.bits, this.nInitialZeroes);
    };
    BitStream.concat = function(a, b) {
        var bitStream = a.clone();
        // .append's argument is readonly
        bitStream.append(b);
        return bitStream;
    };
    // -------------------------------------------------------------------------------------------------------------------------- //
    // ------------------------------------------------------- Operations ------------------------------------------------------- //
    // -------------------------------------------------------------------------------------------------------------------------- //
    BitStream.eq = function(a, b) {
        // if same object (same reference) return true
        // Ω(1) // Omega(1)
        if (a === b) return true;
        return a.nInitialZeroes === b.nInitialZeroes && a.bits === b.bits;
    };
    return BitStream;
}();
exports.BitStream = BitStream;
_a = Symbol.iterator;
var BitStreamIterator = function() {
    function BitStreamIterator(bitStream) {
        if (bitStream.length === 0) {
            this._bitStreamBuff = Uint8Array.from([]);
            this._nZeroesAsPadding = 0;
            this._currByteIndex = 0;
            this._currByte = 0;
            this._currBitIndex = 0;
            this._isDone = function() {
                return true;
            };
            return;
        }
        var _b = bitStream.toBuffer(), buffer = _b.buffer, nZeroesAsEndPadding = _b.nZeroesAsEndPadding;
        this._bitStreamBuff = buffer;
        this._nZeroesAsPadding = nZeroesAsEndPadding;
        this._currByteIndex = 0;
        this._currByte = (0, uint8array_utils_1.readUint8)(this._bitStreamBuff, this._currByteIndex);
        this._currBitIndex = 0;
        this._updateByte = this._updateByte.bind(this);
        this._isDone = this._isDone.bind(this);
    }
    BitStreamIterator.prototype.next = function() {
        if (this._isDone()) return {
            done: true,
            value: 0
        };
        /*
        Debug.ignore.log(
            `currByte: ${this._currByte.toString(2).padStart( 8 , '0' )}`,
            `\nmask    : ${( 0b1 << ( 7 - this._currBitIndex ) ).toString(2).padStart( 8 , '0' )}`,
            `\nresult  : ${(
                this._currByte &
                ( 0b1 << ( 7 - this._currBitIndex ) )
            ).toString(2).padStart( 8 , '0' )}`
        )
        //*/ // get value
        var value = Boolean(this._currByte & 1 << 7 - this._currBitIndex) ? 1 : 0;
        // perform update for next call
        this._currBitIndex++;
        if (this._currBitIndex >= 8) {
            this._currBitIndex = 0;
            this._updateByte();
        }
        // yeilds value
        return {
            value: value,
            done: false
        };
    };
    BitStreamIterator.prototype._updateByte = function() {
        this._currByteIndex++;
        if (this._currByteIndex < this._bitStreamBuff.length) {
            this._currByte = (0, uint8array_utils_1.readUint8)(this._bitStreamBuff, this._currByteIndex);
        }
    };
    BitStreamIterator.prototype._isDone = function() {
        return this._currByteIndex >= this._bitStreamBuff.length || this._currByteIndex === this._bitStreamBuff.length - 1 && this._currBitIndex === 8 - this._nZeroesAsPadding;
    };
    return BitStreamIterator;
}();
exports.BitStreamIterator = BitStreamIterator;
}),
"[project]/node_modules/@harmoniclabs/bitstream/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/bitstream/dist/BitStream.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/pair/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Pair = void 0;
var Pair = function() {
    function Pair(a, b) {
        this.fst = a;
        this.snd = b;
    }
    Object.defineProperty(Pair.prototype, Symbol.toStringTag, {
        get: function() {
            return "Pair( ".concat(this.fst, ", ").concat(this.snd, " )");
        },
        enumerable: false,
        configurable: true
    });
    Pair.isStrictInstance = function(any) {
        if (any === undefined || any === null) return false;
        return Object.getPrototypeOf(any) === Pair.prototype;
    };
    Pair.prototype.asObj = function() {
        return {
            fst: this.fst,
            snd: this.snd
        };
    };
    return Pair;
}();
exports.Pair = Pair;
}),
"[project]/node_modules/@harmoniclabs/bytestring/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ByteString = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
function isHex(anyString) {
    // always think in javasript
    if (typeof anyString !== "string") return false;
    var str = anyString.toLowerCase();
    var validHex = "987654321abcdef0";
    for(var i = 0; i < str.length; i++){
        if (!validHex.includes(str[i])) return false;
    }
    // if false has not been returned yet, then it must be a valid hex
    return true;
}
function assert(condition, errorMessage, addInfos) {
    var args = [];
    for(var _i = 3; _i < arguments.length; _i++){
        args[_i - 3] = arguments[_i];
    }
    if (condition) return;
    args.length > 0 && console.error.apply(console, __spreadArray([], __read(args), false));
    addInfos && console.error(addInfos);
    if (errorMessage instanceof Error) {
        throw errorMessage;
    }
    ;
    throw new Error(errorMessage);
}
var ByteString = function() {
    function ByteString(bs) {
        if (typeof bs === "string") {
            // remove spaces
            bs = bs.trim().split(" ").join("");
            assert(isHex(bs), "invalid hex input while constructing a ByteString: " + bs);
            // even length
            bs = (0, uint8array_utils_1.fromHex)(bs.length % 2 === 1 ? "0" + bs : bs);
        }
        if (!(bs instanceof Uint8Array)) bs = bs.toBuffer();
        assert((0, uint8array_utils_1.isUint8Array)(bs), "invalid Uint8Array input while constructing a ByteString");
        this._bytes = bs;
    }
    ByteString.isStrictInstance = function(bs) {
        return Object.getPrototypeOf(bs) === ByteString.prototype;
    };
    Object.defineProperty(ByteString.prototype, "asString", {
        /**
         * @deprecated use `toString()` instead
         */ get: function() {
            return (0, uint8array_utils_1.toHex)(this._bytes);
        },
        enumerable: false,
        configurable: true
    });
    ByteString.prototype.toString = function() {
        return (0, uint8array_utils_1.toHex)(this._bytes);
    };
    Object.defineProperty(ByteString.prototype, "asBytes", {
        /**
         * @deprecated use `toBuffer()` instead
         */ get: function() {
            return this._bytes.slice();
        },
        enumerable: false,
        configurable: true
    });
    ByteString.prototype.toBuffer = function() {
        return this._bytes.slice();
    };
    ByteString.prototype.clone = function() {
        return new ByteString(this._bytes.slice());
    };
    ByteString.fromAscii = function(asciiStr) {
        return new ByteString((0, uint8array_utils_1.fromAscii)(asciiStr));
    };
    ByteString.toAscii = function(bStr) {
        return (0, uint8array_utils_1.toAscii)(bStr.toBuffer());
    };
    ByteString.isValidHexValue = function(str) {
        return isHex(str) && str.length % 2 === 0;
    };
    return ByteString;
}();
exports.ByteString = ByteString;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/roDescr.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.roDescr = void 0;
exports.roDescr = Object.freeze({
    writable: false,
    enumerable: true,
    configurable: false
});
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/DataB.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataB = void 0;
var bytestring_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bytestring/dist/index.js [app-client] (ecmascript)");
var roDescr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/roDescr.js [app-client] (ecmascript)");
var DataB = function() {
    function DataB(B) {
        if (!(B instanceof bytestring_1.ByteString)) B = new bytestring_1.ByteString(B);
        var _bytes = B.clone();
        Object.defineProperties(this, {
            bytes: __assign({
                value: _bytes
            }, roDescr_1.roDescr)
        });
    }
    DataB.prototype.clone = function() {
        // the constructor clones the bytes
        return new DataB(this.bytes);
    };
    DataB.prototype.toJson = function() {
        return {
            bytes: this.bytes.toString()
        };
    };
    DataB.prototype.toString = function() {
        return "B #".concat(this.bytes.toString());
    };
    return DataB;
}();
exports.DataB = DataB;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/assert.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assert = void 0;
function assert(condition, errorMessage, addInfos) {
    var args = [];
    for(var _i = 3; _i < arguments.length; _i++){
        args[_i - 3] = arguments[_i];
    }
    if (condition) return;
    args.length > 0 && console.error.apply(console, __spreadArray([], __read(args), false));
    addInfos && console.error(addInfos);
    if (errorMessage instanceof Error) {
        throw errorMessage;
    }
    ;
    throw new Error(errorMessage);
}
exports.assert = assert;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/DataConstr.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cborTagToConstrNumber = exports.constrNumberToCborTag = exports.DataConstr = void 0;
var biguint_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/biguint/dist/index.js [app-client] (ecmascript)");
var Data_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/Data.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/assert.js [app-client] (ecmascript)");
var roDescr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/roDescr.js [app-client] (ecmascript)");
var DataConstr = function() {
    function DataConstr(constr, fields) {
        (0, assert_1.assert)(Array.isArray(fields) && fields.every(Data_1.isData), "invalid fields passed to constructor");
        Object.defineProperties(this, {
            constr: __assign({
                value: (0, biguint_1.forceBigUInt)(constr)
            }, roDescr_1.roDescr),
            fields: __assign({
                value: fields
            }, roDescr_1.roDescr)
        });
    }
    DataConstr.prototype.clone = function() {
        return new DataConstr(this.constr, this.fields.map(function(dataElem) {
            return dataElem.clone();
        }));
    };
    DataConstr.prototype.toJson = function() {
        return {
            constr: Number(this.constr),
            fields: this.fields.map(function(f) {
                return f.toJson();
            })
        };
    };
    DataConstr.prototype.toString = function() {
        return "Constr ".concat(this.constr.toString(), " [").concat(this.fields.map(function(data) {
            return data.toString();
        }).join(","), "]");
    };
    return DataConstr;
}();
exports.DataConstr = DataConstr;
/**
 * Note [CBOR alternative tags]
 *
 * We've proposed to add additional tags to the CBOR standard to cover (essentially) sum types.
 * This is exactly what we need to encode the 'Constr' constructor of 'Data' in an unambiguous way.
 * The tags aren't *quite* accepted yet, but they're clearly going to accept so we might as well
 * start using them.
 * The scheme is:
 * - Alternatives 0-6 -> tags 121-127, followed by the arguments in a list
 * - Alternatives 7-127 -> tags 1280-1400, followed by the arguments in a list
 * - Any alternatives, including those that don't fit in the above -> tag 102 followed by a list containing
 * an unsigned integer for the actual alternative, and then the arguments in a (nested!) list.
 */ function constrNumberToCborTag(uint) {
    if (uint < BigInt(0)) {
        throw new Error("an unsinged integer was negative; while constructing a CborTag from a DataConstr; tag: " + uint);
    }
    if (uint < BigInt(7)) {
        return uint + BigInt(121);
    }
    if (uint < BigInt(128)) {
        // ( 1280 - 7 ) + uint
        return BigInt(1273) + uint;
    }
    return BigInt(102);
}
exports.constrNumberToCborTag = constrNumberToCborTag;
/**
 * the case ```tag === 102``` should be handled outside the funciton
 *
 * returns a negative number in case of unrecognized alternative
 */ function cborTagToConstrNumber(tag) {
    // should never happen being tag unsigned
    // ignores the tag if that's the case
    // negative numbers are returned also in case of unrecognized alternative
    if (tag < 0) return tag;
    if (121 <= tag && tag <= 127) return tag - BigInt(121);
    if (1280 <= tag && tag <= 1400) return tag - BigInt(1273);
    if (tag === BigInt(102)) return tag;
    // unrecognized alternative
    return BigInt(-1);
}
exports.cborTagToConstrNumber = cborTagToConstrNumber;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/DataI.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataI = void 0;
var roDescr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/roDescr.js [app-client] (ecmascript)");
var DataI = function() {
    function DataI(I) {
        if (I === void 0) {
            I = 0;
        }
        I = BigInt(I);
        Object.defineProperties(this, {
            int: __assign({
                value: I
            }, roDescr_1.roDescr)
        });
    }
    DataI.prototype.clone = function() {
        return new DataI(this.int);
    };
    DataI.prototype.toJson = function() {
        return {
            int: this.int.toString()
        };
    };
    DataI.prototype.toString = function() {
        return "I ".concat(this.int.toString());
    };
    return DataI;
}();
exports.DataI = DataI;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/DataList.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataList = void 0;
var Data_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/Data.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/assert.js [app-client] (ecmascript)");
var roDescr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/roDescr.js [app-client] (ecmascript)");
var DataList = function() {
    function DataList(list) {
        (0, assert_1.assert)(Array.isArray(list) && list.every(Data_1.isData), "invalid list passed to constructor");
        Object.defineProperties(this, {
            list: __assign({
                value: list
            }, roDescr_1.roDescr)
        });
    }
    DataList.prototype.clone = function() {
        return new DataList(this.list.map(function(dataElem) {
            return dataElem.clone();
        }));
    };
    DataList.prototype.toJson = function() {
        return {
            list: this.list.map(function(elem) {
                return elem.toJson();
            })
        };
    };
    DataList.prototype.toString = function() {
        return "List [".concat(this.list.map(function(data) {
            return data.toString();
        }).join(","), "]");
    };
    return DataList;
}();
exports.DataList = DataList;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/DataPair.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataPair = void 0;
var Data_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/Data.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/assert.js [app-client] (ecmascript)");
var roDescr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/roDescr.js [app-client] (ecmascript)");
var DataPair = function() {
    function DataPair(fst, snd) {
        (0, assert_1.assert)((0, Data_1.isData)(fst) && (0, Data_1.isData)(snd), "invalid Data passed to 'DataPair' constructor; fst: ".concat(fst, "; snd: ").concat(snd));
        Object.defineProperties(this, {
            fst: __assign({
                value: fst
            }, roDescr_1.roDescr),
            snd: __assign({
                value: snd
            }, roDescr_1.roDescr)
        });
    }
    DataPair.prototype.clone = function() {
        return new DataPair(this.fst, this.snd);
    };
    DataPair.prototype.toString = function() {
        return "(".concat(this.fst.toString(), ",").concat(this.snd.toString(), ")");
    };
    return DataPair;
}();
exports.DataPair = DataPair;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/DataMap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataMap = void 0;
var Data_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/Data.js [app-client] (ecmascript)");
var DataPair_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataPair.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/assert.js [app-client] (ecmascript)");
var roDescr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/roDescr.js [app-client] (ecmascript)");
var DataMap = function() {
    function DataMap(map) {
        (0, assert_1.assert)(Array.isArray(map) && map.every(function(entry) {
            return entry instanceof DataPair_1.DataPair && (0, Data_1.isData)(entry.fst) && (0, Data_1.isData)(entry.snd);
        }), "invalid map passed to 'DataPair' constructor");
        Object.defineProperties(this, {
            map: __assign({
                value: map
            }, roDescr_1.roDescr)
        });
    }
    DataMap.prototype.clone = function() {
        return new DataMap(this.map.map(function(pair) {
            return pair.clone();
        }));
    };
    DataMap.prototype.toJson = function() {
        return {
            map: this.map.map(function(_a) {
                var fst = _a.fst, snd = _a.snd;
                return {
                    k: fst.toJson(),
                    v: snd.toJson()
                };
            })
        };
    };
    DataMap.prototype.toString = function() {
        return "Map [".concat(this.map.map(function(dataPair) {
            return dataPair.toString();
        }).join(","), "]");
    };
    return DataMap;
}();
exports.DataMap = DataMap;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/Data.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dataFromJson = exports.cloneData = exports.eqData = exports.isData = void 0;
var DataB_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataB.js [app-client] (ecmascript)");
var DataConstr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataConstr.js [app-client] (ecmascript)");
var DataI_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataI.js [app-client] (ecmascript)");
var DataList_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataList.js [app-client] (ecmascript)");
var DataMap_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataMap.js [app-client] (ecmascript)");
var DataPair_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataPair.js [app-client] (ecmascript)");
function isSomething(something) {
    return something !== null && something !== undefined;
}
function isData(something) {
    if (!isSomething(something)) return false;
    var proto = Object.getPrototypeOf(something);
    return proto === DataConstr_1.DataConstr.prototype || proto === DataMap_1.DataMap.prototype || proto === DataList_1.DataList.prototype || proto === DataI_1.DataI.prototype || proto === DataB_1.DataB.prototype;
}
exports.isData = isData;
function eqData(a, b) {
    if (!(isSomething(a) && isSomething(b))) return false;
    var aProto = Object.getPrototypeOf(a);
    var bProto = Object.getPrototypeOf(b);
    if (aProto !== bProto) return false;
    if (aProto === DataConstr_1.DataConstr.prototype) {
        try {
            return a.constr === b.constr && a.fields.length === b.fields.length && a.fields.every(function(aField, idx) {
                return eqData(aField, b.fields[idx]);
            });
        } catch (e) {
            return false;
        }
    }
    if (aProto === DataMap_1.DataMap.prototype) {
        var aMap = a.map;
        var bMap_1 = b.map;
        return aMap.length === bMap_1.length && aMap.every(function(entry, idx) {
            var bEntry = bMap_1[idx];
            return eqData(entry.fst, bEntry.fst) && eqData(entry.snd, bEntry.snd);
        });
    }
    if (aProto === DataList_1.DataList.prototype) {
        return a.list.every(function(elem, idx) {
            return eqData(elem, b.list[idx]);
        });
    }
    if (aProto === DataI_1.DataI.prototype) {
        return a.int === b.int;
    }
    if (aProto === DataB_1.DataB.prototype) {
        return a.bytes.toString() === b.bytes.toString();
    }
    return false;
}
exports.eqData = eqData;
function cloneData(data) {
    if (!isData(data)) throw new Error("invalid data while cloning");
    return data.clone();
}
exports.cloneData = cloneData;
/**
 * all data instances (from any version) will have a `toJson` method
 * this function will get back the data of this version if needed
**/ function dataFromJson(json) {
    if (typeof json !== "object") throw new TypeError("unexpected input");
    var keys = Object.keys(json);
    if (keys.length <= 0) throw new TypeError("unexpected input");
    var k = keys[0];
    if (k === "int") return new DataI_1.DataI(json[k]);
    if (k === "bytes") return new DataB_1.DataB(json[k]);
    if (k === "list") return new DataList_1.DataList(json[k].map(dataFromJson));
    if (k === "map") {
        var jsonMap = json[k];
        return new DataMap_1.DataMap(jsonMap.map(function(_a) {
            var k = _a.k, v = _a.v;
            return new DataPair_1.DataPair(dataFromJson(k), dataFromJson(v));
        }));
    }
    if (keys.includes("constr")) return new DataConstr_1.DataConstr(json.constr, json.fields.map(dataFromJson));
    throw new Error("unknown json format");
}
exports.dataFromJson = dataFromJson;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/fromCbor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dataFromCbor = exports.dataFromCborObj = void 0;
var cbor_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/index.js [app-client] (ecmascript)");
var DataB_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataB.js [app-client] (ecmascript)");
var DataConstr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataConstr.js [app-client] (ecmascript)");
var DataI_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataI.js [app-client] (ecmascript)");
var DataList_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataList.js [app-client] (ecmascript)");
var DataMap_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataMap.js [app-client] (ecmascript)");
var DataPair_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataPair.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/assert.js [app-client] (ecmascript)");
function dataFromCborObj(cborObj) {
    (0, assert_1.assert)((0, cbor_1.isCborObj)(cborObj), "Invalid cborObj to convert to Data");
    if (cborObj instanceof cbor_1.CborUInt || cborObj instanceof cbor_1.CborNegInt) {
        return new DataI_1.DataI(cborObj.num);
    }
    if (cborObj instanceof cbor_1.CborBytes) {
        // if indefinite length (> 64)
        // `bytes` property already concats the chunks for us 
        return new DataB_1.DataB(cborObj.bytes);
    }
    if (cborObj instanceof cbor_1.CborArray) {
        return new DataList_1.DataList(cborObj.array.map(function(cObj) {
            return dataFromCborObj(cObj);
        }));
    }
    if (cborObj instanceof cbor_1.CborMap) {
        return new DataMap_1.DataMap(cborObj.map.map(function(entry) {
            return new DataPair_1.DataPair(dataFromCborObj(entry.k), dataFromCborObj(entry.v));
        }));
    }
    if (cborObj instanceof cbor_1.CborTag) {
        var tag = (0, DataConstr_1.cborTagToConstrNumber)(cborObj.tag);
        var data = cborObj.data;
        if (// any unrecognized tag
        tag < BigInt(0) || !(data instanceof cbor_1.CborArray)) {
            // ignore the tag and and treats the object as if it were normal CBOR
            return dataFromCborObj(data);
        }
        if (tag === BigInt(102) && cborObj.tag !== BigInt(1375)) {
            var dataArr = data.array;
            if (!(dataArr.length === 2 && dataArr[0] instanceof cbor_1.CborUInt && dataArr[1] instanceof cbor_1.CborArray)) throw new Error("invalid fileds for cbor tag 102 while constructing DataConstr");
            return new DataConstr_1.DataConstr(dataArr[0].num, dataArr[1].array.map(dataFromCborObj));
        }
        return new DataConstr_1.DataConstr(tag, data.array.map(dataFromCborObj));
    }
    // CborText and CborSimple not supported
    throw new Error("invalid CBOR major type for Data");
}
exports.dataFromCborObj = dataFromCborObj;
function dataFromCbor(cbor) {
    return dataFromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cbor)));
}
exports.dataFromCbor = dataFromCbor;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/fromString.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dataFromString = exports.dataFromStringWithOffset = void 0;
var DataB_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataB.js [app-client] (ecmascript)");
var DataConstr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataConstr.js [app-client] (ecmascript)");
var DataI_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataI.js [app-client] (ecmascript)");
var DataList_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataList.js [app-client] (ecmascript)");
var DataPair_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataPair.js [app-client] (ecmascript)");
var DataMap_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataMap.js [app-client] (ecmascript)");
// | [`I ${bigint}` ]
// | [`B #${string}`];
function formatStringByBrackets(str) {
    var openBracketIdx = str.indexOf("[");
    var bIdx = str.indexOf("B");
    var iIdx = str.indexOf("I");
    if (// there is no open bracket
    openBracketIdx < 0 || (// we have an open bracket
    // and B is also present
    bIdx >= 0 ? // and B is before the open bracket
    bIdx < openBracketIdx : // or I is also present
    iIdx >= 0 ? // and I is before
    iIdx < openBracketIdx : // else open bracket comes first
    false)) {
        var intMatch = str// I\s+             -> "I" followed by one or more space
        // \+?\-?           -> may or may nost start with "+" or "-"
        // (?<!\.)          -> MUST NOT have dots before
        // (?<!(#|x)\d*)    -> MUST NOT have before "#" or "x" with 0 or more digits (escluded bls elements and bytestrings)
        // \d+              -> one or more digits
        // (?!(\.|x))       -> MUST NOT have dots after or "x" (x excludes "0x" which are bls elems)
        .match(/I\s+\+?\-?(?<!\.)(?<!(#|x)\d*)\d+(?!(\.|x))/);
        var bsMatch = str.match(/B\s*#[0-9a-fA-F]*/);
        if (!bsMatch && !intMatch) throw new Error("expected Data I or B; found none");
        var match = bsMatch && intMatch ? str.indexOf(bsMatch[0]) < str.indexOf(intMatch[0]) ? bsMatch : intMatch : !bsMatch ? intMatch : bsMatch;
        if (!match) throw new Error("expected Data I or B; found none");
        var formattedStr = match[0];
        return {
            formatted: [
                formattedStr
            ],
            offset: str.indexOf(formattedStr) + formattedStr.length
        }; // I or B
    }
    var start = str.slice(0, openBracketIdx).trim();
    var prev = openBracketIdx + 1;
    var i = prev;
    var ch = "";
    var nOpen = 0;
    var isMap = /^\(?(\s*)?Map/.test(str);
    var insidePair = false;
    var pairK = undefined;
    var rest = [];
    while(true){
        ch = str[i];
        switch(ch){
            case "[":
                {
                    nOpen++;
                    break;
                }
            case "]":
                {
                    if (nOpen === 0) {
                        var elem = str.substring(prev, i).trim();
                        if (elem !== "") rest.push([
                            elem
                        ]);
                        return {
                            formatted: [
                                start,
                                rest
                            ],
                            offset: i + 1
                        };
                    } else nOpen--;
                    break;
                }
            case ",":
                {
                    if (nOpen === 0) {
                        if (!isMap) {
                            rest.push(formatStringByBrackets(str.substring(prev, i)).formatted);
                            prev = i + 1;
                        } else {
                            if (insidePair) {
                                if (str[prev] === ",") prev++;
                                if (str[prev] === "(") prev++;
                                pairK = formatStringByBrackets(str.substring(prev, i)).formatted;
                                prev = i + 1;
                            } else break;
                        }
                    }
                    break;
                }
            case "(":
                {
                    if (nOpen === 0) insidePair = true;
                    break;
                }
            case ")":
                {
                    if (nOpen === 0) {
                        var v = formatStringByBrackets(str.substring(prev, i)).formatted;
                        prev = i + 1;
                        rest.push({
                            k: pairK,
                            v: v
                        });
                        pairK = undefined;
                        insidePair = false;
                    }
                    break;
                }
            default:
                break;
        }
        i++;
    }
}
/**
 * parses the result of `data.toString()`
 *
 * @param {string} str data
 *
 * @returns and object with the parsed data and the length of the string used as `offset`
 */ function dataFromStringWithOffset(str) {
    var _a = formatStringByBrackets(str), words = _a.formatted, offset = _a.offset;
    return {
        data: parseWords(words),
        offset: offset
    };
}
exports.dataFromStringWithOffset = dataFromStringWithOffset;
/**
 * parses the result of `data.toString()`
 *
 * @param {string} str data
 */ function dataFromString(str) {
    return dataFromStringWithOffset(str).data;
}
exports.dataFromString = dataFromString;
function parseWords(words) {
    var start = words[0];
    while(start.startsWith("("))start = start.slice(1);
    if (/^\(?(\s*)?Constr/.test(start)) {
        var _a = __read(start.split(" "), 2), _ = _a[0], idxStr = _a[1];
        var idx = BigInt(idxStr);
        if (Array.isArray(words[1])) {
            var fields = words[1].map(parseWords);
            return new DataConstr_1.DataConstr(idx, fields);
        } else return dataFromString(words[0]);
    }
    if (/^\(?(\s*)?Map/.test(start)) {
        if (Array.isArray(words[1])) {
            var pairs = words[1];
            return new DataMap_1.DataMap(pairs.map(function(_a) {
                var k = _a.k, v = _a.v;
                return new DataPair_1.DataPair(parseWords(k), parseWords(v));
            }));
        } else return dataFromString(words[0]);
    }
    if (/^\(?(\s*)?List/.test(start)) {
        if (Array.isArray(words[1])) {
            return new DataList_1.DataList(words[1].map(parseWords));
        } else return dataFromString(words[0]);
    }
    if (start[0] === "I") {
        var _b = __read(start.split(" "), 2), _ = _b[0], valStr = _b[1];
        return new DataI_1.DataI(BigInt(valStr));
    }
    if (start[0] === "B") {
        var _c = __read(start.split("#"), 2), _ = _c[0], valueStr = _c[1];
        return new DataB_1.DataB(valueStr);
    }
    throw new Error("invalid string to parse Data; " + JSON.stringify(words));
}
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/toCbor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dataToCbor = exports.dataToCborObj = void 0;
var Data_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/Data.js [app-client] (ecmascript)");
var DataConstr_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataConstr.js [app-client] (ecmascript)");
var DataMap_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataMap.js [app-client] (ecmascript)");
var DataList_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataList.js [app-client] (ecmascript)");
var DataI_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataI.js [app-client] (ecmascript)");
var DataB_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataB.js [app-client] (ecmascript)");
var cbor_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/utils/assert.js [app-client] (ecmascript)");
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var minBigInt = BigInt("-18446744073709551616"); // -(2n ** 64n)
var maxBigInt = BigInt("18446744073709551615"); // (2n ** 64n) - 1n
function dataToCborObj(data) {
    (0, assert_1.assert)((0, Data_1.isData)(data), "Invalid data; cannot convert to CBOR");
    if (data instanceof DataConstr_1.DataConstr) {
        var constrNum = data.constr;
        var tag = (0, DataConstr_1.constrNumberToCborTag)(constrNum);
        var fields = new cbor_1.CborArray(data.fields.map(dataToCborObj), {
            indefinite: data.fields.length > 0
        });
        if (Number(tag) === 102) {
            /*
            Any alternatives, including those that don't fit in the above
            
            -> tag 102 followed by a list containing
                an unsigned integer for the actual alternative,
                and then the arguments in a (nested!) list.
            */ fields = new cbor_1.CborArray([
                new cbor_1.CborUInt(constrNum),
                fields
            ]);
        }
        return new cbor_1.CborTag(tag, fields);
    }
    if (data instanceof DataMap_1.DataMap) {
        return new cbor_1.CborMap(data.map.map(function(pair) {
            return {
                k: dataToCborObj(pair.fst),
                v: dataToCborObj(pair.snd)
            };
        }), {
            indefinite: data.map.length > 0
        });
    }
    if (data instanceof DataList_1.DataList) {
        return new cbor_1.CborArray(data.list.map(dataToCborObj), {
            indefinite: data.list.length > 0
        });
    }
    if (data instanceof DataI_1.DataI) {
        var n = data.int;
        return n < 0 ? new cbor_1.CborNegInt(n) : new cbor_1.CborUInt(n);
    }
    if (data instanceof DataB_1.DataB) {
        var bytes = data.bytes.toBuffer();
        // definite length only if length <= 64
        if (bytes.length <= 64) return new cbor_1.CborBytes(bytes);
        var ptr = 64;
        var fst = Uint8Array.prototype.slice.call(bytes, 0, ptr);
        var chunks = [];
        var chunkSize = 0;
        var chunkEnd = 0;
        while(ptr < bytes.length){
            chunkSize = Math.min(64, bytes.length - ptr);
            chunkEnd = ptr + chunkSize;
            chunks.push(Uint8Array.prototype.slice.call(bytes, ptr, chunkEnd));
            ptr = chunkEnd;
        }
        // indefinite length bytes
        return new cbor_1.CborBytes(fst, chunks);
    }
    throw new Error("'dataToCborObj' did not match any possible Data constructor");
}
exports.dataToCborObj = dataToCborObj;
function dataToCbor(data) {
    return cbor_1.Cbor.encode(dataToCborObj(data));
}
exports.dataToCbor = dataToCbor;
function positiveIntegerToBytes(n) {
    var hex = n.toString(16);
    return (0, uint8array_utils_1.fromHex)(hex.length % 2 === 0 ? hex : "0" + hex);
}
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/hashData.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashData = void 0;
var crypto_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/index.js [app-client] (ecmascript)");
var Data_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/Data.js [app-client] (ecmascript)");
var toCbor_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/toCbor.js [app-client] (ecmascript)");
function hashData(data) {
    if (!(0, Data_1.isData)(data)) throw new Error("hashData only works with Data");
    return (0, crypto_1.blake2b_256)((0, toCbor_1.dataToCbor)(data).toBuffer());
}
exports.hashData = hashData;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/toData/interface.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@harmoniclabs/plutus-data/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/Data.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataB.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataConstr.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataI.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataList.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataMap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/DataPair.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/fromCbor.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/fromString.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/toCbor.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/hashData.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/dist/toData/interface.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/biguint/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unsafeForceUInt = exports.forceBigUInt = exports.canBeUInteger = void 0;
function canBeUInteger(something) {
    return typeof something === "bigint" && something >= BigInt(0) || typeof something === "number" && something === Math.round(Math.abs(something));
}
exports.canBeUInteger = canBeUInteger;
function forceBigUInt(toForce) {
    if (!canBeUInteger(toForce)) {
        // console.error( toForce );
        throw new Error("trying to convert an integer to an unsigned Integer, the number was negative");
    }
    return BigInt(toForce);
}
exports.forceBigUInt = forceBigUInt;
;
function unsafeForceUInt(toForce) {
    if (!canBeUInteger(toForce)) {
        // console.error( toForce );
        throw new Error("trying to convert an integer to an unsigned Integer, the number was negative");
    }
    return Number(toForce);
}
exports.unsafeForceUInt = unsafeForceUInt;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborString/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborString = void 0;
var Cbor_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/Cbor/index.js [app-client] (ecmascript)");
var bytestring_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bytestring/dist/index.js [app-client] (ecmascript)");
var CborString = function(_super) {
    __extends(CborString, _super);
    function CborString(cbor) {
        if (typeof cbor === "string") {
            cbor = cbor.split(" ").join("");
            // hex string length has to be even
            cbor = cbor.length % 2 ? "0" + cbor : cbor;
        }
        return _super.call(this, cbor) || this;
    }
    CborString.isStrictInstance = function(cborStr) {
        return cborStr !== undefined && cborStr !== null && cborStr instanceof CborString;
    };
    CborString.fromCborObj = function(jsonCbor) {
        return Cbor_1.Cbor.encode(jsonCbor);
    };
    CborString.prototype.toCborObj = function() {
        return Cbor_1.Cbor.parse(this);
    };
    return CborString;
}(bytestring_1.ByteString);
exports.CborString = CborString;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/constants/max.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MAX_1_BYTE = exports.OVERFLOW_4_BYTES = exports.OVERFLOW_2_BYTES = exports.OVERFLOW_1_BYTE = exports.MAX_4_BYTES = exports.maxBigInt = exports.minBigInt = void 0;
/** Lowest value that can be encoded directly as (negative) integer */ exports.minBigInt = BigInt("-18446744073709551616"); // -(2n ** 64n)
/** Highest value that can be encoded directly as (positive) integer */ exports.maxBigInt = BigInt("18446744073709551615"); // (2n ** 64n) - 1n
exports.MAX_4_BYTES = 4294967295;
exports.OVERFLOW_1_BYTE = 0x100;
exports.OVERFLOW_2_BYTES = 0x10000;
exports.OVERFLOW_4_BYTES = 0x100000000;
exports.MAX_1_BYTE = 255;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/utils/headerFollowingToAddInfos.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.headerFollowingToAddInfos = void 0;
var max_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/constants/max.js [app-client] (ecmascript)");
/**
 *
 * @param {number} following : number immediately following the header
 * usually the payload length, or the number itself for uints and negInts
 *
 * @returns {number} a 5 bit unsigned integer that best represents the number of bytes
 */ function headerFollowingToAddInfos(following) {
    if (following < 0) return headerFollowingToAddInfos(-following);
    if (following > max_1.MAX_4_BYTES) return 27;
    if (following < 24) return Number(following);
    if (following < max_1.OVERFLOW_1_BYTE) return 24;
    if (following < max_1.OVERFLOW_2_BYTES) return 25;
    if (following < max_1.OVERFLOW_4_BYTES) return 26;
    return 27;
}
exports.headerFollowingToAddInfos = headerFollowingToAddInfos;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborBytes.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborBytes = exports.isRawCborBytes = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var headerFollowingToAddInfos_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/headerFollowingToAddInfos.js [app-client] (ecmascript)");
function isRawCborBytes(b) {
    if (typeof b !== "object" || b === null) return false;
    var keys = Object.keys(b);
    return keys.includes("bytes") && (0, uint8array_utils_1.isUint8Array)(b.bytes);
}
exports.isRawCborBytes = isRawCborBytes;
var CborBytes = function() {
    function CborBytes(bytes, addInfos, subCborRef) {
        this.subCborRef = subCborRef;
        this.chunks = bytes;
        this.addInfos = addInfos !== null && addInfos !== void 0 ? addInfos : (0, headerFollowingToAddInfos_1.headerFollowingToAddInfos)(this.bytes.length);
    }
    Object.defineProperty(CborBytes.prototype, "buffer", {
        /** @deprecated use `bytes` instead */ get: function() {
            return this.bytes;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborBytes.prototype, "bytes", {
        /**
         * concatenates all the chunks
         * returns
         **/ get: function() {
            if (this.chunks instanceof Uint8Array) return Uint8Array.prototype.slice.call(this.chunks);
            return uint8array_utils_1.concatUint8Array.apply(void 0, __spreadArray([], __read(this.chunks.map(function(ch) {
                return ch.bytes;
            })), false));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborBytes.prototype, "isDefiniteLength", {
        get: function() {
            return this.chunks instanceof Uint8Array;
        },
        enumerable: false,
        configurable: true
    });
    CborBytes.prototype.toRawObj = function() {
        return {
            bytes: Uint8Array.prototype.slice.call(this.bytes)
        };
    };
    CborBytes.prototype.clone = function() {
        var _a;
        return new CborBytes(this.chunks instanceof Uint8Array ? this.chunks : this.chunks.map(function(ch) {
            return ch.clone();
        }), this.addInfos, (_a = this.subCborRef) === null || _a === void 0 ? void 0 : _a.clone());
    };
    return CborBytes;
}();
exports.CborBytes = CborBytes;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assert = void 0;
function assert(condition, errorMessage, addInfos) {
    var args = [];
    for(var _i = 3; _i < arguments.length; _i++){
        args[_i - 3] = arguments[_i];
    }
    if (condition) return;
    args.length > 0 && console.error.apply(console, __spreadArray([], __read(args), false));
    addInfos && console.error(addInfos);
    if (errorMessage instanceof Error) {
        throw errorMessage;
    }
    ;
    throw new Error(errorMessage);
}
exports.assert = assert;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborMap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborMap = exports.isRawCborMap = void 0;
var obj_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/obj-utils/dist/index.js [app-client] (ecmascript)");
var _1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/index.js [app-client] (ecmascript)");
var headerFollowingToAddInfos_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/headerFollowingToAddInfos.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
var defaultOpts = Object.freeze({
    indefinite: false,
    addInfos: undefined
});
function isRawCborMap(m) {
    if (typeof m !== "object" || m === null) return false;
    var keys = Object.keys(m);
    return keys.includes("map") && Array.isArray(m.map) && m.map.every(function(entry) {
        if (typeof entry !== "object" || entry === null) return false;
        var entryKeys = Object.keys(entry);
        return entryKeys.includes("k") && (0, _1.isRawCborObj)(entry.k) && entryKeys.includes("v") && (0, _1.isRawCborObj)(entry.v);
    });
}
exports.isRawCborMap = isRawCborMap;
var CborMap = function() {
    function CborMap(map, options, subCborRef) {
        var _a;
        this.subCborRef = subCborRef;
        (0, assert_1.assert)(Array.isArray(map) && map.every(function(entry) {
            return (0, obj_utils_1.isObject)(entry) && (0, _1.isCborObj)(entry.k) && (0, _1.isCborObj)(entry.v);
        }), "in 'CborMap' constructor: invalid input; got: " + map);
        var indefinite = (options === null || options === void 0 ? void 0 : options.indefinite) === true ? true : defaultOpts.indefinite;
        this.addInfos = (_a = options === null || options === void 0 ? void 0 : options.addInfos) !== null && _a !== void 0 ? _a : (0, headerFollowingToAddInfos_1.headerFollowingToAddInfos)(map.length);
        this.map = map;
        this.indefinite = indefinite === true;
    }
    CborMap.prototype.toRawObj = function() {
        return {
            map: this.map.map(function(entry) {
                return {
                    k: entry.k.toRawObj(),
                    v: entry.v.toRawObj()
                };
            }),
            options: {
                indefinite: this.indefinite
            }
        };
    };
    CborMap.prototype.clone = function() {
        var _a;
        return new CborMap(this.map.map(function(entry) {
            return {
                k: entry.k.clone(),
                v: entry.v.clone()
            };
        }), {
            indefinite: this.indefinite,
            addInfos: this.addInfos
        }, (_a = this.subCborRef) === null || _a === void 0 ? void 0 : _a.clone());
    };
    return CborMap;
}();
exports.CborMap = CborMap;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborNegInt.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborNegInt = exports.isRawCborNegative = void 0;
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
var CborBytes_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborBytes.js [app-client] (ecmascript)");
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var max_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/constants/max.js [app-client] (ecmascript)");
var headerFollowingToAddInfos_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/headerFollowingToAddInfos.js [app-client] (ecmascript)");
function isRawCborNegative(neg) {
    if (typeof neg !== "object" || neg === null) return false;
    var keys = Object.keys(neg);
    return keys.includes("neg") && typeof neg.neg === "bigint" && neg.neg < 0;
}
exports.isRawCborNegative = isRawCborNegative;
var CborNegInt = function() {
    function CborNegInt(neg, addInfos, bigNumEncoding, subCborRef) {
        this.subCborRef = subCborRef;
        if (typeof neg === "number") neg = BigInt(neg);
        this.num = neg;
        this.addInfos = addInfos !== null && addInfos !== void 0 ? addInfos : (0, headerFollowingToAddInfos_1.headerFollowingToAddInfos)(neg);
        // this.followingHeaderBytes = followingHeaderBytes;
        if (bigNumEncoding instanceof CborBytes_1.CborBytes) this.bigNumEncoding = bigNumEncoding;
        else this.bigNumEncoding = undefined;
    }
    Object.defineProperty(CborNegInt.prototype, "num", {
        get: function() {
            if (this.bigNumEncoding instanceof CborBytes_1.CborBytes) {
                this._num = -(BigInt("0x" + (0, uint8array_utils_1.toHex)(this.bigNumEncoding.bytes)) + BigInt(1));
            }
            return this._num;
        },
        set: function(neg) {
            (0, assert_1.assert)(neg < 0, "neg CBOR numbers must be less than 0; got: " + neg);
            neg = BigInt(neg);
            // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
            if (neg < max_1.minBigInt) {
                neg = BigInt(-1) - BigInt(neg);
                var hex = neg.toString(16);
                if (hex.length % 2 === 1) hex = "0" + hex;
                this.bigNumEncoding = new CborBytes_1.CborBytes((0, uint8array_utils_1.fromHex)(hex));
            }
            this._num = BigInt(neg);
        },
        enumerable: false,
        configurable: true
    });
    CborNegInt.prototype.isBigNum = function() {
        return this.bigNumEncoding instanceof CborBytes_1.CborBytes;
    };
    CborNegInt.bigNum = function(encoding, subCborRef) {
        if (typeof encoding === "number") encoding = BigInt(encoding);
        if (typeof encoding === "bigint" && encoding >= 0) encoding = -encoding; // ensure negative number
        var n = undefined;
        if (!(encoding instanceof CborBytes_1.CborBytes)) {
            n = encoding; // remember negative number
            encoding = BigInt(-1) - BigInt(encoding); // translate to positive so we can encode as bytes
            var hex = encoding.toString(16); // hex
            if (hex.length % 2 === 1) hex = "0" + hex; // even length
            encoding = new CborBytes_1.CborBytes((0, uint8array_utils_1.fromHex)(hex)); // bytes
        } else {
            n = BigInt(-1) - BigInt("0x" + (0, uint8array_utils_1.toHex)(encoding.bytes));
        } // was bytes
        return new CborNegInt(n, 0, encoding, subCborRef);
    };
    CborNegInt.prototype.toRawObj = function() {
        return {
            neg: this.num
        };
    };
    CborNegInt.prototype.clone = function() {
        var _a, _b;
        return new CborNegInt(this.num, this.addInfos, (_a = this.bigNumEncoding) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.subCborRef) === null || _b === void 0 ? void 0 : _b.clone());
    };
    return CborNegInt;
}();
exports.CborNegInt = CborNegInt;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborSimple.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborSimple = exports.isRawCborSimple = exports.isSimpleCborValue = void 0;
var obj_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/obj-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
function isSimpleCborValue(v) {
    var t = typeof v;
    return v === null || t === "boolean" || t === "undefined" || t === "number";
}
exports.isSimpleCborValue = isSimpleCborValue;
function isRawCborSimple(s) {
    if (typeof s !== "object" || s === null) return false;
    var keys = Object.keys(s);
    return keys.includes("simple") && isSimpleCborValue(s.simple);
}
exports.isRawCborSimple = isRawCborSimple;
var CborSimple = function() {
    function CborSimple(simple, interpretNumAs, subCborRef) {
        this.subCborRef = subCborRef;
        if (interpretNumAs === undefined && typeof simple === "number" && simple >= 0 && simple <= 255 && simple === Math.round(simple)) interpretNumAs = "simple";
        if (interpretNumAs === undefined) interpretNumAs = "float";
        if (interpretNumAs === "simple") {
            (0, assert_1.assert)(typeof simple === "number" && simple >= 0 && simple <= 255 && simple === Math.round(simple), "invalid simple value");
        }
        (0, assert_1.assert)(isSimpleCborValue(simple), "invalid cbor simple value; received: " + simple);
        (0, obj_utils_1.defineReadOnlyProperty)(this, "simple", simple);
        (0, obj_utils_1.defineReadOnlyProperty)(this, "numAs", interpretNumAs);
    }
    CborSimple.prototype.toRawObj = function() {
        return {
            simple: this.simple
        };
    };
    CborSimple.prototype.clone = function() {
        var _a;
        return new CborSimple(this.simple, this.numAs, (_a = this.subCborRef) === null || _a === void 0 ? void 0 : _a.clone());
    };
    Object.defineProperty(CborSimple, "null", {
        get: function() {
            return new CborSimple(null);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborSimple, "true", {
        get: function() {
            return new CborSimple(true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborSimple, "false", {
        get: function() {
            return new CborSimple(false);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborSimple, "undefined", {
        get: function() {
            return new CborSimple(undefined);
        },
        enumerable: false,
        configurable: true
    });
    CborSimple.simpleNumber = function(n) {
        if (typeof n !== "number") n = 0;
        return new CborSimple(n, "simple");
    };
    CborSimple.float = function(n) {
        if (typeof n !== "number") n = 0;
        return new CborSimple(n, "float");
    };
    return CborSimple;
}();
exports.CborSimple = CborSimple;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/utils/ints.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unsafeForceUInt = exports.forceBigUInt = exports.canBeUInteger = void 0;
function canBeUInteger(something) {
    return typeof something === "bigint" && something >= BigInt(0) || typeof something === "number" && something === Math.round(Math.abs(something));
}
exports.canBeUInteger = canBeUInteger;
function forceBigUInt(toForce) {
    if (!canBeUInteger(toForce)) {
        // console.error( toForce );
        throw new Error("trying to convert an integer to an unsigned Integer, the number was negative");
    }
    return BigInt(toForce);
}
exports.forceBigUInt = forceBigUInt;
;
function unsafeForceUInt(toForce) {
    if (!canBeUInteger(toForce)) {
        // console.error( toForce );
        throw new Error("trying to convert an integer to an unsigned Integer, the number was negative");
    }
    return Number(toForce);
}
exports.unsafeForceUInt = unsafeForceUInt;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborTag.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborTag = exports.isRawCborTag = void 0;
var obj_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/obj-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
var ints_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/ints.js [app-client] (ecmascript)");
var CborObj_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborObj.js [app-client] (ecmascript)");
function isRawCborTag(t) {
    if (typeof t !== "object" || t === null) return false;
    var keys = Object.keys(t);
    return keys.includes("tag") && keys.includes("data") && (0, ints_1.canBeUInteger)(t.tag) && (0, CborObj_1.isRawCborObj)(t.data);
}
exports.isRawCborTag = isRawCborTag;
var CborTag = function() {
    function CborTag(tag, data, subCborRef) {
        this.subCborRef = subCborRef;
        if (typeof tag === "number") tag = BigInt(tag);
        (0, assert_1.assert)(typeof tag === "bigint" && (0, CborObj_1.isCborObj)(data), "using direct value constructor; either 'tag' is not a number or 'data' is missing");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "tag", tag);
        (0, obj_utils_1.defineReadOnlyProperty)(this, "data", data);
    }
    CborTag.prototype.toRawObj = function() {
        return {
            tag: this.tag,
            data: this.data.toRawObj()
        };
    };
    CborTag.prototype.clone = function() {
        var _a;
        return new CborTag(this.tag, this.data.clone(), (_a = this.subCborRef) === null || _a === void 0 ? void 0 : _a.clone());
    };
    return CborTag;
}();
exports.CborTag = CborTag;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborText.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborText = exports.isRawCborText = void 0;
var headerFollowingToAddInfos_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/headerFollowingToAddInfos.js [app-client] (ecmascript)");
function isRawCborText(t) {
    if (typeof t !== "object" || t === null) return false;
    var keys = Object.keys(t);
    return keys.includes("text") && typeof t.text === "string";
}
exports.isRawCborText = isRawCborText;
var CborText = function() {
    function CborText(text, addInfos, subCborRef) {
        this.subCborRef = subCborRef;
        this.chunks = text;
        this.addInfos = addInfos !== null && addInfos !== void 0 ? addInfos : (0, headerFollowingToAddInfos_1.headerFollowingToAddInfos)(text.length);
    }
    Object.defineProperty(CborText.prototype, "text", {
        get: function() {
            if (typeof this.chunks === "string") return this.chunks;
            return this.chunks.reduce(function(accum, chunk) {
                return accum + chunk.text;
            }, "");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborText.prototype, "isDefiniteLength", {
        get: function() {
            return typeof this.chunks === "string";
        },
        enumerable: false,
        configurable: true
    });
    CborText.prototype.toRawObj = function() {
        return {
            text: this.text
        };
    };
    CborText.prototype.clone = function() {
        var _a;
        return new CborText(typeof this.chunks === "string" ? this.chunks : this.chunks.map(function(chunk) {
            return chunk.clone();
        }), this.addInfos, (_a = this.subCborRef) === null || _a === void 0 ? void 0 : _a.clone());
    };
    return CborText;
}();
exports.CborText = CborText;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborUInt.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborUInt = exports.isRawCborUnsigned = void 0;
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
var CborBytes_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborBytes.js [app-client] (ecmascript)");
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var max_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/constants/max.js [app-client] (ecmascript)");
var headerFollowingToAddInfos_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/headerFollowingToAddInfos.js [app-client] (ecmascript)");
function isRawCborUnsigned(unsign) {
    if (typeof unsign !== "object" || unsign === null) return false;
    var keys = Object.keys(unsign);
    return keys.includes("uint") && typeof unsign.uint === "bigint" && unsign.uint >= 0;
}
exports.isRawCborUnsigned = isRawCborUnsigned;
var CborUInt = function() {
    function CborUInt(uint, addInfos, bigNumEncoding, subCborRef) {
        this.subCborRef = subCborRef;
        this.num = uint;
        this.addInfos = addInfos !== null && addInfos !== void 0 ? addInfos : (0, headerFollowingToAddInfos_1.headerFollowingToAddInfos)(uint);
        if (bigNumEncoding instanceof CborBytes_1.CborBytes) this.bigNumEncoding = bigNumEncoding;
        else this.bigNumEncoding = undefined;
    }
    Object.defineProperty(CborUInt.prototype, "num", {
        get: function() {
            if (this.bigNumEncoding instanceof CborBytes_1.CborBytes) {
                this._num = BigInt("0x" + (0, uint8array_utils_1.toHex)(this.bigNumEncoding.bytes));
            }
            return this._num;
        },
        set: function(uint) {
            (0, assert_1.assert)(uint >= BigInt(0), "uint CBOR numbers must be greater or equal 0; got: " + uint);
            uint = BigInt(uint);
            if (uint > max_1.maxBigInt) {
                var hex = uint.toString(16);
                if (hex.length % 2 === 1) hex = "0" + hex;
                this.bigNumEncoding = new CborBytes_1.CborBytes((0, uint8array_utils_1.fromHex)(hex));
            }
            this._num = uint;
        },
        enumerable: false,
        configurable: true
    });
    CborUInt.prototype.isBigNum = function() {
        return this.bigNumEncoding instanceof CborBytes_1.CborBytes;
    };
    CborUInt.bigNum = function(encoding, subCborRef) {
        var n = undefined;
        if (!(encoding instanceof CborBytes_1.CborBytes)) {
            encoding = BigInt(encoding);
            n = encoding;
            var hex = encoding.toString(16);
            if (hex.length % 2 === 1) hex = "0" + hex;
            encoding = new CborBytes_1.CborBytes((0, uint8array_utils_1.fromHex)(hex));
        } else {
            n = BigInt("0x" + (0, uint8array_utils_1.toHex)(encoding.bytes));
        }
        return new CborUInt(n, 0, encoding, subCborRef);
    };
    CborUInt.prototype.toRawObj = function() {
        return {
            uint: this.num
        };
    };
    CborUInt.prototype.clone = function() {
        var _a, _b;
        return new CborUInt(this.num, this.addInfos, (_a = this.bigNumEncoding) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.subCborRef) === null || _b === void 0 ? void 0 : _b.clone());
    };
    return CborUInt;
}();
exports.CborUInt = CborUInt;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/errors/BaseCborError/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseCborError = void 0;
var BaseCborError = function(_super) {
    __extends(BaseCborError, _super);
    function BaseCborError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return BaseCborError;
}(Error);
exports.BaseCborError = BaseCborError;
;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/errors/BaseCborError/CborParseError.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborParseError = void 0;
var _1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/errors/BaseCborError/index.js [app-client] (ecmascript)");
var CborParseError = function(_super) {
    __extends(CborParseError, _super);
    function CborParseError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CborParseError;
}(_1.BaseCborError);
exports.CborParseError = CborParseError;
;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/errors/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/errors/BaseCborError/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/errors/BaseCborError/CborParseError.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborObj.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
Intermediate data type that allows an easier conversion from (and to) CBOR to (and from) JSON serializables objects
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cborObjFromRaw = exports.isRawCborObj = exports.isCborObj = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var CborArray_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborArray.js [app-client] (ecmascript)");
var CborBytes_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborBytes.js [app-client] (ecmascript)");
var CborMap_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborMap.js [app-client] (ecmascript)");
var CborNegInt_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborNegInt.js [app-client] (ecmascript)");
var CborSimple_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborSimple.js [app-client] (ecmascript)");
var CborTag_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborTag.js [app-client] (ecmascript)");
var CborText_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborText.js [app-client] (ecmascript)");
var CborUInt_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborUInt.js [app-client] (ecmascript)");
var errors_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/errors/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
function isCborObj(cborObj) {
    return cborObj instanceof CborNegInt_1.CborNegInt || cborObj instanceof CborUInt_1.CborUInt || cborObj instanceof CborBytes_1.CborBytes || cborObj instanceof CborText_1.CborText || cborObj instanceof CborArray_1.CborArray || cborObj instanceof CborMap_1.CborMap || cborObj instanceof CborTag_1.CborTag || cborObj instanceof CborSimple_1.CborSimple;
}
exports.isCborObj = isCborObj;
function isRawCborObj(rawCborObj) {
    if (typeof rawCborObj !== "object" || rawCborObj === null || Array.isArray(rawCborObj)) return false;
    var keys = Object.keys(rawCborObj);
    if (keys.length <= 0) return false;
    if (keys.includes("array")) {
        return Array.isArray(rawCborObj.array) && rawCborObj.array.every(isRawCborObj);
    }
    if (keys.includes("map")) {
        return Array.isArray(rawCborObj.map) && rawCborObj.map.every(function(entry) {
            return isRawCborObj(entry.k) && isRawCborObj(entry.v);
        });
    }
    if (keys.includes("tag")) {
        return keys.includes("data") && isRawCborObj(rawCborObj.data);
    }
    var includes = function(k) {
        return keys.includes(k);
    };
    return includes("neg") && typeof rawCborObj.neg === "bigint" && rawCborObj.neg < 0 || includes("uint") && typeof rawCborObj.uint === "bigint" && rawCborObj.uint >= 0 || includes("bytes") && (0, uint8array_utils_1.isUint8Array)(rawCborObj.bytes) || includes("text") && typeof rawCborObj.text === "string" || includes("simple") && (0, CborSimple_1.isSimpleCborValue)(rawCborObj.simple);
}
exports.isRawCborObj = isRawCborObj;
function cborObjFromRaw(_rawCborObj) {
    (0, assert_1.assert)(isRawCborObj(_rawCborObj), "expected a vaild 'RawCborObj' as input; got: " + Object.keys(_rawCborObj));
    function _cborObjFromRaw(rawCborObj) {
        if ((0, CborNegInt_1.isRawCborNegative)(rawCborObj)) return new CborNegInt_1.CborNegInt(rawCborObj.neg);
        if ((0, CborUInt_1.isRawCborUnsigned)(rawCborObj)) return new CborUInt_1.CborUInt(rawCborObj.uint);
        if ((0, CborBytes_1.isRawCborBytes)(rawCborObj)) return new CborBytes_1.CborBytes(rawCborObj.bytes);
        if ((0, CborText_1.isRawCborText)(rawCborObj)) return new CborText_1.CborText(rawCborObj.text);
        if ((0, CborArray_1.isRawCborArray)(rawCborObj)) return new CborArray_1.CborArray(rawCborObj.array.map(_cborObjFromRaw), rawCborObj.options);
        if ((0, CborMap_1.isRawCborMap)(rawCborObj)) return new CborMap_1.CborMap(rawCborObj.map.map(function(entry) {
            return {
                k: _cborObjFromRaw(entry.k),
                v: _cborObjFromRaw(entry.v)
            };
        }), rawCborObj.options);
        if ((0, CborTag_1.isRawCborTag)(rawCborObj)) return new CborTag_1.CborTag(rawCborObj.tag, _cborObjFromRaw(rawCborObj.data));
        if ((0, CborSimple_1.isRawCborSimple)(rawCborObj)) return new CborSimple_1.CborSimple(rawCborObj.simple);
        throw new errors_1.BaseCborError("'cborObjFromRaw' did not match any possible 'RawCborObj'");
    }
    return _cborObjFromRaw(_rawCborObj);
}
exports.cborObjFromRaw = cborObjFromRaw;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborArray.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborArray = exports.isRawCborArray = void 0;
var CborObj_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborObj.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
var headerFollowingToAddInfos_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/headerFollowingToAddInfos.js [app-client] (ecmascript)");
function isRawCborArray(arr) {
    if (typeof arr !== "object") return false;
    var keys = Object.keys(arr);
    return keys.includes("array") && Array.isArray(arr.array) && arr.array.every(CborObj_1.isRawCborObj);
}
exports.isRawCborArray = isRawCborArray;
var defaultOpts = Object.freeze({
    indefinite: false,
    addInfos: 0
});
var CborArray = function() {
    function CborArray(array, options, subCborRef) {
        var _a;
        this.subCborRef = subCborRef;
        (0, assert_1.assert)(Array.isArray(array) && array.every(CborObj_1.isCborObj), "in 'CborArray' constructor: invalid input; got: " + array);
        var indefinite = (options === null || options === void 0 ? void 0 : options.indefinite) === true ? true : defaultOpts.indefinite;
        this.addInfos = (_a = options === null || options === void 0 ? void 0 : options.addInfos) !== null && _a !== void 0 ? _a : (0, headerFollowingToAddInfos_1.headerFollowingToAddInfos)(array.length);
        this.array = array;
        this.indefinite = indefinite === true;
    }
    CborArray.prototype.toRawObj = function() {
        return {
            array: this.array.map(function(cborObj) {
                return cborObj.toRawObj();
            }),
            options: this.indefinite === true ? {
                indefinite: this.indefinite
            } : undefined
        };
    };
    CborArray.prototype.clone = function() {
        var _a;
        return new CborArray(this.array.map(function(elem) {
            return elem.clone();
        }), {
            indefinite: this.indefinite,
            addInfos: this.addInfos
        }, (_a = this.subCborRef) === null || _a === void 0 ? void 0 : _a.clone());
    };
    return CborArray;
}();
exports.CborArray = CborArray;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/interfaces/ToRawObj.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/interfaces/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/interfaces/ToRawObj.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborArray.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborBytes.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborMap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborNegInt.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborSimple.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborTag.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborText.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborUInt.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/interfaces/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborObj.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/Cbor/Constants/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborConstants = exports.isUInt8MajorType = exports.UInt8MajorType = exports.isMajorTypeTag = exports.MajorType = void 0;
var MajorType;
(function(MajorType) {
    MajorType[MajorType["unsigned"] = 0] = "unsigned";
    MajorType[MajorType["negative"] = 1] = "negative";
    MajorType[MajorType["bytes"] = 2] = "bytes";
    MajorType[MajorType["text"] = 3] = "text";
    MajorType[MajorType["array"] = 4] = "array";
    MajorType[MajorType["map"] = 5] = "map";
    MajorType[MajorType["tag"] = 6] = "tag";
    MajorType[MajorType["float_or_simple"] = 7] = "float_or_simple"; // 111x_xxxx // 
})(MajorType = exports.MajorType || (exports.MajorType = {}));
;
Object.freeze(MajorType);
function isMajorTypeTag(majorTag) {
    return majorTag >= 0 && majorTag <= 7 && majorTag === Math.round(majorTag);
}
exports.isMajorTypeTag = isMajorTypeTag;
var UInt8MajorType;
(function(UInt8MajorType) {
    UInt8MajorType[UInt8MajorType["unsigned"] = 0] = "unsigned";
    UInt8MajorType[UInt8MajorType["negative"] = 32] = "negative";
    UInt8MajorType[UInt8MajorType["bytes"] = 64] = "bytes";
    UInt8MajorType[UInt8MajorType["text"] = 96] = "text";
    UInt8MajorType[UInt8MajorType["array"] = 128] = "array";
    UInt8MajorType[UInt8MajorType["map"] = 160] = "map";
    UInt8MajorType[UInt8MajorType["tag"] = 192] = "tag";
    UInt8MajorType[UInt8MajorType["float_or_simple"] = 224] = "float_or_simple";
})(UInt8MajorType = exports.UInt8MajorType || (exports.UInt8MajorType = {}));
Object.freeze(UInt8MajorType);
function isUInt8MajorType(byte) {
    return (byte & 224) === byte && isMajorTypeTag(byte >> 5);
}
exports.isUInt8MajorType = isUInt8MajorType;
/**
 * @static
 */ var AddInfos = function() {
    function AddInfos() {}
    AddInfos.Length = Object.freeze({
        expect_uint8: 24,
        expect_uint16: 25,
        expect_uint32: 26,
        expect_uint64: 27,
        make_infinite: 31
    });
    AddInfos.Tag = {
        utf8_string: 0 | 0,
        epoch_datetime: 1 | 0,
        positive_bignum: 2 | 0,
        negative_bignum: 3 | 0,
        decimal_frac_array: 4 | 0,
        bigfloat: 5 | 0,
        expect_base64_url: 21 | 0,
        expect_base64: 22 | 0,
        expect_base16: 23 | 0,
        sub_cbor: 24 | 0,
        uri: 32 | 0,
        base64_url: 33 | 0,
        base64: 34 | 0,
        regexp: 35 | 0,
        MIME: 36 | 0,
        self_cbor: 55799 | 0
    };
    AddInfos.Major7 = Object.freeze({
        false: 20,
        true: 21,
        null: 22,
        undefined: 23,
        simple_byte: 24,
        float_half: 25,
        float_single: 26,
        float_double: 27,
        infinite_break: 31
    });
    return AddInfos;
}();
/**
 * @static
 */ var CborConstants = function() {
    function CborConstants() {}
    ;
    CborConstants.MajorTypeMask = 224;
    CborConstants.AdditionalInfosMask = 31;
    CborConstants.AddInfos = AddInfos;
    CborConstants.MajorType = Object.freeze({
        unsigned: 0,
        negative: 1,
        bytes: 2,
        text: 3,
        array: 4,
        map: 5,
        tag: 6,
        float_or_simple: 7 // 111x_xxxx // 
    });
    CborConstants.UInt8MajorType = Object.freeze({
        unsigned: 0,
        negative: 32,
        bytes: 64,
        text: 96,
        array: 128,
        map: 160,
        tag: 192,
        float_or_simple: 224
    });
    CborConstants.infinite_break = 255; // 0xff // 255
    return CborConstants;
}();
exports.CborConstants = CborConstants;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborArray.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LazyCborArray = void 0;
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
var defaultOpts = Object.freeze({
    indefinite: false,
    addInfos: 0
});
var LazyCborArray = function() {
    function LazyCborArray(array, options) {
        (0, assert_1.assert)(Array.isArray(array) && array.every(function(elem) {
            return elem instanceof Uint8Array;
        }), "in 'LazyCborArray' constructor: invalid input; got: " + array);
        var indefinite = __assign(__assign({}, defaultOpts), options).indefinite;
        var _array = array;
        Object.defineProperties(this, {
            array: {
                get: function() {
                    return _array;
                },
                set: function(arr) {
                    if (Array.isArray(arr) && arr.every(function(elem) {
                        return elem instanceof Uint8Array;
                    })) {
                        _array = arr;
                    }
                },
                enumerable: true,
                configurable: false
            },
            indefinite: {
                value: indefinite,
                writable: false,
                enumerable: true,
                configurable: false
            }
        });
    }
    LazyCborArray.prototype.clone = function() {
        return new LazyCborArray(this.array.map(function(elem) {
            return Uint8Array.prototype.slice.call(elem);
        }), {
            indefinite: this.indefinite
        });
    };
    return LazyCborArray;
}();
exports.LazyCborArray = LazyCborArray;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborMap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LazyCborMap = exports.isLazyCborMapEntry = void 0;
var obj_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/obj-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
var defaultOpts = Object.freeze({
    indefinite: false,
    addInfos: undefined
});
function isLazyCborMapEntry(thing) {
    return (0, obj_utils_1.isObject)(thing) && (0, obj_utils_1.hasOwn)(thing, "k") && thing.k instanceof Uint8Array && (0, obj_utils_1.hasOwn)(thing, "v") && thing.v instanceof Uint8Array;
}
exports.isLazyCborMapEntry = isLazyCborMapEntry;
var LazyCborMap = function() {
    function LazyCborMap(map, options) {
        (0, assert_1.assert)(Array.isArray(map) && map.every(isLazyCborMapEntry), "in 'LazyCborMap' constructor: invalid input; got: " + map);
        var indefinite = __assign(__assign({}, defaultOpts), options).indefinite;
        var _map = map;
        Object.defineProperties(this, {
            array: {
                get: function() {
                    return _map;
                },
                set: function(newMap) {
                    if (Array.isArray(newMap) && newMap.every(isLazyCborMapEntry)) {
                        _map = newMap;
                    }
                },
                enumerable: true,
                configurable: false
            },
            indefinite: {
                value: indefinite,
                writable: false,
                enumerable: true,
                configurable: false
            }
        });
    }
    LazyCborMap.prototype.clone = function() {
        return new LazyCborMap(this.map.map(function(_a) {
            var k = _a.k, v = _a.v;
            return {
                k: Uint8Array.prototype.slice.call(k),
                v: Uint8Array.prototype.slice.call(v)
            };
        }), {
            indefinite: this.indefinite
        });
    };
    return LazyCborMap;
}();
exports.LazyCborMap = LazyCborMap;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborObj.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isLazyCborObj = void 0;
var CborObj_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/index.js [app-client] (ecmascript)");
var LazyCborArray_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborArray.js [app-client] (ecmascript)");
var LazyCborMap_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborMap.js [app-client] (ecmascript)");
var LazyCborTag_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborTag.js [app-client] (ecmascript)");
function isLazyCborObj(cborObj) {
    return cborObj instanceof CborObj_1.CborNegInt || cborObj instanceof CborObj_1.CborUInt || cborObj instanceof CborObj_1.CborBytes || cborObj instanceof CborObj_1.CborText || cborObj instanceof LazyCborArray_1.LazyCborArray || cborObj instanceof LazyCborMap_1.LazyCborMap || cborObj instanceof LazyCborTag_1.LazyCborTag || cborObj instanceof CborObj_1.CborSimple;
}
exports.isLazyCborObj = isLazyCborObj;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborTag.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LazyCborTag = void 0;
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
var LazyCborObj_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborObj.js [app-client] (ecmascript)");
var LazyCborTag = function() {
    function LazyCborTag(tag, data) {
        if (typeof tag === "number") {
            tag = BigInt(tag);
        }
        (0, assert_1.assert)(typeof tag === "bigint" && (0, LazyCborObj_1.isLazyCborObj)(data), "using direct value constructor; either 'tag' is not a number or 'data' is not 'LazyCborObj'");
        var _tag = tag;
        var _data = data;
        Object.defineProperties(this, {
            tag: {
                get: function() {
                    return _tag;
                },
                set: function(val) {
                    if (typeof tag === "number") tag = BigInt(tag);
                    if (typeof tag === "bigint") {
                        _tag = tag;
                    }
                },
                enumerable: true,
                configurable: false
            },
            data: {
                get: function() {
                    return _data;
                },
                set: function(val) {
                    if ((0, LazyCborObj_1.isLazyCborObj)(val)) {
                        _data = val;
                    }
                },
                enumerable: true,
                configurable: false
            }
        });
    }
    LazyCborTag.prototype.clone = function() {
        return new LazyCborTag(this.tag, this.data.clone());
    };
    return LazyCborTag;
}();
exports.LazyCborTag = LazyCborTag;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/SubCborRef.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubCborRef = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var CborString_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborString/index.js [app-client] (ecmascript)");
var SubCborRef = function(_super) {
    __extends(SubCborRef, _super);
    function SubCborRef(_a) {
        var _bytes = _a._bytes, start = _a.start, end = _a.end;
        var _this = _super.call(this, _bytes) || this;
        // super might have cloned `_bytes`, but in `SubCborRef` we want to keep the reference
        _this._bytes = _bytes;
        _this.start = start;
        _this.end = end;
        return _this;
    }
    SubCborRef.prototype.toString = function() {
        return (0, uint8array_utils_1.toHex)(this.toBuffer());
    };
    SubCborRef.prototype.toBuffer = function() {
        return Uint8Array.prototype.slice.call(this._bytes, this.start, this.end);
    };
    SubCborRef.prototype.clone = function() {
        return new SubCborRef({
            _bytes: this._bytes,
            start: this.start,
            end: this.end
        });
    };
    return SubCborRef;
}(CborString_1.CborString);
exports.SubCborRef = SubCborRef;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/Cbor/overwriteSubCborRefBytes.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.overwriteSubCborRefBytes = void 0;
var CborObj_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/index.js [app-client] (ecmascript)");
var SubCborRef_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/SubCborRef.js [app-client] (ecmascript)");
function overwriteSubCborRefBytes(cObj, bytes) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    if (!(cObj.subCborRef instanceof SubCborRef_1.SubCborRef)) return;
    if (cObj instanceof CborObj_1.CborText && typeof cObj.chunks !== "string") {
        try {
            for(var _e = __values(cObj.chunks), _f = _e.next(); !_f.done; _f = _e.next()){
                var chunk = _f.value;
                overwriteSubCborRefBytes(chunk, bytes);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    }
    if (cObj instanceof CborObj_1.CborBytes && !(cObj.chunks instanceof Uint8Array)) {
        try {
            for(var _g = __values(cObj.chunks), _h = _g.next(); !_h.done; _h = _g.next()){
                var chunk = _h.value;
                overwriteSubCborRefBytes(chunk, bytes);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
    }
    if (cObj instanceof CborObj_1.CborTag) {
        overwriteSubCborRefBytes(cObj.data, bytes);
    }
    if ((cObj instanceof CborObj_1.CborUInt || cObj instanceof CborObj_1.CborNegInt) && cObj.bigNumEncoding instanceof CborObj_1.CborBytes) {
        overwriteSubCborRefBytes(cObj.bigNumEncoding, bytes);
    }
    if (cObj instanceof CborObj_1.CborMap) {
        try {
            for(var _j = __values(cObj.map), _k = _j.next(); !_k.done; _k = _j.next()){
                var _l = _k.value, k = _l.k, v = _l.v;
                overwriteSubCborRefBytes(k, bytes);
                overwriteSubCborRefBytes(v, bytes);
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
    }
    if (cObj instanceof CborObj_1.CborArray) {
        try {
            for(var _m = __values(cObj.array), _o = _m.next(); !_o.done; _o = _m.next()){
                var elem = _o.value;
                overwriteSubCborRefBytes(elem, bytes);
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
    }
    cObj.subCborRef._bytes = bytes;
}
exports.overwriteSubCborRefBytes = overwriteSubCborRefBytes;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/Cbor/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Cbor = exports.defaultParseOptions = void 0;
var CborString_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborString/index.js [app-client] (ecmascript)");
var CborObj_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/index.js [app-client] (ecmascript)");
var Constants_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/Cbor/Constants/index.js [app-client] (ecmascript)");
var CborBytes_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborBytes.js [app-client] (ecmascript)");
var CborText_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborText.js [app-client] (ecmascript)");
var CborArray_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborArray.js [app-client] (ecmascript)");
var CborMap_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborMap.js [app-client] (ecmascript)");
var CborTag_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborTag.js [app-client] (ecmascript)");
var CborSimple_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborSimple.js [app-client] (ecmascript)");
var CborUInt_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborUInt.js [app-client] (ecmascript)");
var CborNegInt_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborNegInt.js [app-client] (ecmascript)");
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var BaseCborError_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/errors/BaseCborError/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/assert.js [app-client] (ecmascript)");
var LazyCborArray_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborArray.js [app-client] (ecmascript)");
var LazyCborMap_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborMap.js [app-client] (ecmascript)");
var LazyCborTag_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborTag.js [app-client] (ecmascript)");
var errors_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/errors/index.js [app-client] (ecmascript)");
var max_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/constants/max.js [app-client] (ecmascript)");
var SubCborRef_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/SubCborRef.js [app-client] (ecmascript)");
var overwriteSubCborRefBytes_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/Cbor/overwriteSubCborRefBytes.js [app-client] (ecmascript)");
/**
 * @private to the module; not needed elsewhere
 */ var CborEncoding = function() {
    function CborEncoding() {
        this._buff = new Uint8Array(256); // (1 << 8) bytes, 1/4 kB
        this._len = 0;
    }
    Object.defineProperty(CborEncoding.prototype, "bytes", {
        get: function() {
            return Uint8Array.prototype.slice.call(this._buff, 0, this._len);
        // this._buff.slice( 0, this._len );
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborEncoding.prototype, "length", {
        get: function() {
            return this._len;
        },
        enumerable: false,
        configurable: true
    });
    CborEncoding.prototype._prepareAppendOfByteLength = function(l) {
        var requiredLen = this._len + l;
        var newBuffLen = this._buff.byteLength;
        // expand the Uint8Array if needed
        while(newBuffLen < requiredLen){
            newBuffLen = newBuffLen << 1; // old length * 2
        }
        // copies the old Uint8Array if expanded
        if (newBuffLen !== this._buff.byteLength) {
            var newBuff = new Uint8Array(newBuffLen);
            for(var i = 0; i < this._len; i++){
                (0, uint8array_utils_1.writeUInt8)(newBuff, (0, uint8array_utils_1.readUInt8)(this._buff, i), i);
            }
            this._buff = newBuff;
        }
    };
    CborEncoding.prototype._commitAppendOfByteLength = function(l) {
        this._len += l;
    };
    CborEncoding.prototype.appendRawBytes = function(bytes) {
        this._prepareAppendOfByteLength(bytes.length);
        this._buff.set(bytes, this._len);
        this._commitAppendOfByteLength(bytes.length);
    };
    CborEncoding.prototype.appendUInt8 = function(uint8) {
        (0, assert_1.assert)(uint8 >= 0 && uint8 <= 255 && uint8 === Math.round(uint8), "expected a byte; got: " + uint8);
        this._prepareAppendOfByteLength(1);
        (0, uint8array_utils_1.writeUInt8)(this._buff, uint8, this._len);
        this._commitAppendOfByteLength(1);
    };
    CborEncoding.prototype.appendUInt16 = function(uint16) {
        (0, assert_1.assert)(uint16 >= 0 && uint16 <= 65535 && uint16 === Math.round(uint16), "expected two bytes; got: " + uint16);
        this._prepareAppendOfByteLength(2);
        (0, uint8array_utils_1.writeUInt16BE)(this._buff, uint16, this._len);
        this._commitAppendOfByteLength(2);
    };
    CborEncoding.prototype.appendUInt32 = function(uint32) {
        (0, assert_1.assert)(uint32 >= 0 && uint32 <= 4294967295 && uint32 === Math.round(uint32), "expected 4 bytes; got: " + uint32);
        this._prepareAppendOfByteLength(4);
        (0, uint8array_utils_1.writeUInt32BE)(this._buff, uint32, this._len);
        this._commitAppendOfByteLength(4);
    };
    CborEncoding.prototype.appendUInt64 = function(uint64) {
        (0, assert_1.assert)(typeof uint64 === "bigint" && uint64 >= BigInt(0) && uint64 <= BigInt("0b" + "11111111".repeat(8)), "expected 8 bytes; got: " + uint64);
        this._prepareAppendOfByteLength(8);
        (0, uint8array_utils_1.writeBigUInt64BE)(this._buff, uint64, this._len);
        this._commitAppendOfByteLength(8);
    };
    CborEncoding.prototype.appendFloat64 = function(float64) {
        (0, assert_1.assert)(typeof float64 === "number", "expected 8 bytes; got: " + float64);
        this._prepareAppendOfByteLength(8);
        (0, uint8array_utils_1.writeFloat64BE)(this._buff, float64, this._len);
        this._commitAppendOfByteLength(8);
    };
    CborEncoding.prototype.appendTypeAndLength = function(cborType, length, addInfos) {
        (0, assert_1.assert)((0, Constants_1.isMajorTypeTag)(cborType), "passed tag is not a valid major cbor type");
        (0, assert_1.assert)((typeof length === "number" || typeof length === "bigint") && length >= 0, "invalid length");
        if (length > max_1.MAX_4_BYTES || addInfos === 27) {
            if (typeof length === "number") length = BigInt(length);
            this.appendUInt8(cborType << 5 | 27 /*expect_uint64*/ );
            this.appendUInt64(length);
            return;
        }
        if (typeof length === "bigint") length = Number(length);
        var specifcAddInfos = typeof addInfos === "number" && addInfos >= 24 && addInfos <= 27;
        if (length < 24 && !specifcAddInfos // use the specified addInfos if any
        ) {
            this.appendUInt8(cborType << 5 | length);
        } else if (length < max_1.OVERFLOW_1_BYTE && (!specifcAddInfos || addInfos === 24)) {
            this.appendUInt8(cborType << 5 | 24);
            this.appendUInt8(length);
        } else if (length < max_1.OVERFLOW_2_BYTES && (!specifcAddInfos || addInfos === 25)) {
            this.appendUInt8(cborType << 5 | 25);
            this.appendUInt16(length);
        } else /*
        if (
            length < 0x100000000 &&
            (
                !specifcAddInfos ||
                addInfos === 26
            )
        ) //*/ {
            this.appendUInt8(cborType << 5 | 26);
            this.appendUInt32(length);
        }
    };
    CborEncoding.prototype.appendCborObjEncoding = function(cObj) {
        (0, assert_1.assert)((0, CborObj_1.isCborObj)(cObj), "expected 'CborObj' strict instance; got: " + cObj);
        var startOffset = this.length;
        if (cObj instanceof CborUInt_1.CborUInt) {
            (0, assert_1.assert)(cObj.num >= BigInt(0), "encoding invalid unsigned integer as CBOR");
            // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
            if (cObj.bigNumEncoding instanceof CborBytes_1.CborBytes) {
                this.appendCborObjEncoding(new CborTag_1.CborTag(2, cObj.bigNumEncoding));
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            var n = cObj.num;
            // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
            if (n > max_1.maxBigInt) {
                console.dir(cObj, {
                    depth: Infinity
                });
                console.warn("big positive int encountered but `bigNumEncoding` is not set; " + "you should see the value causing this problem in the console; " + "please report this issue at https://github.com/HarmonicLabs/cbor/issues");
                this.appendCborObjEncoding(CborUInt_1.CborUInt.bigNum(n));
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            // else
            this.appendTypeAndLength(Constants_1.MajorType.unsigned, cObj.num, cObj.addInfos);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborNegInt_1.CborNegInt) {
            (0, assert_1.assert)(cObj.num < BigInt(0), "encoding invalid negative integer as CBOR");
            if (cObj.bigNumEncoding instanceof CborBytes_1.CborBytes) {
                this.appendCborObjEncoding(new CborTag_1.CborTag(3, cObj.bigNumEncoding));
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            var n = cObj.num;
            // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
            if (n < max_1.minBigInt) {
                console.dir(cObj, {
                    depth: Infinity
                });
                console.warn("big negative int encountered but `bigNumEncoding` is not set; " + "you should see the value causing this problem in the console; " + "please report this issue at https://github.com/HarmonicLabs/cbor/issues");
                this.appendCborObjEncoding(CborNegInt_1.CborNegInt.bigNum(n));
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            // else
            this.appendTypeAndLength(Constants_1.MajorType.negative, -(n + BigInt(1)), cObj.addInfos);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborBytes_1.CborBytes) {
            // if( cObj.isDefiniteLength )
            if (cObj.chunks instanceof Uint8Array) {
                var bs = cObj.chunks;
                this.appendTypeAndLength(Constants_1.MajorType.bytes, bs.length, cObj.addInfos);
                this.appendRawBytes(bs);
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            } else {
                var chunks = cObj.chunks;
                var nChunks = chunks.length;
                this.appendUInt8(Constants_1.MajorType.bytes << 5 | 31);
                for(var i = 0; i < nChunks; i++){
                    this.appendCborObjEncoding(chunks[i]);
                }
                this.appendUInt8(255); // break
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
        }
        if (cObj instanceof CborText_1.CborText) {
            // if( cObj.isDefiniteLength )
            if (typeof cObj.chunks === "string") {
                var bs = (0, uint8array_utils_1.fromUtf8)(cObj.text);
                this.appendTypeAndLength(Constants_1.MajorType.text, bs.length, cObj.addInfos);
                this.appendRawBytes(bs);
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            } else {
                var chunks = cObj.chunks;
                var nChunks = chunks.length;
                this.appendUInt8(Constants_1.MajorType.text << 5 | 31);
                for(var i = 0; i < nChunks; i++){
                    this.appendCborObjEncoding(chunks[i]);
                }
                this.appendUInt8(255); // break
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            //TURBOPACK unreachable
            ;
        }
        if (cObj instanceof CborArray_1.CborArray) {
            var arr = cObj.array;
            var arrLen = arr.length;
            if (cObj.indefinite) this.appendUInt8(0x9f);
            else this.appendTypeAndLength(Constants_1.MajorType.array, arrLen, cObj.addInfos);
            for(var i = 0; i < arrLen; i++){
                this.appendCborObjEncoding(arr[i]);
            }
            if (cObj.indefinite) this.appendUInt8(0xff);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborMap_1.CborMap) {
            var map = cObj.map;
            if (cObj.indefinite) this.appendUInt8(0xbf);
            else this.appendTypeAndLength(Constants_1.MajorType.map, map.length, cObj.addInfos);
            for(var i = 0; i < map.length; i++){
                this.appendCborObjEncoding(map[i].k);
                this.appendCborObjEncoding(map[i].v);
            }
            if (cObj.indefinite) this.appendUInt8(0xff);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborTag_1.CborTag) {
            this.appendTypeAndLength(Constants_1.MajorType.tag, cObj.tag);
            this.appendCborObjEncoding(cObj.data);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborSimple_1.CborSimple) {
            var simpValue = cObj.simple;
            if (simpValue === false) {
                this.appendUInt8(0xf4); // major type 6 (tag) | 20
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            if (simpValue === true) {
                this.appendUInt8(0xf5); // major type 6 (tag) | 21
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            if (simpValue === null) {
                this.appendUInt8(0xf6); // major type 6 (tag) | 22
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            if (simpValue === undefined) {
                this.appendUInt8(0xf7); // major type 6 (tag) | 23
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            if (cObj.numAs === "simple" && simpValue >= 0 && simpValue <= 255 && simpValue === Math.round(simpValue)) {
                this.appendTypeAndLength(Constants_1.MajorType.float_or_simple, simpValue);
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            this.appendUInt8(0xfb); // (MajorType.float_or_simple << 5) | 27 (double precidison float)
            this.appendFloat64(simpValue);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        throw new BaseCborError_1.BaseCborError("'CborEncoding.appendCborObjEncoding' did not match any possible 'CborObj'");
    };
    return CborEncoding;
}();
exports.defaultParseOptions = Object.freeze({
    keepRef: true
});
/**
 * static class that allows CBOR encoding and decoding
 *
 * >**_NOTE:_** some tags that are not defined in the proper CBOR specification are automaticaly treated as PlutusData
 */ var Cbor = function() {
    function Cbor() {}
    ; // static class, working as namespace
    Cbor.encode = function(cborObj) {
        var encoded = new CborEncoding();
        encoded.appendCborObjEncoding(cborObj);
        // .bytes is a getter, call once
        var bytes = encoded.bytes;
        // point the sub cbor refs to the final bytes
        // (forget intermediate results)
        (0, overwriteSubCborRefBytes_1.overwriteSubCborRefBytes)(cborObj, bytes);
        return new CborString_1.CborString(bytes);
    };
    Cbor.parse = function(cbor, parseOpts) {
        if (parseOpts === void 0) {
            parseOpts = exports.defaultParseOptions;
        }
        return Cbor.parseWithOffset(cbor, parseOpts).parsed;
    };
    Cbor.parseWithOffset = function(cbor, parseOpts) {
        var _a;
        if (parseOpts === void 0) {
            parseOpts = exports.defaultParseOptions;
        }
        if (typeof cbor === "string") cbor = (0, uint8array_utils_1.fromHex)(cbor);
        (0, assert_1.assert)(cbor instanceof Uint8Array || cbor instanceof CborString_1.CborString, "in 'Cbor.parse' expected an instance of 'CborString' or a 'Uint8Array' as input; got: " + cbor);
        var bytes = cbor instanceof CborString_1.CborString ? cbor.toBuffer() : cbor;
        var keepRef = Boolean((_a = parseOpts.keepRef) !== null && _a !== void 0 ? _a : exports.defaultParseOptions.keepRef);
        /**
         * number of bytes red
         * */ var offset = 0;
        var getSubCborRef = keepRef ? function(startOffset) {
            return new SubCborRef_1.SubCborRef({
                _bytes: bytes,
                start: startOffset,
                end: offset
            });
        } : function(_) {
            return undefined;
        };
        function incrementOffsetBy(l) {
            offset += l;
        }
        function getBytesOfLength(l) {
            if (bytes.length < offset + l) throw new errors_1.CborParseError("not enoug bytes; missing at least " + (offset + l - bytes.length) + " bytes");
            incrementOffsetBy(l);
            return bytes.slice(offset - l, offset);
        }
        function getUInt8() {
            incrementOffsetBy(1);
            return (0, uint8array_utils_1.readUInt8)(bytes, offset - 1 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt16() {
            incrementOffsetBy(2);
            return (0, uint8array_utils_1.readUInt16BE)(bytes, offset - 2 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt32() {
            incrementOffsetBy(4);
            return (0, uint8array_utils_1.readUInt32BE)(bytes, offset - 4 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt64() {
            incrementOffsetBy(8);
            return (0, uint8array_utils_1.readBigUInt64BE)(bytes, offset - 8 // offset has been incremented prior reading
            );
        }
        ;
        function getFloat16() {
            // increments the offset here
            var floatBits = getUInt16();
            var tempArrayBuffer = new ArrayBuffer(4);
            var tempDataView = new DataView(tempArrayBuffer);
            var sign = floatBits & 32768;
            var exponent = floatBits & 31744;
            var fraction = floatBits & 1023;
            if (exponent === 0x7c00) exponent = 0xff << 10;
            else if (exponent !== 0) exponent += 127 - 15 << 10;
            else if (fraction !== 0) return new CborSimple_1.CborSimple((sign !== 0 ? -1 : 1) * fraction * 5.960464477539063e-8, "float");
            tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
            return new CborSimple_1.CborSimple(tempDataView.getFloat32(0), "float");
        }
        function getFloat32() {
            incrementOffsetBy(4);
            return new CborSimple_1.CborSimple((0, uint8array_utils_1.readFloat32BE)(bytes, offset - 4 // offset has been incremented prior reading
            ), "float");
        }
        function getFloat64() {
            incrementOffsetBy(8);
            return new CborSimple_1.CborSimple((0, uint8array_utils_1.readFloat64BE)(bytes, offset - 8 // offset has been incremented prior reading
            ), "float");
        }
        /**
         *  if the next byte is a break, it increments the offset and returns true
         *  otherwise returns false without side effects
         */ function skipBreak() {
            if ((0, uint8array_utils_1.readUInt8)(bytes, offset) !== 0xff) return false;
            incrementOffsetBy(1);
            return true;
        }
        /*
        function skipBreak(): boolean
        {
            const isBreak = readUInt8( bytes, offset ) === 0xff;
            if( isBreak ) incrementOffsetBy( 1 );
            return isBreak;
        }
        */ function getLength(addInfos) {
            if (addInfos < 24) return BigInt(addInfos);
            if (addInfos === 24) return BigInt(getUInt8());
            if (addInfos === 25) return BigInt(getUInt16());
            if (addInfos === 26) return BigInt(getUInt32());
            if (addInfos === 27) return getUInt64();
            if (addInfos === 31) return BigInt(-1); // indefinite length element follows
            throw new BaseCborError_1.BaseCborError("Invalid length encoding while parsing CBOR");
        }
        /*
        function getIndefiniteElemLengthOfType( majorType: MajorType ): bigint
        {
            const headerByte = getUInt8();

            if( headerByte === 0xff ) // break indefinite
                return BigInt( -1 );
            
            const elemLength = getLength( headerByte & 0b000_11111 );

            if( elemLength <  0 || (headerByte >> 5 !== majorType ) )
                throw new BaseCborError( "unexpected nested indefinite length element" );

            return elemLength;
        }
        //*/ function getTextOfLength(l) {
            // increments offset while getting the bytes
            return (0, uint8array_utils_1.toUtf8)(getBytesOfLength(l));
        }
        function parseCborObj() {
            var startOffset = offset;
            var headerByte = getUInt8();
            var major = headerByte >> 5;
            var addInfos = headerByte & 31;
            if (major === Constants_1.MajorType.float_or_simple) {
                if (addInfos === 25) return getFloat16();
                if (addInfos === 26) return getFloat32();
                if (addInfos === 27) return getFloat64();
            }
            var length = getLength(addInfos);
            if (length < 0 && (major < 2 || major > 6)) {
                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing CBOR");
            }
            switch(major){
                case Constants_1.MajorType.unsigned:
                    {
                        return new CborUInt_1.CborUInt(length, addInfos, undefined, getSubCborRef(startOffset));
                    }
                case Constants_1.MajorType.negative:
                    {
                        return new CborNegInt_1.CborNegInt(-BigInt(1) - length, addInfos, undefined, getSubCborRef(startOffset));
                    }
                case Constants_1.MajorType.bytes:
                    {
                        // data in UPLC v1.*.* serializes as indefinite length
                        // indefinie length
                        if (length < 0) {
                            var chunks = [];
                            var elem = void 0;
                            while(!skipBreak()){
                                elem = parseCborObj();
                                if (!(elem instanceof CborBytes_1.CborBytes)) {
                                    throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing indefinite length bytes");
                                }
                                chunks.push(elem);
                            }
                            return new CborBytes_1.CborBytes(chunks, addInfos, getSubCborRef(startOffset));
                        }
                        // definite length
                        return new CborBytes_1.CborBytes(getBytesOfLength(Number(length)), addInfos, getSubCborRef(startOffset));
                    }
                case Constants_1.MajorType.text:
                    {
                        if (length < 0) {
                            var chunks = [];
                            var elem = void 0;
                            while(!skipBreak()){
                                elem = parseCborObj();
                                if (!(elem instanceof CborText_1.CborText)) {
                                    console.dir(elem, {
                                        depth: Infinity
                                    });
                                    throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing indefinite length text");
                                }
                                chunks.push(elem);
                            }
                            return new CborText_1.CborText(chunks, addInfos, getSubCborRef(startOffset));
                        }
                        return new CborText_1.CborText(getTextOfLength(Number(length)), addInfos, getSubCborRef(startOffset));
                    }
                case Constants_1.MajorType.array:
                    {
                        var arrOfCbors = void 0;
                        if (length < 0) {
                            arrOfCbors = [];
                            while(!skipBreak()){
                                arrOfCbors.push(parseCborObj());
                            }
                        } else {
                            arrOfCbors = new Array(Number(length));
                            for(var i = 0; i < length; i++){
                                arrOfCbors[i] = parseCborObj();
                            }
                        }
                        return new CborArray_1.CborArray(arrOfCbors, {
                            indefinite: length < 0,
                            addInfos: addInfos
                        }, getSubCborRef(startOffset));
                    }
                case Constants_1.MajorType.map:
                    {
                        var entries = void 0;
                        if (length < 0) {
                            entries = [];
                            while(!skipBreak()){
                                entries.push({
                                    k: parseCborObj(),
                                    v: parseCborObj()
                                });
                            }
                        } else {
                            entries = new Array(Number(length));
                            for(var i = 0; i < length; i++){
                                entries[i] = {
                                    k: parseCborObj(),
                                    v: parseCborObj()
                                };
                            }
                        }
                        return new CborMap_1.CborMap(entries, {
                            indefinite: length < 0,
                            addInfos: addInfos
                        }, getSubCborRef(startOffset));
                    }
                case Constants_1.MajorType.tag:
                    {
                        var l = Number(length);
                        var data = parseCborObj();
                        // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
                        if (l === 2 && data instanceof CborBytes_1.CborBytes) {
                            return CborUInt_1.CborUInt.bigNum(data, getSubCborRef(startOffset));
                        } else if (l === 3 && data instanceof CborBytes_1.CborBytes) {
                            return CborNegInt_1.CborNegInt.bigNum(data, getSubCborRef(startOffset));
                        }
                        // else just tag
                        return new CborTag_1.CborTag(l, data);
                    }
                case Constants_1.MajorType.float_or_simple:
                    {
                        var nLen = Number(length);
                        var subCborRef = getSubCborRef(startOffset);
                        if (nLen === 20) return new CborSimple_1.CborSimple(false, undefined, subCborRef); // 0xf4
                        if (nLen === 21) return new CborSimple_1.CborSimple(true, undefined, subCborRef); // 0xf5
                        if (nLen === 22) return new CborSimple_1.CborSimple(null, undefined, subCborRef); // 0xf6
                        if (nLen === 23) return new CborSimple_1.CborSimple(undefined, undefined, subCborRef); // 0xf7
                        // floats handled at the beginning of the function
                        // since length isn't required
                        throw new BaseCborError_1.BaseCborError("unrecognized simple value");
                    }
                default:
                    throw new BaseCborError_1.BaseCborError("unrecognized majorType: " + major);
            }
        }
        return {
            parsed: parseCborObj(),
            offset: offset
        };
    };
    Cbor.parseLazy = function(cbor) {
        return Cbor.parseLazyWithOffset(cbor).parsed;
    };
    Cbor.parseLazyWithOffset = function(cbor) {
        if (typeof cbor === "string") cbor = (0, uint8array_utils_1.fromHex)(cbor);
        (0, assert_1.assert)(cbor instanceof Uint8Array || CborString_1.CborString.isStrictInstance(cbor), "in 'Cbor.parse' expected an instance of 'CborString' or a 'Uint8Array' as input; got: " + cbor);
        var bytes = cbor instanceof CborString_1.CborString ? cbor.toBuffer() : cbor;
        /**
         * number of bytes red
         * */ var offset = 0;
        function incrementOffsetBy(l) {
            offset += l;
        }
        function getBytesOfLength(l) {
            if (bytes.length < offset + l) throw new errors_1.CborParseError("not enoug bytes; missing at least " + (offset + l - bytes.length) + " bytes");
            incrementOffsetBy(l);
            return bytes.slice(offset - l, offset);
        }
        function getUInt8() {
            incrementOffsetBy(1);
            return (0, uint8array_utils_1.readUInt8)(bytes, offset - 1 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt16() {
            incrementOffsetBy(2);
            return (0, uint8array_utils_1.readUInt16BE)(bytes, offset - 2 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt32() {
            incrementOffsetBy(4);
            return (0, uint8array_utils_1.readUInt32BE)(bytes, offset - 4 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt64() {
            incrementOffsetBy(8);
            return (0, uint8array_utils_1.readBigUInt64BE)(bytes, offset - 8 // offset has been incremented prior reading
            );
        }
        ;
        function getFloat16() {
            // increments the offset here
            var floatBits = getUInt16();
            var tempArrayBuffer = new ArrayBuffer(4);
            var tempDataView = new DataView(tempArrayBuffer);
            var sign = floatBits & 32768;
            var exponent = floatBits & 31744;
            var fraction = floatBits & 1023;
            if (exponent === 0x7c00) exponent = 0xff << 10;
            else if (exponent !== 0) exponent += 127 - 15 << 10;
            else if (fraction !== 0) return new CborSimple_1.CborSimple((sign !== 0 ? -1 : 1) * fraction * 5.960464477539063e-8, "float");
            tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
            return new CborSimple_1.CborSimple(tempDataView.getFloat32(0), "float");
        }
        function getFloat32() {
            incrementOffsetBy(4);
            return new CborSimple_1.CborSimple((0, uint8array_utils_1.readFloat32BE)(bytes, offset - 4 // offset has been incremented prior reading
            ), "float");
        }
        function getFloat64() {
            incrementOffsetBy(8);
            return new CborSimple_1.CborSimple((0, uint8array_utils_1.readFloat64BE)(bytes, offset - 8 // offset has been incremented prior reading
            ), "float");
        }
        function skipBreak() {
            if ((0, uint8array_utils_1.readUInt8)(bytes, offset) !== 0xff) return false;
            incrementOffsetBy(1);
            return true;
        }
        function getLength(addInfos) {
            if (addInfos < 24) return BigInt(addInfos);
            if (addInfos === 24) return BigInt(getUInt8());
            if (addInfos === 25) return BigInt(getUInt16());
            if (addInfos === 26) return BigInt(getUInt32());
            if (addInfos === 27) return getUInt64();
            if (addInfos === 31) return BigInt(-1); // indefinite length element follows
            throw new BaseCborError_1.BaseCborError("Invalid length encoding while parsing CBOR");
        }
        function getIndefiniteElemLengthOfType(majorType) {
            var headerByte = getUInt8();
            if (headerByte === 0xff) return BigInt(-1);
            var elemLength = getLength(headerByte & 31);
            if (elemLength < 0 || headerByte >> 5 !== majorType) throw new BaseCborError_1.BaseCborError("unexpected nested indefinite length element");
            return elemLength;
        }
        function getTextOfLength(l) {
            // increments offset while getting the bytes
            return (0, uint8array_utils_1.toUtf8)(getBytesOfLength(l));
        }
        function getNextElemBytes() {
            var elemStart = offset;
            var headerByte = getUInt8();
            var major = headerByte >> 5;
            var addInfos = headerByte & 31;
            if (major === Constants_1.MajorType.float_or_simple) {
                if (addInfos === 25) return bytes.slice(elemStart, elemStart + 2);
                if (addInfos === 26) return bytes.slice(elemStart, elemStart + 3);
                if (addInfos === 27) return bytes.slice(elemStart, elemStart + 5);
            }
            var preLenOffset = offset;
            var length = getLength(addInfos);
            var postLenOffset = offset;
            if (length < 0 && (major < 2 || major > 6)) {
                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing CBOR");
            }
            switch(major){
                case Constants_1.MajorType.unsigned:
                    return bytes.slice(elemStart, postLenOffset);
                case Constants_1.MajorType.negative:
                    return bytes.slice(elemStart, postLenOffset);
                case Constants_1.MajorType.bytes:
                    if (length < 0) {
                        var elementLength = void 0;
                        while((elementLength = getIndefiniteElemLengthOfType(major)) >= 0){
                            // this operation is done when calling
                            // `getBytesOfLength( Number( elementLength )`
                            /// in the non-lazy verision
                            incrementOffsetBy(Number(elementLength));
                        }
                        return bytes.slice(elemStart, offset);
                    }
                    // definite length
                    // void getBytesOfLength( Number( length ) )
                    incrementOffsetBy(Number(length)); // this is the only part we need of the above function
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.text:
                    if (length < 0) {
                        var str = "";
                        var l = 0;
                        while((l = Number(getIndefiniteElemLengthOfType(Constants_1.MajorType.text))) >= 0){
                            // str += getTextOfLength( l );
                            incrementOffsetBy(l);
                        }
                        return bytes.slice(elemStart, offset);
                    }
                    // void getTextOfLength( Number( length ) );
                    incrementOffsetBy(Number(length)); // this is the only part we need of the above function
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.array:
                    if (length < 0) {
                        while(!skipBreak()){
                            void getNextElemBytes();
                        }
                    } else {
                        for(var i = 0; i < length; i++){
                            void getNextElemBytes();
                        }
                    }
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.map:
                    if (length < 0) {
                        while(!skipBreak()){
                            void getNextElemBytes();
                            void getNextElemBytes();
                        }
                    } else {
                        for(var i = 0; i < length; i++){
                            void getNextElemBytes();
                            void getNextElemBytes();
                        }
                    }
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.tag:
                    void getNextElemBytes();
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.float_or_simple:
                    var nLen = Number(length);
                    if (nLen === 20) return bytes.slice(elemStart, offset); // 0xf4
                    if (nLen === 21) return bytes.slice(elemStart, offset); // 0xf5
                    if (nLen === 22) return bytes.slice(elemStart, offset); // 0xf6
                    if (nLen === 23) return bytes.slice(elemStart, offset); // 0xf7
                    // floats handled at the beginning of the function
                    // since length isn't required
                    throw new BaseCborError_1.BaseCborError("unrecognized simple value");
                default:
                    throw new BaseCborError_1.BaseCborError("unrecognized majorType: " + major);
            }
        }
        function parseCborObj() {
            var headerByte = getUInt8();
            var major = headerByte >> 5;
            var addInfos = headerByte & 31;
            if (major === Constants_1.MajorType.float_or_simple) {
                if (addInfos === 25) return getFloat16();
                if (addInfos === 26) return getFloat32();
                if (addInfos === 27) return getFloat64();
            }
            var length = getLength(addInfos);
            if (length < 0 && (major < 2 || major > 6)) {
                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing CBOR");
            }
            switch(major){
                case Constants_1.MajorType.unsigned:
                    return new CborUInt_1.CborUInt(length, addInfos);
                case Constants_1.MajorType.negative:
                    {
                        return new CborNegInt_1.CborNegInt(-BigInt(1) - length, addInfos);
                    }
                case Constants_1.MajorType.bytes:
                    {
                        // data in UPLC v1.*.* serializes as indefinite length
                        // indefinie length
                        if (length < 0) {
                            var chunks = [];
                            var elem = void 0;
                            while(!skipBreak()){
                                elem = parseCborObj();
                                if (!(elem instanceof CborBytes_1.CborBytes)) {
                                    throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing indefinite length bytes");
                                }
                                chunks.push(elem);
                            }
                            return new CborBytes_1.CborBytes(chunks, addInfos);
                        }
                        // definite length
                        return new CborBytes_1.CborBytes(getBytesOfLength(Number(length)), addInfos);
                    }
                case Constants_1.MajorType.text:
                    {
                        if (length < 0) {
                            var chunks = [];
                            var elem = void 0;
                            while(!skipBreak()){
                                elem = parseCborObj();
                                if (!(elem instanceof CborText_1.CborText)) {
                                    console.dir(elem, {
                                        depth: Infinity
                                    });
                                    throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing indefinite length text");
                                }
                                chunks.push(elem);
                            }
                            return new CborText_1.CborText(chunks, addInfos);
                        }
                        return new CborText_1.CborText(getTextOfLength(Number(length)), addInfos);
                    }
                case Constants_1.MajorType.array:
                    {
                        if (length < 0) {
                            var arr = [];
                            while(!skipBreak()){
                                arr.push(getNextElemBytes());
                            }
                            return new LazyCborArray_1.LazyCborArray(arr, {
                                indefinite: true,
                                addInfos: addInfos
                            });
                        } else {
                            var arr = new Array(Number(length));
                            for(var i = 0; i < length; i++){
                                arr[i] = getNextElemBytes();
                            }
                            return new LazyCborArray_1.LazyCborArray(arr, {
                                indefinite: false,
                                addInfos: addInfos
                            });
                        }
                    }
                case Constants_1.MajorType.map:
                    {
                        if (length < 0) {
                            var entries = [];
                            while(!skipBreak()){
                                entries.push({
                                    k: getNextElemBytes(),
                                    v: getNextElemBytes()
                                });
                            }
                            return new LazyCborMap_1.LazyCborMap(entries, {
                                indefinite: true,
                                addInfos: addInfos
                            });
                        } else {
                            var entries = new Array(Number(length));
                            for(var i = 0; i < length; i++){
                                entries[i] = {
                                    k: getNextElemBytes(),
                                    v: getNextElemBytes()
                                };
                            }
                            return new LazyCborMap_1.LazyCborMap(entries, {
                                indefinite: true,
                                addInfos: addInfos
                            });
                        }
                    }
                case Constants_1.MajorType.tag:
                    return new LazyCborTag_1.LazyCborTag(Number(length), parseCborObj());
                case Constants_1.MajorType.float_or_simple:
                    var nLen = Number(length);
                    if (nLen === 20) return new CborSimple_1.CborSimple(false); // 0xf4
                    if (nLen === 21) return new CborSimple_1.CborSimple(true); // 0xf5
                    if (nLen === 22) return new CborSimple_1.CborSimple(null); // 0xf6
                    if (nLen === 23) return new CborSimple_1.CborSimple(undefined); // 0xf7
                    // floats handled at the beginning of the function
                    // since length isn't required
                    throw new BaseCborError_1.BaseCborError("unrecognized simple value");
                default:
                    throw new BaseCborError_1.BaseCborError("unrecognized majorType: " + major);
            }
        }
        return {
            parsed: parseCborObj(),
            offset: offset
        };
    };
    return Cbor;
}();
exports.Cbor = Cbor;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/CanBeCborString.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.canBeCborString = exports.forceCborString = void 0;
var bytestring_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bytestring/dist/index.js [app-client] (ecmascript)");
var CborString_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborString/index.js [app-client] (ecmascript)");
function forceCborString(cStr) {
    return new CborString_1.CborString(cStr instanceof bytestring_1.ByteString ? cStr.toBuffer() : cStr);
}
exports.forceCborString = forceCborString;
function canBeCborString(stuff) {
    return typeof stuff === "string" || stuff instanceof Uint8Array || stuff instanceof bytestring_1.ByteString;
}
exports.canBeCborString = canBeCborString;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborArray.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborMap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborObj.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/LazyCborTag.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/extra/CborRational.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CborPositiveRational = void 0;
var obj_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/obj-utils/dist/index.js [app-client] (ecmascript)");
var CborArray_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborArray.js [app-client] (ecmascript)");
var CborTag_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborTag.js [app-client] (ecmascript)");
var CborUInt_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/CborUInt.js [app-client] (ecmascript)");
var ints_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/utils/ints.js [app-client] (ecmascript)");
var CborPositiveRational = function(_super) {
    __extends(CborPositiveRational, _super);
    function CborPositiveRational(num, den) {
        var _this = this;
        var _num = (0, ints_1.forceBigUInt)(num);
        var _den = (0, ints_1.forceBigUInt)(den);
        _this = _super.call(this, 30, new CborArray_1.CborArray([
            new CborUInt_1.CborUInt(_num),
            new CborUInt_1.CborUInt(_den)
        ])) || this;
        (0, obj_utils_1.defineReadOnlyProperty)(_this, "num", _num);
        (0, obj_utils_1.defineReadOnlyProperty)(_this, "den", _den);
        return _this;
    }
    CborPositiveRational.fromCborObjOrUndef = function(cObj) {
        return cObj instanceof CborTag_1.CborTag && cObj.data instanceof CborArray_1.CborArray && cObj.data.array[0] instanceof CborUInt_1.CborUInt && cObj.data.array[1] instanceof CborUInt_1.CborUInt ? new CborPositiveRational(cObj.data.array[0].num, cObj.data.array[1].num) : undefined;
    };
    CborPositiveRational.fromNumber = function(n) {
        var _a = __read(n.toString().split("."), 2), a = _a[0], b = _a[1];
        /**
         * b might be undefinded (eg. whole numbers)
         * @since patch 1.1.2
        **/ if (!(typeof b === "string")) {
            return new CborPositiveRational(Number(a), 1);
        }
        return new CborPositiveRational(// `a + b` is string concatenation
        Number(a + b), Number("1e".concat(b.length)));
    };
    CborPositiveRational.prototype.toNumber = function() {
        return Number(this.num) / Number(this.den);
    };
    CborPositiveRational.prototype.valueOf = function() {
        return this.toNumber();
    };
    return CborPositiveRational;
}(CborTag_1.CborTag);
exports.CborPositiveRational = CborPositiveRational;
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/extra/readCborTypeAndLength.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readCborTypeAndLength = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var Constants_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/Cbor/Constants/index.js [app-client] (ecmascript)");
function readCborTypeAndLength(bytes) {
    if (bytes.length < 1) return undefined;
    var headerByte = bytes[0];
    var major = headerByte >> 5;
    var addInfos = headerByte & 31;
    if (major === Constants_1.MajorType.float_or_simple) {
        if (addInfos === 25) {
            var float = getFloat16(bytes);
            if (float === undefined) return undefined;
            return {
                type: major,
                length: float
            };
        }
        if (addInfos === 26) {
            var float = getFloat32(bytes);
            if (float === undefined) return undefined;
            return {
                type: major,
                length: float
            };
        }
        if (addInfos === 27) {
            var float = getFloat64(bytes);
            if (float === undefined) return undefined;
            return {
                type: major,
                length: float
            };
        }
        return {
            type: major,
            length: addInfos
        };
    }
    var length = getLength(addInfos, bytes);
    if (typeof length !== "bigint") return undefined;
    if (length < 0) return {
        type: major,
        length: undefined // indefinite length
    };
    else return {
        type: major,
        length: length
    };
// if( length < 0 &&
//     ( major < 2 || major > 6 )
// )
// {
//     throw new BaseCborError( "unexpected indefinite length element while parsing CBOR" );
// }
}
exports.readCborTypeAndLength = readCborTypeAndLength;
function getLength(addInfos, bytes) {
    if (addInfos < 24) return BigInt(addInfos);
    if (addInfos === 24) {
        if (bytes.length < 2) return undefined;
        return BigInt((0, uint8array_utils_1.readUint8)(bytes, 1));
    }
    if (addInfos === 25) {
        if (bytes.length < 3) return undefined;
        return BigInt((0, uint8array_utils_1.readUint16BE)(bytes, 1));
    }
    if (addInfos === 26) {
        if (bytes.length < 5) return undefined;
        return BigInt((0, uint8array_utils_1.readUint32BE)(bytes, 1));
    }
    if (addInfos === 27) {
        if (bytes.length < 9) return undefined;
        return BigInt((0, uint8array_utils_1.readBigUInt64BE)(bytes, 1));
    }
    if (addInfos === 31) return BigInt(-1); // indefinite length element follows
    // throw new BaseCborError( "Invalid length encoding while parsing CBOR" );
    return undefined;
}
function getFloat16(bytes) {
    if (bytes.length < 3) return undefined;
    // increments the offset here
    var floatBits = (0, uint8array_utils_1.readUint16BE)(bytes, 1);
    var tempArrayBuffer = new ArrayBuffer(4);
    var tempDataView = new DataView(tempArrayBuffer);
    var sign = floatBits & 32768;
    var exponent = floatBits & 31744;
    var fraction = floatBits & 1023;
    if (exponent === 0x7c00) exponent = 0xff << 10;
    else if (exponent !== 0) exponent += 127 - 15 << 10;
    else if (fraction !== 0) return (sign !== 0 ? -1 : 1) * fraction * 5.960464477539063e-8;
    tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
    return tempDataView.getFloat32(0);
}
function getFloat32(bytes) {
    if (bytes.length < 5) return undefined;
    return (0, uint8array_utils_1.readFloat32BE)(bytes, 1);
}
function getFloat64(bytes) {
    if (bytes.length < 9) return undefined;
    return (0, uint8array_utils_1.readFloat64BE)(bytes, 1);
}
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/extra/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/extra/CborRational.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/extra/readCborTypeAndLength.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/interfaces/CBORSerializable.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/interfaces/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/interfaces/CBORSerializable.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/cbor/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/Cbor/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CanBeCborString.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborObj/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/LazyCborObj/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/CborString/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/errors/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/extra/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/interfaces/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/cbor/dist/SubCborRef.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/obj-utils/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a, _b;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defineNormalProperty = exports.defineFixedDeletableProperty = exports.defineHiddenNormalProperty = exports.defineDeletableDescriptor = exports.defineNonDeletableNormalProperty = exports.defineReadOnlyProperty = exports.defineWritableHiddenProperty = exports.defineGetterOnlyProperty = exports.defineReadOnlyHiddenProperty = exports.definePropertyIfNotPresent = exports.defineProperty = exports.freezeAll = exports.deepClone = exports.jsonClone = exports.deepEqual = exports.isSerializable = exports.hasOwn = exports.has_n_determined_keys = exports.containsKeys = exports.hasNkeys = exports.hasUniqueKey = exports.isObject = exports.isNotArray = void 0;
function isNotArray(obj) {
    return !Array.isArray(obj);
}
exports.isNotArray = isNotArray;
function isObject(obj) {
    return typeof obj === "object" && isNotArray(obj) && obj !== null && obj !== undefined // useless since "typeof" would have returned "undefined", but better safe than sorry :P
    ;
}
exports.isObject = isObject;
function hasUniqueKey(obj, key) {
    if (key === void 0) {
        key = undefined;
    }
    var keys = Object.keys(obj);
    return keys.length === 1 && (typeof key !== "undefined" ? keys[0] === key : true);
}
exports.hasUniqueKey = hasUniqueKey;
function hasNkeys(obj, n) {
    return isObject(obj) && Object.keys(obj).length === n;
}
exports.hasNkeys = hasNkeys;
function containsKeys(obj) {
    var keys = [];
    for(var _i = 1; _i < arguments.length; _i++){
        keys[_i - 1] = arguments[_i];
    }
    var oKeys = Object.keys(obj);
    for(var i = 0; i < keys.length; i++){
        if (!oKeys.includes(keys[i])) return false;
    }
    return true;
}
exports.containsKeys = containsKeys;
function has_n_determined_keys(obj, n) {
    var keys = [];
    for(var _i = 2; _i < arguments.length; _i++){
        keys[_i - 2] = arguments[_i];
    }
    return hasNkeys(obj, n) && keys.length === n && containsKeys.apply(void 0, __spreadArray([
        obj
    ], __read(keys), false));
}
exports.has_n_determined_keys = has_n_determined_keys;
exports.hasOwn = (_b = (_a = Object.hasOwn) !== null && _a !== void 0 ? _a : Object.prototype.hasOwnProperty.call) !== null && _b !== void 0 ? _b : containsKeys;
function isSerializable(obj) {
    var keys = Object.keys(obj);
    for(var i = 0; i < keys.length; i++){
        var value = obj[keys[i]];
        if (typeof value === "number" || typeof value === "bigint" || typeof value === "boolean" || typeof value === "string" || typeof value === "undefined") continue; // this single value is true, don't know the others
        else {
            if (Array.isArray(value)) {
                for(var i_1 = 0; i_1 < value.length; i_1++){
                    // all array elements must be serilalizable to
                    // equivalent to AND all elments
                    if (!isSerializable(value[i_1])) return false;
                }
            } else if (typeof value === "object") {
                if (!isSerializable(value)) continue; // this single value is true, don't know the others
                else return false;
            } else if (typeof value === "function") return false;
        }
    }
    return true;
}
exports.isSerializable = isSerializable;
function deepEqual(a, b) {
    if (typeof a !== typeof b) {
        return false;
    }
    /*
    covers:
    - nuber
    - strings
    - boolean
    - functions only if are the same object
    ( unfortunately, proving deep function equality is not possible (yet) )
    */ if (a === b) {
        return true;
    }
    if (Array.isArray(a)) {
        if (Array.isArray(b)) {
            if (a.length !== b.length) return false;
            for(var i = 0; i < a.length; i++){
                if (!deepEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        } else {
            return false;
        }
    } else if (Array.isArray(b)) return false; // a is an array indeed
    // type equality checked before, no need to re-check
    if (typeof a === "object") {
        var aKeys = Object.keys(a);
        var bKeys = Object.keys(b);
        if (aKeys.length !== aKeys.length) {
            return false;
        }
        // {} === {} -> true
        if (aKeys.length === 0 && bKeys.length === 0) {
            return true;
        }
        for(var i = 0; i < aKeys.length; i++){
            var foundThis_a = false;
            for(var j = 0; j < bKeys.length; j++){
                if (aKeys[i] === bKeys[j]) {
                    foundThis_a = true;
                    break;
                }
            }
            if (foundThis_a) {
                if (deepEqual(a[aKeys[i]], b[aKeys[i]])) {
                    if (i === aKeys.length - 1) {
                        return true;
                    }
                    continue;
                } else return false;
            } else {
                return false;
            }
        }
    }
    return false;
}
exports.deepEqual = deepEqual;
function jsonClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
exports.jsonClone = jsonClone;
function deepClone(obj) {
    var clone;
    //@ts-ignore
    if (typeof obj === "function") return cloneFunc(obj);
    if (typeof obj === "object") {
        if (Array.isArray(obj)) {
            clone = [];
            for(var i = 0; i < obj.length; i++){
                clone[i] = deepClone(obj[i]);
            }
            return clone;
        }
        var objKeys = Object.keys(obj);
        for(var i = 0; i < objKeys.length; i++){
            clone[objKeys[i]] = deepClone(obj[objKeys[i]]);
        }
        return clone;
    }
    // number
    // string
    // boolean
    return obj;
}
exports.deepClone = deepClone;
function freezeAll(something) {
    if (typeof something === "object" && something !== null) {
        var ks = Object.keys(something);
        for(var i = 0; i < ks.length; i++){
            freezeAll(something[ks[i]]);
        }
    }
    return Object.freeze(something);
}
exports.freezeAll = freezeAll;
var writableProperty = 1;
var enumerableProperty = 2;
var configurableProperty = 4;
/*
https://stackoverflow.com/questions/52204566/typescript-add-dynamically-named-property-to-return-type

declare function addKeyValue2<T extends {}, K extends keyof any, V>(obj: T, key: K, value: V):
    { [P in keyof (T & Record<K, any>)]: P extends K ? V : P extends keyof T ? T[P] : never }
*/ /**
 *
 * @param obj {object} to define the property on
 * @param name {PropertyKey} name of the property
 * @param value {any} value of the property
 * @param accessLevel writable / enumerable / configurable
 *
 * enumerable   = 0b010, if ```false``` is not showed
 * configurable = 0b100, if ```false``` cannot be deleted or changed
 *
 * 0 -> none // hidden object-specific descriptor
 *
 * 1 -> writable only // hidden, modifiable, non deletable
 *
 * 2 -> enumerable only // showed object-specific descriptor
 *
 * 3 -> writable AND enumerable // non deletable
 *
 * 4 -> configurable only // hidden object-specific deleteable descriptor
 *
 * 5 -> configurable AND writable // hidden, modifiable, deletable
 *
 * 6 -> configurable AND enumerable // showed, non modifiable, deletable
 *
 * 7 -> all // showed, modifiable, deletable
 *
 */ function defineProperty(obj, name, value, accessLevel) {
    if (accessLevel === void 0) {
        accessLevel = 0;
    }
    return Object.defineProperty(obj, name, {
        value: value,
        writable: (accessLevel & writableProperty) === writableProperty,
        enumerable: (accessLevel & enumerableProperty) === enumerableProperty,
        configurable: (accessLevel & configurableProperty) === configurableProperty
    });
}
exports.defineProperty = defineProperty;
function definePropertyIfNotPresent(obj, name, descriptor) {
    if ((0, exports.hasOwn)(obj, name)) return obj;
    return Object.defineProperty(obj, name, descriptor);
}
exports.definePropertyIfNotPresent = definePropertyIfNotPresent;
function defineReadOnlyHiddenProperty(obj, name, value) {
    return defineProperty(obj, name, value, 0);
}
exports.defineReadOnlyHiddenProperty = defineReadOnlyHiddenProperty;
function defineGetterOnlyProperty(obj, name, valueGetter) {
    return definePropertyIfNotPresent(obj, name, {
        get: valueGetter,
        set: function() {},
        configurable: false,
        enumerable: true
    });
}
exports.defineGetterOnlyProperty = defineGetterOnlyProperty;
function defineWritableHiddenProperty(obj, name, value) {
    return defineProperty(obj, name, value, 1);
}
exports.defineWritableHiddenProperty = defineWritableHiddenProperty;
/**
 * 2 -> enumerable only
 *
 * property is showed and can be accessed trough indexing
 *
 * cannot be modified
 *
 * cannot be deleted
 */ function defineReadOnlyProperty(obj, name, value) {
    var _a;
    if ((0, exports.hasOwn)(obj, name) && !((_a = Object.getOwnPropertyDescriptor(obj, name)) === null || _a === void 0 ? void 0 : _a.writable) // and it cannot be overridden
    ) return obj; // return that object;
    return defineProperty(obj, name, value, 2);
}
exports.defineReadOnlyProperty = defineReadOnlyProperty;
function defineNonDeletableNormalProperty(obj, name, value) {
    var _a;
    if ((0, exports.hasOwn)(obj, name) && !((_a = Object.getOwnPropertyDescriptor(obj, name)) === null || _a === void 0 ? void 0 : _a.writable) // and it cannot be overridden
    ) return obj; // return that object;
    return defineProperty(obj, name, value, 3);
}
exports.defineNonDeletableNormalProperty = defineNonDeletableNormalProperty;
function defineDeletableDescriptor(obj, name, value) {
    return defineProperty(obj, name, value, 4);
}
exports.defineDeletableDescriptor = defineDeletableDescriptor;
function defineHiddenNormalProperty(obj, name, value) {
    return defineProperty(obj, name, value, 5);
}
exports.defineHiddenNormalProperty = defineHiddenNormalProperty;
function defineFixedDeletableProperty(obj, name, value) {
    return defineProperty(obj, name, value, 6);
}
exports.defineFixedDeletableProperty = defineFixedDeletableProperty;
function defineNormalProperty(obj, name, value) {
    return defineProperty(obj, name, value, 7);
}
exports.defineNormalProperty = defineNormalProperty;
function cloneFunc(func) {
    var cloneObj = func;
    //@ts-ignore
    if (func.__isClone) {
        //@ts-ignore
        cloneObj = func.__clonedFrom;
    }
    //@ts-ignore
    var temp = function() {
        return cloneObj.apply(this, arguments);
    };
    for(var key in func){
        //@ts-ignore
        temp[key] = func[key];
    }
    //@ts-ignore
    temp.__isClone = true;
    //@ts-ignore
    temp.__clonedFrom = cloneObj;
    return temp;
}
;
}),
"[project]/node_modules/@harmoniclabs/bigint-utils/dist/utils/assert.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assert = void 0;
function assert(condition, errorMessage, addInfos) {
    var args = [];
    for(var _i = 3; _i < arguments.length; _i++){
        args[_i - 3] = arguments[_i];
    }
    if (condition) return;
    args.length > 0 && console.error.apply(console, __spreadArray([], __read(args), false));
    addInfos && console.error(addInfos);
    if (errorMessage instanceof Error) {
        throw errorMessage;
    }
    ;
    throw new Error(errorMessage);
}
exports.assert = assert;
}),
"[project]/node_modules/@harmoniclabs/bigint-utils/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bigintToBuffer = exports.bigintFromBuffer = exports.bigintFromBufferLE = exports.log2 = exports.min = exports.max = exports.random = exports.abs = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bigint-utils/dist/utils/assert.js [app-client] (ecmascript)");
/**
 * same as ```Math.abs``` but for bigints
 */ function abs(n) {
    return n < BigInt(0) ? -n : n;
}
exports.abs = abs;
/**
 * @returns {bigint} a ```bigint``` between ```0``` and ```Number.MAX_SAFE_INTEGER``` so that is safe to convert to Number for whatever reason
 */ function random() {
    return BigInt(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
}
exports.random = random;
function max() {
    var nums = [];
    for(var _i = 0; _i < arguments.length; _i++){
        nums[_i] = arguments[_i];
    }
    return nums.reduce(function(a, b) {
        return a > b ? a : b;
    });
}
exports.max = max;
function min() {
    var nums = [];
    for(var _i = 0; _i < arguments.length; _i++){
        nums[_i] = arguments[_i];
    }
    return nums.reduce(function(a, b) {
        return a < b ? a : b;
    });
}
exports.min = min;
function log2(num) {
    if (num === BigInt(0)) return BigInt(0);
    if (num < BigInt(0)) return -log2(abs(num));
    var n = BigInt(num);
    var result = BigInt(0);
    while(n >>= BigInt(1))result++;
    return result;
}
exports.log2 = log2;
/**
 * uses the bytes of the buffer to construct a BigInteger
 * > **IMPORTANT** the bytes are considered in Little Endian order; use ```bigintFromBuffer``` for Big Endian
 */ function bigintFromBufferLE(buffer) {
    return bigintFromBuffer(// need to copy so that it doesn't reverses the original buffer
    Uint8Array.from(buffer).reverse());
}
exports.bigintFromBufferLE = bigintFromBufferLE;
/**
 * converts a Uint8Array to a ```bigint```
 * Big-Endian default
 */ function bigintFromBuffer(buffer) {
    (0, assert_1.assert)((0, uint8array_utils_1.isUint8Array)(buffer), "expected buffer as input, while constructing a bigint instance using bigintFromBufferBE");
    var hexBuff = (0, uint8array_utils_1.toHex)(buffer);
    if (hexBuff.length === 0) {
        return BigInt(0);
    }
    return BigInt("0x".concat(hexBuff));
}
exports.bigintFromBuffer = bigintFromBuffer;
/**
 * converts a ```bigint``` to a ```Uint8Array``` of length ```nBytes``` given as second argument
 *
 * if ```nBytes``` is not specified the Uint8Array takes only the bytes needed
 * @param bigint
 * @param nBytes
 * @returns
 */ function bigintToBuffer(bigint, nBytes) {
    if (nBytes === void 0) {
        nBytes = undefined;
    }
    (0, assert_1.assert)(bigint >= BigInt(0), "cannot convert negative bigint to buffer");
    if (bigint == BigInt(0)) {
        if (nBytes === undefined) {
            return Uint8Array.from([]);
        }
        return new Uint8Array(nBytes);
    }
    var buffHexString = bigint.toString(16);
    buffHexString = buffHexString.length % 2 === 0 ? buffHexString : '0' + buffHexString;
    if (nBytes !== undefined) {
        (0, assert_1.assert)(Math.round(Math.abs(nBytes)) === nBytes, "cannot construct a buffer of length " + nBytes + ", while using bigintToBufferOfNBytesBE");
        // pads with zeroes so that the final length is of nBytes*2 (2 hex digits per byte)
        // String.prototype.padStart docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
        buffHexString = buffHexString.padStart(nBytes * 2, "00");
        if (buffHexString.length > nBytes * 2) {
            console.warn("required buffer size is smaller than the one used effectively by the given bigint, truncating the initial bytes as overflow");
            buffHexString = buffHexString.slice(buffHexString.length - nBytes * 2);
        }
    }
    return (0, uint8array_utils_1.fromHex)(buffHexString);
}
exports.bigintToBuffer = bigintToBuffer;
}),
"[project]/node_modules/@scure/base/lib/esm/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ __turbopack_context__.s([
    "base16",
    ()=>base16,
    "base32",
    ()=>base32,
    "base32crockford",
    ()=>base32crockford,
    "base32hex",
    ()=>base32hex,
    "base32hexnopad",
    ()=>base32hexnopad,
    "base32nopad",
    ()=>base32nopad,
    "base58",
    ()=>base58,
    "base58check",
    ()=>base58check,
    "base58flickr",
    ()=>base58flickr,
    "base58xmr",
    ()=>base58xmr,
    "base58xrp",
    ()=>base58xrp,
    "base64",
    ()=>base64,
    "base64nopad",
    ()=>base64nopad,
    "base64url",
    ()=>base64url,
    "base64urlnopad",
    ()=>base64urlnopad,
    "bech32",
    ()=>bech32,
    "bech32m",
    ()=>bech32m,
    "bytes",
    ()=>bytes,
    "bytesToString",
    ()=>bytesToString,
    "createBase58check",
    ()=>createBase58check,
    "hex",
    ()=>hex,
    "str",
    ()=>str,
    "stringToBytes",
    ()=>stringToBytes,
    "utf8",
    ()=>utf8,
    "utils",
    ()=>utils
]);
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function isArrayOf(isString, arr) {
    if (!Array.isArray(arr)) return false;
    if (arr.length === 0) return true;
    if (isString) {
        return arr.every((item)=>typeof item === 'string');
    } else {
        return arr.every((item)=>Number.isSafeInteger(item));
    }
}
// no abytes: seems to have 10% slowdown. Why?!
function afn(input) {
    if (typeof input !== 'function') throw new Error('function expected');
    return true;
}
function astr(label, input) {
    if (typeof input !== 'string') throw new Error(`${label}: string expected`);
    return true;
}
function anumber(n) {
    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
    if (!Array.isArray(input)) throw new Error('array expected');
}
function astrArr(label, input) {
    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function chain(...args) {
    const id = (a)=>a;
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b)=>(c)=>a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.map((x)=>x.decode).reduce(wrap, id);
    return {
        encode,
        decode
    };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back.
 * Could also be array of strings.
 * @__NO_SIDE_EFFECTS__
 */ function alphabet(letters) {
    // mapping 1 to "b"
    const lettersA = typeof letters === 'string' ? letters.split('') : letters;
    const len = lettersA.length;
    astrArr('alphabet', lettersA);
    // mapping "b" to 1
    const indexes = new Map(lettersA.map((l, i)=>[
            l,
            i
        ]));
    return {
        encode: (digits)=>{
            aArr(digits);
            return digits.map((i)=>{
                if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
                return lettersA[i];
            });
        },
        decode: (input)=>{
            aArr(input);
            return input.map((letter)=>{
                astr('alphabet.decode', letter);
                const i = indexes.get(letter);
                if (i === undefined) throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
                return i;
            });
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function join(separator = '') {
    astr('join', separator);
    return {
        encode: (from)=>{
            astrArr('join.decode', from);
            return from.join(separator);
        },
        decode: (to)=>{
            astr('join.decode', to);
            return to.split(separator);
        }
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */ function padding(bits, chr = '=') {
    anumber(bits);
    astr('padding', chr);
    return {
        encode (data) {
            astrArr('padding.encode', data);
            while(data.length * bits % 8)data.push(chr);
            return data;
        },
        decode (input) {
            astrArr('padding.decode', input);
            let end = input.length;
            if (end * bits % 8) throw new Error('padding: invalid, string should have whole number of bytes');
            for(; end > 0 && input[end - 1] === chr; end--){
                const last = end - 1;
                const byte = last * bits;
                if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');
            }
            return input.slice(0, end);
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function normalize(fn) {
    afn(fn);
    return {
        encode: (from)=>from,
        decode: (to)=>fn(to)
    };
}
/**
 * Slow: O(n^2) time complexity
 */ function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data);
    if (!data.length) return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data, (d)=>{
        anumber(d);
        if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
        return d;
    });
    const dlen = digits.length;
    while(true){
        let carry = 0;
        let done = true;
        for(let i = pos; i < dlen; i++){
            const digit = digits[i];
            const fromCarry = from * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
                throw new Error('convertRadix: carry overflow');
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');
            if (!done) continue;
            else if (!rounded) pos = i;
            else done = false;
        }
        res.push(carry);
        if (done) break;
    }
    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);
    return res.reverse();
}
const gcd = (a, b)=>b === 0 ? a : gcd(b, a % b);
const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));
const powers = /* @__PURE__ */ (()=>{
    let res = [];
    for(let i = 0; i < 40; i++)res.push(2 ** i);
    return res;
})();
/**
 * Implemented with numbers, because BigInt is 5x slower
 */ function convertRadix2(data, from, to, padding) {
    aArr(data);
    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data){
        anumber(n);
        if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);
        const pow = powers[pos];
        if (pow === undefined) throw new Error('invalid carry');
        carry &= pow - 1; // clean carry, otherwise it will cause overflow
    }
    carry = carry << to - pos & mask;
    if (!padding && pos >= from) throw new Error('Excess padding');
    if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0) res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function radix(num) {
    anumber(num);
    const _256 = 2 ** 8;
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits)=>{
            anumArr('radix.decode', digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
        }
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */ function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits)=>{
            anumArr('radix2.decode', digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
    };
}
function unsafeWrapper(fn) {
    afn(fn);
    return function(...args) {
        try {
            return fn.apply(null, args);
        } catch (e) {}
    };
}
function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
        encode (data) {
            if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');
            const sum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(sum, data.length);
            return res;
        },
        decode (data) {
            if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const oldChecksum = data.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');
            return payload;
        }
    };
}
const utils = {
    alphabet,
    chain,
    checksum,
    convertRadix,
    convertRadix2,
    radix,
    radix2,
    join,
    padding
};
const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));
const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));
const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s)=>s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64
// prettier-ignore
const hasBase64Builtin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toBase64 === 'function' && typeof Uint8Array.fromBase64 === 'function')();
const decodeBase64Builtin = (s, isUrl)=>{
    astr('base64', s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet = isUrl ? 'base64url' : 'base64';
    if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');
    return Uint8Array.fromBase64(s, {
        alphabet,
        lastChunkHandling: 'strict'
    });
};
const base64 = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64();
    },
    decode (s) {
        return decodeBase64Builtin(s, false);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
const base64url = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64({
            alphabet: 'base64url'
        });
    },
    decode (s) {
        return decodeBase64Builtin(s, true);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc)=>chain(radix(58), alphabet(abc), join(''));
const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [
    0,
    2,
    3,
    5,
    6,
    7,
    9,
    10,
    11
];
const base58xmr = {
    encode (data) {
        let res = '';
        for(let i = 0; i < data.length; i += 8){
            const block = data.subarray(i, i + 8);
            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode (str) {
        let res = [];
        for(let i = 0; i < str.length; i += 11){
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = base58.decode(slice);
            for(let j = 0; j < block.length - blockLen; j++){
                if (block[j] !== 0) throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    }
};
const createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);
const base58check = createBase58check;
const BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [
    0x3b6a57b2,
    0x26508e6d,
    0x1ea119fa,
    0x3d4233dd,
    0x2a1462b3
];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){
        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for(let i = 0; i < len; i++){
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;
    for (let v of words)chk = bech32Polymod(chk) ^ v;
    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([
        chk % powers[30]
    ], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        astr('bech32.encode prefix', prefix);
        if (isBytes(words)) words = Array.from(words);
        anumArr('bech32.encode', words);
        const plen = prefix.length;
        if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        astr('bech32.decode input', str);
        const slen = str.length;
        if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6) throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return {
            prefix,
            words
        };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return {
            prefix,
            words,
            bytes: fromWords(words)
        };
    }
    function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
    }
    return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
    };
}
const bech32 = genBech32('bech32');
const bech32m = genBech32('bech32m');
const utf8 = {
    encode: (data)=>new TextDecoder().decode(data),
    decode: (str)=>new TextEncoder().encode(str)
};
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
// prettier-ignore
const hasHexBuiltin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// prettier-ignore
const hexBuiltin = {
    encode (data) {
        abytes(data);
        return data.toHex();
    },
    decode (s) {
        astr('hex', s);
        return Uint8Array.fromHex(s);
    }
};
const hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s)=>{
    if (typeof s !== 'string' || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
// prettier-ignore
const CODERS = {
    utf8,
    hex,
    base16,
    base32,
    base64,
    base64url,
    base58,
    base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
const bytesToString = (type, bytes)=>{
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
const str = bytesToString; // as in python, but for bytes only
const stringToBytes = (type, str)=>{
    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
const bytes = stringToBytes; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/bech32/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for(let z = 0; z < ALPHABET.length; z++){
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (pre & 0x1ffffff) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}
function prefixChk(prefix) {
    let chk = 1;
    for(let i = 0; i < prefix.length; ++i){
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for(let i = 0; i < prefix.length; ++i){
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 0x1f;
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for(let i = 0; i < data.length; ++i){
        value = value << inBits | data[i];
        bits += inBits;
        while(bits >= outBits){
            bits -= outBits;
            result.push(value >> bits & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push(value << outBits - bits & maxV);
        }
    } else {
        if (bits >= inBits) return 'Excess padding';
        if (value << outBits - bits & maxV) return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    } else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string') throw new Error(chk);
        let result = prefix + '1';
        for(let i = 0; i < words.length; ++i){
            const x = words[i];
            if (x >> 5 !== 0) throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for(let i = 0; i < 6; ++i){
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for(let i = 0; i < 6; ++i){
            const v = chk >> (5 - i) * 5 & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8) return str + ' too short';
        if (str.length > LIMIT) return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1) return 'No separator character for ' + str;
        if (split === 0) return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6) return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string') return chk;
        const words = [];
        for(let i = 0; i < wordChars.length; ++i){
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined) return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length) continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str;
        return {
            prefix,
            words
        };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object') return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object') return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');
}),
"[project]/node_modules/ts-custom-error/dist/custom-error.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CustomError",
    ()=>CustomError,
    "customErrorFactory",
    ()=>customErrorFactory
]);
function fixProto(target, prototype) {
    var setPrototypeOf = Object.setPrototypeOf;
    setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
}
function fixStack(target, fn) {
    if (fn === void 0) {
        fn = target.constructor;
    }
    var captureStackTrace = Error.captureStackTrace;
    captureStackTrace && captureStackTrace(target, fn);
}
var __extends = undefined && undefined.__extends || function() {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b){
                if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var CustomError = function(_super) {
    __extends(CustomError, _super);
    function CustomError(message, options) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message, options) || this;
        Object.defineProperty(_this, 'name', {
            value: _newTarget.name,
            enumerable: false,
            configurable: true
        });
        fixProto(_this, _newTarget.prototype);
        fixStack(_this);
        return _this;
    }
    return CustomError;
}(Error);
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
function customErrorFactory(fn, parent) {
    if (parent === void 0) {
        parent = Error;
    }
    function CustomError() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        if (!(this instanceof CustomError)) return new (CustomError.bind.apply(CustomError, __spreadArray([
            void 0
        ], args, false)))();
        parent.apply(this, args);
        Object.defineProperty(this, 'name', {
            value: fn.name || parent.name,
            enumerable: false,
            configurable: true
        });
        fn.apply(this, args);
        fixStack(this, CustomError);
    }
    return Object.defineProperties(CustomError, {
        prototype: {
            value: Object.create(parent.prototype, {
                constructor: {
                    value: CustomError,
                    writable: true,
                    configurable: true
                }
            })
        }
    });
}
;
 //# sourceMappingURL=custom-error.mjs.map
}),
"[project]/node_modules/@cardano-sdk/util/dist/esm/errors.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ComposableError",
    ()=>ComposableError,
    "InvalidArgumentError",
    ()=>InvalidArgumentError,
    "InvalidStateError",
    ()=>InvalidStateError,
    "InvalidStringError",
    ()=>InvalidStringError,
    "formatErrorMessage",
    ()=>formatErrorMessage,
    "stripStackTrace",
    ()=>stripStackTrace
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ts$2d$custom$2d$error$2f$dist$2f$custom$2d$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ts-custom-error/dist/custom-error.mjs [app-client] (ecmascript)");
;
const formatErrorMessage = (reason, detail)=>reason + (detail ? ` (${detail})` : '');
const isWithInnerError = (error)=>error !== null && typeof error === 'object' && 'innerError' in error;
const isErrorLike = (error)=>{
    if (!error || typeof error !== 'object' || !('message' in error && 'stack' in error)) return false;
    const { message, stack } = error;
    return typeof message === 'string' && typeof stack === 'string';
};
const stripStackTrace = (error)=>{
    if (!error) return;
    if (isErrorLike(error)) {
        delete error.stack;
    }
    if (isWithInnerError(error)) {
        stripStackTrace(error.innerError);
    }
};
class ComposableError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ts$2d$custom$2d$error$2f$dist$2f$custom$2d$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CustomError"] {
    constructor(message, innerError){
        let firstLineOfInnerErrorStack = '';
        let innerErrorStack = [];
        if (isErrorLike(innerError) && innerError.stack) {
            [firstLineOfInnerErrorStack, ...innerErrorStack] = innerError.stack.split(ComposableError.stackDelimiter);
            message = `${message} due to\n ${firstLineOfInnerErrorStack}`;
        }
        if (typeof innerError === 'string') message = `${message} due to\n ${innerError}`;
        super(message);
        this.innerError = innerError;
        if (!this.stack || innerErrorStack.length === 0) return;
        const [firstLineOfStack] = this.stack.split(ComposableError.stackDelimiter);
        Object.defineProperty(this, 'stack', {
            configurable: true,
            value: `${firstLineOfStack}${innerErrorStack.join(ComposableError.stackDelimiter)}`
        });
    }
}
ComposableError.stackDelimiter = '\n    at ';
class InvalidStringError extends ComposableError {
    constructor(expectation, innerError){
        super(`Invalid string: "${expectation}"`, innerError);
    }
}
class InvalidArgumentError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ts$2d$custom$2d$error$2f$dist$2f$custom$2d$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CustomError"] {
    constructor(argName, message){
        super(`Invalid argument '${argName}': ${message}`);
    }
}
class InvalidStateError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ts$2d$custom$2d$error$2f$dist$2f$custom$2d$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CustomError"] {
    constructor(message){
        super(`Invalid state': ${message}`);
    }
} //# sourceMappingURL=errors.js.map
}),
"[project]/node_modules/@cardano-sdk/util/dist/esm/primitives.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Base64Blob",
    ()=>Base64Blob,
    "HexBlob",
    ()=>HexBlob,
    "assertIsBech32WithPrefix",
    ()=>assertIsBech32WithPrefix,
    "assertIsHexString",
    ()=>assertIsHexString,
    "castHexBlob",
    ()=>castHexBlob,
    "typedBech32",
    ()=>typedBech32,
    "typedHex",
    ()=>typedHex
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bech32$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bech32/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cardano-sdk/util/dist/esm/errors.js [app-client] (ecmascript)");
;
;
const MAX_BECH32_LENGTH_LIMIT = 1023;
const isOneOf = (target, options)=>Array.isArray(options) && options.includes(target) || target === options;
const assertIsBech32WithPrefix = (target, prefix, expectedDecodedLength)=>{
    let decoded;
    try {
        decoded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bech32$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bech32"].decode(target, MAX_BECH32_LENGTH_LIMIT);
    } catch (error) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidStringError"](`expected bech32-encoded string with '${prefix}' prefix`, error);
    }
    if (!isOneOf(decoded.prefix, prefix)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidStringError"](`expected bech32 prefix '${prefix}', got '${decoded.prefix}''`);
    }
    if (expectedDecodedLength && !isOneOf(decoded.words.length, expectedDecodedLength)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidStringError"](`expected decoded length of '${expectedDecodedLength}', got '${decoded.words.length}'`);
    }
};
const typedBech32 = (target, prefix, expectedDecodedLength)=>{
    assertIsBech32WithPrefix(target, prefix, expectedDecodedLength);
    return target;
};
const assertLength = (expectedLength, target)=>{
    if (expectedLength && target.length !== expectedLength) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidStringError"](`expected length '${expectedLength}', got ${target.length}`);
    }
};
const assertIsHexString = (target, expectedLength)=>{
    assertLength(expectedLength, target);
    if (target.length > 0 && !/^[\da-f]+$/i.test(target)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidStringError"]('expected hex string');
    }
};
const typedHex = (value, length)=>{
    assertIsHexString(value, length);
    return value;
};
const Base64Blob = (target)=>{
    if (/^(?:[\d+/a-z]{4})*(?:[\d+/a-z]{2}==|[\d+/a-z]{3}=)?$/i.test(target)) {
        return target;
    }
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidStringError"]('expected base64 string');
};
Base64Blob.fromBytes = (bytes)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(bytes).toString('base64');
const HexBlob = (target)=>typedHex(target);
HexBlob.fromBytes = (bytes)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(bytes).toString('hex');
HexBlob.fromBase64 = (rawData)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(rawData, 'base64').toString('hex');
HexBlob.toTypedBech32 = (prefix, hexString)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bech32$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bech32"].encode(prefix, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bech32$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bech32"].toWords(Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(hexString, 'hex'))));
const castHexBlob = (target, expectedLength)=>{
    assertLength(expectedLength, target);
    return target;
}; //# sourceMappingURL=primitives.js.map
}),
"[project]/node_modules/@cardano-sdk/util/dist/esm/isNotNil.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isNotNil",
    ()=>isNotNil
]);
const isNotNil = (item)=>typeof item !== 'undefined' && item !== null; //# sourceMappingURL=isNotNil.js.map
}),
"[project]/node_modules/@cardano-sdk/util/dist/esm/BigIntMath.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BigIntMath",
    ()=>BigIntMath
]);
const BigIntMath = {
    abs (x) {
        return x < 0n ? -x : x;
    },
    max (arr) {
        if (arr.length === 0) return null;
        let max = arr[0];
        for (const num of arr.slice(1)){
            if (num > max) max = num;
        }
        return max;
    },
    subtract (arr) {
        if (arr.length === 0) return 0n;
        return arr.reduce((result, num)=>result - num);
    },
    sum (arr) {
        return arr.reduce((result, num)=>result + num, 0n);
    }
}; //# sourceMappingURL=BigIntMath.js.map
}),
"[project]/node_modules/@cardano-sdk/util/dist/esm/Percent.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Percent",
    ()=>Percent,
    "calcPercentages",
    ()=>calcPercentages
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/sum.js [app-client] (ecmascript)");
;
const Percent = (value)=>value;
const calcPercentages = (parts, total = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(parts))=>{
    if (parts.length === 0) {
        return [];
    }
    let partsSum = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(parts);
    if (total < partsSum) total = partsSum;
    if (total === 0) {
        parts = parts.map(()=>1);
        partsSum = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(parts);
        total = partsSum;
    }
    return parts.map((part)=>Percent(part / total));
}; //# sourceMappingURL=Percent.js.map
}),
"[project]/node_modules/@cardano-sdk/crypto/dist/esm/hexTypes.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BIP32_PUBLIC_KEY_HASH_LENGTH",
    ()=>BIP32_PUBLIC_KEY_HASH_LENGTH,
    "Bip32PrivateKeyHex",
    ()=>Bip32PrivateKeyHex,
    "Bip32PublicKeyHashHex",
    ()=>Bip32PublicKeyHashHex,
    "Bip32PublicKeyHex",
    ()=>Bip32PublicKeyHex,
    "Ed25519KeyHashHex",
    ()=>Ed25519KeyHashHex,
    "Ed25519PrivateExtendedKeyHex",
    ()=>Ed25519PrivateExtendedKeyHex,
    "Ed25519PrivateNormalKeyHex",
    ()=>Ed25519PrivateNormalKeyHex,
    "Ed25519PublicKeyHex",
    ()=>Ed25519PublicKeyHex,
    "Ed25519SignatureHex",
    ()=>Ed25519SignatureHex,
    "Hash28ByteBase16",
    ()=>Hash28ByteBase16,
    "Hash32ByteBase16",
    ()=>Hash32ByteBase16
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cardano-sdk/util/dist/esm/primitives.js [app-client] (ecmascript)");
;
const BIP32_PUBLIC_KEY_HASH_LENGTH = 28;
const Ed25519SignatureHex = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(value, 128);
const Bip32PublicKeyHex = (key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(key, 128);
const Bip32PrivateKeyHex = (key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(key, 192);
const Ed25519PublicKeyHex = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(value, 64);
const Ed25519PrivateExtendedKeyHex = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(value, 128);
const Ed25519PrivateNormalKeyHex = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(value, 64);
const Ed25519KeyHashHex = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(value, 56);
const Bip32PublicKeyHashHex = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(value, BIP32_PUBLIC_KEY_HASH_LENGTH * 2);
const Hash32ByteBase16 = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(value, 64);
Hash32ByteBase16.fromHexBlob = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["castHexBlob"])(value, 64);
const Hash28ByteBase16 = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$util$2f$dist$2f$esm$2f$primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typedHex"])(value, 56);
Hash28ByteBase16.fromEd25519KeyHashHex = (value)=>value; //# sourceMappingURL=hexTypes.js.map
}),
"[project]/node_modules/@foxglove/crc/dist/esm/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Compute CRC32 lookup tables as described at:
 * https://github.com/komrad36/CRC#option-6-1-byte-tabular
 *
 * An iteration of CRC computation can be performed on 8 bits of input at once. By pre-computing a
 * table of the values of CRC(?) for all 2^8 = 256 possible byte values, during the final
 * computation we can replace a loop over 8 bits with a single lookup in the table.
 *
 * For further speedup, we can also pre-compute the values of CRC(?0) for all possible bytes when a
 * zero byte is appended. Then we can process two bytes of input at once by computing CRC(AB) =
 * CRC(A0) ^ CRC(B), using one lookup in the CRC(?0) table and one lookup in the CRC(?) table.
 *
 * The same technique applies for any number of bytes to be processed at once, although the speed
 * improvements diminish.
 *
 * @param polynomial The binary representation of the polynomial to use (reversed, i.e. most
 * significant bit represents x^0).
 * @param numTables The number of bytes of input that will be processed at once.
 */ __turbopack_context__.s([
    "crc32",
    ()=>crc32,
    "crc32Final",
    ()=>crc32Final,
    "crc32GenerateTables",
    ()=>crc32GenerateTables,
    "crc32Init",
    ()=>crc32Init,
    "crc32Update",
    ()=>crc32Update
]);
function crc32GenerateTables({ polynomial, numTables }) {
    const table = new Uint32Array(256 * numTables);
    for(let i = 0; i < 256; i++){
        let r = i;
        r = (r & 1) * polynomial ^ r >>> 1;
        r = (r & 1) * polynomial ^ r >>> 1;
        r = (r & 1) * polynomial ^ r >>> 1;
        r = (r & 1) * polynomial ^ r >>> 1;
        r = (r & 1) * polynomial ^ r >>> 1;
        r = (r & 1) * polynomial ^ r >>> 1;
        r = (r & 1) * polynomial ^ r >>> 1;
        r = (r & 1) * polynomial ^ r >>> 1;
        table[i] = r;
    }
    for(let i = 256; i < table.length; i++){
        const value = table[i - 256];
        table[i] = table[value & 0xff] ^ value >>> 8;
    }
    return table;
}
const CRC32_TABLE = crc32GenerateTables({
    polynomial: 0xedb88320,
    numTables: 8
});
function crc32Init() {
    return ~0;
}
function crc32Update(prev, data) {
    const byteLength = data.byteLength;
    const view = new DataView(data.buffer, data.byteOffset, byteLength);
    let r = prev;
    let offset = 0;
    // Process bytes one by one until we reach 4-byte alignment, which will speed up uint32 access.
    const toAlign = -view.byteOffset & 3;
    for(; offset < toAlign && offset < byteLength; offset++){
        r = CRC32_TABLE[(r ^ view.getUint8(offset)) & 0xff] ^ r >>> 8;
    }
    if (offset === byteLength) {
        return r;
    }
    offset = toAlign;
    // Process 8 bytes (2 uint32s) at a time.
    let remainingBytes = byteLength - offset;
    for(; remainingBytes >= 8; offset += 8, remainingBytes -= 8){
        r ^= view.getUint32(offset, true);
        const r2 = view.getUint32(offset + 4, true);
        r = CRC32_TABLE[0 * 256 + (r2 >>> 24 & 0xff)] ^ CRC32_TABLE[1 * 256 + (r2 >>> 16 & 0xff)] ^ CRC32_TABLE[2 * 256 + (r2 >>> 8 & 0xff)] ^ CRC32_TABLE[3 * 256 + (r2 >>> 0 & 0xff)] ^ CRC32_TABLE[4 * 256 + (r >>> 24 & 0xff)] ^ CRC32_TABLE[5 * 256 + (r >>> 16 & 0xff)] ^ CRC32_TABLE[6 * 256 + (r >>> 8 & 0xff)] ^ CRC32_TABLE[7 * 256 + (r >>> 0 & 0xff)];
    }
    // Process any remaining bytes one by one. (Perf note: inexplicably, using a temporary variable
    // `i` rather than reusing `offset` here is faster in V8.)
    for(let i = offset; i < byteLength; i++){
        r = CRC32_TABLE[(r ^ view.getUint8(i)) & 0xff] ^ r >>> 8;
    }
    return r;
}
function crc32Final(prev) {
    return (prev ^ ~0) >>> 0;
}
function crc32(data) {
    return crc32Final(crc32Update(crc32Init(), data));
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/lodash/_baseSum.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */ function baseSum(array, iteratee) {
    var result, index = -1, length = array.length;
    while(++index < length){
        var current = iteratee(array[index]);
        if (current !== undefined) {
            result = result === undefined ? current : result + current;
        }
    }
    return result;
}
module.exports = baseSum;
}),
"[project]/node_modules/lodash/identity.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */ function identity(value) {
    return value;
}
module.exports = identity;
}),
"[project]/node_modules/lodash/sum.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var baseSum = __turbopack_context__.r("[project]/node_modules/lodash/_baseSum.js [app-client] (ecmascript)"), identity = __turbopack_context__.r("[project]/node_modules/lodash/identity.js [app-client] (ecmascript)");
/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */ function sum(array) {
    return array && array.length ? baseSum(array, identity) : 0;
}
module.exports = sum;
}),
"[project]/node_modules/web-encoding/src/lib.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// In node `export { TextEncoder }` throws:
// "Export 'TextEncoder' is not defined in module"
// To workaround we first define constants and then export with as.
__turbopack_context__.s([
    "TextDecoder",
    ()=>Decoder,
    "TextEncoder",
    ()=>Encoder
]);
const Encoder = TextEncoder;
const Decoder = TextDecoder;
;
}),
"[project]/node_modules/nanoassert/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = assert;
class AssertionError extends Error {
}
AssertionError.prototype.name = 'AssertionError';
/**
 * Minimal assert function
 * @param  {any} t Value to check if falsy
 * @param  {string=} m Optional assertion error message
 * @throws {AssertionError}
 */ function assert(t, m) {
    if (!t) {
        var err = new AssertionError(m);
        if (Error.captureStackTrace) Error.captureStackTrace(err, assert);
        throw err;
    }
}
}),
"[project]/node_modules/b4a/lib/ascii.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

function byteLength(string) {
    return string.length;
}
function toString(buffer) {
    const len = buffer.byteLength;
    let result = '';
    for(let i = 0; i < len; i++){
        result += String.fromCharCode(buffer[i]);
    }
    return result;
}
function write(buffer, string) {
    const len = buffer.byteLength;
    for(let i = 0; i < len; i++){
        buffer[i] = string.charCodeAt(i);
    }
    return len;
}
module.exports = {
    byteLength,
    toString,
    write
};
}),
"[project]/node_modules/b4a/lib/base64.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const codes = new Uint8Array(256);
for(let i = 0; i < alphabet.length; i++){
    codes[alphabet.charCodeAt(i)] = i;
}
codes[/* - */ 0x2d] = 62;
codes[/* _ */ 0x5f] = 63;
function byteLength(string) {
    let len = string.length;
    if (string.charCodeAt(len - 1) === 0x3d) len--;
    if (len > 1 && string.charCodeAt(len - 1) === 0x3d) len--;
    return len * 3 >>> 2;
}
function toString(buffer) {
    const len = buffer.byteLength;
    let result = '';
    for(let i = 0; i < len; i += 3){
        result += alphabet[buffer[i] >> 2] + alphabet[(buffer[i] & 3) << 4 | buffer[i + 1] >> 4] + alphabet[(buffer[i + 1] & 15) << 2 | buffer[i + 2] >> 6] + alphabet[buffer[i + 2] & 63];
    }
    if (len % 3 === 2) {
        result = result.substring(0, result.length - 1) + '=';
    } else if (len % 3 === 1) {
        result = result.substring(0, result.length - 2) + '==';
    }
    return result;
}
function write(buffer, string) {
    const len = buffer.byteLength;
    for(let i = 0, j = 0; j < len; i += 4){
        const a = codes[string.charCodeAt(i)];
        const b = codes[string.charCodeAt(i + 1)];
        const c = codes[string.charCodeAt(i + 2)];
        const d = codes[string.charCodeAt(i + 3)];
        buffer[j++] = a << 2 | b >> 4;
        buffer[j++] = (b & 15) << 4 | c >> 2;
        buffer[j++] = (c & 3) << 6 | d & 63;
    }
    return len;
}
module.exports = {
    byteLength,
    toString,
    write
};
}),
"[project]/node_modules/b4a/lib/hex.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

function byteLength(string) {
    return string.length >>> 1;
}
function toString(buffer) {
    const len = buffer.byteLength;
    buffer = new DataView(buffer.buffer, buffer.byteOffset, len);
    let result = '';
    let i = 0;
    for(let n = len - len % 4; i < n; i += 4){
        result += buffer.getUint32(i).toString(16).padStart(8, '0');
    }
    for(; i < len; i++){
        result += buffer.getUint8(i).toString(16).padStart(2, '0');
    }
    return result;
}
function write(buffer, string) {
    const len = buffer.byteLength;
    for(let i = 0; i < len; i++){
        const a = hexValue(string.charCodeAt(i * 2));
        const b = hexValue(string.charCodeAt(i * 2 + 1));
        if (a === undefined || b === undefined) {
            return buffer.subarray(0, i);
        }
        buffer[i] = a << 4 | b;
    }
    return len;
}
module.exports = {
    byteLength,
    toString,
    write
};
function hexValue(char) {
    if (char >= 0x30 && char <= 0x39) return char - 0x30;
    if (char >= 0x41 && char <= 0x46) return char - 0x41 + 10;
    if (char >= 0x61 && char <= 0x66) return char - 0x61 + 10;
}
}),
"[project]/node_modules/b4a/lib/utf8.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

function byteLength(string) {
    let length = 0;
    for(let i = 0, n = string.length; i < n; i++){
        const code = string.charCodeAt(i);
        if (code >= 0xd800 && code <= 0xdbff && i + 1 < n) {
            const code = string.charCodeAt(i + 1);
            if (code >= 0xdc00 && code <= 0xdfff) {
                length += 4;
                i++;
                continue;
            }
        }
        if (code <= 0x7f) length += 1;
        else if (code <= 0x7ff) length += 2;
        else length += 3;
    }
    return length;
}
let toString;
if (typeof TextDecoder !== 'undefined') {
    const decoder = new TextDecoder();
    toString = function toString(buffer) {
        return decoder.decode(buffer);
    };
} else {
    toString = function toString(buffer) {
        const len = buffer.byteLength;
        let output = '';
        let i = 0;
        while(i < len){
            let byte = buffer[i];
            if (byte <= 0x7f) {
                output += String.fromCharCode(byte);
                i++;
                continue;
            }
            let bytesNeeded = 0;
            let codePoint = 0;
            if (byte <= 0xdf) {
                bytesNeeded = 1;
                codePoint = byte & 0x1f;
            } else if (byte <= 0xef) {
                bytesNeeded = 2;
                codePoint = byte & 0x0f;
            } else if (byte <= 0xf4) {
                bytesNeeded = 3;
                codePoint = byte & 0x07;
            }
            if (len - i - bytesNeeded > 0) {
                let k = 0;
                while(k < bytesNeeded){
                    byte = buffer[i + k + 1];
                    codePoint = codePoint << 6 | byte & 0x3f;
                    k += 1;
                }
            } else {
                codePoint = 0xfffd;
                bytesNeeded = len - i;
            }
            output += String.fromCodePoint(codePoint);
            i += bytesNeeded + 1;
        }
        return output;
    };
}
let write;
if (typeof TextEncoder !== 'undefined') {
    const encoder = new TextEncoder();
    write = function write(buffer, string) {
        return encoder.encodeInto(string, buffer).written;
    };
} else {
    write = function write(buffer, string) {
        const len = buffer.byteLength;
        let i = 0;
        let j = 0;
        while(i < string.length){
            const code = string.codePointAt(i);
            if (code <= 0x7f) {
                buffer[j++] = code;
                i++;
                continue;
            }
            let count = 0;
            let bits = 0;
            if (code <= 0x7ff) {
                count = 6;
                bits = 0xc0;
            } else if (code <= 0xffff) {
                count = 12;
                bits = 0xe0;
            } else if (code <= 0x1fffff) {
                count = 18;
                bits = 0xf0;
            }
            buffer[j++] = bits | code >> count;
            count -= 6;
            while(count >= 0){
                buffer[j++] = 0x80 | code >> count & 0x3f;
                count -= 6;
            }
            i += code >= 0x10000 ? 2 : 1;
        }
        return len;
    };
}
module.exports = {
    byteLength,
    toString,
    write
};
}),
"[project]/node_modules/b4a/lib/utf16le.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

function byteLength(string) {
    return string.length * 2;
}
function toString(buffer) {
    const len = buffer.byteLength;
    let result = '';
    for(let i = 0; i < len - 1; i += 2){
        result += String.fromCharCode(buffer[i] + buffer[i + 1] * 256);
    }
    return result;
}
function write(buffer, string) {
    const len = buffer.byteLength;
    let units = len;
    for(let i = 0; i < string.length; ++i){
        if ((units -= 2) < 0) break;
        const c = string.charCodeAt(i);
        const hi = c >> 8;
        const lo = c % 256;
        buffer[i * 2] = lo;
        buffer[i * 2 + 1] = hi;
    }
    return len;
}
module.exports = {
    byteLength,
    toString,
    write
};
}),
"[project]/node_modules/b4a/browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const ascii = __turbopack_context__.r("[project]/node_modules/b4a/lib/ascii.js [app-client] (ecmascript)");
const base64 = __turbopack_context__.r("[project]/node_modules/b4a/lib/base64.js [app-client] (ecmascript)");
const hex = __turbopack_context__.r("[project]/node_modules/b4a/lib/hex.js [app-client] (ecmascript)");
const utf8 = __turbopack_context__.r("[project]/node_modules/b4a/lib/utf8.js [app-client] (ecmascript)");
const utf16le = __turbopack_context__.r("[project]/node_modules/b4a/lib/utf16le.js [app-client] (ecmascript)");
const LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff;
function codecFor(encoding) {
    switch(encoding){
        case 'ascii':
            return ascii;
        case 'base64':
            return base64;
        case 'hex':
            return hex;
        case 'utf8':
        case 'utf-8':
        case undefined:
        case null:
            return utf8;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16le;
        default:
            throw new Error(`Unknown encoding '${encoding}'`);
    }
}
function isBuffer(value) {
    return value instanceof Uint8Array;
}
function isEncoding(encoding) {
    try {
        codecFor(encoding);
        return true;
    } catch  {
        return false;
    }
}
function alloc(size, fill, encoding) {
    const buffer = new Uint8Array(size);
    if (fill !== undefined) {
        exports.fill(buffer, fill, 0, buffer.byteLength, encoding);
    }
    return buffer;
}
function allocUnsafe(size) {
    return new Uint8Array(size);
}
function allocUnsafeSlow(size) {
    return new Uint8Array(size);
}
function byteLength(string, encoding) {
    return codecFor(encoding).byteLength(string);
}
function compare(a, b) {
    if (a === b) return 0;
    const len = Math.min(a.byteLength, b.byteLength);
    a = new DataView(a.buffer, a.byteOffset, a.byteLength);
    b = new DataView(b.buffer, b.byteOffset, b.byteLength);
    let i = 0;
    for(let n = len - len % 4; i < n; i += 4){
        const x = a.getUint32(i, LE);
        const y = b.getUint32(i, LE);
        if (x !== y) break;
    }
    for(; i < len; i++){
        const x = a.getUint8(i);
        const y = b.getUint8(i);
        if (x < y) return -1;
        if (x > y) return 1;
    }
    return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0;
}
function concat(buffers, length) {
    if (length === undefined) {
        length = buffers.reduce((len, buffer)=>len + buffer.byteLength, 0);
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const buffer of buffers){
        if (offset + buffer.byteLength > result.byteLength) {
            result.set(buffer.subarray(0, result.byteLength - offset), offset);
            return result;
        }
        result.set(buffer, offset);
        offset += buffer.byteLength;
    }
    return result;
}
function copy(source, target, targetStart = 0, sourceStart = 0, sourceEnd = source.byteLength) {
    if (targetStart < 0) targetStart = 0;
    if (targetStart >= target.byteLength) return 0;
    const targetLength = target.byteLength - targetStart;
    if (sourceStart < 0) sourceStart = 0;
    if (sourceStart >= source.byteLength) return 0;
    if (sourceEnd <= sourceStart) return 0;
    if (sourceEnd > source.byteLength) sourceEnd = source.byteLength;
    if (sourceEnd - sourceStart > targetLength) {
        sourceEnd = sourceStart + targetLength;
    }
    const sourceLength = sourceEnd - sourceStart;
    if (source === target) {
        target.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        if (sourceStart !== 0 || sourceEnd !== source.byteLength) {
            source = source.subarray(sourceStart, sourceEnd);
        }
        target.set(source, targetStart);
    }
    return sourceLength;
}
function equals(a, b) {
    if (a === b) return true;
    if (a.byteLength !== b.byteLength) return false;
    return compare(a, b) === 0;
}
function fill(buffer, value, offset = 0, end = buffer.byteLength, encoding = 'utf8') {
    if (typeof value === 'string') {
        if (typeof offset === 'string') {
            // fill(string, encoding)
            encoding = offset;
            offset = 0;
            end = buffer.byteLength;
        } else if (typeof end === 'string') {
            // fill(string, offset, encoding)
            encoding = end;
            end = buffer.byteLength;
        }
    } else if (typeof value === 'number') {
        value = value & 0xff;
    } else if (typeof value === 'boolean') {
        value = +value;
    }
    if (offset < 0) offset = 0;
    if (offset >= buffer.byteLength) return buffer;
    if (end <= offset) return buffer;
    if (end > buffer.byteLength) end = buffer.byteLength;
    if (typeof value === 'number') return buffer.fill(value, offset, end);
    if (typeof value === 'string') value = exports.from(value, encoding);
    const len = value.byteLength;
    for(let i = 0, n = end - offset; i < n; ++i){
        buffer[i + offset] = value[i % len];
    }
    return buffer;
}
function from(value, encodingOrOffset, length) {
    // from(string, encoding)
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    // from(array)
    if (Array.isArray(value)) return fromArray(value);
    // from(buffer)
    if (ArrayBuffer.isView(value)) return fromBuffer(value);
    // from(arrayBuffer[, byteOffset[, length]])
    return fromArrayBuffer(value, encodingOrOffset, length);
}
function fromString(string, encoding) {
    const codec = codecFor(encoding);
    const buffer = new Uint8Array(codec.byteLength(string));
    codec.write(buffer, string);
    return buffer;
}
function fromArray(array) {
    const buffer = new Uint8Array(array.length);
    buffer.set(array);
    return buffer;
}
function fromBuffer(buffer) {
    const copy = new Uint8Array(buffer.byteLength);
    copy.set(buffer);
    return copy;
}
function fromArrayBuffer(arrayBuffer, byteOffset, length) {
    return new Uint8Array(arrayBuffer, byteOffset, length);
}
function includes(buffer, value, byteOffset, encoding) {
    return indexOf(buffer, value, byteOffset, encoding) !== -1;
}
function indexOf(buffer, value, byteOffset, encoding) {
    return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true);
}
function lastIndexOf(buffer, value, byteOffset, encoding) {
    return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false);
}
function bidirectionalIndexOf(buffer, value, byteOffset, encoding, first) {
    if (buffer.byteLength === 0) return -1;
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset === undefined) {
        byteOffset = first ? 0 : buffer.length - 1;
    } else if (byteOffset < 0) {
        byteOffset += buffer.byteLength;
    }
    if (byteOffset >= buffer.byteLength) {
        if (first) return -1;
        else byteOffset = buffer.byteLength - 1;
    } else if (byteOffset < 0) {
        if (first) byteOffset = 0;
        else return -1;
    }
    if (typeof value === 'string') {
        value = from(value, encoding);
    } else if (typeof value === 'number') {
        value = value & 0xff;
        if (first) {
            return buffer.indexOf(value, byteOffset);
        } else {
            return buffer.lastIndexOf(value, byteOffset);
        }
    }
    if (value.byteLength === 0) return -1;
    if (first) {
        let foundIndex = -1;
        for(let i = byteOffset; i < buffer.byteLength; i++){
            if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === value.byteLength) return foundIndex;
            } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
            }
        }
    } else {
        if (byteOffset + value.byteLength > buffer.byteLength) {
            byteOffset = buffer.byteLength - value.byteLength;
        }
        for(let i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < value.byteLength; j++){
                if (buffer[i + j] !== value[j]) {
                    found = false;
                    break;
                }
            }
            if (found) return i;
        }
    }
    return -1;
}
function swap(buffer, n, m) {
    const i = buffer[n];
    buffer[n] = buffer[m];
    buffer[m] = i;
}
function swap16(buffer) {
    const len = buffer.byteLength;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(let i = 0; i < len; i += 2)swap(buffer, i, i + 1);
    return buffer;
}
function swap32(buffer) {
    const len = buffer.byteLength;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(let i = 0; i < len; i += 4){
        swap(buffer, i, i + 3);
        swap(buffer, i + 1, i + 2);
    }
    return buffer;
}
function swap64(buffer) {
    const len = buffer.byteLength;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(let i = 0; i < len; i += 8){
        swap(buffer, i, i + 7);
        swap(buffer, i + 1, i + 6);
        swap(buffer, i + 2, i + 5);
        swap(buffer, i + 3, i + 4);
    }
    return buffer;
}
function toBuffer(buffer) {
    return buffer;
}
function toString(buffer, encoding = 'utf8', start = 0, end = buffer.byteLength) {
    // toString(buffer)
    if (arguments.length === 1) return utf8.toString(buffer);
    // toString(buffer, encoding)
    if (arguments.length === 2) return codecFor(encoding).toString(buffer);
    if (start < 0) start = 0;
    if (start >= buffer.byteLength) return '';
    if (end <= start) return '';
    if (end > buffer.byteLength) end = buffer.byteLength;
    if (start !== 0 || end !== buffer.byteLength) {
        buffer = buffer.subarray(start, end);
    }
    return codecFor(encoding).toString(buffer);
}
function write(buffer, string, offset, length, encoding) {
    // write(buffer, string)
    if (arguments.length === 2) return utf8.write(buffer, string);
    if (typeof offset === 'string') {
        // write(buffer, string, encoding)
        encoding = offset;
        offset = 0;
        length = buffer.byteLength;
    } else if (typeof length === 'string') {
        // write(buffer, string, offset, encoding)
        encoding = length;
        length = buffer.byteLength - offset;
    }
    length = Math.min(length, exports.byteLength(string, encoding));
    let start = offset;
    if (start < 0) start = 0;
    if (start >= buffer.byteLength) return 0;
    let end = offset + length;
    if (end <= start) return 0;
    if (end > buffer.byteLength) end = buffer.byteLength;
    if (start !== 0 || end !== buffer.byteLength) {
        buffer = buffer.subarray(start, end);
    }
    return codecFor(encoding).write(buffer, string);
}
function readDoubleBE(buffer, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    return view.getFloat64(offset, false);
}
function readDoubleLE(buffer, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    return view.getFloat64(offset, true);
}
function readFloatBE(buffer, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    return view.getFloat32(offset, false);
}
function readFloatLE(buffer, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    return view.getFloat32(offset, true);
}
function readInt32BE(buffer, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    return view.getInt32(offset, false);
}
function readInt32LE(buffer, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    return view.getInt32(offset, true);
}
function readUInt32BE(buffer, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    return view.getUint32(offset, false);
}
function readUInt32LE(buffer, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    return view.getUint32(offset, true);
}
function writeDoubleBE(buffer, value, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    view.setFloat64(offset, value, false);
    return offset + 8;
}
function writeDoubleLE(buffer, value, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    view.setFloat64(offset, value, true);
    return offset + 8;
}
function writeFloatBE(buffer, value, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    view.setFloat32(offset, value, false);
    return offset + 4;
}
function writeFloatLE(buffer, value, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    view.setFloat32(offset, value, true);
    return offset + 4;
}
function writeInt32BE(buffer, value, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    view.setInt32(offset, value, false);
    return offset + 4;
}
function writeInt32LE(buffer, value, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    view.setInt32(offset, value, true);
    return offset + 4;
}
function writeUInt32BE(buffer, value, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    view.setUint32(offset, value, false);
    return offset + 4;
}
function writeUInt32LE(buffer, value, offset = 0) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    view.setUint32(offset, value, true);
    return offset + 4;
}
module.exports = exports = {
    isBuffer,
    isEncoding,
    alloc,
    allocUnsafe,
    allocUnsafeSlow,
    byteLength,
    compare,
    concat,
    copy,
    equals,
    fill,
    from,
    includes,
    indexOf,
    lastIndexOf,
    swap16,
    swap32,
    swap64,
    toBuffer,
    toString,
    write,
    readDoubleBE,
    readDoubleLE,
    readFloatBE,
    readFloatLE,
    readInt32BE,
    readInt32LE,
    readUInt32BE,
    readUInt32LE,
    writeDoubleBE,
    writeDoubleLE,
    writeFloatBE,
    writeFloatLE,
    writeInt32BE,
    writeInt32LE,
    writeUInt32BE,
    writeUInt32LE
};
}),
"[project]/node_modules/blake2b-wasm/blake2b.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[Object.keys(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __toBinary = /* @__PURE__ */ (()=>{
    var table = new Uint8Array(128);
    for(var i = 0; i < 64; i++)table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
    return (base64)=>{
        var n = base64.length, bytes2 = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
        for(var i2 = 0, j = 0; i2 < n;){
            var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
            var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
            bytes2[j++] = c0 << 2 | c1 >> 4;
            bytes2[j++] = c1 << 4 | c2 >> 2;
            bytes2[j++] = c2 << 6 | c3;
        }
        return bytes2;
    };
})();
// wasm-binary:./blake2b.wat
var require_blake2b = __commonJS({
    "wasm-binary:./blake2b.wat" (exports2, module2) {
        module2.exports = __toBinary("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMKvz8EwAIAIABCADcDACAAQgA3AwggAEIANwMQIABCADcDGCAAQgA3AyAgAEIANwMoIABCADcDMCAAQgA3AzggAEIANwNAIABCADcDSCAAQgA3A1AgAEIANwNYIABCADcDYCAAQgA3A2ggAEIANwNwIABCADcDeCAAQoiS853/zPmE6gBBACkDAIU3A4ABIABCu86qptjQ67O7f0EIKQMAhTcDiAEgAEKr8NP0r+68tzxBECkDAIU3A5ABIABC8e30+KWn/aelf0EYKQMAhTcDmAEgAELRhZrv+s+Uh9EAQSApAwCFNwOgASAAQp/Y+dnCkdqCm39BKCkDAIU3A6gBIABC6/qG2r+19sEfQTApAwCFNwOwASAAQvnC+JuRo7Pw2wBBOCkDAIU3A7gBIABCADcDwAEgAEIANwPIASAAQgA3A9ABC20BA38gAEHAAWohAyAAQcgBaiEEIAQpAwCnIQUCQANAIAEgAkYNASAFQYABRgRAIAMgAykDACAFrXw3AwBBACEFIAAQAwsgACAFaiABLQAAOgAAIAVBAWohBSABQQFqIQEMAAsLIAQgBa03AwALYQEDfyAAQcABaiEBIABByAFqIQIgASABKQMAIAIpAwB8NwMAIABCfzcD0AEgAikDAKchAwJAA0AgA0GAAUYNASAAIANqQQA6AAAgA0EBaiEDDAALCyACIAOtNwMAIAAQAwuqOwIgfgl/IABBgAFqISEgAEGIAWohIiAAQZABaiEjIABBmAFqISQgAEGgAWohJSAAQagBaiEmIABBsAFqIScgAEG4AWohKCAhKQMAIQEgIikDACECICMpAwAhAyAkKQMAIQQgJSkDACEFICYpAwAhBiAnKQMAIQcgKCkDACEIQoiS853/zPmE6gAhCUK7zqqm2NDrs7t/IQpCq/DT9K/uvLc8IQtC8e30+KWn/aelfyEMQtGFmu/6z5SH0QAhDUKf2PnZwpHagpt/IQ5C6/qG2r+19sEfIQ9C+cL4m5Gjs/DbACEQIAApAwAhESAAKQMIIRIgACkDECETIAApAxghFCAAKQMgIRUgACkDKCEWIAApAzAhFyAAKQM4IRggACkDQCEZIAApA0ghGiAAKQNQIRsgACkDWCEcIAApA2AhHSAAKQNoIR4gACkDcCEfIAApA3ghICANIAApA8ABhSENIA8gACkD0AGFIQ8gASAFIBF8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSASfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgE3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBR8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAVfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBd8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAYfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgGXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBp8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAbfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgHHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIB18fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAefHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgH3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFICB8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAffHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgG3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBV8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAZfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHICB8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAefHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggF3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBJ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAdfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgEXx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBN8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAcfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGHx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBZ8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAUfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHHx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBl8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAdfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgEXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBZ8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByATfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggIHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIB58fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAbfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgH3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBR8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAXfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBJ8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAafHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFXx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBh8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAafHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFHx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBJ8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAefHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHXx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBx8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAffHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgE3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBd8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAWfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgG3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBV8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCARfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgIHx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBl8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAafHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEXx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBZ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAYfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgE3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBV8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAbfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggIHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIB98fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiASfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgHHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB18fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAXfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBR8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAefHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgE3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIB18fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAXfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgG3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBF8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAcfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggGXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBR8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAVfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBh8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAWfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggIHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB98fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSASfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgGnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB18fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAWfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgEnx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGICB8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAffHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBV8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAbfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBh8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAXfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBp8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCATfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGXx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBx8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAefHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgHHx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBh8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAffHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBJ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAUfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBZ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiARfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgIHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBV8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAZfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggF3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBN8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAbfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgF3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFICB8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAffHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGnx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBx8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAUfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggEXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBl8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAdfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgE3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIB58fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAYfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggEnx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBV8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAbfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBt8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSATfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgGXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBV8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAYfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgF3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBJ8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAWfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgIHx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBx8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAafHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgH3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBR8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAdfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgHnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBF8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgISAhKQMAIAEgCYWFNwMAICIgIikDACACIAqFhTcDACAjICMpAwAgAyALhYU3AwAgJCAkKQMAIAQgDIWFNwMAICUgJSkDACAFIA2FhTcDACAmICYpAwAgBiAOhYU3AwAgJyAnKQMAIAcgD4WFNwMAICggKCkDACAIIBCFhTcDAAs=");
    }
});
// wasm-module:./blake2b.wat
var bytes = require_blake2b();
var compiled = WebAssembly.compile(bytes);
module.exports = async (imports)=>{
    const instance = await WebAssembly.instantiate(await compiled, imports);
    return instance.exports;
};
}),
"[project]/node_modules/blake2b-wasm/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var assert = __turbopack_context__.r("[project]/node_modules/nanoassert/index.js [app-client] (ecmascript)");
var b4a = __turbopack_context__.r("[project]/node_modules/b4a/browser.js [app-client] (ecmascript)");
var wasm = null;
var wasmPromise = typeof WebAssembly !== "undefined" && __turbopack_context__.r("[project]/node_modules/blake2b-wasm/blake2b.js [app-client] (ecmascript)")().then((mod)=>{
    wasm = mod;
});
var head = 64;
var freeList = [];
module.exports = Blake2b;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;
function Blake2b(digestLength, key, salt, personal, noAssert) {
    if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert);
    if (!wasm) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)');
    if (!digestLength) digestLength = 32;
    if (noAssert !== true) {
        assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength);
        assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength);
        if (key != null) {
            assert(key instanceof Uint8Array, 'key must be Uint8Array or Buffer');
            assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
            assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length);
        }
        if (salt != null) {
            assert(salt instanceof Uint8Array, 'salt must be Uint8Array or Buffer');
            assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
        }
        if (personal != null) {
            assert(personal instanceof Uint8Array, 'personal must be Uint8Array or Buffer');
            assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
        }
    }
    if (!freeList.length) {
        freeList.push(head);
        head += 216;
    }
    this.digestLength = digestLength;
    this.finalized = false;
    this.pointer = freeList.pop();
    this._memory = new Uint8Array(wasm.memory.buffer);
    this._memory.fill(0, 0, 64);
    this._memory[0] = this.digestLength;
    this._memory[1] = key ? key.length : 0;
    this._memory[2] = 1; // fanout
    this._memory[3] = 1; // depth
    if (salt) this._memory.set(salt, 32);
    if (personal) this._memory.set(personal, 48);
    if (this.pointer + 216 > this._memory.length) this._realloc(this.pointer + 216); // we need 216 bytes for the state
    wasm.blake2b_init(this.pointer, this.digestLength);
    if (key) {
        this.update(key);
        this._memory.fill(0, head, head + key.length); // whiteout key
        this._memory[this.pointer + 200] = 128;
    }
}
Blake2b.prototype._realloc = function(size) {
    wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)));
    this._memory = new Uint8Array(wasm.memory.buffer);
};
Blake2b.prototype.update = function(input) {
    assert(this.finalized === false, 'Hash instance finalized');
    assert(input instanceof Uint8Array, 'input must be Uint8Array or Buffer');
    if (head + input.length > this._memory.length) this._realloc(head + input.length);
    this._memory.set(input, head);
    wasm.blake2b_update(this.pointer, head, head + input.length);
    return this;
};
Blake2b.prototype.digest = function(enc) {
    assert(this.finalized === false, 'Hash instance finalized');
    this.finalized = true;
    freeList.push(this.pointer);
    wasm.blake2b_final(this.pointer);
    if (!enc || enc === 'binary') {
        return this._memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
    }
    if (typeof enc === 'string') {
        return b4a.toString(this._memory, enc, this.pointer + 128, this.pointer + 128 + this.digestLength);
    }
    assert(enc instanceof Uint8Array && enc.length >= this.digestLength, 'input must be Uint8Array or Buffer');
    for(var i = 0; i < this.digestLength; i++){
        enc[i] = this._memory[this.pointer + 128 + i];
    }
    return enc;
};
// libsodium compat
Blake2b.prototype.final = Blake2b.prototype.digest;
Blake2b.WASM = wasm;
Blake2b.SUPPORTED = typeof WebAssembly !== 'undefined';
Blake2b.ready = function(cb) {
    if (!cb) cb = noop;
    if (!wasmPromise) return cb(new Error('WebAssembly not supported'));
    return wasmPromise.then(()=>cb(), cb);
};
Blake2b.prototype.ready = Blake2b.ready;
Blake2b.prototype.getPartialHash = function() {
    return this._memory.slice(this.pointer, this.pointer + 216);
};
Blake2b.prototype.setPartialHash = function(ph) {
    this._memory.set(ph, this.pointer);
};
function noop() {}
}),
"[project]/node_modules/blake2b/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var assert = __turbopack_context__.r("[project]/node_modules/nanoassert/index.js [app-client] (ecmascript)");
var b2wasm = __turbopack_context__.r("[project]/node_modules/blake2b-wasm/index.js [app-client] (ecmascript)");
// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA(v, a, b) {
    var o0 = v[a] + v[b];
    var o1 = v[a + 1] + v[b + 1];
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC(v, a, b0, b1) {
    var o0 = v[a] + b0;
    if (b0 < 0) {
        o0 += 0x100000000;
    }
    var o1 = v[a + 1] + b1;
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// Little-endian byte access
function B2B_GET32(arr, i) {
    return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
}
// G Mixing function
// The ROTRs are inlined for speed
function B2B_G(a, b, c, d, ix, iy) {
    var x0 = m[ix];
    var x1 = m[ix + 1];
    var y0 = m[iy];
    var y1 = m[iy + 1];
    ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
    ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
    var xor0 = v[d] ^ v[a];
    var xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor1;
    v[d + 1] = xor0;
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor0 >>> 24 ^ xor1 << 8;
    v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v, a, b);
    ADD64AC(v, a, y0, y1);
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
    xor0 = v[d] ^ v[a];
    xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor0 >>> 16 ^ xor1 << 16;
    v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor1 >>> 31 ^ xor0 << 1;
    v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
}
// Initialization Vector
var BLAKE2B_IV32 = new Uint32Array([
    0xF3BCC908,
    0x6A09E667,
    0x84CAA73B,
    0xBB67AE85,
    0xFE94F82B,
    0x3C6EF372,
    0x5F1D36F1,
    0xA54FF53A,
    0xADE682D1,
    0x510E527F,
    0x2B3E6C1F,
    0x9B05688C,
    0xFB41BD6B,
    0x1F83D9AB,
    0x137E2179,
    0x5BE0CD19
]);
var SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
];
// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
var SIGMA82 = new Uint8Array(SIGMA8.map(function(x) {
    return x * 2;
}));
// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
var v = new Uint32Array(32);
var m = new Uint32Array(32);
function blake2bCompress(ctx, last) {
    var i = 0;
    // init work variables
    for(i = 0; i < 16; i++){
        v[i] = ctx.h[i];
        v[i + 16] = BLAKE2B_IV32[i];
    }
    // low 64 bits of offset
    v[24] = v[24] ^ ctx.t;
    v[25] = v[25] ^ ctx.t / 0x100000000;
    // high 64 bits not supported, offset may not be higher than 2**53-1
    // last block flag set ?
    if (last) {
        v[28] = ~v[28];
        v[29] = ~v[29];
    }
    // get little-endian words
    for(i = 0; i < 32; i++){
        m[i] = B2B_GET32(ctx.b, 4 * i);
    }
    // twelve rounds of mixing
    for(i = 0; i < 12; i++){
        B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    for(i = 0; i < 16; i++){
        ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
    }
}
// reusable parameter_block
var parameter_block = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 // 60: personal
]);
// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
function Blake2b(outlen, key, salt, personal) {
    // zero out parameter_block before usage
    parameter_block.fill(0);
    // state, 'param block'
    this.b = new Uint8Array(128);
    this.h = new Uint32Array(16);
    this.t = 0; // input count
    this.c = 0; // pointer within buffer
    this.outlen = outlen; // output length in bytes
    parameter_block[0] = outlen;
    if (key) parameter_block[1] = key.length;
    parameter_block[2] = 1; // fanout
    parameter_block[3] = 1; // depth
    if (salt) parameter_block.set(salt, 32);
    if (personal) parameter_block.set(personal, 48);
    // initialize hash state
    for(var i = 0; i < 16; i++){
        this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4);
    }
    // key the hash, if applicable
    if (key) {
        blake2bUpdate(this, key);
        // at the end
        this.c = 128;
    }
}
Blake2b.prototype.update = function(input) {
    assert(input instanceof Uint8Array, 'input must be Uint8Array or Buffer');
    blake2bUpdate(this, input);
    return this;
};
Blake2b.prototype.digest = function(out) {
    var buf = !out || out === 'binary' || out === 'hex' ? new Uint8Array(this.outlen) : out;
    assert(buf instanceof Uint8Array, 'out must be "binary", "hex", Uint8Array, or Buffer');
    assert(buf.length >= this.outlen, 'out must have at least outlen bytes of space');
    blake2bFinal(this, buf);
    if (out === 'hex') return hexSlice(buf);
    return buf;
};
Blake2b.prototype.final = Blake2b.prototype.digest;
Blake2b.ready = function(cb) {
    b2wasm.ready(function() {
        cb(); // ignore the error
    });
};
// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate(ctx, input) {
    for(var i = 0; i < input.length; i++){
        if (ctx.c === 128) {
            ctx.t += ctx.c; // add counters
            blake2bCompress(ctx, false); // compress (not last)
            ctx.c = 0; // counter to zero
        }
        ctx.b[ctx.c++] = input[i];
    }
}
// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal(ctx, out) {
    ctx.t += ctx.c; // mark last block offset
    while(ctx.c < 128){
        ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true); // final block flag = 1
    for(var i = 0; i < ctx.outlen; i++){
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
    }
    return out;
}
function hexSlice(buf) {
    var str = '';
    for(var i = 0; i < buf.length; i++)str += toHex(buf[i]);
    return str;
}
function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
}
var Proto = Blake2b;
module.exports = function createHash(outlen, key, salt, personal, noAssert) {
    if (noAssert !== true) {
        assert(outlen >= BYTES_MIN, 'outlen must be at least ' + BYTES_MIN + ', was given ' + outlen);
        assert(outlen <= BYTES_MAX, 'outlen must be at most ' + BYTES_MAX + ', was given ' + outlen);
        if (key != null) {
            assert(key instanceof Uint8Array, 'key must be Uint8Array or Buffer');
            assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
            assert(key.length <= KEYBYTES_MAX, 'key must be at most ' + KEYBYTES_MAX + ', was given ' + key.length);
        }
        if (salt != null) {
            assert(salt instanceof Uint8Array, 'salt must be Uint8Array or Buffer');
            assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
        }
        if (personal != null) {
            assert(personal instanceof Uint8Array, 'personal must be Uint8Array or Buffer');
            assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
        }
    }
    return new Proto(outlen, key, salt, personal);
};
module.exports.ready = function(cb) {
    b2wasm.ready(function() {
        cb();
    });
};
module.exports.WASM_SUPPORTED = b2wasm.SUPPORTED;
module.exports.WASM_LOADED = false;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;
b2wasm.ready(function(err) {
    if (!err) {
        module.exports.WASM_LOADED = true;
        module.exports = b2wasm;
    }
});
}),
"[project]/node_modules/blake2b/index.js [app-client] (ecmascript) <export default as blake2b>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "blake2b",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$blake2b$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$blake2b$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/blake2b/index.js [app-client] (ecmascript)");
}),
"[project]/node_modules/fraction.js/fraction.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * @license Fraction.js v4.0.1 09/09/2015
 * http://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2015, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/ /**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <nominator>, 1 => <denominator> ]
 * [ n => <nominator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */ (function(root) {
    "use strict";
    // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
    // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
    // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
    var MAX_CYCLE_LEN = 2000;
    // Parsed data to avoid calling "new" all the time
    var P = {
        "s": 1,
        "n": 0,
        "d": 1
    };
    function createError(name) {
        var errorConstructor = function() {
            var temp = Error.apply(this, arguments);
            temp.name = this.name = name;
            this.stack = temp.stack;
            this.message = temp.message;
        };
        var IntermediateInheritor = function() {};
        IntermediateInheritor.prototype = Error.prototype;
        errorConstructor.prototype = new IntermediateInheritor();
        return errorConstructor;
    }
    var DivisionByZero = Fraction['DivisionByZero'] = createError('DivisionByZero');
    var InvalidParameter = Fraction['InvalidParameter'] = createError('InvalidParameter');
    function assign(n, s) {
        if (isNaN(n = parseInt(n, 10))) {
            throwInvalidParam();
        }
        return n * s;
    }
    function throwInvalidParam() {
        throw new InvalidParameter();
    }
    var parse = function(p1, p2) {
        var n = 0, d = 1, s = 1;
        var v = 0, w = 0, x = 0, y = 1, z = 1;
        var A = 0, B = 1;
        var C = 1, D = 1;
        var N = 10000000;
        var M;
        if (p1 === undefined || p1 === null) {
        /* void */ } else if (p2 !== undefined) {
            n = p1;
            d = p2;
            s = n * d;
        } else switch(typeof p1){
            case "object":
                {
                    if ("d" in p1 && "n" in p1) {
                        n = p1["n"];
                        d = p1["d"];
                        if ("s" in p1) n *= p1["s"];
                    } else if (0 in p1) {
                        n = p1[0];
                        if (1 in p1) d = p1[1];
                    } else {
                        throwInvalidParam();
                    }
                    s = n * d;
                    break;
                }
            case "number":
                {
                    if (p1 < 0) {
                        s = p1;
                        p1 = -p1;
                    }
                    if (p1 % 1 === 0) {
                        n = p1;
                    } else if (p1 > 0) {
                        if (p1 >= 1) {
                            z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                            p1 /= z;
                        }
                        // Using Farey Sequences
                        // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/
                        while(B <= N && D <= N){
                            M = (A + C) / (B + D);
                            if (p1 === M) {
                                if (B + D <= N) {
                                    n = A + C;
                                    d = B + D;
                                } else if (D > B) {
                                    n = C;
                                    d = D;
                                } else {
                                    n = A;
                                    d = B;
                                }
                                break;
                            } else {
                                if (p1 > M) {
                                    A += C;
                                    B += D;
                                } else {
                                    C += A;
                                    D += B;
                                }
                                if (B > N) {
                                    n = C;
                                    d = D;
                                } else {
                                    n = A;
                                    d = B;
                                }
                            }
                        }
                        n *= z;
                    } else if (isNaN(p1) || isNaN(p2)) {
                        d = n = NaN;
                    }
                    break;
                }
            case "string":
                {
                    B = p1.match(/\d+|./g);
                    if (B[A] === '-') {
                        s = -1;
                        A++;
                    } else if (B[A] === '+') {
                        A++;
                    }
                    if (B.length === A + 1) {
                        w = assign(B[A++], s);
                    } else if (B[A + 1] === '.' || B[A] === '.') {
                        if (B[A] !== '.') {
                            v = assign(B[A++], s);
                        }
                        A++;
                        // Check for decimal places
                        if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                            w = assign(B[A], s);
                            y = Math.pow(10, B[A].length);
                            A++;
                        }
                        // Check for repeating places
                        if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                            x = assign(B[A + 1], s);
                            z = Math.pow(10, B[A + 1].length) - 1;
                            A += 3;
                        }
                    } else if (B[A + 1] === '/' || B[A + 1] === ':') {
                        w = assign(B[A], s);
                        y = assign(B[A + 2], 1);
                        A += 3;
                    } else if (B[A + 3] === '/' && B[A + 1] === ' ') {
                        v = assign(B[A], s);
                        w = assign(B[A + 2], s);
                        y = assign(B[A + 4], 1);
                        A += 5;
                    }
                    if (B.length <= A) {
                        d = y * z;
                        s = /* void */ n = x + d * v + z * w;
                        break;
                    }
                /* Fall through on error */ }
            default:
                throwInvalidParam();
        }
        if (d === 0) {
            throw new DivisionByZero();
        }
        P["s"] = s < 0 ? -1 : 1;
        P["n"] = Math.abs(n);
        P["d"] = Math.abs(d);
    };
    var modpow = function(b, e, m) {
        for(var r = 1; e > 0; b = b * b % m, e >>= 1){
            if (e & 1) {
                r = r * b % m;
            }
        }
        return r;
    };
    var cycleLen = function(n, d) {
        for(; d % 2 === 0; d /= 2){}
        for(; d % 5 === 0; d /= 5){}
        if (d === 1) return 0;
        // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
        // 10^(d-1) % d == 1
        // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
        // as we want to translate the numbers to strings.
        var rem = 10 % d;
        for(var t = 1; rem !== 1; t++){
            rem = rem * 10 % d;
            if (t > MAX_CYCLE_LEN) return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
        }
        return t;
    };
    var cycleStart = function(n, d, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d);
        for(var t = 0; t < 300; t++){
            // Solve 10^s == 10^(s+t) (mod d)
            if (rem1 === rem2) return t;
            rem1 = rem1 * 10 % d;
            rem2 = rem2 * 10 % d;
        }
        return 0;
    };
    var gcd = function(a, b) {
        if (!a) return b;
        if (!b) return a;
        while(1){
            a %= b;
            if (!a) return b;
            b %= a;
            if (!b) return a;
        }
    };
    /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction} a
   * @param {number=} b
   */ function Fraction(a, b) {
        if (!(this instanceof Fraction)) {
            return new Fraction(a, b);
        }
        parse(a, b);
        if (Fraction['REDUCE']) {
            a = gcd(P["d"], P["n"]); // Abuse a
        } else {
            a = 1;
        }
        this["s"] = P["s"];
        this["n"] = P["n"] / a;
        this["d"] = P["d"] / a;
    }
    /**
   * Boolean global variable to be able to disable automatic reduction of the fraction
   *
   */ Fraction['REDUCE'] = 1;
    Fraction.prototype = {
        "s": 1,
        "n": 0,
        "d": 1,
        /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/ "abs": function() {
            return new Fraction(this["n"], this["d"]);
        },
        /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/ "neg": function() {
            return new Fraction(-this["s"] * this["n"], this["d"]);
        },
        /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/ "add": function(a, b) {
            parse(a, b);
            return new Fraction(this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/ "sub": function(a, b) {
            parse(a, b);
            return new Fraction(this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/ "mul": function(a, b) {
            parse(a, b);
            return new Fraction(this["s"] * P["s"] * this["n"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/ "div": function(a, b) {
            parse(a, b);
            return new Fraction(this["s"] * P["s"] * this["n"] * P["d"], this["d"] * P["n"]);
        },
        /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/ "clone": function() {
            return new Fraction(this);
        },
        /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/ "mod": function(a, b) {
            if (isNaN(this['n']) || isNaN(this['d'])) {
                return new Fraction(NaN);
            }
            if (a === undefined) {
                return new Fraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse(a, b);
            if (0 === P["n"] && 0 === this["d"]) {
                Fraction(0, 0); // Throw DivisionByZero
            }
            /*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*/ /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */ return new Fraction(this["s"] * P["d"] * this["n"] % (P["n"] * this["d"]), P["d"] * this["d"]);
        },
        /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */ "gcd": function(a, b) {
            parse(a, b);
            // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)
            return new Fraction(gcd(P["n"], this["n"]), P["d"] * this["d"] / gcd(P["d"], this["d"]));
        },
        /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */ "lcm": function(a, b) {
            parse(a, b);
            // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)
            if (P["n"] === 0 && this["n"] === 0) {
                return new Fraction;
            }
            return new Fraction(P["n"] * this["n"] / gcd(P["n"], this["n"]), gcd(P["d"], this["d"]));
        },
        /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/ "ceil": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return new Fraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/ "floor": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return new Fraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/ "round": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return new Fraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Gets the inverse of the fraction, means numerator and denumerator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/ "inverse": function() {
            return new Fraction(this["s"] * this["d"], this["n"]);
        },
        /**
     * Calculates the fraction to some integer exponent
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */ "pow": function(m) {
            if (m < 0) {
                return new Fraction(Math.pow(this['s'] * this["d"], -m), Math.pow(this["n"], -m));
            } else {
                return new Fraction(Math.pow(this['s'] * this["n"], m), Math.pow(this["d"], m));
            }
        },
        /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/ "equals": function(a, b) {
            parse(a, b);
            return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
        },
        /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/ "compare": function(a, b) {
            parse(a, b);
            var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
            return (0 < t) - (t < 0);
        },
        /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */ "divisible": function(a, b) {
            parse(a, b);
            return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
        },
        /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/ 'valueOf': function() {
            return this["s"] * this["n"] / this["d"];
        },
        /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
     **/ 'toFraction': function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
                str += '-';
            }
            if (d === 1) {
                str += n;
            } else {
                if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                    str += whole;
                    str += " ";
                    n %= d;
                }
                str += n;
                str += '/';
                str += d;
            }
            return str;
        },
        /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/ 'toLatex': function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
                str += '-';
            }
            if (d === 1) {
                str += n;
            } else {
                if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                    str += whole;
                    n %= d;
                }
                str += "\\frac{";
                str += n;
                str += '}{';
                str += d;
                str += '}';
            }
            return str;
        },
        /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */ 'toContinued': function() {
            var t;
            var a = this['n'];
            var b = this['d'];
            var res = [];
            do {
                res.push(Math.floor(a / b));
                t = a % b;
                a = b;
                b = t;
            }while (a !== 1)
            return res;
        },
        /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/ 'toString': function() {
            var g;
            var N = this["n"];
            var D = this["d"];
            if (isNaN(N) || isNaN(D)) {
                return "NaN";
            }
            if (!Fraction['REDUCE']) {
                g = gcd(N, D);
                N /= g;
                D /= g;
            }
            var dec = 15; // 15 = decimal places when no repitation
            var cycLen = cycleLen(N, D); // Cycle length
            var cycOff = cycleStart(N, D, cycLen); // Cycle start
            var str = this['s'] === -1 ? "-" : "";
            str += N / D | 0;
            N %= D;
            N *= 10;
            if (N) str += ".";
            if (cycLen) {
                for(var i = cycOff; i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
                str += "(";
                for(var i = cycLen; i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
                str += ")";
            } else {
                for(var i = dec; N && i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
            }
            return str;
        }
    };
    if (typeof define === "function" && define["amd"]) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return Fraction;
        }());
    } else if ("TURBOPACK compile-time truthy", 1) {
        module["exports"] = Fraction;
    } else //TURBOPACK unreachable
    ;
})(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/@noble/hashes/crypto.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined; //# sourceMappingURL=crypto.js.map
}),
"[project]/node_modules/@noble/hashes/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/crypto.js [app-client] (ecmascript)");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is positive integer. */ function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */ function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {
    for(let i = 0; i < arrays.length; i++){
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
}
/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ exports.isLE = (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */ function byteSwap(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
}
/** Conditionally byte swap if on a big-endian platform */ exports.swap8IfBE = exports.isLE ? (n)=>n : (n)=>byteSwap(n);
/** @deprecated */ exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */ function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++){
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE ? (u)=>u : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore
    typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */ const nextTick = async ()=>{};
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */ function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */ function kdfInputToBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */ class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@noble/hashes/_md.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */ const utils_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-client] (ecmascript)");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */ function Chi(a, b, c) {
    return a & b ^ ~a & c;
}
/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */ class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ exports.SHA256_IV = Uint32Array.from([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8,
    0x367cd507,
    0x3070dd17,
    0xf70e5939,
    0xffc00b31,
    0x68581511,
    0x64f98fa7,
    0xbefa4fa4
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d,
    0xc1059ed8,
    0x629a292a,
    0x367cd507,
    0x9159015a,
    0x3070dd17,
    0x152fecd8,
    0xf70e5939,
    0x67332667,
    0xffc00b31,
    0x8eb44a87,
    0x68581511,
    0xdb0c2e0d,
    0x64f98fa7,
    0x47b5481d,
    0xbefa4fa4
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ exports.SHA512_IV = Uint32Array.from([
    0x6a09e667,
    0xf3bcc908,
    0xbb67ae85,
    0x84caa73b,
    0x3c6ef372,
    0xfe94f82b,
    0xa54ff53a,
    0x5f1d36f1,
    0x510e527f,
    0xade682d1,
    0x9b05688c,
    0x2b3e6c1f,
    0x1f83d9ab,
    0xfb41bd6b,
    0x5be0cd19,
    0x137e2179
]); //# sourceMappingURL=_md.js.map
}),
"[project]/node_modules/@noble/hashes/_u64.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for(let i = 0; i < len; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l)=>h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
exports.default = u64; //# sourceMappingURL=_u64.js.map
}),
"[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */ const _md_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/_md.js [app-client] (ecmascript)");
const u64 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/_u64.js [app-client] (ecmascript)");
const utils_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-client] (ecmascript)");
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */ // prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32){
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor(){
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (()=>u64.split([
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
    ].map((n)=>BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();
const SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64){
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(let i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for(let i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor(){
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8,
    0x19544da2,
    0x73e19966,
    0x89dcd4d6,
    0x1dfab7ae,
    0x32ff9c82,
    0x679dd514,
    0x582f9fcf,
    0x0f6d2b69,
    0x7bd44da8,
    0x77e36f73,
    0x04c48942,
    0x3f9d85a8,
    0x6a1d36c8,
    0x1112e6ad,
    0x91d692a1
]);
/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194,
    0xfc2bf72c,
    0x9f555fa3,
    0xc84c64c2,
    0x2393b86b,
    0x6f53b151,
    0x96387719,
    0x5940eabd,
    0x96283ee2,
    0xa88effe3,
    0xbe5e1e25,
    0x53863992,
    0x2b0199fc,
    0x2c85b8aa,
    0x0eb72ddc,
    0x81c52ca2
]);
class SHA512_224 extends SHA512 {
    constructor(){
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor(){
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */ exports.sha256 = (0, utils_ts_1.createHasher)(()=>new SHA256());
/** SHA2-224 hash function from RFC 4634 */ exports.sha224 = (0, utils_ts_1.createHasher)(()=>new SHA224());
/** SHA2-512 hash function from RFC 4634. */ exports.sha512 = (0, utils_ts_1.createHasher)(()=>new SHA512());
/** SHA2-384 hash function from RFC 4634. */ exports.sha384 = (0, utils_ts_1.createHasher)(()=>new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */ exports.sha512_256 = (0, utils_ts_1.createHasher)(()=>new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */ exports.sha512_224 = (0, utils_ts_1.createHasher)(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map
}),
"[project]/node_modules/@noble/hashes/sha256.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
/**
 * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
 *
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 *
 * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 * @deprecated
 */ const sha2_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA256 = sha2_ts_1.SHA256;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha256 = sha2_ts_1.sha256;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA224 = sha2_ts_1.SHA224;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha224 = sha2_ts_1.sha224; //# sourceMappingURL=sha256.js.map
}),
"[project]/node_modules/@noble/hashes/sha512.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha512_256 = exports.SHA512_256 = exports.sha512_224 = exports.SHA512_224 = exports.sha384 = exports.SHA384 = exports.sha512 = exports.SHA512 = void 0;
/**
 * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.
 *
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).
 * @module
 * @deprecated
 */ const sha2_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA512 = sha2_ts_1.SHA512;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha512 = sha2_ts_1.sha512;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA384 = sha2_ts_1.SHA384;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha384 = sha2_ts_1.sha384;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA512_224 = sha2_ts_1.SHA512_224;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha512_224 = sha2_ts_1.sha512_224;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA512_256 = sha2_ts_1.SHA512_256;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha512_256 = sha2_ts_1.sha512_256; //# sourceMappingURL=sha512.js.map
}),
"[project]/node_modules/@noble/hashes/hmac.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hmac = exports.HMAC = void 0;
/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */ const utils_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-client] (ecmascript)");
class HMAC extends utils_ts_1.Hash {
    constructor(hash, _key){
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map
}),
"[project]/node_modules/@noble/hashes/pbkdf2.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pbkdf2 = pbkdf2;
exports.pbkdf2Async = pbkdf2Async;
/**
 * PBKDF (RFC 2898). Can be used to create a key from password and salt.
 * @module
 */ const hmac_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/hmac.js [app-client] (ecmascript)");
// prettier-ignore
const utils_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-client] (ecmascript)");
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, utils_ts_1.ahash)(hash);
    const opts = (0, utils_ts_1.checkOpts)({
        dkLen: 32,
        asyncTick: 10
    }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, utils_ts_1.anumber)(c);
    (0, utils_ts_1.anumber)(dkLen);
    (0, utils_ts_1.anumber)(asyncTick);
    if (c < 1) throw new Error('iterations (c) should be >= 1');
    const password = (0, utils_ts_1.kdfInputToBytes)(_password);
    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_ts_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return {
        c,
        dkLen,
        asyncTick,
        DK,
        PRF,
        PRFSalt
    };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW) prfW.destroy();
    (0, utils_ts_1.clean)(u);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 * @example
 * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });
 */ function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for(let ui = 1; ui < c; ui++){
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.
 * @example
 * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });
 */ async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, ()=>{
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
} //# sourceMappingURL=pbkdf2.js.map
}),
"[project]/node_modules/@lucid-evolution/crc8/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/crc8.ts
__turbopack_context__.s([
    "crc8",
    ()=>crc8
]);
var TABLE = [
    0,
    7,
    14,
    9,
    28,
    27,
    18,
    21,
    56,
    63,
    54,
    49,
    36,
    35,
    42,
    45,
    112,
    119,
    126,
    121,
    108,
    107,
    98,
    101,
    72,
    79,
    70,
    65,
    84,
    83,
    90,
    93,
    224,
    231,
    238,
    233,
    252,
    251,
    242,
    245,
    216,
    223,
    214,
    209,
    196,
    195,
    202,
    205,
    144,
    151,
    158,
    153,
    140,
    139,
    130,
    133,
    168,
    175,
    166,
    161,
    180,
    179,
    186,
    189,
    199,
    192,
    201,
    206,
    219,
    220,
    213,
    210,
    255,
    248,
    241,
    246,
    227,
    228,
    237,
    234,
    183,
    176,
    185,
    190,
    171,
    172,
    165,
    162,
    143,
    136,
    129,
    134,
    147,
    148,
    157,
    154,
    39,
    32,
    41,
    46,
    59,
    60,
    53,
    50,
    31,
    24,
    17,
    22,
    3,
    4,
    13,
    10,
    87,
    80,
    89,
    94,
    75,
    76,
    69,
    66,
    111,
    104,
    97,
    102,
    115,
    116,
    125,
    122,
    137,
    142,
    135,
    128,
    149,
    146,
    155,
    156,
    177,
    182,
    191,
    184,
    173,
    170,
    163,
    164,
    249,
    254,
    247,
    240,
    229,
    226,
    235,
    236,
    193,
    198,
    207,
    200,
    221,
    218,
    211,
    212,
    105,
    110,
    103,
    96,
    117,
    114,
    123,
    124,
    81,
    86,
    95,
    88,
    77,
    74,
    67,
    68,
    25,
    30,
    23,
    16,
    5,
    2,
    11,
    12,
    33,
    38,
    47,
    40,
    61,
    58,
    51,
    52,
    78,
    73,
    64,
    71,
    82,
    85,
    92,
    91,
    118,
    113,
    120,
    127,
    106,
    109,
    100,
    99,
    62,
    57,
    48,
    55,
    34,
    37,
    44,
    43,
    6,
    1,
    8,
    15,
    26,
    29,
    20,
    19,
    174,
    169,
    160,
    167,
    178,
    181,
    188,
    187,
    150,
    145,
    152,
    159,
    138,
    141,
    132,
    131,
    222,
    217,
    208,
    215,
    194,
    197,
    204,
    203,
    230,
    225,
    232,
    239,
    250,
    253,
    244,
    243
];
if (typeof Int32Array !== "undefined") {
    TABLE = new Int32Array(TABLE);
}
function crc8(current, previous = 0) {
    let crc = ~~previous;
    for(let index = 0; index < current.length; index++){
        crc = TABLE[(crc ^ current[index]) & 255] & 255;
    }
    return crc;
}
;
}),
"[project]/node_modules/@lucid-evolution/utils/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

// src/native.ts
__turbopack_context__.s([
    "CBOREncodingLevel",
    ()=>CBOREncodingLevel,
    "PROTOCOL_PARAMETERS_DEFAULT",
    ()=>PROTOCOL_PARAMETERS_DEFAULT,
    "addAssets",
    ()=>addAssets,
    "addressFromHexOrBech32",
    ()=>addressFromHexOrBech32,
    "applyDoubleCborEncoding",
    ()=>applyDoubleCborEncoding,
    "applyParamsToScript",
    ()=>applyParamsToScript,
    "applySingleCborEncoding",
    ()=>applySingleCborEncoding,
    "assetsToValue",
    ()=>assetsToValue,
    "calculateMinLovelaceFromUTxO",
    ()=>calculateMinLovelaceFromUTxO,
    "coreToOutRef",
    ()=>coreToOutRef,
    "coreToTxOutput",
    ()=>coreToTxOutput,
    "coreToUtxo",
    ()=>coreToUtxo,
    "coresToOutRefs",
    ()=>coresToOutRefs,
    "coresToTxOutputs",
    ()=>coresToTxOutputs,
    "coresToUtxos",
    ()=>coresToUtxos,
    "createCostModels",
    ()=>createCostModels,
    "credentialToAddress",
    ()=>credentialToAddress,
    "credentialToRewardAddress",
    ()=>credentialToRewardAddress,
    "datumJsonToCbor",
    ()=>datumJsonToCbor,
    "datumToHash",
    ()=>datumToHash,
    "drepIDToCredential",
    ()=>drepIDToCredential,
    "fromCMLRedeemerTag",
    ()=>fromCMLRedeemerTag,
    "fromLabel",
    ()=>fromLabel,
    "fromScriptRef",
    ()=>fromScriptRef,
    "fromUnit",
    ()=>fromUnit,
    "generatePrivateKey",
    ()=>generatePrivateKey,
    "generateSeedPhrase",
    ()=>generateSeedPhrase,
    "getAddressDetails",
    ()=>getAddressDetails,
    "getInputIndices",
    ()=>getInputIndices,
    "getUniqueTokenName",
    ()=>getUniqueTokenName,
    "isEqualUTxO",
    ()=>isEqualUTxO,
    "keyHashToCredential",
    ()=>keyHashToCredential,
    "mintingPolicyToId",
    ()=>mintingPolicyToId,
    "networkToId",
    ()=>networkToId,
    "parseCMLNative",
    ()=>parseCMLNative,
    "paymentCredentialOf",
    ()=>paymentCredentialOf,
    "scriptFromCMLNative",
    ()=>scriptFromCMLNative,
    "scriptFromNative",
    ()=>scriptFromNative,
    "scriptHashToCredential",
    ()=>scriptHashToCredential,
    "selectUTxOs",
    ()=>selectUTxOs,
    "slotToUnixTime",
    ()=>slotToUnixTime,
    "sortCanonical",
    ()=>sortCanonical,
    "sortUTxOs",
    ()=>sortUTxOs,
    "stakeCredentialOf",
    ()=>stakeCredentialOf,
    "stringify",
    ()=>stringify,
    "toCMLNativeScript",
    ()=>toCMLNativeScript,
    "toCMLRedeemerTag",
    ()=>toCMLRedeemerTag,
    "toLabel",
    ()=>toLabel,
    "toPublicKey",
    ()=>toPublicKey,
    "toScriptRef",
    ()=>toScriptRef,
    "toUnit",
    ()=>toUnit,
    "unixTimeToSlot",
    ()=>unixTimeToSlot,
    "utxoToCore",
    ()=>utxoToCore,
    "utxoToTransactionInput",
    ()=>utxoToTransactionInput,
    "utxoToTransactionOutput",
    ()=>utxoToTransactionOutput,
    "utxosToCores",
    ()=>utxosToCores,
    "validatorToAddress",
    ()=>validatorToAddress,
    "validatorToRewardAddress",
    ()=>validatorToRewardAddress,
    "validatorToScriptHash",
    ()=>validatorToScriptHash,
    "valueToAssets",
    ()=>valueToAssets
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/Schema.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$ParseResult$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/ParseResult.js [app-client] (ecmascript)");
// src/core.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@anastasia-labs/cardano-multiplatform-lib-browser/cardano_multiplatform_lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@anastasia-labs/cardano-multiplatform-lib-browser/cardano_multiplatform_lib_bg.js [app-client] (ecmascript)");
// src/cbor.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/core-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cbor-x/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cbor-x/decode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cbor-x/encode.js [app-client] (ecmascript) <locals>");
// src/scripts.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$plutus$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/plutus/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$harmoniclabs$2f$uplc$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@harmoniclabs/uplc/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$harmoniclabs$2f$plutus$2d$data$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@harmoniclabs/plutus-data/dist/index.js [app-client] (ecmascript)");
// src/credential.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$core$2f$dist$2f$esm$2f$Cardano$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Cardano$3e$__ = __turbopack_context__.i("[project]/node_modules/@cardano-sdk/core/dist/esm/Cardano/index.js [app-client] (ecmascript) <export * as Cardano>");
// src/keys.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bip39$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bip39/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$crc8$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/crc8/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$effect$2f$dist$2f$esm$2f$Function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/effect/dist/esm/Function.js [app-client] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$plutus$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$plutus$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
// src/native.ts
var toCMLNativeScript = (native)=>{
    switch(native.type){
        case "sig":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScript"].new_script_pubkey(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ed25519KeyHash"].from_hex(native.keyHash));
        case "before":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScript"].new_script_invalid_hereafter(BigInt(native.slot));
        case "after":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScript"].new_script_invalid_before(BigInt(native.slot));
        case "all":
            {
                const nativeList = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScriptList"].new();
                native.scripts.map((script)=>nativeList.add(toCMLNativeScript(script)));
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScript"].new_script_all(nativeList);
            }
        case "any":
            {
                const nativeList = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScriptList"].new();
                native.scripts.map((script)=>nativeList.add(toCMLNativeScript(script)));
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScript"].new_script_any(nativeList);
            }
        case "atLeast":
            {
                const nativeList = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScriptList"].new();
                native.scripts.map((script)=>nativeList.add(toCMLNativeScript(script)));
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScript"].new_script_n_of_k(BigInt(native.required), nativeList);
            }
    }
};
var scriptFromNative = (native)=>{
    return {
        type: "Native",
        script: toCMLNativeScript(native).to_cbor_hex()
    };
};
var CMLNativeSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Union"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
    ScriptPubkey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
        ed25519_key_hash: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["String"]
    })
}), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
    ScriptInvalidBefore: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
        before: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Number"]
    })
}), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
    ScriptInvalidHereafter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
        after: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Number"]
    })
}), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
    ScriptAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
        native_scripts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Array"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["suspend"](()=>CMLNativeSchema))
    })
}), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
    ScriptAny: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
        native_scripts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Array"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["suspend"](()=>CMLNativeSchema))
    })
}), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
    ScriptNOfK: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Struct"]({
        n: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Number"],
        native_scripts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Array"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$Schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["suspend"](()=>CMLNativeSchema))
    })
}));
var parseCMLNative = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$node_modules$2f40$effect$2f$schema$2f$dist$2f$esm$2f$ParseResult$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeUnknownSync"](CMLNativeSchema);
var scriptFromCMLNative = (cmlNative)=>{
    return {
        type: "Native",
        script: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScript"].from_json(JSON.stringify(cmlNative)).to_cbor_hex()
    };
};
// src/network.ts
function networkToId(network) {
    switch(network){
        case "Preview":
            return 0;
        case "Preprod":
            return 0;
        case "Custom":
            return 0;
        case "Mainnet":
            return 1;
        default:
            throw new Error("Network not found");
    }
}
;
;
var applyDoubleCborEncoding = (script)=>{
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script)));
        return script;
    } catch (error) {
        try {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script));
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(Uint8Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script).buffer)));
        } catch (error2) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(Uint8Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script).buffer))));
        }
    }
};
var applySingleCborEncoding = (script)=>{
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script)));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script)));
    } catch (error) {
        try {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script));
            return script;
        } catch (error2) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(Uint8Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script).buffer)));
        }
    }
};
var CBOREncodingLevel = (script)=>{
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script)));
        return "double";
    } catch (error) {
        try {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(script));
            return "single";
        } catch (error2) {
            throw new Error("Script is not CBOR-encoded or invalid format.");
        }
    }
};
function datumJsonToCbor(json) {
    const convert = (json2)=>{
        if (!isNaN(json2.int)) {
            const plutusBigInt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigInteger"].from_str(json2.int.toString());
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_integer(plutusBigInt);
        } else if (json2.bytes || !isNaN(Number(json2.bytes))) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_bytes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(json2.bytes));
        } else if (json2.list) {
            const l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusDataList"].new();
            json2.list.forEach((v)=>{
                l.add(convert(v));
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_list(l);
        } else if (json2.map && json2.map.length > 0 && typeof json2.map[0] === "object") {
            const m = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusMap"].new();
            json2.map.forEach(({ k, v })=>{
                m.set(convert(k), convert(v));
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_map(m);
        } else if (json2.map && typeof json2.map === "function") {
            const l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusDataList"].new();
            Object.values(json2).forEach((value)=>{
                l.add(convert(value));
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_list(l);
        } else if (!isNaN(json2.constructor)) {
            const l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusDataList"].new();
            json2.fields.forEach((v)=>{
                l.add(convert(v));
            });
            const bigInt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigInteger"].from_str(json2.constructor.toString()).as_u64();
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].new_constr_plutus_data(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConstrPlutusData"].new(bigInt, l));
        }
        throw new Error("Unsupported type");
    };
    return convert(json).to_cbor_hex();
}
;
;
;
;
;
function validatorToAddress(network, validator, stakeCredential) {
    const validatorHash = validatorToScriptHash(validator);
    if (stakeCredential) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseAddress"].new(networkToId(network), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_script(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScriptHash"].from_hex(validatorHash)), stakeCredential.type === "Key" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ed25519KeyHash"].from_hex(stakeCredential.hash)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_script(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScriptHash"].from_hex(stakeCredential.hash))).to_address().to_bech32(void 0);
    } else {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EnterpriseAddress"].new(networkToId(network), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_script(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScriptHash"].from_hex(validatorHash))).to_address().to_bech32(void 0);
    }
}
function validatorToScriptHash(validator) {
    switch(validator.type){
        case "Native":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScript"].from_cbor_hex(validator.script).hash().to_hex();
        case "PlutusV1":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusScript"].from_v1(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusV1Script"].from_cbor_hex(applyDoubleCborEncoding(validator.script))).hash().to_hex();
        case "PlutusV2":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusScript"].from_v2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusV2Script"].from_cbor_hex(applyDoubleCborEncoding(validator.script))).hash().to_hex();
        case "PlutusV3":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusScript"].from_v3(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusV3Script"].from_cbor_hex(applyDoubleCborEncoding(validator.script))).hash().to_hex();
        default:
            throw new Error("No variant matched");
    }
}
function toScriptRef(script) {
    switch(script.type){
        case "Native":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Script"].new_native(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NativeScript"].from_cbor_hex(script.script));
        case "PlutusV1":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Script"].new_plutus_v1(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusV1Script"].from_cbor_hex(applyDoubleCborEncoding(script.script)));
        case "PlutusV2":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Script"].new_plutus_v2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusV2Script"].from_cbor_hex(applyDoubleCborEncoding(script.script)));
        case "PlutusV3":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Script"].new_plutus_v3(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusV3Script"].from_cbor_hex(applyDoubleCborEncoding(script.script)));
        default:
            throw new Error("No variant matched.");
    }
}
function fromScriptRef(scriptRef) {
    const kind = scriptRef.kind();
    switch(kind){
        case 0:
            return {
                type: "Native",
                script: scriptRef.as_native().to_cbor_hex()
            };
        case 1:
            return {
                type: "PlutusV1",
                script: scriptRef.as_plutus_v1().to_cbor_hex()
            };
        case 2:
            return {
                type: "PlutusV2",
                script: scriptRef.as_plutus_v2().to_cbor_hex()
            };
        case 3:
            return {
                type: "PlutusV3",
                script: scriptRef.as_plutus_v3().to_cbor_hex()
            };
        default:
            throw new Error("No variant matched.");
    }
}
function mintingPolicyToId(mintingPolicy) {
    return validatorToScriptHash(mintingPolicy);
}
function applyParamsToScript(plutusScript, params, type) {
    const program = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$harmoniclabs$2f$uplc$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseUPLC"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$x$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(applyDoubleCborEncoding(plutusScript)))), "flat");
    const parameters = type ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$plutus$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Data"].castTo(params, type) : params;
    const appliedProgram = parameters.reduce((body, currentParameter)=>{
        const data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$harmoniclabs$2f$uplc$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UPLCConst"].data((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$harmoniclabs$2f$plutus$2d$data$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataFromCbor"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$plutus$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Data"].to(currentParameter)));
        const appliedParameter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$harmoniclabs$2f$uplc$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Application"](body, data);
        return appliedParameter;
    }, program.body);
    return applyDoubleCborEncoding((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$harmoniclabs$2f$uplc$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeUPLC"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$harmoniclabs$2f$uplc$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UPLCProgram"](program.version, appliedProgram)).toBuffer().buffer));
}
// src/address.ts
function addressFromHexOrBech32(address) {
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Address"].from_hex(address);
    } catch (_e) {
        try {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Address"].from_bech32(address);
        } catch (_e2) {
            throw new Error("Could not deserialize address.");
        }
    }
}
function credentialToRewardAddress(network, stakeCredential) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RewardAddress"].new(networkToId(network), stakeCredential.type === "Key" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ed25519KeyHash"].from_hex(stakeCredential.hash)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_script(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScriptHash"].from_hex(stakeCredential.hash))).to_address().to_bech32(void 0);
}
function validatorToRewardAddress(network, validator) {
    const validatorHash = validatorToScriptHash(validator);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RewardAddress"].new(networkToId(network), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_script(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScriptHash"].from_hex(validatorHash))).to_address().to_bech32(void 0);
}
function getAddressDetails(address) {
    try {
        const parsedAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseAddress"].from_address(addressFromHexOrBech32(address));
        const paymentCredential = parsedAddress.payment().kind() === 0 ? {
            type: "Key",
            hash: parsedAddress.payment().as_pub_key().to_hex()
        } : {
            type: "Script",
            hash: parsedAddress.payment().as_script().to_hex()
        };
        const stakeCredential = parsedAddress.stake().kind() === 0 ? {
            type: "Key",
            hash: parsedAddress.stake().as_pub_key().to_hex()
        } : {
            type: "Script",
            hash: parsedAddress.stake().as_script().to_hex()
        };
        return {
            type: "Base",
            networkId: parsedAddress.to_address().network_id(),
            address: {
                bech32: parsedAddress.to_address().to_bech32(void 0),
                hex: parsedAddress.to_address().to_hex()
            },
            paymentCredential,
            stakeCredential
        };
    } catch (_e) {}
    try {
        const parsedAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EnterpriseAddress"].from_address(addressFromHexOrBech32(address));
        const paymentCredential = parsedAddress.payment().kind() === 0 ? {
            type: "Key",
            hash: parsedAddress.payment().as_pub_key().to_hex()
        } : {
            type: "Script",
            hash: parsedAddress.payment().as_script().to_hex()
        };
        return {
            type: "Enterprise",
            networkId: parsedAddress.to_address().network_id(),
            address: {
                bech32: parsedAddress.to_address().to_bech32(void 0),
                hex: parsedAddress.to_address().to_hex()
            },
            paymentCredential
        };
    } catch (_e) {}
    try {
        const parsedAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointerAddress"].from_address(addressFromHexOrBech32(address));
        const paymentCredential = parsedAddress?.payment().kind() === 0 ? {
            type: "Key",
            hash: parsedAddress.payment().as_pub_key().to_hex()
        } : {
            type: "Script",
            hash: parsedAddress.payment().as_script().to_hex()
        };
        return {
            type: "Pointer",
            networkId: parsedAddress.to_address().network_id(),
            address: {
                bech32: parsedAddress.to_address().to_bech32(void 0),
                hex: parsedAddress.to_address().to_hex()
            },
            paymentCredential
        };
    } catch (_e) {}
    try {
        const parsedAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RewardAddress"].from_address(addressFromHexOrBech32(address));
        const stakeCredential = parsedAddress.payment().kind() === 0 ? {
            type: "Key",
            hash: parsedAddress.payment().as_pub_key().to_hex()
        } : {
            type: "Script",
            hash: parsedAddress.payment().as_script().to_hex()
        };
        return {
            type: "Reward",
            networkId: parsedAddress.to_address().network_id(),
            address: {
                bech32: parsedAddress.to_address().to_bech32(void 0),
                hex: parsedAddress.to_address().to_hex()
            },
            stakeCredential
        };
    } catch (_e) {}
    try {
        const parsedAddress = ((address2)=>{
            try {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ByronAddress"].from_cbor_hex(address2);
            } catch (_e) {
                try {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ByronAddress"].from_base58(address2);
                } catch (_e2) {
                    throw new Error("Could not deserialize address.");
                }
            }
        })(address);
        return {
            type: "Byron",
            networkId: parsedAddress.content().network_id(),
            address: {
                bech32: "",
                hex: parsedAddress.to_address().to_hex()
            }
        };
    } catch (_e) {}
    throw new Error("No address type matched for: " + address);
}
// src/cost_model.ts
function createCostModels(costModels) {
    const costmodel = {
        0: [],
        1: [],
        2: []
    };
    for (const cost of Object.values(costModels.PlutusV1)){
        costmodel[0]?.push(cost);
    }
    for (const cost of Object.values(costModels.PlutusV2)){
        costmodel[1]?.push(cost);
    }
    for (const cost of Object.values(costModels.PlutusV3)){
        costmodel[2]?.push(cost);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CostModels"].from_json(JSON.stringify(costmodel));
}
var PROTOCOL_PARAMETERS_DEFAULT = {
    minFeeA: 44,
    minFeeB: 155381,
    maxTxSize: 16384,
    maxValSize: 5e3,
    keyDeposit: 2000000n,
    poolDeposit: 500000000n,
    drepDeposit: 500000000n,
    govActionDeposit: 100000000000n,
    priceMem: 0.0577,
    priceStep: 721e-7,
    maxTxExMem: 14000000n,
    maxTxExSteps: 10000000000n,
    coinsPerUtxoByte: 4310n,
    collateralPercentage: 150,
    maxCollateralInputs: 3,
    minFeeRefScriptCostPerByte: 15,
    costModels: {
        PlutusV1: {
            "0": 100788,
            "1": 420,
            "2": 1,
            "3": 1,
            "4": 1e3,
            "5": 173,
            "6": 0,
            "7": 1,
            "8": 1e3,
            "9": 59957,
            "10": 4,
            "11": 1,
            "12": 11183,
            "13": 32,
            "14": 201305,
            "15": 8356,
            "16": 4,
            "17": 16e3,
            "18": 100,
            "19": 16e3,
            "20": 100,
            "21": 16e3,
            "22": 100,
            "23": 16e3,
            "24": 100,
            "25": 16e3,
            "26": 100,
            "27": 16e3,
            "28": 100,
            "29": 100,
            "30": 100,
            "31": 16e3,
            "32": 100,
            "33": 94375,
            "34": 32,
            "35": 132994,
            "36": 32,
            "37": 61462,
            "38": 4,
            "39": 72010,
            "40": 178,
            "41": 0,
            "42": 1,
            "43": 22151,
            "44": 32,
            "45": 91189,
            "46": 769,
            "47": 4,
            "48": 2,
            "49": 85848,
            "50": 228465,
            "51": 122,
            "52": 0,
            "53": 1,
            "54": 1,
            "55": 1e3,
            "56": 42921,
            "57": 4,
            "58": 2,
            "59": 24548,
            "60": 29498,
            "61": 38,
            "62": 1,
            "63": 898148,
            "64": 27279,
            "65": 1,
            "66": 51775,
            "67": 558,
            "68": 1,
            "69": 39184,
            "70": 1e3,
            "71": 60594,
            "72": 1,
            "73": 141895,
            "74": 32,
            "75": 83150,
            "76": 32,
            "77": 15299,
            "78": 32,
            "79": 76049,
            "80": 1,
            "81": 13169,
            "82": 4,
            "83": 22100,
            "84": 10,
            "85": 28999,
            "86": 74,
            "87": 1,
            "88": 28999,
            "89": 74,
            "90": 1,
            "91": 43285,
            "92": 552,
            "93": 1,
            "94": 44749,
            "95": 541,
            "96": 1,
            "97": 33852,
            "98": 32,
            "99": 68246,
            "100": 32,
            "101": 72362,
            "102": 32,
            "103": 7243,
            "104": 32,
            "105": 7391,
            "106": 32,
            "107": 11546,
            "108": 32,
            "109": 85848,
            "110": 228465,
            "111": 122,
            "112": 0,
            "113": 1,
            "114": 1,
            "115": 90434,
            "116": 519,
            "117": 0,
            "118": 1,
            "119": 74433,
            "120": 32,
            "121": 85848,
            "122": 228465,
            "123": 122,
            "124": 0,
            "125": 1,
            "126": 1,
            "127": 85848,
            "128": 228465,
            "129": 122,
            "130": 0,
            "131": 1,
            "132": 1,
            "133": 270652,
            "134": 22588,
            "135": 4,
            "136": 1457325,
            "137": 64566,
            "138": 4,
            "139": 20467,
            "140": 1,
            "141": 4,
            "142": 0,
            "143": 141992,
            "144": 32,
            "145": 100788,
            "146": 420,
            "147": 1,
            "148": 1,
            "149": 81663,
            "150": 32,
            "151": 59498,
            "152": 32,
            "153": 20142,
            "154": 32,
            "155": 24588,
            "156": 32,
            "157": 20744,
            "158": 32,
            "159": 25933,
            "160": 32,
            "161": 24623,
            "162": 32,
            "163": 53384111,
            "164": 14333,
            "165": 10
        },
        PlutusV2: {
            "0": 100788,
            "1": 420,
            "2": 1,
            "3": 1,
            "4": 1e3,
            "5": 173,
            "6": 0,
            "7": 1,
            "8": 1e3,
            "9": 59957,
            "10": 4,
            "11": 1,
            "12": 11183,
            "13": 32,
            "14": 201305,
            "15": 8356,
            "16": 4,
            "17": 16e3,
            "18": 100,
            "19": 16e3,
            "20": 100,
            "21": 16e3,
            "22": 100,
            "23": 16e3,
            "24": 100,
            "25": 16e3,
            "26": 100,
            "27": 16e3,
            "28": 100,
            "29": 100,
            "30": 100,
            "31": 16e3,
            "32": 100,
            "33": 94375,
            "34": 32,
            "35": 132994,
            "36": 32,
            "37": 61462,
            "38": 4,
            "39": 72010,
            "40": 178,
            "41": 0,
            "42": 1,
            "43": 22151,
            "44": 32,
            "45": 91189,
            "46": 769,
            "47": 4,
            "48": 2,
            "49": 85848,
            "50": 228465,
            "51": 122,
            "52": 0,
            "53": 1,
            "54": 1,
            "55": 1e3,
            "56": 42921,
            "57": 4,
            "58": 2,
            "59": 24548,
            "60": 29498,
            "61": 38,
            "62": 1,
            "63": 898148,
            "64": 27279,
            "65": 1,
            "66": 51775,
            "67": 558,
            "68": 1,
            "69": 39184,
            "70": 1e3,
            "71": 60594,
            "72": 1,
            "73": 141895,
            "74": 32,
            "75": 83150,
            "76": 32,
            "77": 15299,
            "78": 32,
            "79": 76049,
            "80": 1,
            "81": 13169,
            "82": 4,
            "83": 22100,
            "84": 10,
            "85": 28999,
            "86": 74,
            "87": 1,
            "88": 28999,
            "89": 74,
            "90": 1,
            "91": 43285,
            "92": 552,
            "93": 1,
            "94": 44749,
            "95": 541,
            "96": 1,
            "97": 33852,
            "98": 32,
            "99": 68246,
            "100": 32,
            "101": 72362,
            "102": 32,
            "103": 7243,
            "104": 32,
            "105": 7391,
            "106": 32,
            "107": 11546,
            "108": 32,
            "109": 85848,
            "110": 228465,
            "111": 122,
            "112": 0,
            "113": 1,
            "114": 1,
            "115": 90434,
            "116": 519,
            "117": 0,
            "118": 1,
            "119": 74433,
            "120": 32,
            "121": 85848,
            "122": 228465,
            "123": 122,
            "124": 0,
            "125": 1,
            "126": 1,
            "127": 85848,
            "128": 228465,
            "129": 122,
            "130": 0,
            "131": 1,
            "132": 1,
            "133": 955506,
            "134": 213312,
            "135": 0,
            "136": 2,
            "137": 270652,
            "138": 22588,
            "139": 4,
            "140": 1457325,
            "141": 64566,
            "142": 4,
            "143": 20467,
            "144": 1,
            "145": 4,
            "146": 0,
            "147": 141992,
            "148": 32,
            "149": 100788,
            "150": 420,
            "151": 1,
            "152": 1,
            "153": 81663,
            "154": 32,
            "155": 59498,
            "156": 32,
            "157": 20142,
            "158": 32,
            "159": 24588,
            "160": 32,
            "161": 20744,
            "162": 32,
            "163": 25933,
            "164": 32,
            "165": 24623,
            "166": 32,
            "167": 43053543,
            "168": 10,
            "169": 53384111,
            "170": 14333,
            "171": 10,
            "172": 43574283,
            "173": 26308,
            "174": 10
        },
        PlutusV3: {
            "0": 100788,
            "1": 420,
            "2": 1,
            "3": 1,
            "4": 1e3,
            "5": 173,
            "6": 0,
            "7": 1,
            "8": 1e3,
            "9": 59957,
            "10": 4,
            "11": 1,
            "12": 11183,
            "13": 32,
            "14": 201305,
            "15": 8356,
            "16": 4,
            "17": 16e3,
            "18": 100,
            "19": 16e3,
            "20": 100,
            "21": 16e3,
            "22": 100,
            "23": 16e3,
            "24": 100,
            "25": 16e3,
            "26": 100,
            "27": 16e3,
            "28": 100,
            "29": 100,
            "30": 100,
            "31": 16e3,
            "32": 100,
            "33": 94375,
            "34": 32,
            "35": 132994,
            "36": 32,
            "37": 61462,
            "38": 4,
            "39": 72010,
            "40": 178,
            "41": 0,
            "42": 1,
            "43": 22151,
            "44": 32,
            "45": 91189,
            "46": 769,
            "47": 4,
            "48": 2,
            "49": 85848,
            "50": 123203,
            "51": 7305,
            "52": -900,
            "53": 1716,
            "54": 549,
            "55": 57,
            "56": 85848,
            "57": 0,
            "58": 1,
            "59": 1,
            "60": 1e3,
            "61": 42921,
            "62": 4,
            "63": 2,
            "64": 24548,
            "65": 29498,
            "66": 38,
            "67": 1,
            "68": 898148,
            "69": 27279,
            "70": 1,
            "71": 51775,
            "72": 558,
            "73": 1,
            "74": 39184,
            "75": 1e3,
            "76": 60594,
            "77": 1,
            "78": 141895,
            "79": 32,
            "80": 83150,
            "81": 32,
            "82": 15299,
            "83": 32,
            "84": 76049,
            "85": 1,
            "86": 13169,
            "87": 4,
            "88": 22100,
            "89": 10,
            "90": 28999,
            "91": 74,
            "92": 1,
            "93": 28999,
            "94": 74,
            "95": 1,
            "96": 43285,
            "97": 552,
            "98": 1,
            "99": 44749,
            "100": 541,
            "101": 1,
            "102": 33852,
            "103": 32,
            "104": 68246,
            "105": 32,
            "106": 72362,
            "107": 32,
            "108": 7243,
            "109": 32,
            "110": 7391,
            "111": 32,
            "112": 11546,
            "113": 32,
            "114": 85848,
            "115": 123203,
            "116": 7305,
            "117": -900,
            "118": 1716,
            "119": 549,
            "120": 57,
            "121": 85848,
            "122": 0,
            "123": 1,
            "124": 90434,
            "125": 519,
            "126": 0,
            "127": 1,
            "128": 74433,
            "129": 32,
            "130": 85848,
            "131": 123203,
            "132": 7305,
            "133": -900,
            "134": 1716,
            "135": 549,
            "136": 57,
            "137": 85848,
            "138": 0,
            "139": 1,
            "140": 1,
            "141": 85848,
            "142": 123203,
            "143": 7305,
            "144": -900,
            "145": 1716,
            "146": 549,
            "147": 57,
            "148": 85848,
            "149": 0,
            "150": 1,
            "151": 955506,
            "152": 213312,
            "153": 0,
            "154": 2,
            "155": 270652,
            "156": 22588,
            "157": 4,
            "158": 1457325,
            "159": 64566,
            "160": 4,
            "161": 20467,
            "162": 1,
            "163": 4,
            "164": 0,
            "165": 141992,
            "166": 32,
            "167": 100788,
            "168": 420,
            "169": 1,
            "170": 1,
            "171": 81663,
            "172": 32,
            "173": 59498,
            "174": 32,
            "175": 20142,
            "176": 32,
            "177": 24588,
            "178": 32,
            "179": 20744,
            "180": 32,
            "181": 25933,
            "182": 32,
            "183": 24623,
            "184": 32,
            "185": 43053543,
            "186": 10,
            "187": 53384111,
            "188": 14333,
            "189": 10,
            "190": 43574283,
            "191": 26308,
            "192": 10,
            "193": 16e3,
            "194": 100,
            "195": 16e3,
            "196": 100,
            "197": 962335,
            "198": 18,
            "199": 2780678,
            "200": 6,
            "201": 442008,
            "202": 1,
            "203": 52538055,
            "204": 3756,
            "205": 18,
            "206": 267929,
            "207": 18,
            "208": 76433006,
            "209": 8868,
            "210": 18,
            "211": 52948122,
            "212": 18,
            "213": 1995836,
            "214": 36,
            "215": 3227919,
            "216": 12,
            "217": 901022,
            "218": 1,
            "219": 166917843,
            "220": 4307,
            "221": 36,
            "222": 284546,
            "223": 36,
            "224": 158221314,
            "225": 26549,
            "226": 36,
            "227": 74698472,
            "228": 36,
            "229": 333849714,
            "230": 1,
            "231": 254006273,
            "232": 72,
            "233": 2174038,
            "234": 72,
            "235": 2261318,
            "236": 64571,
            "237": 4,
            "238": 207616,
            "239": 8310,
            "240": 4,
            "241": 1293828,
            "242": 28716,
            "243": 63,
            "244": 0,
            "245": 1,
            "246": 1006041,
            "247": 43623,
            "248": 251,
            "249": 0,
            "250": 1,
            "251": 100181,
            "252": 726,
            "253": 719,
            "254": 0,
            "255": 1,
            "256": 100181,
            "257": 726,
            "258": 719,
            "259": 0,
            "260": 1,
            "261": 100181,
            "262": 726,
            "263": 719,
            "264": 0,
            "265": 1,
            "266": 107878,
            "267": 680,
            "268": 0,
            "269": 1,
            "270": 95336,
            "271": 1,
            "272": 281145,
            "273": 18848,
            "274": 0,
            "275": 1,
            "276": 180194,
            "277": 159,
            "278": 1,
            "279": 1,
            "280": 158519,
            "281": 8942,
            "282": 0,
            "283": 1,
            "284": 159378,
            "285": 8813,
            "286": 0,
            "287": 1,
            "288": 107490,
            "289": 3298,
            "290": 1,
            "291": 106057,
            "292": 655,
            "293": 1,
            "294": 1964219,
            "295": 24520,
            "296": 3
        }
    }
};
;
function credentialToAddress(network, paymentCredential, stakeCredential) {
    if (stakeCredential) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseAddress"].new(networkToId(network), paymentCredential.type === "Key" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ed25519KeyHash"].from_hex(paymentCredential.hash)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_script(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScriptHash"].from_hex(paymentCredential.hash)), stakeCredential.type === "Key" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ed25519KeyHash"].from_hex(stakeCredential.hash)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_script(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScriptHash"].from_hex(stakeCredential.hash))).to_address().to_bech32(void 0);
    } else {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EnterpriseAddress"].new(networkToId(network), paymentCredential.type === "Key" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ed25519KeyHash"].from_hex(paymentCredential.hash)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_script(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScriptHash"].from_hex(paymentCredential.hash))).to_address().to_bech32(void 0);
    }
}
function scriptHashToCredential(scriptHash) {
    return {
        type: "Script",
        hash: scriptHash
    };
}
function keyHashToCredential(keyHash) {
    return {
        type: "Key",
        hash: keyHash
    };
}
function paymentCredentialOf(address) {
    const { paymentCredential } = getAddressDetails(address);
    if (!paymentCredential) {
        throw new Error("The specified address does not contain a payment credential.");
    }
    return paymentCredential;
}
function stakeCredentialOf(rewardAddress) {
    const { stakeCredential } = getAddressDetails(rewardAddress);
    if (!stakeCredential) {
        throw new Error("The specified address does not contain a stake credential.");
    }
    return stakeCredential;
}
var drepIDToCredential = (drepID)=>{
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$core$2f$dist$2f$esm$2f$Cardano$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Cardano$3e$__["Cardano"].DRepID.isValid(drepID)) {
        throw new Error(`Invalid DRep ID: ${drepID}`);
    }
    const drepId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$core$2f$dist$2f$esm$2f$Cardano$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Cardano$3e$__["Cardano"].DRepID(drepID);
    const drepCred = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$core$2f$dist$2f$esm$2f$Cardano$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Cardano$3e$__["Cardano"].DRepID.toCredential(drepId);
    return {
        type: drepCred.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cardano$2d$sdk$2f$core$2f$dist$2f$esm$2f$Cardano$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Cardano$3e$__["Cardano"].CredentialType.KeyHash ? "Key" : "Script",
        hash: drepCred.hash
    };
};
// src/datum.ts
function datumToHash(datum) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hash_plutus_data"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].from_cbor_hex(datum)).to_hex();
}
;
function generatePrivateKey() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrivateKey"].generate_ed25519().to_bech32();
}
function generateSeedPhrase() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bip39$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateMnemonic"])(256);
}
function toPublicKey(privateKey) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrivateKey"].from_bech32(privateKey).to_public().to_bech32();
}
;
;
function toLabel(num) {
    if (num < 0 || num > 65535) {
        throw new Error(`Label ${num} out of range: min label 1 - max label 65535.`);
    }
    const numHex = num.toString(16).padStart(4, "0");
    return "0" + numHex + checksum(numHex) + "0";
}
function fromLabel(label) {
    if (label.length !== 8 || !(label[0] === "0" && label[7] === "0")) {
        return null;
    }
    const numHex = label.slice(1, 5);
    const num = parseInt(numHex, 16);
    const check = label.slice(5, 7);
    return check === checksum(numHex) ? num : null;
}
function checksum(num) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$crc8$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crc8"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(num)).toString(16).padStart(2, "0");
}
;
function unixTimeToSlot(network, unixTime) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$plutus$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unixTimeToEnclosingSlot"])(unixTime, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$plutus$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SLOT_CONFIG_NETWORK"][network]);
}
function slotToUnixTime(network, slot) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$plutus$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["slotToBeginUnixTime"])(slot, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$plutus$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SLOT_CONFIG_NETWORK"][network]);
}
;
;
function valueToAssets(value) {
    const assets = {};
    assets["lovelace"] = value.coin();
    if (value.has_multiassets()) {
        const ma = value.multi_asset();
        const multiAssets = ma.keys();
        for(let j = 0; j < multiAssets.len(); j++){
            const policy = multiAssets.get(j);
            const policyAssets = ma.get_assets(policy);
            const assetNames = policyAssets.keys();
            for(let k = 0; k < assetNames.len(); k++){
                const policyAsset = assetNames.get(k);
                const quantity = policyAssets.get(policyAsset);
                const unit = policy.to_hex() + policyAsset.to_js_value();
                assets[unit] = quantity;
            }
        }
    }
    return assets;
}
function assetsToValue(assets) {
    const multiAsset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MultiAsset"].new();
    const lovelace = assets["lovelace"] ? BigInt(assets["lovelace"]) : 0n;
    const units = Object.keys(assets);
    const policies = Array.from(new Set(units.filter((unit)=>unit !== "lovelace").map((unit)=>unit.slice(0, 56))));
    for (const policy of policies){
        const policyUnits = units.filter((unit)=>unit.slice(0, 56) === policy);
        const assetsValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MapAssetNameToCoin"].new();
        for (const unit of policyUnits){
            assetsValue.insert(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AssetName"].from_hex(unit.slice(56)), BigInt(assets[unit]));
        }
        multiAsset.insert_assets(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScriptHash"].from_hex(policy), assetsValue);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Value"].new(lovelace, multiAsset);
}
function fromUnit(unit) {
    const policyId = unit.slice(0, 56);
    const assetName = unit.slice(56) || null;
    const label = fromLabel(unit.slice(56, 64));
    const name = (()=>{
        const hexName = Number.isInteger(label) ? unit.slice(64) : unit.slice(56);
        return hexName || null;
    })();
    return {
        policyId,
        assetName,
        name,
        label
    };
}
function toUnit(policyId, name, label) {
    const hexLabel = Number.isInteger(label) ? toLabel(label) : "";
    const n = name ? name : "";
    if ((n + hexLabel).length > 64) {
        throw new Error("Asset name size exceeds 32 bytes.");
    }
    if (policyId.length !== 56) {
        throw new Error(`Policy id invalid: ${policyId}.`);
    }
    return policyId + hexLabel + n;
}
function addAssets(...assets) {
    return assets.reduce((a, b)=>{
        for(const k in b){
            if (Object.hasOwn(b, k)) {
                const sum = (a[k] || 0n) + b[k];
                if (sum === 0n) {
                    delete a[k];
                } else {
                    a[k] = sum;
                }
            }
        }
        return a;
    }, {});
}
async function getUniqueTokenName(utxo) {
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(utxo.txHash);
    const data = new Uint8Array([
        utxo.outputIndex,
        ...id
    ]);
    const hash = new Uint8Array(await crypto.subtle.digest("SHA3-256", data));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(hash);
}
var sortCanonical = (assets)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$effect$2f$dist$2f$esm$2f$Function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipe"])(Object.entries(assets).sort(([aUnit], [bUnit])=>{
        const a = fromUnit(aUnit);
        const b = fromUnit(bUnit);
        if (a.policyId.length !== b.policyId.length) return a.policyId.length - b.policyId.length;
        if (a.policyId === b.policyId) {
            const aAssetName = a.assetName || "";
            const bAssetName = b.assetName || "";
            if (aAssetName.length !== bAssetName.length) return aAssetName.length - bAssetName.length;
            return aAssetName.localeCompare(bAssetName);
        }
        return a.policyId.localeCompare(b.policyId);
    }), Object.fromEntries);
// src/utxo.ts
var utxoToTransactionOutput = (utxo)=>{
    return buildOutput(utxo).with_value(assetsToValue(utxo.assets)).build().output();
};
var utxoToTransactionInput = (utxo)=>{
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionInput"].new(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionHash"].from_hex(utxo.txHash), BigInt(utxo.outputIndex));
};
var utxoToCore = (utxo)=>{
    const out = utxoToTransactionOutput(utxo);
    const utxoCore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionUnspentOutput"].new(utxoToTransactionInput(utxo), out);
    return utxoCore;
};
function utxosToCores(utxos) {
    const result = [];
    for (const utxo of utxos){
        result.push(utxoToCore(utxo));
    }
    return result;
}
function coreToUtxo(coreUtxo) {
    const utxo = {
        ...coreToOutRef(coreUtxo.input()),
        ...coreToTxOutput(coreUtxo.output())
    };
    return utxo;
}
function coresToUtxos(utxos) {
    const result = [];
    for(let i = 0; i < utxos.length; i++){
        result.push(coreToUtxo(utxos[i]));
    }
    return result;
}
function coreToOutRef(input) {
    return {
        txHash: input.transaction_id().to_hex(),
        outputIndex: parseInt(input.index().toString())
    };
}
function coresToOutRefs(inputs) {
    const result = [];
    for(let i = 0; i < inputs.length; i++){
        result.push(coreToOutRef(inputs[i]));
    }
    return result;
}
function coreToTxOutput(output) {
    return {
        assets: valueToAssets(output.amount()),
        address: output.address().to_bech32(void 0),
        datumHash: output.datum()?.as_hash()?.to_hex(),
        datum: output.datum()?.as_datum()?.to_cbor_hex(),
        scriptRef: output.script_ref() && fromScriptRef(output.script_ref())
    };
}
function coresToTxOutputs(outputs) {
    let result = [];
    for(let i = 0; i < outputs.length; i++){
        result.push(coreToTxOutput(outputs[i]));
    }
    return result;
}
var selectUTxOs = (utxos, totalAssets, includeUTxOsWithScriptRef = false)=>{
    const selectedUtxos = [];
    let isSelected = false;
    const assetsRequired = new Map(Object.entries(totalAssets));
    for (const utxo of utxos){
        if (!includeUTxOsWithScriptRef && utxo.scriptRef) continue;
        isSelected = false;
        for (const [unit, amount] of assetsRequired){
            if (Object.hasOwn(utxo.assets, unit)) {
                const utxoAmount = utxo.assets[unit];
                if (utxoAmount >= amount) {
                    assetsRequired.delete(unit);
                } else {
                    assetsRequired.set(unit, amount - utxoAmount);
                }
                isSelected = true;
            }
        }
        if (isSelected) {
            selectedUtxos.push(utxo);
        }
        if (assetsRequired.size == 0) {
            break;
        }
    }
    if (assetsRequired.size > 0) return [];
    return selectedUtxos;
};
var sortUTxOs = (utxos, order = "LargestFirst")=>{
    switch(order){
        case "LargestFirst":
            return [
                ...utxos
            ].sort(largestFirst);
        case "SmallestFirst":
            return [
                ...utxos
            ].sort(smallestFirst);
        case "Canonical":
            return [
                ...utxos
            ].sort(canonical);
    }
};
var largestFirst = (a, b)=>{
    const lovelaceA = Number(a.assets["lovelace"]);
    const lovelaceB = Number(b.assets["lovelace"]);
    if (lovelaceA === lovelaceB) {
        return Object.keys(a.assets).length - Object.keys(b.assets).length;
    }
    return -1 * (lovelaceA - lovelaceB);
};
var smallestFirst = (a, b)=>{
    const lovelaceA = Number(a.assets["lovelace"]);
    const lovelaceB = Number(b.assets["lovelace"]);
    if (lovelaceA == lovelaceB) {
        return Object.keys(a.assets).length - Object.keys(b.assets).length;
    }
    return lovelaceA - lovelaceB;
};
var canonical = (a, b)=>{
    if (a.txHash < b.txHash) {
        return -1;
    } else if (a.txHash > b.txHash) {
        return 1;
    } else {
        return a.outputIndex - b.outputIndex;
    }
};
var isEqualUTxO = (self, that)=>self.txHash === that.txHash && self.outputIndex === that.outputIndex;
function getInputIndices(indexInputs, allInputs, sorted = false) {
    const sortedInputs = sorted ? allInputs : sortUTxOs(allInputs, "Canonical");
    const indicesMap = /* @__PURE__ */ new Map();
    sortedInputs.forEach((value, index)=>{
        indicesMap.set(value.txHash + value.outputIndex, BigInt(index));
    });
    return indexInputs.flatMap((value)=>{
        const index = indicesMap.get(value.txHash + value.outputIndex);
        if (index !== void 0) return index;
        else return [];
    });
}
var calculateMinLovelaceFromUTxO = (coinsPerUtxoByte, utxo)=>buildOutput(utxo).with_asset_and_min_required_coin(assetsToValue(utxo.assets).multi_asset(), coinsPerUtxoByte).build().output().amount().coin();
var buildOutput = (utxo)=>{
    const builder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionOutputBuilder"].new().with_address(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Address"].from_bech32(utxo.address));
    return utxo.scriptRef ? buildDatum(utxo, builder).with_reference_script(toScriptRef(utxo.scriptRef)).next() : buildDatum(utxo, builder).next();
};
var buildDatum = (utxo, builder)=>{
    if (utxo.datumHash && utxo.datum) return builder.with_communication_data(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].from_cbor_hex(utxo.datum));
    if (utxo.datum) return builder.with_data(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DatumOption"].new_datum(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlutusData"].from_cbor_hex(utxo.datum)));
    return builder;
};
// src/objects.ts
var stringify = (data)=>JSON.stringify(data, (key, value)=>typeof value === "bigint" ? value.toString() + "n" : value, 2);
// src/redeemer.ts
var toCMLRedeemerTag = (tag)=>{
    switch(tag){
        case "spend":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Spend;
        case "mint":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Mint;
        case "publish":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Cert;
        case "withdraw":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Reward;
        case "vote":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Voting;
        case "propose":
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Proposing;
        default:
            throw new Error(`Exhaustive check failed: Unhandled case ${tag}`);
    }
};
var fromCMLRedeemerTag = (tag)=>{
    switch(tag){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Spend:
            return "spend";
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Mint:
            return "mint";
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Cert:
            return "publish";
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Reward:
            return "withdraw";
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Voting:
            return "vote";
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedeemerTag"].Proposing:
            return "propose";
        default:
            throw new Error(`Exhaustive check failed: Unhandled case ${tag}`);
    }
};
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/@lucid-evolution/uplc/dist/browser/uplc_tx_bg.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__wbg_buffer_609cc3eee51ed158",
    ()=>__wbg_buffer_609cc3eee51ed158,
    "__wbg_length_a446193dc22c12f8",
    ()=>__wbg_length_a446193dc22c12f8,
    "__wbg_new_a12002a7f91c75be",
    ()=>__wbg_new_a12002a7f91c75be,
    "__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a",
    ()=>__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a,
    "__wbg_set_65595bdd868b3009",
    ()=>__wbg_set_65595bdd868b3009,
    "__wbg_set_wasm",
    ()=>__wbg_set_wasm,
    "__wbindgen_init_externref_table",
    ()=>__wbindgen_init_externref_table,
    "__wbindgen_memory",
    ()=>__wbindgen_memory,
    "__wbindgen_string_new",
    ()=>__wbindgen_string_new,
    "__wbindgen_throw",
    ()=>__wbindgen_throw,
    "apply_params_to_script",
    ()=>apply_params_to_script,
    "eval_phase_two_raw",
    ()=>eval_phase_two_raw
]);
let wasm;
function __wbg_set_wasm(val) {
    wasm = val;
}
const lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;
let cachedTextDecoder = new lTextDecoder('utf-8', {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}
function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
let WASM_VECTOR_LEN = 0;
function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
let cachedDataViewMemory0 = null;
function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
}
function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_0.set(idx, obj);
    return idx;
}
function passArrayJsValueToWasm0(array, malloc) {
    const ptr = malloc(array.length * 4, 4) >>> 0;
    for(let i = 0; i < array.length; i++){
        const add = addToExternrefTable0(array[i]);
        getDataViewMemory0().setUint32(ptr + 4 * i, add, true);
    }
    WASM_VECTOR_LEN = array.length;
    return ptr;
}
function takeFromExternrefTable0(idx) {
    const value = wasm.__wbindgen_export_0.get(idx);
    wasm.__externref_table_dealloc(idx);
    return value;
}
function getArrayJsValueFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    const mem = getDataViewMemory0();
    const result = [];
    for(let i = ptr; i < ptr + 4 * len; i += 4){
        result.push(wasm.__wbindgen_export_0.get(mem.getUint32(i, true)));
    }
    wasm.__externref_drop_slice(ptr, len);
    return result;
}
function eval_phase_two_raw(tx_bytes, utxos_bytes_x, utxos_bytes_y, cost_mdls_bytes, initial_budget_n, initial_budget_d, slot_config_x, slot_config_y, slot_config_z) {
    const ptr0 = passArray8ToWasm0(tx_bytes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passArrayJsValueToWasm0(utxos_bytes_x, wasm.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passArrayJsValueToWasm0(utxos_bytes_y, wasm.__wbindgen_malloc);
    const len2 = WASM_VECTOR_LEN;
    const ptr3 = passArray8ToWasm0(cost_mdls_bytes, wasm.__wbindgen_malloc);
    const len3 = WASM_VECTOR_LEN;
    const ret = wasm.eval_phase_two_raw(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, initial_budget_n, initial_budget_d, slot_config_x, slot_config_y, slot_config_z);
    if (ret[3]) {
        throw takeFromExternrefTable0(ret[2]);
    }
    var v5 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v5;
}
function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
function apply_params_to_script(params_bytes, plutus_script_bytes) {
    const ptr0 = passArray8ToWasm0(params_bytes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passArray8ToWasm0(plutus_script_bytes, wasm.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.apply_params_to_script(ptr0, len0, ptr1, len1);
    if (ret[3]) {
        throw takeFromExternrefTable0(ret[2]);
    }
    var v3 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    return v3;
}
function __wbg_buffer_609cc3eee51ed158(arg0) {
    const ret = arg0.buffer;
    return ret;
}
;
function __wbg_length_a446193dc22c12f8(arg0) {
    const ret = arg0.length;
    return ret;
}
;
function __wbg_new_a12002a7f91c75be(arg0) {
    const ret = new Uint8Array(arg0);
    return ret;
}
;
function __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a(arg0, arg1, arg2) {
    const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
    return ret;
}
;
function __wbg_set_65595bdd868b3009(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
}
;
function __wbindgen_init_externref_table() {
    const table = wasm.__wbindgen_export_0;
    const offset = table.grow(4);
    table.set(0, undefined);
    table.set(offset + 0, undefined);
    table.set(offset + 1, null);
    table.set(offset + 2, true);
    table.set(offset + 3, false);
    ;
}
;
function __wbindgen_memory() {
    const ret = wasm.memory;
    return ret;
}
;
function __wbindgen_string_new(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return ret;
}
;
function __wbindgen_throw(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
}
;
}),
"[project]/node_modules/@lucid-evolution/uplc/dist/browser/uplc_tx_bg.wasm [app-client] (wasm raw)", ((__turbopack_context__) => {

__turbopack_context__.v("static/chunks/node_modules_@lucid-evolution_uplc_dist_browser_uplc_tx_bg_11d1fd06.wasm");}),
"[project]/node_modules/@lucid-evolution/uplc/dist/browser/uplc_tx_bg.wasm [app-client] (wasm module)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "__externref_drop_slice",
    ()=>__externref_drop_slice,
    "__externref_table_alloc",
    ()=>__externref_table_alloc,
    "__externref_table_dealloc",
    ()=>__externref_table_dealloc,
    "__wbindgen_export_0",
    ()=>__wbindgen_export_0,
    "__wbindgen_free",
    ()=>__wbindgen_free,
    "__wbindgen_malloc",
    ()=>__wbindgen_malloc,
    "__wbindgen_start",
    ()=>__wbindgen_start,
    "apply_params_to_script",
    ()=>apply_params_to_script,
    "eval_phase_two_raw",
    ()=>eval_phase_two_raw,
    "memory",
    ()=>memory
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/uplc/dist/browser/uplc_tx_bg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$wasm__$5b$app$2d$client$5d$__$28$wasm__raw$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/uplc/dist/browser/uplc_tx_bg.wasm [app-client] (wasm raw)");
;
;
const { memory, eval_phase_two_raw, apply_params_to_script, __wbindgen_export_0, __wbindgen_malloc, __externref_table_alloc, __externref_table_dealloc, __externref_drop_slice, __wbindgen_free, __wbindgen_start } = await /*TURBOPACK member replacement*/ __turbopack_context__.w(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$wasm__$5b$app$2d$client$5d$__$28$wasm__raw$29$__["default"], ()=>wasm_da8cd6cc9967fc81, {
    "./uplc_tx_bg.js": {
        "__wbindgen_string_new": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbindgen_string_new"],
        "__wbindgen_memory": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbindgen_memory"],
        "__wbg_buffer_609cc3eee51ed158": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbg_buffer_609cc3eee51ed158"],
        "__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a"],
        "__wbg_new_a12002a7f91c75be": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbg_new_a12002a7f91c75be"],
        "__wbg_length_a446193dc22c12f8": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbg_length_a446193dc22c12f8"],
        "__wbg_set_65595bdd868b3009": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbg_set_65595bdd868b3009"],
        "__wbindgen_throw": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbindgen_throw"],
        "__wbindgen_init_externref_table": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbindgen_init_externref_table"]
    }
});
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/node_modules/@lucid-evolution/uplc/dist/browser/uplc_tx.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$wasm__$5b$app$2d$client$5d$__$28$wasm__module$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/uplc/dist/browser/uplc_tx_bg.wasm [app-client] (wasm module)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/uplc/dist/browser/uplc_tx_bg.js [app-client] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$wasm__$5b$app$2d$client$5d$__$28$wasm__module$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$wasm__$5b$app$2d$client$5d$__$28$wasm__module$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__wbg_set_wasm"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$wasm__$5b$app$2d$client$5d$__$28$wasm__module$29$__);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$uplc$2f$dist$2f$browser$2f$uplc_tx_bg$2e$wasm__$5b$app$2d$client$5d$__$28$wasm__module$29$__.__wbindgen_start();
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/@lucid-evolution/sign_data/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

// src/sign_data.ts
__turbopack_context__.s([
    "signData",
    ()=>signData,
    "verifyData",
    ()=>verifyData
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/core-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@anastasia-labs/cardano-multiplatform-lib-browser/cardano_multiplatform_lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@anastasia-labs/cardano-multiplatform-lib-browser/cardano_multiplatform_lib_bg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@emurgo/cardano-message-signing-browser/cardano_message_signing.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@emurgo/cardano-message-signing-browser/cardano_message_signing_bg.js [app-client] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
function signData(addressHex, payload, privateKey) {
    const protectedHeaders = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HeaderMap"].new();
    protectedHeaders.set_algorithm_id(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Label"].from_algorithm_id(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AlgorithmId"].EdDSA));
    protectedHeaders.set_header(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Label"].new_text("address"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CBORValue"].new_bytes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(addressHex)));
    const protectedSerialized = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ProtectedHeaderMap"].new(protectedHeaders);
    const unprotectedHeaders = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HeaderMap"].new();
    const headers = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Headers"].new(protectedSerialized, unprotectedHeaders);
    const builder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COSESign1Builder"].new(headers, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(payload), false);
    const toSign = builder.make_data_to_sign().to_bytes();
    const priv = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrivateKey"].from_bech32(privateKey);
    const signedSigStruc = priv.sign(toSign).to_raw_bytes();
    const coseSign1 = builder.build(signedSigStruc);
    const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COSEKey"].new(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Label"].from_key_type(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeyType"].OKP));
    key.set_algorithm_id(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Label"].from_algorithm_id(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AlgorithmId"].EdDSA));
    key.set_header(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Label"].new_int(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Int"].new_negative(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNum"].from_str("1"))), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CBORValue"].new_int(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Int"].new_i32(6)));
    key.set_header(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Label"].new_int(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Int"].new_negative(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNum"].from_str("2"))), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CBORValue"].new_bytes(priv.to_public().to_raw_bytes()));
    return {
        signature: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(coseSign1.to_bytes()),
        key: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(key.to_bytes())
    };
}
function verifyData(addressHex, keyHash, payload, signedMessage) {
    const cose1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COSESign1"].from_bytes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(signedMessage.signature));
    const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COSEKey"].from_bytes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(signedMessage.key));
    const protectedHeaders = cose1.headers().protected().deserialized_headers();
    const cose1Address = (()=>{
        try {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(protectedHeaders.header(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Label"].new_text("address"))?.as_bytes());
        } catch (_e) {
            throw new Error("No address found in signature.");
        }
    })();
    const cose1AlgorithmId = (()=>{
        try {
            const int = protectedHeaders.algorithm_id()?.as_int();
            if (int?.is_positive()) return parseInt(int.as_positive()?.to_str());
            return parseInt(int?.as_negative()?.to_str());
        } catch (_e) {
            throw new Error("Failed to retrieve Algorithm Id.");
        }
    })();
    const keyAlgorithmId = (()=>{
        try {
            const int = key.algorithm_id()?.as_int();
            if (int?.is_positive()) return parseInt(int.as_positive()?.to_str());
            return parseInt(int?.as_negative()?.to_str());
        } catch (_e) {
            throw new Error("Failed to retrieve Algorithm Id.");
        }
    })();
    const keyCurve = (()=>{
        try {
            const int = key.header(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Label"].new_int(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Int"].new_negative(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNum"].from_str("1"))))?.as_int();
            if (int?.is_positive()) return parseInt(int.as_positive()?.to_str());
            return parseInt(int?.as_negative()?.to_str());
        } catch (_e) {
            throw new Error("Failed to retrieve Curve.");
        }
    })();
    const keyType = (()=>{
        try {
            const int = key.key_type().as_int();
            if (int?.is_positive()) return parseInt(int.as_positive()?.to_str());
            return parseInt(int?.as_negative()?.to_str());
        } catch (_e) {
            throw new Error("Failed to retrieve Key Type.");
        }
    })();
    const publicKey = (()=>{
        try {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PublicKey"].from_bytes(key.header(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Label"].new_int(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Int"].new_negative(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNum"].from_str("2"))))?.as_bytes());
        } catch (_e) {
            throw new Error("No public key found.");
        }
    })();
    const cose1Payload = (()=>{
        try {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(cose1.payload());
        } catch (_e) {
            throw new Error("No payload found.");
        }
    })();
    const signature = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ed25519Signature"].from_raw_bytes(cose1.signature());
    const data = cose1.signed_data(void 0, void 0).to_bytes();
    if (cose1Address !== addressHex) return false;
    if (keyHash !== publicKey.hash().to_hex()) return false;
    if (cose1AlgorithmId !== keyAlgorithmId && cose1AlgorithmId !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$emurgo$2f$cardano$2d$message$2d$signing$2d$browser$2f$cardano_message_signing_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AlgorithmId"].EdDSA) {
        return false;
    }
    if (keyCurve !== 6) return false;
    if (keyType !== 1) return false;
    if (cose1Payload !== payload) return false;
    return publicKey.verify(data, signature);
}
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/@lucid-evolution/wallet/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

// src/wallet.ts
__turbopack_context__.s([
    "discoverOwnUsedTxKeyHashes",
    ()=>discoverOwnUsedTxKeyHashes,
    "makeWalletFromAPI",
    ()=>makeWalletFromAPI,
    "makeWalletFromAddress",
    ()=>makeWalletFromAddress,
    "makeWalletFromPrivateKey",
    ()=>makeWalletFromPrivateKey,
    "makeWalletFromSeed",
    ()=>makeWalletFromSeed,
    "walletFromSeed",
    ()=>walletFromSeed
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/core-utils/dist/index.js [app-client] (ecmascript)");
// src/core.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@anastasia-labs/cardano-multiplatform-lib-browser/cardano_multiplatform_lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@anastasia-labs/cardano-multiplatform-lib-browser/cardano_multiplatform_lib_bg.js [app-client] (ecmascript)");
// src/wallet.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bip39$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bip39/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$sign_data$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lucid-evolution/sign_data/dist/index.js [app-client] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$sign_data$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$sign_data$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
;
function walletFromSeed(seed, options = {}) {
    const { addressType = "Base", accountIndex = 0, network = "Mainnet" } = options;
    function harden(num) {
        if (typeof num !== "number") throw new Error("Type number required here!");
        return 2147483648 + num;
    }
    const entropy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bip39$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mnemonicToEntropy"])(seed);
    const rootKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bip32PrivateKey"].from_bip39_entropy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(entropy), options?.password ? new TextEncoder().encode(options.password) : new Uint8Array());
    const accountKey = rootKey.derive(harden(1852)).derive(harden(1815)).derive(harden(accountIndex));
    rootKey.free();
    const paymentKey = accountKey.derive(0).derive(0).to_raw_key();
    const stakeKey = accountKey.derive(2).derive(0).to_raw_key();
    const paymentKeyHash = paymentKey.to_public().hash();
    const stakeKeyHash = stakeKey.to_public().hash();
    const networkId = network === "Mainnet" ? 1 : 0;
    const address = addressType === "Base" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseAddress"].new(networkId, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(paymentKeyHash), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(stakeKeyHash)).to_address().to_bech32(void 0) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EnterpriseAddress"].new(networkId, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(paymentKeyHash)).to_address().to_bech32(void 0);
    const rewardAddress = addressType === "Base" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RewardAddress"].new(networkId, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(stakeKeyHash)).to_address().to_bech32(void 0) : null;
    return {
        address,
        rewardAddress,
        paymentKey: paymentKey.to_bech32(),
        stakeKey: addressType === "Base" ? stakeKey.to_bech32() : null
    };
}
function discoverOwnUsedTxKeyHashes(tx, ownKeyHashes, ownUtxos) {
    const usedKeyHashes = [];
    const inputs = tx.body().inputs();
    for(let i = 0; i < inputs.len(); i++){
        const input = inputs.get(i);
        const txHash = input.transaction_id().to_hex();
        const outputIndex = Number(input.index());
        const utxo = ownUtxos.find((utxo2)=>utxo2.txHash === txHash && utxo2.outputIndex === outputIndex);
        if (utxo) {
            const { paymentCredential } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddressDetails"])(utxo.address);
            usedKeyHashes.push(paymentCredential?.hash);
        }
    }
    const txBody = tx.body();
    function keyHashFromCert(txBody2) {
        const certs = txBody2.certs();
        if (!certs) return;
        for(let i = 0; i < certs.len(); i++){
            const cert = certs.get(i);
            switch(cert.kind()){
                case 0:
                    break;
                case 1:
                    {
                        const credential = cert.as_stake_deregistration()?.stake_credential();
                        switch(credential?.kind()){
                            case 0:
                                usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                                break;
                            case 1:
                                usedKeyHashes.push(credential.as_script()?.to_hex());
                                break;
                        }
                        break;
                    }
                case 2:
                    {
                        const credential = cert.as_stake_delegation()?.stake_credential();
                        if (credential?.kind() === 0) {
                            const keyHash = credential.as_pub_key()?.to_hex();
                            usedKeyHashes.push(keyHash);
                        }
                        break;
                    }
                case 3:
                    {
                        const poolParams = cert.as_pool_registration()?.pool_params();
                        const owners = poolParams?.pool_owners();
                        if (!owners) break;
                        for(let i2 = 0; i2 < owners.len(); i2++){
                            const keyHash = owners.get(i2).to_hex();
                            usedKeyHashes.push(keyHash);
                        }
                        const operator = poolParams.operator().to_hex();
                        usedKeyHashes.push(operator);
                        break;
                    }
                case 4:
                    {
                        const operator = cert.as_pool_retirement()?.pool().to_hex();
                        usedKeyHashes.push(operator);
                        break;
                    }
                case 6:
                    {
                        const credential = cert.as_unreg_cert()?.stake_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 7:
                    {
                        const credential = cert.as_vote_deleg_cert()?.stake_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 8:
                    {
                        const credential = cert.as_stake_vote_deleg_cert()?.stake_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 9:
                    {
                        const credential = cert.as_stake_reg_deleg_cert()?.stake_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 10:
                    {
                        const credential = cert.as_vote_reg_deleg_cert()?.stake_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 11:
                    {
                        const credential = cert.as_stake_vote_reg_deleg_cert()?.stake_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 12:
                    {
                        const credential = cert.as_auth_committee_hot_cert()?.committee_cold_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 13:
                    {
                        const credential = cert.as_resign_committee_cold_cert()?.committee_cold_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 14:
                    {
                        const credential = cert.as_reg_drep_cert()?.drep_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 15:
                    {
                        const credential = cert.as_unreg_drep_cert()?.drep_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                case 16:
                    {
                        const credential = cert.as_update_drep_cert()?.drep_credential();
                        if (credential) {
                            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                        }
                        break;
                    }
                default:
                    break;
            }
        }
    }
    if (txBody.certs()) keyHashFromCert(txBody);
    const withdrawals = txBody.withdrawals();
    function keyHashFromWithdrawal(withdrawals2) {
        const rewardAddresses = withdrawals2.keys();
        for(let i = 0; i < rewardAddresses.len(); i++){
            const credential = rewardAddresses.get(i).payment();
            switch(credential.kind()){
                case 0:
                    usedKeyHashes.push(credential.as_pub_key()?.to_hex());
                    break;
                case 1:
                    usedKeyHashes.push(credential.as_script()?.to_hex());
                    break;
            }
        }
    }
    if (withdrawals) keyHashFromWithdrawal(withdrawals);
    const scripts = tx.witness_set().native_scripts();
    function keyHashFromScript(scripts2) {
        for(let i = 0; i < scripts2.len(); i++){
            const script = scripts2.get(i);
            if (script.kind() === 0) {
                const keyHash = script.as_script_pubkey()?.ed25519_key_hash().to_hex();
                usedKeyHashes.push(keyHash);
            }
            if (script.kind() === 1) {
                keyHashFromScript(script.as_script_all().native_scripts());
                return;
            }
            if (script.kind() === 2) {
                keyHashFromScript(script.as_script_any().native_scripts());
                return;
            }
            if (script.kind() === 3) {
                keyHashFromScript(script.as_script_n_of_k().native_scripts());
                return;
            }
        }
    }
    if (scripts) keyHashFromScript(scripts);
    const requiredSigners = txBody.required_signers();
    if (requiredSigners) {
        for(let i = 0; i < requiredSigners.len(); i++){
            usedKeyHashes.push(requiredSigners.get(i).to_hex());
        }
    }
    const collateral = txBody.collateral_inputs();
    if (collateral) {
        for(let i = 0; i < collateral.len(); i++){
            const input = collateral.get(i);
            const txHash = input.transaction_id().to_hex();
            const outputIndex = Number(input.index());
            const utxo = ownUtxos.find((utxo2)=>utxo2.txHash === txHash && utxo2.outputIndex === outputIndex);
            if (utxo) {
                const { paymentCredential } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddressDetails"])(utxo.address);
                usedKeyHashes.push(paymentCredential?.hash);
            }
        }
    }
    return usedKeyHashes.filter((k)=>ownKeyHashes.includes(k));
}
;
;
;
var makeWalletFromSeed = (provider, network, seed, options)=>{
    const config = {
        overriddenUTxOs: []
    };
    const { address, rewardAddress, paymentKey, stakeKey } = walletFromSeed(seed, {
        addressType: options?.addressType || "Base",
        accountIndex: options?.accountIndex || 0,
        password: options?.password,
        network
    });
    const paymentKeyHash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrivateKey"].from_bech32(paymentKey).to_public().hash().to_hex();
    const stakeKeyHash = stakeKey ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrivateKey"].from_bech32(stakeKey).to_public().hash().to_hex() : "";
    const privKeyHashMap = {
        [paymentKeyHash]: paymentKey,
        [stakeKeyHash]: stakeKey
    };
    return {
        overrideUTxOs: (utxos)=>config.overriddenUTxOs = utxos,
        address: async ()=>address,
        rewardAddress: async ()=>rewardAddress || null,
        getUtxos: async ()=>config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : provider.getUtxos(address),
        getUtxosCore: async ()=>{
            const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : await provider.getUtxos(address);
            const coreUtxos = [];
            for (const utxo of utxos){
                coreUtxos.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utxoToCore"])(utxo));
            }
            return coreUtxos;
        },
        getDelegation: async ()=>{
            return rewardAddress ? await provider.getDelegation(rewardAddress) : {
                poolId: null,
                rewards: 0n
            };
        },
        signTx: async (tx)=>{
            const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : await provider.getUtxos(address);
            const ownKeyHashes = [
                paymentKeyHash,
                stakeKeyHash
            ];
            const usedKeyHashes = discoverOwnUsedTxKeyHashes(tx, ownKeyHashes, utxos);
            const txWitnessSetBuilder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionWitnessSetBuilder"].new();
            for (const keyHash of usedKeyHashes){
                const priv = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrivateKey"].from_bech32(privKeyHashMap[keyHash]);
                const witness = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["make_vkey_witness"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hash_transaction"](tx.body()), priv);
                txWitnessSetBuilder.add_vkey(witness);
            }
            return txWitnessSetBuilder.build();
        },
        signMessage: async (address2, payload)=>{
            const { paymentCredential, stakeCredential, address: { hex: hexAddress } } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddressDetails"])(address2);
            const keyHash = paymentCredential?.hash || stakeCredential?.hash;
            const privateKey = privKeyHashMap[keyHash];
            if (!privateKey) {
                throw new Error(`Cannot sign message for address: ${address2}.`);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$sign_data$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signData"])(hexAddress, payload, privateKey);
        },
        submitTx: async (tx)=>provider.submitTx(tx)
    };
};
var makeWalletFromPrivateKey = (provider, network, privateKey)=>{
    const priv = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrivateKey"].from_bech32(privateKey);
    const pubKeyHash = priv.to_public().hash();
    const address = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EnterpriseAddress"].new(network === "Mainnet" ? 1 : 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Credential"].new_pub_key(pubKeyHash)).to_address().to_bech32(void 0);
    const config = {
        overriddenUTxOs: []
    };
    return {
        overrideUTxOs: (utxos)=>config.overriddenUTxOs = utxos,
        address: async ()=>address,
        rewardAddress: async ()=>null,
        getUtxos: async ()=>config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : provider.getUtxos(address),
        getUtxosCore: async ()=>{
            const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : await provider.getUtxos(address);
            const coreUtxos = [];
            for (const utxo of utxos){
                coreUtxos.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utxoToCore"])(utxo));
            }
            return coreUtxos;
        },
        getDelegation: async ()=>{
            return {
                poolId: null,
                rewards: 0n
            };
        },
        signTx: async (tx)=>{
            const witness = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["make_vkey_witness"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hash_transaction"](tx.body()), priv);
            const txWitnessSetBuilder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionWitnessSetBuilder"].new();
            txWitnessSetBuilder.add_vkey(witness);
            return txWitnessSetBuilder.build();
        },
        signMessage: async (address2, payload)=>{
            const { paymentCredential, address: { hex: hexAddress } } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddressDetails"])(address2);
            const keyHash = paymentCredential?.hash;
            const originalKeyHash = pubKeyHash.to_hex();
            if (!keyHash || keyHash !== originalKeyHash) {
                throw new Error(`Cannot sign message for address: ${address2}.`);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$sign_data$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signData"])(hexAddress, payload, privateKey);
        },
        submitTx: async (tx)=>{
            return await provider.submitTx(tx);
        }
    };
};
var makeWalletFromAPI = (provider, api)=>{
    const config = {
        overriddenUTxOs: []
    };
    const getAddressHex = async ()=>{
        const [addressHex] = await api.getUsedAddresses();
        if (addressHex) return addressHex;
        const [unusedAddressHex] = await api.getUnusedAddresses();
        return unusedAddressHex;
    };
    const getRewardAddress = async ()=>{
        const [rewardAddressHex] = await api.getRewardAddresses();
        const rewardAddress = rewardAddressHex ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RewardAddress"].from_address(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Address"].from_hex(rewardAddressHex)).to_address().to_bech32(void 0) : null;
        return rewardAddress;
    };
    return {
        overrideUTxOs: (utxos)=>config.overriddenUTxOs = utxos,
        address: async ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Address"].from_hex(await getAddressHex()).to_bech32(void 0),
        rewardAddress: async ()=>getRewardAddress(),
        getUtxos: async ()=>{
            const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : (await api.getUtxos() || []).map((utxo)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coreToUtxo"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionUnspentOutput"].from_cbor_bytes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(utxo))));
            return utxos;
        },
        getUtxosCore: async ()=>{
            const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utxoToCore"]) : (await api.getUtxos() || []).map((utxo)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionUnspentOutput"].from_cbor_hex(utxo));
            return utxos;
        },
        getDelegation: async ()=>{
            const rewardAddr = await getRewardAddress();
            return rewardAddr ? await provider.getDelegation(rewardAddr) : {
                poolId: null,
                rewards: 0n
            };
        },
        signTx: async (tx)=>{
            const witnessSet = await api.signTx((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(tx.to_cbor_bytes()), true);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionWitnessSet"].from_cbor_hex(witnessSet);
        },
        signMessage: async (address, payload)=>{
            const hexAddress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$core$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anastasia$2d$labs$2f$cardano$2d$multiplatform$2d$lib$2d$browser$2f$cardano_multiplatform_lib_bg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Address"].from_bech32(address).to_raw_bytes());
            return await api.signData(hexAddress, payload);
        },
        submitTx: async (tx)=>api.submitTx(tx)
    };
};
var makeWalletFromAddress = (provider, network, address, utxos)=>{
    const { stakeCredential } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddressDetails"])(address);
    const rewardAddress = stakeCredential ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["credentialToRewardAddress"])(network, stakeCredential) : null;
    const config = {
        overriddenUTxOs: utxos
    };
    return {
        overrideUTxOs: (utxos2)=>config.overriddenUTxOs = utxos2,
        address: async ()=>address,
        rewardAddress: async ()=>rewardAddress,
        getUtxos: async ()=>config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : provider.getUtxos(address),
        getUtxosCore: async ()=>{
            const utxos2 = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : await provider.getUtxos(address);
            const coreUtxos = [];
            for (const utxo of utxos2){
                coreUtxos.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lucid$2d$evolution$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utxoToCore"])(utxo));
            }
            return coreUtxos;
        },
        getDelegation: async ()=>rewardAddress ? provider.getDelegation(rewardAddress) : {
                poolId: null,
                rewards: 0n
            },
        signTx: async (_tx)=>{
            throw new Error("Not implemented");
        },
        signMessage: async (_address, _payload)=>{
            throw new Error("Not implemented");
        },
        submitTx: async (tx)=>provider.submitTx(tx)
    };
};
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/@lucid-evolution/core-types/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
}),
"[project]/node_modules/styled-jsx/dist/index/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/next/dist/compiled/client-only/index.js [app-client] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
        'default': e
    };
}
var React__default = /*#__PURE__*/ _interopDefaultLegacy(React);
/*
Based on Glamor's sheet
https://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js
*/ function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var isProd = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env && ("TURBOPACK compile-time value", "development") === "production";
var isString = function(o) {
    return Object.prototype.toString.call(o) === "[object String]";
};
var StyleSheet = /*#__PURE__*/ function() {
    function StyleSheet(param) {
        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? "stylesheet" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;
        invariant$1(isString(name), "`name` must be a string");
        this._name = name;
        this._deletedRulePlaceholder = "#" + name + "-deleted-rule____{}";
        invariant$1(typeof optimizeForSpeed === "boolean", "`optimizeForSpeed` must be a boolean");
        this._optimizeForSpeed = optimizeForSpeed;
        this._serverSheet = undefined;
        this._tags = [];
        this._injected = false;
        this._rulesCount = 0;
        var node = typeof window !== "undefined" && document.querySelector('meta[property="csp-nonce"]');
        this._nonce = node ? node.getAttribute("content") : null;
    }
    var _proto = StyleSheet.prototype;
    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {
        invariant$1(typeof bool === "boolean", "`setOptimizeForSpeed` accepts a boolean");
        invariant$1(this._rulesCount === 0, "optimizeForSpeed cannot be when rules have already been inserted");
        this.flush();
        this._optimizeForSpeed = bool;
        this.inject();
    };
    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {
        return this._optimizeForSpeed;
    };
    _proto.inject = function inject() {
        var _this = this;
        invariant$1(!this._injected, "sheet already injected");
        this._injected = true;
        if (typeof window !== "undefined" && this._optimizeForSpeed) {
            this._tags[0] = this.makeStyleTag(this._name);
            this._optimizeForSpeed = "insertRule" in this.getSheet();
            if (!this._optimizeForSpeed) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.");
                }
                this.flush();
                this._injected = true;
            }
            return;
        }
        this._serverSheet = {
            cssRules: [],
            insertRule: function(rule, index) {
                if (typeof index === "number") {
                    _this._serverSheet.cssRules[index] = {
                        cssText: rule
                    };
                } else {
                    _this._serverSheet.cssRules.push({
                        cssText: rule
                    });
                }
                return index;
            },
            deleteRule: function(index) {
                _this._serverSheet.cssRules[index] = null;
            }
        };
    };
    _proto.getSheetForTag = function getSheetForTag(tag) {
        if (tag.sheet) {
            return tag.sheet;
        }
        // this weirdness brought to you by firefox
        for(var i = 0; i < document.styleSheets.length; i++){
            if (document.styleSheets[i].ownerNode === tag) {
                return document.styleSheets[i];
            }
        }
    };
    _proto.getSheet = function getSheet() {
        return this.getSheetForTag(this._tags[this._tags.length - 1]);
    };
    _proto.insertRule = function insertRule(rule, index) {
        invariant$1(isString(rule), "`insertRule` accepts only strings");
        if (typeof window === "undefined") {
            if (typeof index !== "number") {
                index = this._serverSheet.cssRules.length;
            }
            this._serverSheet.insertRule(rule, index);
            return this._rulesCount++;
        }
        if (this._optimizeForSpeed) {
            var sheet = this.getSheet();
            if (typeof index !== "number") {
                index = sheet.cssRules.length;
            }
            // this weirdness for perf, and chrome's weird bug
            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule
            try {
                sheet.insertRule(rule, index);
            } catch (error) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("StyleSheet: illegal rule: \n\n" + rule + "\n\nSee https://stackoverflow.com/q/20007992 for more info");
                }
                return -1;
            }
        } else {
            var insertionPoint = this._tags[index];
            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));
        }
        return this._rulesCount++;
    };
    _proto.replaceRule = function replaceRule(index, rule) {
        if (this._optimizeForSpeed || typeof window === "undefined") {
            var sheet = typeof window !== "undefined" ? this.getSheet() : this._serverSheet;
            if (!rule.trim()) {
                rule = this._deletedRulePlaceholder;
            }
            if (!sheet.cssRules[index]) {
                // @TBD Should we throw an error?
                return index;
            }
            sheet.deleteRule(index);
            try {
                sheet.insertRule(rule, index);
            } catch (error) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("StyleSheet: illegal rule: \n\n" + rule + "\n\nSee https://stackoverflow.com/q/20007992 for more info");
                }
                // In order to preserve the indices we insert a deleteRulePlaceholder
                sheet.insertRule(this._deletedRulePlaceholder, index);
            }
        } else {
            var tag = this._tags[index];
            invariant$1(tag, "old rule at index `" + index + "` not found");
            tag.textContent = rule;
        }
        return index;
    };
    _proto.deleteRule = function deleteRule(index) {
        if (typeof window === "undefined") {
            this._serverSheet.deleteRule(index);
            return;
        }
        if (this._optimizeForSpeed) {
            this.replaceRule(index, "");
        } else {
            var tag = this._tags[index];
            invariant$1(tag, "rule at index `" + index + "` not found");
            tag.parentNode.removeChild(tag);
            this._tags[index] = null;
        }
    };
    _proto.flush = function flush() {
        this._injected = false;
        this._rulesCount = 0;
        if (typeof window !== "undefined") {
            this._tags.forEach(function(tag) {
                return tag && tag.parentNode.removeChild(tag);
            });
            this._tags = [];
        } else {
            // simpler on server
            this._serverSheet.cssRules = [];
        }
    };
    _proto.cssRules = function cssRules() {
        var _this = this;
        if (typeof window === "undefined") {
            return this._serverSheet.cssRules;
        }
        return this._tags.reduce(function(rules, tag) {
            if (tag) {
                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {
                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;
                }));
            } else {
                rules.push(null);
            }
            return rules;
        }, []);
    };
    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {
        if (cssString) {
            invariant$1(isString(cssString), "makeStyleTag accepts only strings as second parameter");
        }
        var tag = document.createElement("style");
        if (this._nonce) tag.setAttribute("nonce", this._nonce);
        tag.type = "text/css";
        tag.setAttribute("data-" + name, "");
        if (cssString) {
            tag.appendChild(document.createTextNode(cssString));
        }
        var head = document.head || document.getElementsByTagName("head")[0];
        if (relativeToTag) {
            head.insertBefore(tag, relativeToTag);
        } else {
            head.appendChild(tag);
        }
        return tag;
    };
    _createClass(StyleSheet, [
        {
            key: "length",
            get: function get() {
                return this._rulesCount;
            }
        }
    ]);
    return StyleSheet;
}();
function invariant$1(condition, message) {
    if (!condition) {
        throw new Error("StyleSheet: " + message + ".");
    }
}
function hash(str) {
    var _$hash = 5381, i = str.length;
    while(i){
        _$hash = _$hash * 33 ^ str.charCodeAt(--i);
    }
    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;
}
var stringHash = hash;
var sanitize = function(rule) {
    return rule.replace(/\/style/gi, "\\/style");
};
var cache = {};
/**
 * computeId
 *
 * Compute and memoize a jsx id from a basedId and optionally props.
 */ function computeId(baseId, props) {
    if (!props) {
        return "jsx-" + baseId;
    }
    var propsToString = String(props);
    var key = baseId + propsToString;
    if (!cache[key]) {
        cache[key] = "jsx-" + stringHash(baseId + "-" + propsToString);
    }
    return cache[key];
}
/**
 * computeSelector
 *
 * Compute and memoize dynamic selectors.
 */ function computeSelector(id, css) {
    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;
    // Sanitize SSR-ed CSS.
    // Client side code doesn't need to be sanitized since we use
    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).
    if (typeof window === "undefined") {
        css = sanitize(css);
    }
    var idcss = id + css;
    if (!cache[idcss]) {
        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);
    }
    return cache[idcss];
}
function mapRulesToStyle(cssRules, options) {
    if (options === void 0) options = {};
    return cssRules.map(function(args) {
        var id = args[0];
        var css = args[1];
        return /*#__PURE__*/ React__default["default"].createElement("style", {
            id: "__" + id,
            // Avoid warnings upon render with a key
            key: "__" + id,
            nonce: options.nonce ? options.nonce : undefined,
            dangerouslySetInnerHTML: {
                __html: css
            }
        });
    });
}
var StyleSheetRegistry = /*#__PURE__*/ function() {
    function StyleSheetRegistry(param) {
        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;
        this._sheet = styleSheet || new StyleSheet({
            name: "styled-jsx",
            optimizeForSpeed: optimizeForSpeed
        });
        this._sheet.inject();
        if (styleSheet && typeof optimizeForSpeed === "boolean") {
            this._sheet.setOptimizeForSpeed(optimizeForSpeed);
            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();
        }
        this._fromServer = undefined;
        this._indices = {};
        this._instancesCounts = {};
    }
    var _proto = StyleSheetRegistry.prototype;
    _proto.add = function add(props) {
        var _this = this;
        if (undefined === this._optimizeForSpeed) {
            this._optimizeForSpeed = Array.isArray(props.children);
            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);
            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();
        }
        if (typeof window !== "undefined" && !this._fromServer) {
            this._fromServer = this.selectFromServer();
            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {
                acc[tagName] = 0;
                return acc;
            }, {});
        }
        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;
        // Deduping: just increase the instances count.
        if (styleId in this._instancesCounts) {
            this._instancesCounts[styleId] += 1;
            return;
        }
        var indices = rules.map(function(rule) {
            return _this._sheet.insertRule(rule);
        }) // Filter out invalid rules
        .filter(function(index) {
            return index !== -1;
        });
        this._indices[styleId] = indices;
        this._instancesCounts[styleId] = 1;
    };
    _proto.remove = function remove(props) {
        var _this = this;
        var styleId = this.getIdAndRules(props).styleId;
        invariant(styleId in this._instancesCounts, "styleId: `" + styleId + "` not found");
        this._instancesCounts[styleId] -= 1;
        if (this._instancesCounts[styleId] < 1) {
            var tagFromServer = this._fromServer && this._fromServer[styleId];
            if (tagFromServer) {
                tagFromServer.parentNode.removeChild(tagFromServer);
                delete this._fromServer[styleId];
            } else {
                this._indices[styleId].forEach(function(index) {
                    return _this._sheet.deleteRule(index);
                });
                delete this._indices[styleId];
            }
            delete this._instancesCounts[styleId];
        }
    };
    _proto.update = function update(props, nextProps) {
        this.add(nextProps);
        this.remove(props);
    };
    _proto.flush = function flush() {
        this._sheet.flush();
        this._sheet.inject();
        this._fromServer = undefined;
        this._indices = {};
        this._instancesCounts = {};
    };
    _proto.cssRules = function cssRules() {
        var _this = this;
        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {
            return [
                styleId,
                _this._fromServer[styleId]
            ];
        }) : [];
        var cssRules = this._sheet.cssRules();
        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {
            return [
                styleId,
                _this._indices[styleId].map(function(index) {
                    return cssRules[index].cssText;
                }).join(_this._optimizeForSpeed ? "" : "\n")
            ];
        }) // filter out empty rules
        .filter(function(rule) {
            return Boolean(rule[1]);
        }));
    };
    _proto.styles = function styles(options) {
        return mapRulesToStyle(this.cssRules(), options);
    };
    _proto.getIdAndRules = function getIdAndRules(props) {
        var css = props.children, dynamic = props.dynamic, id = props.id;
        if (dynamic) {
            var styleId = computeId(id, dynamic);
            return {
                styleId: styleId,
                rules: Array.isArray(css) ? css.map(function(rule) {
                    return computeSelector(styleId, rule);
                }) : [
                    computeSelector(styleId, css)
                ]
            };
        }
        return {
            styleId: computeId(id),
            rules: Array.isArray(css) ? css : [
                css
            ]
        };
    };
    /**
   * selectFromServer
   *
   * Collects style tags from the document with id __jsx-XXX
   */ _proto.selectFromServer = function selectFromServer() {
        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^="__jsx-"]'));
        return elements.reduce(function(acc, element) {
            var id = element.id.slice(2);
            acc[id] = element;
            return acc;
        }, {});
    };
    return StyleSheetRegistry;
}();
function invariant(condition, message) {
    if (!condition) {
        throw new Error("StyleSheetRegistry: " + message + ".");
    }
}
var StyleSheetContext = /*#__PURE__*/ React.createContext(null);
StyleSheetContext.displayName = "StyleSheetContext";
function createStyleRegistry() {
    return new StyleSheetRegistry();
}
function StyleRegistry(param) {
    var configuredRegistry = param.registry, children = param.children;
    var rootRegistry = React.useContext(StyleSheetContext);
    var ref = React.useState({
        "StyleRegistry.useState[ref]": function() {
            return rootRegistry || configuredRegistry || createStyleRegistry();
        }
    }["StyleRegistry.useState[ref]"]), registry = ref[0];
    return /*#__PURE__*/ React__default["default"].createElement(StyleSheetContext.Provider, {
        value: registry
    }, children);
}
function useStyleRegistry() {
    return React.useContext(StyleSheetContext);
}
// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.
// https://github.com/reactwg/react-18/discussions/110
var useInsertionEffect = React__default["default"].useInsertionEffect || React__default["default"].useLayoutEffect;
var defaultRegistry = typeof window !== "undefined" ? createStyleRegistry() : undefined;
function JSXStyle(props) {
    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();
    // If `registry` does not exist, we do nothing here.
    if (!registry) {
        return null;
    }
    if (typeof window === "undefined") {
        registry.add(props);
        return null;
    }
    useInsertionEffect({
        "JSXStyle.useInsertionEffect": function() {
            registry.add(props);
            return ({
                "JSXStyle.useInsertionEffect": function() {
                    registry.remove(props);
                }
            })["JSXStyle.useInsertionEffect"];
        // props.children can be string[], will be striped since id is identical
        }
    }["JSXStyle.useInsertionEffect"], [
        props.id,
        String(props.dynamic)
    ]);
    return null;
}
JSXStyle.dynamic = function(info) {
    return info.map(function(tagInfo) {
        var baseId = tagInfo[0];
        var props = tagInfo[1];
        return computeId(baseId, props);
    }).join(" ");
};
exports.StyleRegistry = StyleRegistry;
exports.createStyleRegistry = createStyleRegistry;
exports.style = JSXStyle;
exports.useStyleRegistry = useStyleRegistry;
}),
"[project]/node_modules/styled-jsx/style.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/styled-jsx/dist/index/index.js [app-client] (ecmascript)").style;
}),
]);

//# sourceMappingURL=node_modules_04751755._.js.map