(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertBytes = exports.assertPostiveInteger = exports.assert = void 0;
function assert(condition, errorMessage, addInfos) {
    var args = [];
    for(var _i = 3; _i < arguments.length; _i++){
        args[_i - 3] = arguments[_i];
    }
    if (condition) return;
    args.length > 0 && console.error.apply(console, __spreadArray([], __read(args), false));
    addInfos && console.error(addInfos);
    if (errorMessage instanceof Error) {
        throw errorMessage;
    }
    ;
    throw new Error(errorMessage);
}
exports.assert = assert;
// keccak asserts
function assertPostiveInteger(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, not ".concat(n));
}
exports.assertPostiveInteger = assertPostiveInteger;
function assertBytes(stuff) {
    if (!(stuff instanceof Uint8Array)) throw new Error("Uint8Array expected");
}
exports.assertBytes = assertBytes;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uint64Rotr = exports.uint64ToBytesBE = exports.uint64ToBytesLE = exports.isUint64 = exports.forceUint64 = exports.uint64 = exports.buffToUint5Arr = exports.byteArrToBin = exports.byteArrToHex = exports.buffToByteArr = exports.isByteArr = exports.isByte = exports.byte = exports.isUint6 = exports.isUint5 = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
function isUint5(n) {
    return typeof n === "number" && n >= 0 && n <= 31 && n === Math.round(n);
}
exports.isUint5 = isUint5;
function isUint6(n) {
    return typeof n === "number" && n >= 0 && n <= 63 && n === Math.round(n);
}
exports.isUint6 = isUint6;
function byte(bint) {
    return Number(bint) & 0xff;
}
exports.byte = byte;
function isByte(n) {
    return typeof n === "number" && n >= 0 && n <= 255 && n === Math.round(n);
}
exports.isByte = isByte;
function isByteArr(something) {
    return Array.isArray(something) && something.every(isByte);
}
exports.isByteArr = isByteArr;
function buffToByteArr(buff) {
    if (!(0, uint8array_utils_1.isUint8Array)(buff)) {
        if (isByteArr(buff)) return buff.slice();
        throw new Error("can't convert non-buffer to byte array");
    }
    return Array.from(buff);
}
exports.buffToByteArr = buffToByteArr;
function byteArrToHex(bytes) {
    if (bytes instanceof Uint8Array) bytes = Array.from(bytes);
    return bytes.reduce(function(acc, val) {
        return acc + val.toString(16).slice(0, 2).padStart(2, '0');
    }, '');
}
exports.byteArrToHex = byteArrToHex;
function byteArrToBin(bytes) {
    return bytes.reduce(function(acc, val) {
        return acc + val.toString(2).slice(0, 8).padStart(8, '0');
    }, '');
}
exports.byteArrToBin = byteArrToBin;
/**
 * Internal method
 *
 * `bytes` is **padded at the end** to be a multiple of 5
 */ function buffToUint5Arr(bytes) {
    var result = [];
    var bits = (0, uint8array_utils_1.isUint8Array)(bytes) ? Array.from(bytes).reduce(function(acc, n) {
        return acc + n.toString(2).padStart(8, '0');
    }, "") : isByteArr(bytes) ? byteArrToBin(bytes) : undefined;
    if (bits === undefined) {
        throw new Error("invalid input to convert ot uint5 array");
    }
    var mod5Len = bits.length % 5;
    if (mod5Len !== 0) {
        bits = bits.padEnd(bits.length + (5 - mod5Len), '0');
    }
    bits = bits.split('');
    for(var i = 0; i < bits.length;){
        result.push(Number("0b".concat(bits[i++]).concat(bits[i++]).concat(bits[i++]).concat(bits[i++]).concat(bits[i++])));
    }
    return result;
}
exports.buffToUint5Arr = buffToUint5Arr;
function uint64(n) {
    var _n = BigInt(n);
    if (!isUint64(_n)) throw new Error("can't convert " + n + " to uint64");
    return _n;
}
exports.uint64 = uint64;
function forceUint64(n) {
    return BigInt(n) & BigInt("0x" + "ff".repeat(8));
}
exports.forceUint64 = forceUint64;
function isUint64(n) {
    return typeof n === "bigint" && n >= BigInt(0) && n < BigInt("0x1" + "00".repeat(8)) // n < (1 << 64)
    ;
}
exports.isUint64 = isUint64;
function uint64ToBytesLE(uint) {
    return [
        byte(BigInt("0x00000000000000ff") & uint),
        byte((BigInt("0x000000000000ff00") & uint) >> BigInt(8)),
        byte((BigInt("0x0000000000ff0000") & uint) >> BigInt(16)),
        byte((BigInt("0x00000000ff000000") & uint) >> BigInt(24)),
        byte((BigInt("0x000000ff00000000") & uint) >> BigInt(32)),
        byte((BigInt("0x0000ff0000000000") & uint) >> BigInt(40)),
        byte((BigInt("0x00ff000000000000") & uint) >> BigInt(48)),
        byte((BigInt("0xff00000000000000") & uint) >> BigInt(56))
    ];
}
exports.uint64ToBytesLE = uint64ToBytesLE;
function uint64ToBytesBE(uint) {
    return uint64ToBytesLE(uint).reverse();
}
exports.uint64ToBytesBE = uint64ToBytesBE;
function uint64Rotr(a, b) {
    (0, assert_1.assert)(isUint64(a) && isUint6(b), "invalid args for 'uint64And'");
    if (b === 0) return a;
    var n = BigInt(b);
    return forceUint64(forceUint64(a >> n) | forceUint64(a << BigInt(64) - n));
}
exports.uint64Rotr = uint64Rotr;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/base32.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeBase32Bech32 = exports.decodeBase32rfc4648 = exports.encodeBase32rfc4648 = exports.BECH32_BASE32_ALPHABET = exports.rfc4648_ALPHABET = void 0;
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var bitstream_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bitstream/dist/index.js [app-client] (ecmascript)");
exports.rfc4648_ALPHABET = Object.freeze([
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'g',
    'h',
    'i',
    'j',
    'k',
    'l',
    'm',
    'n',
    'o',
    'p',
    'q',
    'r',
    's',
    't',
    'u',
    'v',
    'w',
    'x',
    'y',
    'z',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7'
]);
exports.BECH32_BASE32_ALPHABET = Object.freeze([
    'q',
    'p',
    'z',
    'r',
    'y',
    '9',
    'x',
    '8',
    'g',
    'f',
    '2',
    't',
    'v',
    'd',
    'w',
    '0',
    's',
    '3',
    'j',
    'n',
    '5',
    '4',
    'k',
    'h',
    'c',
    'e',
    '6',
    'm',
    'u',
    'a',
    '7',
    'l'
]);
function encodeBase32rfc4648(bytes) {
    return (0, types_1.buffToUint5Arr)(bytes).map(function(c) {
        return exports.rfc4648_ALPHABET[c];
    }).join("");
}
exports.encodeBase32rfc4648 = encodeBase32rfc4648;
function decodeBase32(base32Str, alpabeth) {
    if (!Array.from(base32Str).every(function(ch) {
        return alpabeth.includes(ch);
    })) throw new Error("can't decode base32 a string that is not in base32 (rfc 4648); string was: " + base32Str);
    var len = base32Str.length;
    var bits = '';
    for(var i = 0; i < len - 1; i++){
        var num_1 = alpabeth.indexOf(base32Str[i].toLowerCase());
        bits += num_1.toString(2).padStart(5, '0');
    }
    // last, make sure we align to byte
    var nCut = len * 5 - 8 * Math.floor(len * 5 / 8);
    var num = alpabeth.indexOf(base32Str[len - 1].toLowerCase());
    var lastbits = num.toString(2).padStart(5, '0');
    bits += lastbits.slice(0, 5 - nCut);
    return bitstream_1.BitStream.fromBinStr(bits).toBuffer().buffer;
}
function decodeBase32rfc4648(base32Str) {
    return decodeBase32(base32Str, exports.rfc4648_ALPHABET);
}
exports.decodeBase32rfc4648 = decodeBase32rfc4648;
function decodeBase32Bech32(base32Str) {
    return decodeBase32(base32Str, exports.BECH32_BASE32_ALPHABET);
}
exports.decodeBase32Bech32 = decodeBase32Bech32;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/bech32.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeBech32 = exports.isBech32 = exports.encodeBech32 = exports.getBech32Checksum = exports.getBech32Polymod = exports.expandBech32HumanReadablePart = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var base32_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/base32.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
/**
 * Expand human readable prefix of the bech32 encoding so it can be used in the checkSum
 */ function expandBech32HumanReadablePart(hrp) {
    var e_1, _a, e_2, _b;
    var bytes = [];
    try {
        for(var hrp_1 = __values(hrp), hrp_1_1 = hrp_1.next(); !hrp_1_1.done; hrp_1_1 = hrp_1.next()){
            var c = hrp_1_1.value;
            bytes.push(c.charCodeAt(0) >> 5);
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (hrp_1_1 && !hrp_1_1.done && (_a = hrp_1.return)) _a.call(hrp_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    bytes.push(0);
    try {
        for(var hrp_2 = __values(hrp), hrp_2_1 = hrp_2.next(); !hrp_2_1.done; hrp_2_1 = hrp_2.next()){
            var c = hrp_2_1.value;
            bytes.push(c.charCodeAt(0) & 31);
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (hrp_2_1 && !hrp_2_1.done && (_b = hrp_2.return)) _b.call(hrp_2);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return bytes;
}
exports.expandBech32HumanReadablePart = expandBech32HumanReadablePart;
var BECH32_POLYMOD_GEN = Object.freeze([
    0x3b6a57b2,
    0x26508e6d,
    0x1ea119fa,
    0x3d4233dd,
    0x2a1462b3
]);
/**
 * Used as part of the bech32 checksum.
 */ function getBech32Polymod(bytes) {
    var e_3, _a;
    var checksum = 1;
    try {
        for(var bytes_1 = __values(bytes), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()){
            var byte_1 = bytes_1_1.value;
            var c = checksum >> 25;
            checksum = (checksum & 0x1fffffff) << 5 ^ byte_1;
            for(var i = 0; i < 5; i++){
                if ((c >> i & 1) != 0) {
                    checksum ^= BECH32_POLYMOD_GEN[i];
                }
            }
        }
    } catch (e_3_1) {
        e_3 = {
            error: e_3_1
        };
    } finally{
        try {
            if (bytes_1_1 && !bytes_1_1.done && (_a = bytes_1.return)) _a.call(bytes_1);
        } finally{
            if (e_3) throw e_3.error;
        }
    }
    return checksum;
}
exports.getBech32Polymod = getBech32Polymod;
/**
 * Generate the bech32 checksum
 */ function getBech32Checksum(humanReadablePart, data) {
    var checksum = getBech32Polymod(expandBech32HumanReadablePart(humanReadablePart).concat(data).concat([
        0,
        0,
        0,
        0,
        0,
        0
    ])) ^ 1;
    var chkSum = [];
    for(var i = 0; i < 6; i++){
        chkSum.push(checksum >> 5 * (5 - i) & 31);
    }
    return chkSum;
}
exports.getBech32Checksum = getBech32Checksum;
/**
 * Creates a bech32 checksummed string (used to represent Cardano addresses)
 * @example
 * encodeBech32("foo", textToBytes("foobar")) => "foo1vehk7cnpwgry9h96"
 * @example
 * encodeBech32("addr_test", hexToBytes("70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539")) => "addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld"
 * @param {byte[]} data - uint8 0 - 256
 */ function encodeBech32(humanReadablePart, data) {
    (0, assert_1.assert)(humanReadablePart.length > 0, "human-readable-part must have non-zero length");
    var _data = (0, types_1.buffToUint5Arr)((0, uint8array_utils_1.isUint8Array)(data) ? data : new Uint8Array(data));
    return humanReadablePart + "1" + _data.concat(getBech32Checksum(humanReadablePart, _data)).map(function(val) {
        return base32_1.BECH32_BASE32_ALPHABET[val];
    }).join("");
}
exports.encodeBech32 = encodeBech32;
/**
 * Verify a bech32 checksum
 * @example
 * isBech32("foo1vehk7cnpwgry9h96") => true
 * @example
 * isBech32("foo1vehk7cnpwgry9h97") => false
 * @example
 * isBech32("a12uel5l") => true
 * @example
 * isBech32("mm1crxm3i") => false
 * @example
 * isBech32("A1G7SGD8") => false
 * @example
 * isBech32("abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw") => true
 * @example
 * isBech32("?1ezyfcl") => true
 * @example
 * isBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld") => true
 * @param {string} addr
 * @returns {boolean}
 */ function isBech32(addr) {
    var e_4, _a;
    var i = addr.indexOf("1");
    if (i == -1 || i == 0) {
        return false;
    }
    var hrp = addr.slice(0, i);
    addr = addr.slice(i + 1);
    var data = [];
    try {
        for(var addr_1 = __values(addr), addr_1_1 = addr_1.next(); !addr_1_1.done; addr_1_1 = addr_1.next()){
            var ch = addr_1_1.value;
            var j = base32_1.BECH32_BASE32_ALPHABET.indexOf(ch);
            if (j == -1) {
                return false;
            }
            data.push(j);
        }
    } catch (e_4_1) {
        e_4 = {
            error: e_4_1
        };
    } finally{
        try {
            if (addr_1_1 && !addr_1_1.done && (_a = addr_1.return)) _a.call(addr_1);
        } finally{
            if (e_4) throw e_4.error;
        }
    }
    var chkSumA = data.slice(data.length - 6);
    var chkSumB = getBech32Checksum(hrp, data.slice(0, data.length - 6));
    for(var i_1 = 0; i_1 < 6; i_1++){
        if (chkSumA[i_1] != chkSumB[i_1]) {
            return false;
        }
    }
    return true;
}
exports.isBech32 = isBech32;
/**
 * Decomposes a bech32 checksummed string (i.e. Cardano address), and returns the human readable part and the original bytes
 * Throws an error if checksum is invalid.
 * @example
 * bytesToHex(decodeBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld")[1]) => "70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539"
 * @param {string} addr
 * @returns {[humanReadablePart: string, bytes: byte[]]}
 */ function decodeBech32(addr) {
    (0, assert_1.assert)(isBech32(addr), "invalid bech32 addr");
    var i = addr.indexOf("1");
    (0, assert_1.assert)(i != -1, "bech32 address missing the '1' separator");
    var hrp = addr.slice(0, i);
    addr = addr.slice(i + 1);
    var data = (0, base32_1.decodeBase32Bech32)(addr.slice(0, addr.length - 6));
    return [
        hrp,
        Array.from(data)
    ];
}
exports.decodeBech32 = decodeBech32;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/blake2b.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.blake2b_512 = exports.blake2b_256 = exports.blake2b_224 = exports.blake2b_128 = exports.blake2b = void 0;
/**
 * 64-bit unsigned addition
 * Sets v[a,a+1] += v[b,b+1]
 * v should be a Uint32Array
 */ function ADD64AA(v, a, b) {
    var o0 = v[a] + v[b];
    var o1 = v[a + 1] + v[b + 1];
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC(v, a, b0, b1) {
    var o0 = v[a] + b0;
    if (b0 < 0) {
        o0 += 0x100000000;
    }
    var o1 = v[a + 1] + b1;
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// Little-endian byte access
function B2B_GET32(arr, i) {
    return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
}
// G Mixing function
// The ROTRs are inlined for speed
function B2B_G(a, b, c, d, ix, iy) {
    var x0 = m[ix];
    var x1 = m[ix + 1];
    var y0 = m[iy];
    var y1 = m[iy + 1];
    ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
    ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
    var xor0 = v[d] ^ v[a];
    var xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor1;
    v[d + 1] = xor0;
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor0 >>> 24 ^ xor1 << 8;
    v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v, a, b);
    ADD64AC(v, a, y0, y1);
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
    xor0 = v[d] ^ v[a];
    xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor0 >>> 16 ^ xor1 << 16;
    v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor1 >>> 31 ^ xor0 << 1;
    v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
}
// Initialization Vector
var BLAKE2B_IV32 = new Uint32Array([
    0xf3bcc908,
    0x6a09e667,
    0x84caa73b,
    0xbb67ae85,
    0xfe94f82b,
    0x3c6ef372,
    0x5f1d36f1,
    0xa54ff53a,
    0xade682d1,
    0x510e527f,
    0x2b3e6c1f,
    0x9b05688c,
    0xfb41bd6b,
    0x1f83d9ab,
    0x137e2179,
    0x5be0cd19
]);
var SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
];
// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
var SIGMA82 = new Uint8Array(SIGMA8.map(function(x) {
    return x * 2;
}));
// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
var v = new Uint32Array(32);
var m = new Uint32Array(32);
function blake2bCompress(ctx, last) {
    var i = 0;
    // init work variables
    for(i = 0; i < 16; i++){
        v[i] = ctx.h[i];
        v[i + 16] = BLAKE2B_IV32[i];
    }
    // low 64 bits of offset
    v[24] = v[24] ^ ctx.t;
    v[25] = v[25] ^ ctx.t / 0x100000000;
    // high 64 bits not supported, offset may not be higher than 2**53-1
    // last block flag set ?
    if (last) {
        v[28] = ~v[28];
        v[29] = ~v[29];
    }
    // get little-endian words
    for(i = 0; i < 32; i++){
        m[i] = B2B_GET32(ctx.b, 4 * i);
    }
    // twelve rounds of mixing
    // uncomment the DebugPrint calls to log the computation
    // and match the RFC sample documentation
    // util.debugPrint('          m[16]', m, 64)
    for(i = 0; i < 12; i++){
        // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
        B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    // util.debugPrint('   (i=12) v[16]', v, 64)
    for(i = 0; i < 16; i++){
        ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
    }
// util.debugPrint('h[8]', ctx.h, 64)
}
/** reusable parameterBlock */ var parameterBlock = new Uint8Array(64).fill(0);
function blake2bInit(digestSize) {
    // state, 'param block'
    var ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        c: 0,
        digestSize: digestSize // output length in bytes
    };
    // initialize parameterBlock before usage
    parameterBlock.fill(0);
    parameterBlock[0] = digestSize;
    parameterBlock[2] = 1; // fanout
    parameterBlock[3] = 1; // depth
    // initialize hash state
    for(var i = 0; i < 16; i++){
        ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
    }
    return ctx;
}
// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate(ctx, input) {
    for(var i = 0; i < input.length; i++){
        if (ctx.c === 128) {
            // buffer full ?
            ctx.t += ctx.c; // add counters
            blake2bCompress(ctx, false); // compress (not last)
            ctx.c = 0; // counter to zero
        }
        ctx.b[ctx.c++] = input[i];
    }
}
// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal(ctx) {
    ctx.t += ctx.c; // mark last block offset
    while(ctx.c < 128){
        // fill up with zeros
        ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true); // final block flag = 1
    // little endian convert and store
    var out = new Uint8Array(ctx.digestSize);
    for(var i = 0; i < ctx.digestSize; i++){
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
    }
    return out;
}
function blake2b(data, digestSize) {
    if (digestSize === void 0) {
        digestSize = 32;
    }
    data = new Uint8Array(data);
    var ctx = blake2bInit(digestSize);
    blake2bUpdate(ctx, data);
    return blake2bFinal(ctx);
}
exports.blake2b = blake2b;
function blake2b_128(data) {
    return blake2b(data, 16);
}
exports.blake2b_128 = blake2b_128;
function blake2b_224(data) {
    return blake2b(data, 28);
}
exports.blake2b_224 = blake2b_224;
function blake2b_256(data) {
    return blake2b(data, 32);
}
exports.blake2b_256 = blake2b_256;
function blake2b_512(data) {
    return blake2b(data, 64);
}
exports.blake2b_512 = blake2b_512;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_u64.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.add5H = exports.add5L = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-hashes/blob/6ae82e75d4c354d53a488e95b1bfe9cba90bd6ff/src/_u64.ts#L1

it was modified and adapted to this repository to re-use already defined stuff

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var U32_MASK64 = /* @__PURE__ */ BigInt(Math.pow(2, 32) - 1);
var _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le) {
    if (le === void 0) {
        le = false;
    }
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
exports.fromBig = fromBig;
function split(lst, le) {
    var _a;
    if (le === void 0) {
        le = false;
    }
    var Ah = new Uint32Array(lst.length);
    var Al = new Uint32Array(lst.length);
    for(var i = 0; i < lst.length; i++){
        var _b = fromBig(lst[i], le), h = _b.h, l = _b.l;
        _a = __read([
            h,
            l
        ], 2), Ah[i] = _a[0], Al[i] = _a[1];
    }
    return [
        Ah,
        Al
    ];
}
exports.split = split;
var toBig = function(h, l) {
    return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
};
exports.toBig = toBig;
// for Shift in [0, 32)
var shrSH = function(h, _l, s) {
    return h >>> s;
};
exports.shrSH = shrSH;
var shrSL = function(h, l, s) {
    return h << 32 - s | l >>> s;
};
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
var rotrSH = function(h, l, s) {
    return h >>> s | l << 32 - s;
};
exports.rotrSH = rotrSH;
var rotrSL = function(h, l, s) {
    return h << 32 - s | l >>> s;
};
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotrBH = function(h, l, s) {
    return h << 64 - s | l >>> s - 32;
};
exports.rotrBH = rotrBH;
var rotrBL = function(h, l, s) {
    return h >>> s - 32 | l << 64 - s;
};
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
var rotr32H = function(_h, l) {
    return l;
};
exports.rotr32H = rotr32H;
var rotr32L = function(h, _l) {
    return h;
};
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
var rotlSH = function(h, l, s) {
    return h << s | l >>> 32 - s;
};
exports.rotlSH = rotlSH;
var rotlSL = function(h, l, s) {
    return l << s | h >>> 32 - s;
};
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotlBH = function(h, l, s) {
    return l << s - 32 | h >>> 64 - s;
};
exports.rotlBH = rotlBH;
var rotlBL = function(h, l, s) {
    return h << s - 32 | l >>> 64 - s;
};
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    var l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,
        l: l | 0
    };
}
exports.add = add;
// Addition with more than 2 elements
var add3L = function(Al, Bl, Cl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
};
exports.add3L = add3L;
var add3H = function(low, Ah, Bh, Ch) {
    return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add3H = add3H;
var add4L = function(Al, Bl, Cl, Dl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
};
exports.add4L = add4L;
var add4H = function(low, Ah, Bh, Ch, Dh) {
    return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add4H = add4H;
var add5L = function(Al, Bl, Cl, Dl, El) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
};
exports.add5L = add5L;
var add5H = function(low, Ah, Bh, Ch, Dh, Eh) {
    return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add5H = add5H;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/crypto.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-hashes/blob/6ae82e75d4c354d53a488e95b1bfe9cba90bd6ff/src/utils.ts#L1

it was modified and adapted to this repository to re-use already defined stuff

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
var crypto_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/crypto.js [app-client] (ecmascript)");
// Cast array to different type
var u8 = function(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
};
exports.u8 = u8;
var u32 = function(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
};
exports.u32 = u32;
// Cast array to view
var createView = function(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
};
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
var rotr = function(word, shift) {
    return word << 32 - shift | word >>> shift;
};
exports.rotr = rotr;
// The rotate left (circular left shift) operation for uint32
var rotl = function(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
};
exports.rotl = rotl;
exports.isLE = new Uint8Array(new Uint32Array([
    0x11223344
]).buffer)[0] === 0x44;
// The byte swap operation for uint32
var byteSwap = function(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
};
exports.byteSwap = byteSwap;
// Conditionally byte swap if on a big-endian platform
exports.byteSwapIfBE = exports.isLE ? function(n) {
    return n;
} : function(n) {
    return (0, exports.byteSwap)(n);
};
// In place byte swap for Uint32Array
function byteSwap32(arr) {
    for(var i = 0; i < arr.length; i++){
        arr[i] = (0, exports.byteSwap)(arr[i]);
    }
}
exports.byteSwap32 = byteSwap32;
// Array where index 0xf0 (240) is mapped to string 'f0'
var hexes = /* @__PURE__ */ Array.from({
    length: 256
}, function(_, i) {
    return i.toString(16).padStart(2, '0');
});
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    (0, assert_1.assertBytes)(bytes);
    // pre-caching improves the speed 6x
    var hex = '';
    for(var i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
// We use optimized technique to convert hex string to byte array
var asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    var hl = hex.length;
    var al = hl / 2;
    if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    var array = new Uint8Array(al);
    for(var ai = 0, hi = 0; ai < al; ai++, hi += 2){
        var n1 = asciiToBase16(hex.charCodeAt(hi));
        var n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            var char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
var nextTick = function() {
    return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_b) {
            return [
                2 /*return*/ 
            ];
        });
    });
};
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
function asyncLoop(iters, tick, cb) {
    return __awaiter(this, void 0, void 0, function() {
        var ts, i, diff;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    ts = Date.now();
                    i = 0;
                    _b.label = 1;
                case 1:
                    if (!(i < iters)) return [
                        3 /*break*/ ,
                        4
                    ];
                    cb(i);
                    diff = Date.now() - ts;
                    if (diff >= 0 && diff < tick) return [
                        3 /*break*/ ,
                        3
                    ];
                    return [
                        4 /*yield*/ ,
                        (0, exports.nextTick)()
                    ];
                case 2:
                    _b.sent();
                    ts += diff;
                    _b.label = 3;
                case 3:
                    i++;
                    return [
                        3 /*break*/ ,
                        1
                    ];
                case 4:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}
exports.asyncLoop = asyncLoop;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ function toBytes(data) {
    if (typeof data === 'string') data = (0, uint8array_utils_1.fromUtf8)(data);
    (0, assert_1.assertBytes)(data);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */ function concatBytes() {
    var arrays = [];
    for(var _i = 0; _i < arguments.length; _i++){
        arrays[_i] = arguments[_i];
    }
    var sum = 0;
    for(var i = 0; i < arrays.length; i++){
        var a = arrays[i];
        (0, assert_1.assertBytes)(a);
        sum += a.length;
    }
    var res = new Uint8Array(sum);
    for(var i = 0, pad = 0; i < arrays.length; i++){
        var a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
var Hash = function() {
    function Hash() {}
    // Safe version that clones internal state
    Hash.prototype.clone = function() {
        return this._cloneInto();
    };
    return Hash;
}();
exports.Hash = Hash;
var toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
    var merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    var hashC = function(msg) {
        return hashCons().update(toBytes(msg)).digest();
    };
    var tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function() {
        return hashCons();
    };
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    var hashC = function(msg, opts) {
        return hashCons(opts).update(toBytes(msg)).digest();
    };
    var tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function(opts) {
        return hashCons(opts);
    };
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    var hashC = function(msg, opts) {
        return hashCons(opts).update(toBytes(msg)).digest();
    };
    var tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function(opts) {
        return hashCons(opts);
    };
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */ function randomBytes(bytesLength) {
    if (bytesLength === void 0) {
        bytesLength = 32;
    }
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/keccak.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.Keccak = exports.keccakP = void 0;
/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-hashes/blob/6ae82e75d4c354d53a488e95b1bfe9cba90bd6ff/src/sha3.ts#L1

it was modified and adapted to this repository to re-use already defined stuff

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var _u64_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_u64.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n = /** @__PURE__ */ BigInt(0);
var _1n = /** @__PURE__ */ BigInt(1);
var _2n = /** @__PURE__ */ BigInt(2);
var _7n = /** @__PURE__ */ BigInt(7);
var _256n = /** @__PURE__ */ BigInt(256);
var _0x71n = /** @__PURE__ */ BigInt(0x71);
for(var round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    _a = __read([
        y,
        (2 * x + 3 * y) % 5
    ], 2), x = _a[0], y = _a[1];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    var t = _0n;
    for(var j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /** @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
var _b = __read(/** @__PURE__ */ (0, _u64_1.split)(_SHA3_IOTA, true), 2), SHA3_IOTA_H = _b[0], SHA3_IOTA_L = _b[1];
// Left rotation (without 0, 32, 64)
var rotlH = function(h, l, s) {
    return s > 32 ? (0, _u64_1.rotlBH)(h, l, s) : (0, _u64_1.rotlSH)(h, l, s);
};
var rotlL = function(h, l, s) {
    return s > 32 ? (0, _u64_1.rotlBL)(h, l, s) : (0, _u64_1.rotlSL)(h, l, s);
};
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds) {
    if (rounds === void 0) {
        rounds = 24;
    }
    var B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(var round = 24 - rounds; round < 24; round++){
        // Theta 
        for(var x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(var x = 0; x < 10; x += 2){
            var idx1 = (x + 8) % 10;
            var idx0 = (x + 2) % 10;
            var B0 = B[idx0];
            var B1 = B[idx0 + 1];
            var Th = rotlH(B0, B1, 1) ^ B[idx1];
            var Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(var y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        var curH = s[2];
        var curL = s[3];
        for(var t = 0; t < 24; t++){
            var shift = SHA3_ROTL[t];
            var Th = rotlH(curH, curL, shift);
            var Tl = rotlL(curH, curL, shift);
            var PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for(var y = 0; y < 50; y += 10){
            for(var x = 0; x < 10; x++)B[x] = s[y + x];
            for(var x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
var Keccak = function(_super) {
    __extends(Keccak, _super);
    // NOTE: we accept arguments in bytes instead of bits here.
    function Keccak(blockLen, suffix, outputLen, enableXOF, rounds) {
        if (enableXOF === void 0) {
            enableXOF = false;
        }
        if (rounds === void 0) {
            rounds = 24;
        }
        var _this = _super.call(this) || this;
        _this.blockLen = blockLen;
        _this.suffix = suffix;
        _this.outputLen = outputLen;
        _this.enableXOF = enableXOF;
        _this.rounds = rounds;
        _this.pos = 0;
        _this.posOut = 0;
        _this.finished = false;
        _this.destroyed = false;
        // Can be passed from user as dkLen
        (0, assert_1.assertPostiveInteger)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= _this.blockLen || _this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
        _this.state = new Uint8Array(200);
        _this.state32 = (0, utils_1.u32)(_this.state);
        return _this;
    }
    Keccak.prototype.keccak = function() {
        if (!utils_1.isLE) (0, utils_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_1.isLE) (0, utils_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    };
    Keccak.prototype.update = function(data) {
        this.assertExists();
        var _a = this, blockLen = _a.blockLen, state = _a.state;
        data = (0, utils_1.toBytes)(data);
        var len = data.length;
        for(var pos = 0; pos < len;){
            var take = Math.min(blockLen - this.pos, len - pos);
            for(var i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    };
    Keccak.prototype.finish = function() {
        if (this.finished) return;
        this.finished = true;
        var _a = this, state = _a.state, suffix = _a.suffix, pos = _a.pos, blockLen = _a.blockLen;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    };
    Keccak.prototype.writeInto = function(out) {
        this.assertExists(false);
        if (!(out instanceof Uint8Array)) throw new Error("Uint8Array expected");
        this.finish();
        var bufferOut = this.state;
        var blockLen = this.blockLen;
        for(var pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            var take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    };
    Keccak.prototype.xofInto = function(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    };
    Keccak.prototype.xof = function(bytes) {
        (0, assert_1.assertPostiveInteger)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    };
    Keccak.prototype.digestInto = function(out) {
        // output(out, this);
        if (!(out instanceof Uint8Array)) throw new Error("Uint8Array expected");
        var min = this.outputLen;
        if (out.length < min) throw new Error("digestInto() expects output buffer of length at least ".concat(min));
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    };
    Keccak.prototype.digest = function() {
        return this.digestInto(new Uint8Array(this.outputLen));
    };
    Keccak.prototype.destroy = function() {
        this.destroyed = true;
        this.state.fill(0);
    };
    Keccak.prototype._cloneInto = function(to) {
        var _a = this, blockLen = _a.blockLen, suffix = _a.suffix, outputLen = _a.outputLen, rounds = _a.rounds, enableXOF = _a.enableXOF;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    };
    Keccak.prototype.assertExists = function(checkFinished) {
        if (checkFinished === void 0) {
            checkFinished = true;
        }
        if (this.destroyed) throw new Error('Hash instance has been destroyed');
        if (checkFinished && this.finished) throw new Error('Hash#digest() has already been called');
    };
    return Keccak;
}(utils_1.Hash);
exports.Keccak = Keccak;
var gen = function(suffix, blockLen, outputLen) {
    return (0, utils_1.wrapConstructor)(function() {
        return new Keccak(blockLen, suffix, outputLen);
    });
};
// export const sha3_224 = /** @__PURE__ */ gen(0x06, 144, 224 / 8);
// /**
//  * SHA3-256 hash function
//  * @param message - that would be hashed
//  */
// export const sha3_256 = /** @__PURE__ */ gen(0x06, 136, 256 / 8);
// export const sha3_384 = /** @__PURE__ */ gen(0x06, 104, 384 / 8);
// export const sha3_512 = /** @__PURE__ */ gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */ exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8); // const genShake = (suffix: number, blockLen: number, outputLen: number) =>
 //   wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(
 //     (opts: ShakeOpts = {}) =>
 //       new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)
 //   );
 // 
 // export const shake128 = /** @__PURE__ */ genShake(0x1f, 168, 128 / 8);
 // export const shake256 = /** @__PURE__ */ genShake(0x1f, 136, 256 / 8);
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/utils.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = exports.abytes = exports.isBytes = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';
}
exports.isBytes = isBytes;
function abytes(item) {
    if (!isBytes(item)) throw new Error('Uint8Array expected');
}
exports.abytes = abytes;
// Array where index 0xf0 (240) is mapped to string 'f0'
var hexes = /* @__PURE__ */ Array.from({
    length: 256
}, function(_, i) {
    return i.toString(16).padStart(2, '0');
});
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // pre-caching improves the speed 6x
    var hex = '';
    for(var i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    var hex = num.toString(16);
    return hex.length & 1 ? "0".concat(hex) : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : "0x".concat(hex));
}
exports.hexToNumber = hexToNumber;
// We use optimized technique to convert hex string to byte array
var asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    var hl = hex.length;
    var al = hl / 2;
    if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    var array = new Uint8Array(al);
    for(var ai = 0, hi = 0; ai < al; ai++, hi += 2){
        var n1 = asciiToBase16(hex.charCodeAt(hi));
        var n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            var char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    abytes(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */ function ensureBytes(title, hex, expectedLength) {
    var res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        } catch (e) {
            throw new Error("".concat(title, " must be valid hex string, got \"").concat(hex, "\". Cause: ").concat(e));
        }
    } else if (isBytes(hex)) {
        // Uint8Array.from() instead of hash.slice() because node Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    } else {
        throw new Error("".concat(title, " must be hex string or Uint8Array"));
    }
    var len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error("".concat(title, " expected ").concat(expectedLength, " bytes, got ").concat(len));
    return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */ function concatBytes() {
    var arrays = [];
    for(var _i = 0; _i < arguments.length; _i++){
        arrays[_i] = arguments[_i];
    }
    var sum = 0;
    for(var i = 0; i < arrays.length; i++){
        var a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    var res = new Uint8Array(sum);
    for(var i = 0, pad = 0; i < arrays.length; i++){
        var a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
exports.concatBytes = concatBytes;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    var diff = 0;
    for(var i = 0; i < a.length; i++)diff |= a[i] ^ b[i];
    return diff === 0;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error("utf8ToBytes expected string, got ".concat(typeof str));
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */ function bitLen(n) {
    var len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */ function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */ function bitSet(n, pos, value) {
    return n | (value ? _1n : _0n) << BigInt(pos);
}
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */ var bitMask = function(n) {
    return (_2n << BigInt(n - 1)) - _1n;
};
exports.bitMask = bitMask;
// DRBG
var u8n = function(data) {
    return new Uint8Array(data);
}; // creates Uint8Array
var u8fr = function(arr) {
    return Uint8Array.from(arr);
}; // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    var v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    var k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    var i = 0; // Iterations counter, will throw when over 1000
    var reset = function() {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    var h = function() {
        var b = [];
        for(var _i = 0; _i < arguments.length; _i++){
            b[_i] = arguments[_i];
        }
        return hmacFn.apply(void 0, __spreadArray([
            k,
            v
        ], __read(b), false));
    }; // hmac(k)(v, ...values)
    var reseed = function(seed) {
        if (seed === void 0) {
            seed = u8n();
        }
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([
            0x00
        ]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8fr([
            0x01
        ]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    var gen = function() {
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error('drbg: tried 1000 values');
        var len = 0;
        var out = [];
        while(len < qByteLen){
            v = h();
            var sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes.apply(void 0, __spreadArray([], __read(out), false));
    };
    var genUntil = function(seed, pred) {
        reset();
        reseed(seed); // Steps D-G
        var res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
var validatorFns = {
    bigint: function(val) {
        return typeof val === 'bigint';
    },
    function: function(val) {
        return typeof val === 'function';
    },
    boolean: function(val) {
        return typeof val === 'boolean';
    },
    string: function(val) {
        return typeof val === 'string';
    },
    stringOrUint8Array: function(val) {
        return typeof val === 'string' || isBytes(val);
    },
    isSafeInteger: function(val) {
        return Number.isSafeInteger(val);
    },
    array: function(val) {
        return Array.isArray(val);
    },
    field: function(val, object) {
        return object.Fp.isValid(val);
    },
    hash: function(val) {
        return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
    }
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators) {
    var e_1, _b, e_2, _c;
    if (optValidators === void 0) {
        optValidators = {};
    }
    var checkField = function(fieldName, type, isOptional) {
        var checkVal = validatorFns[type];
        if (typeof checkVal !== 'function') throw new Error("Invalid validator \"".concat(type, "\", expected function"));
        var val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) {
            throw new Error("Invalid param ".concat(String(fieldName), "=").concat(val, " (").concat(typeof val, "), expected ").concat(type));
        }
    };
    try {
        for(var _d = __values(Object.entries(validators)), _e = _d.next(); !_e.done; _e = _d.next()){
            var _g = __read(_e.value, 2), fieldName = _g[0], type = _g[1];
            checkField(fieldName, type, false);
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    try {
        for(var _h = __values(Object.entries(optValidators)), _j = _h.next(); !_j.done; _j = _h.next()){
            var _k = __read(_j.value, 2), fieldName = _k[0], type = _k[1];
            checkField(fieldName, type, true);
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return object;
}
exports.validateObject = validateObject; // validate type tests
 // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
 // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
 // // Should fail type-check
 // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
 // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
 // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
 // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/modular.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
// prettier-ignore
var _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
var _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
var _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    var result = a % b;
    return result >= _0n ? result : b + result;
}
exports.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */ // TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');
    if (modulo === _1n) return _0n;
    var res = _1n;
    while(power > _0n){
        if (power & _1n) res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
    }
    return res;
}
exports.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    var res = x;
    while(power-- > _0n){
        res *= res;
        res %= modulo;
    }
    return res;
}
exports.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
        throw new Error("invert: expected positive integers, got n=".concat(number, " mod=").concat(modulo));
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    var a = mod(number, modulo);
    var b = modulo;
    // prettier-ignore
    var x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        // JIT applies optimization if those two lines follow each other
        var q = b / a;
        var r = b % a;
        var m = x - u * q;
        var n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    var gcd = b;
    if (gcd !== _1n) throw new Error('invert: does not exist');
    return mod(x, modulo);
}
exports.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */ function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p)  1    if a is a square (mod p)
    // (a | p)  -1   if a is not a square (mod p)
    // (a | p)  0    if a  0 (mod p)
    var legendreC = (P - _1n) / _2n;
    var Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);
    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);
    // Fast-path
    if (S === 1) {
        var p1div4_1 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            var root = Fp.pow(n, p1div4_1);
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    var Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be  -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');
        var r = S;
        // TODO: will fail at Fp2/etc
        var g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        var x = Fp.pow(n, Q1div2); // first guess at the square root
        var b = Fp.pow(n, Q); // first guess at the fudge factor
        while(!Fp.eql(b, Fp.ONE)){
            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            var m = 1;
            for(var t2 = Fp.sqr(b); m < r; m++){
                if (Fp.eql(t2, Fp.ONE)) break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            var ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
exports.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P  3 (mod 4)
    // n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        var p1div4_2 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            var root = Fp.pow(n, p1div4_2);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        var c1_1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            var n2 = Fp.mul(n, _2n);
            var v = Fp.pow(n2, c1_1);
            var nv = Fp.mul(n, v);
            var i = Fp.mul(Fp.mul(nv, _2n), v);
            var root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
            return root;
        };
    }
    // P  9 (mod 16)
    if (P % _16n === _9n) {
    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
    // Means we cannot use sqrt for constants at all!
    //
    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
    // sqrt = (x) => {
    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
    // }
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
exports.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
var isNegativeLE = function(num, modulo) {
    return (mod(num, modulo) & _1n) === _1n;
};
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
var FIELD_FIELDS = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
];
function validateField(field) {
    var initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger'
    };
    var opts = FIELD_FIELDS.reduce(function(map, val) {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_1.validateObject)(field, opts);
}
exports.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */ function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n) throw new Error('Expected power > 0');
    if (power === _0n) return f.ONE;
    if (power === _1n) return num;
    var p = f.ONE;
    var d = num;
    while(power > _0n){
        if (power & _1n) p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
exports.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */ function FpInvertBatch(f, nums) {
    var tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    var lastMultiplied = nums.reduce(function(acc, num, i) {
        if (f.is0(num)) return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    var inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight(function(acc, num, i) {
        if (f.is0(num)) return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
exports.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
exports.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    var legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return function(x) {
        var p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
exports.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    var _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    var nByteLength = Math.ceil(_nBitLength / 8);
    return {
        nBitLength: _nBitLength,
        nByteLength: nByteLength
    };
}
exports.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */ function Field(ORDER, bitLen, isLE, redef) {
    if (isLE === void 0) {
        isLE = false;
    }
    if (redef === void 0) {
        redef = {};
    }
    if (ORDER <= _0n) throw new Error("Expected Field ORDER > 0, got ".concat(ORDER));
    var _a = nLength(ORDER, bitLen), BITS = _a.nBitLength, BYTES = _a.nByteLength;
    if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');
    var sqrtP = FpSqrt(ORDER);
    var f = Object.freeze({
        ORDER: ORDER,
        BITS: BITS,
        BYTES: BYTES,
        MASK: (0, utils_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: function(num) {
            return mod(num, ORDER);
        },
        isValid: function(num) {
            if (typeof num !== 'bigint') throw new Error("Invalid field element: expected bigint, got ".concat(typeof num));
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: function(num) {
            return num === _0n;
        },
        isOdd: function(num) {
            return (num & _1n) === _1n;
        },
        neg: function(num) {
            return mod(-num, ORDER);
        },
        eql: function(lhs, rhs) {
            return lhs === rhs;
        },
        sqr: function(num) {
            return mod(num * num, ORDER);
        },
        add: function(lhs, rhs) {
            return mod(lhs + rhs, ORDER);
        },
        sub: function(lhs, rhs) {
            return mod(lhs - rhs, ORDER);
        },
        mul: function(lhs, rhs) {
            return mod(lhs * rhs, ORDER);
        },
        pow: function(num, power) {
            return FpPow(f, num, power);
        },
        div: function(lhs, rhs) {
            return mod(lhs * invert(rhs, ORDER), ORDER);
        },
        // Same as above, but doesn't normalize
        sqrN: function(num) {
            return num * num;
        },
        addN: function(lhs, rhs) {
            return lhs + rhs;
        },
        subN: function(lhs, rhs) {
            return lhs - rhs;
        },
        mulN: function(lhs, rhs) {
            return lhs * rhs;
        },
        inv: function(num) {
            return invert(num, ORDER);
        },
        sqrt: redef.sqrt || function(n) {
            return sqrtP(f, n);
        },
        invertBatch: function(lst) {
            return FpInvertBatch(f, lst);
        },
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: function(a, b, c) {
            return c ? b : a;
        },
        toBytes: function(num) {
            return isLE ? (0, utils_1.numberToBytesLE)(num, BYTES) : (0, utils_1.numberToBytesBE)(num, BYTES);
        },
        fromBytes: function(bytes) {
            if (bytes.length !== BYTES) throw new Error("Fp.fromBytes: expected ".concat(BYTES, ", got ").concat(bytes.length));
            return isLE ? (0, utils_1.bytesToNumberLE)(bytes) : (0, utils_1.bytesToNumberBE)(bytes);
        }
    });
    return Object.freeze(f);
}
exports.Field = Field;
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    var root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
exports.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    var root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
exports.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */ function hashToPrivateScalar(hash, groupOrder, isLE) {
    if (isLE === void 0) {
        isLE = false;
    }
    hash = (0, utils_1.ensureBytes)('privateHash', hash);
    var hashLen = hash.length;
    var minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error("hashToPrivateScalar: expected ".concat(minLen, "-1024 bytes of input, got ").concat(hashLen));
    var num = isLE ? (0, utils_1.bytesToNumberLE)(hash) : (0, utils_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
exports.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */ function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');
    var bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
exports.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */ function getMinHashLength(fieldOrder) {
    var length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
exports.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */ function mapHashToField(key, fieldOrder, isLE) {
    if (isLE === void 0) {
        isLE = false;
    }
    var len = key.length;
    var fieldLen = getFieldBytesLength(fieldOrder);
    var minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024) throw new Error("expected ".concat(minLen, "-1024 bytes of input, got ").concat(len));
    var num = isLE ? (0, utils_1.bytesToNumberBE)(key) : (0, utils_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    var reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_1.numberToBytesBE)(reduced, fieldLen);
}
exports.mapHashToField = mapHashToField;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/hash-to-curve.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
var modular_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
var os2ip = utils_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << 8 * length) {
        throw new Error("bad I2OSP call: value=".concat(value, " length=").concat(length));
    }
    var res = Array.from({
        length: length
    }).fill(0);
    for(var i = length - 1; i >= 0; i--){
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    var arr = new Uint8Array(a.length);
    for(var i = 0; i < a.length; i++){
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item)) throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_1.abytes)(msg);
    (0, utils_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255) DST = H((0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    var b_in_bytes = H.outputLen, r_in_bytes = H.blockLen;
    var ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255) throw new Error('Invalid xmd length');
    var DST_prime = (0, utils_1.concatBytes)(DST, i2osp(DST.length, 1));
    var Z_pad = i2osp(0, r_in_bytes);
    var l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    var b = new Array(ell);
    var b_0 = H((0, utils_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for(var i = 1; i <= ell; i++){
        var args = [
            strxor(b_0, b[i - 1]),
            i2osp(i + 1, 1),
            DST_prime
        ];
        b[i] = H(utils_1.concatBytes.apply(void 0, __spreadArray([], __read(args), false)));
    }
    var pseudo_random_bytes = utils_1.concatBytes.apply(void 0, __spreadArray([], __read(b), false));
    return pseudo_random_bytes.slice(0, lenInBytes);
}
exports.expand_message_xmd = expand_message_xmd;
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_1.abytes)(msg);
    (0, utils_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        var dkLen = Math.ceil(2 * k / 8);
        DST = H.create({
            dkLen: dkLen
        }).update((0, utils_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');
    return H.create({
        dkLen: lenInBytes
    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)
    .update(DST).update(i2osp(DST.length, 1)).digest();
}
exports.expand_message_xof = expand_message_xof;
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */ function hash_to_field(msg, count, options) {
    (0, utils_1.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash'
    });
    var p = options.p, k = options.k, m = options.m, hash = options.hash, expand = options.expand, _DST = options.DST;
    (0, utils_1.abytes)(msg);
    anum(count);
    var DST = typeof _DST === 'string' ? (0, utils_1.utf8ToBytes)(_DST) : _DST;
    var log2p = p.toString(2).length;
    var L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    var len_in_bytes = count * m * L;
    var prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    } else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    } else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    } else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    var u = new Array(count);
    for(var i = 0; i < count; i++){
        var e = new Array(m);
        for(var j = 0; j < m; j++){
            var elm_offset = L * (j + i * m);
            var tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
exports.hash_to_field = hash_to_field;
function isogenyMap(field, map) {
    // Make same order as in spec
    var COEFF = map.map(function(i) {
        return Array.from(i).reverse();
    });
    return function(x, y) {
        var _a = __read(COEFF.map(function(val) {
            return val.reduce(function(acc, i) {
                return field.add(field.mul(acc, x), i);
            });
        }), 4), xNum = _a[0], xDen = _a[1], yNum = _a[2], yDen = _a[3];
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return {
            x: x,
            y: y
        };
    };
}
exports.isogenyMap = isogenyMap;
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve: function(msg, options) {
            var u = hash_to_field(msg, 2, __assign(__assign(__assign({}, def), {
                DST: def.DST
            }), options));
            var u0 = Point.fromAffine(mapToCurve(u[0]));
            var u1 = Point.fromAffine(mapToCurve(u[1]));
            var P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve: function(msg, options) {
            var u = hash_to_field(msg, 1, __assign(__assign(__assign({}, def), {
                DST: def.encodeDST
            }), options));
            var P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        }
    };
}
exports.createHasher = createHasher;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/curve.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/curve.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateBasic = exports.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities
var modular_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
var _0n = BigInt(0);
var _1n = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    var constTimeNegate = function(condition, item) {
        var neg = item.negate();
        return condition ? neg : item;
    };
    var opts = function(W) {
        var windows = Math.ceil(bits / W) + 1; // +1, because
        var windowSize = Math.pow(2, W - 1); // -1 because we skip zero
        return {
            windows: windows,
            windowSize: windowSize
        };
    };
    return {
        constTimeNegate: constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder: function(elm, n) {
            var p = c.ZERO;
            var d = elm;
            while(n > _0n){
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */ precomputeWindow: function(elm, W) {
            var _a = opts(W), windows = _a.windows, windowSize = _a.windowSize;
            var points = [];
            var p = elm;
            var base = p;
            for(var window_1 = 0; window_1 < windows; window_1++){
                base = p;
                points.push(base);
                // =1, because we skip zero
                for(var i = 1; i < windowSize; i++){
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */ wNAF: function(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            var _a = opts(W), windows = _a.windows, windowSize = _a.windowSize;
            var p = c.ZERO;
            var f = c.BASE;
            var mask = BigInt(Math.pow(2, W) - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            var maxNumber = Math.pow(2, W);
            var shiftBy = BigInt(W);
            for(var window_2 = 0; window_2 < windows; window_2++){
                var offset = window_2 * windowSize;
                // Extract W bits.
                var wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                var offset1 = offset;
                var offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                var cond1 = window_2 % 2 !== 0;
                var cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                } else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return {
                p: p,
                f: f
            };
        },
        wNAFCached: function(P, precomputesMap, n, transform) {
            // @ts-ignore
            var W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            var comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    precomputesMap.set(P, transform(comp));
                }
            }
            return this.wNAF(W, comp, n);
        }
    };
}
exports.wNAF = wNAF;
function validateBasic(curve) {
    (0, modular_1.validateField)(curve.Fp);
    (0, utils_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field'
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger'
    });
    // Set defaults
    return Object.freeze(__assign(__assign(__assign({}, (0, modular_1.nLength)(curve.n, curve.nBitLength)), curve), {
        p: curve.Fp.ORDER
    }));
}
exports.validateBasic = validateBasic;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/weierstrass.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/weierstrass.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y = x + ax + b
var mod = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)"));
var ut = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)"));
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
var curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/curve.js [app-client] (ecmascript)");
function validatePointOpts(curve) {
    var opts = (0, curve_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field'
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function'
    });
    var endo = opts.endo, Fp = opts.Fp, a = opts.a;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze(__assign({}, opts));
}
// ASN.1 DER encoding utilities
var b2n = ut.bytesToNumberBE, h2b = ut.hexToBytes;
exports.DER = {
    // asn.1 DER encoding utils
    Err: function(_super) {
        __extends(DERErr, _super);
        function DERErr(m) {
            if (m === void 0) {
                m = '';
            }
            return _super.call(this, m) || this;
        }
        return DERErr;
    }(Error),
    _parseInt: function(data) {
        var E = exports.DER.Err;
        if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');
        var len = data[1];
        var res = data.subarray(2, len + 2);
        if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 128) throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 128)) throw new E('Invalid signature integer: unnecessary leading zero');
        return {
            d: b2n(res),
            l: data.subarray(len + 2)
        }; // d is data, l is left
    },
    toSig: function(hex) {
        // parse DER signature
        var E = exports.DER.Err;
        var data = typeof hex === 'string' ? h2b(hex) : hex;
        ut.abytes(data);
        var l = data.length;
        if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');
        if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');
        var _a = exports.DER._parseInt(data.subarray(2)), r = _a.d, sBytes = _a.l;
        var _b = exports.DER._parseInt(sBytes), s = _b.d, rBytesLeft = _b.l;
        if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');
        return {
            r: r,
            s: s
        };
    },
    hexFromSig: function(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        var slice = function(s) {
            return Number.parseInt(s[0], 16) & 8 ? '00' + s : s;
        };
        var h = function(num) {
            var hex = num.toString(16);
            return hex.length & 1 ? "0".concat(hex) : hex;
        };
        var s = slice(h(sig.s));
        var r = slice(h(sig.r));
        var shl = s.length / 2;
        var rhl = r.length / 2;
        var sl = h(shl);
        var rl = h(rhl);
        return "30".concat(h(rhl + shl + 4), "02").concat(rl).concat(r, "02").concat(sl).concat(s);
    }
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
var _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    var CURVE = validatePointOpts(opts);
    var Fp = CURVE.Fp; // All curves has same field / group length as for now, but they can differ
    var toBytes = CURVE.toBytes || function(_c, point, _isCompressed) {
        var a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([
            0x04
        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    };
    var fromBytes = CURVE.fromBytes || function(bytes) {
        // const head = bytes[0];
        var tail = bytes.subarray(1);
        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
        var x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        var y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return {
            x: x,
            y: y
        };
    };
    /**
     * y = x + ax + b: Short weierstrass curve formula
     * @returns y
     */ function weierstrassEquation(x) {
        var a = CURVE.a, b = CURVE.b;
        var x2 = Fp.sqr(x); // x * x
        var x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        var lengths = CURVE.allowedPrivateKeyLengths, nByteLength = CURVE.nByteLength, wrapPrivateKey = CURVE.wrapPrivateKey, n = CURVE.n;
        if (lengths && typeof key !== 'bigint') {
            if (ut.isBytes(key)) key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        var num;
        try {
            num = typeof key === 'bigint' ? key : ut.bytesToNumberBE((0, utils_1.ensureBytes)('private key', key, nByteLength));
        } catch (error) {
            throw new Error("private key must be ".concat(nByteLength, " bytes, hex or bigint, not ").concat(typeof key));
        }
        if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    var pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */ var Point = function() {
        function Point(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px)) throw new Error('x required');
            if (py == null || !Fp.isValid(py)) throw new Error('y required');
            if (pz == null || !Fp.isValid(pz)) throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        Point.fromAffine = function(p) {
            var _a = p || {}, x = _a.x, y = _a.y;
            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');
            if (p instanceof Point) throw new Error('projective point not allowed');
            var is0 = function(i) {
                return Fp.eql(i, Fp.ZERO);
            };
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y)) return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        };
        Object.defineProperty(Point.prototype, "x", {
            get: function() {
                return this.toAffine().x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Point.prototype, "y", {
            get: function() {
                return this.toAffine().y;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */ Point.normalizeZ = function(points) {
            var toInv = Fp.invertBatch(points.map(function(p) {
                return p.pz;
            }));
            return points.map(function(p, i) {
                return p.toAffine(toInv[i]);
            }).map(Point.fromAffine);
        };
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */ Point.fromHex = function(hex) {
            var P = Point.fromAffine(fromBytes((0, utils_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        };
        // Multiplies generator point by privateKey.
        Point.fromPrivateKey = function(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        };
        // "Private method", don't use it directly
        Point.prototype._setWindowSize = function(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        };
        // A point on curve is valid if it conforms to equation.
        Point.prototype.assertValidity = function() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            var _a = this.toAffine(), x = _a.x, y = _a.y;
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');
            var left = Fp.sqr(y); // y
            var right = weierstrassEquation(x); // x + ax + b
            if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
        };
        Point.prototype.hasEvenY = function() {
            var y = this.toAffine().y;
            if (Fp.isOdd) return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        };
        /**
         * Compare one point to another.
         */ Point.prototype.equals = function(other) {
            assertPrjPoint(other);
            var _a = this, X1 = _a.px, Y1 = _a.py, Z1 = _a.pz;
            var X2 = other.px, Y2 = other.py, Z2 = other.pz;
            var U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            var U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        };
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */ Point.prototype.negate = function() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        };
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        Point.prototype.double = function() {
            var a = CURVE.a, b = CURVE.b;
            var b3 = Fp.mul(b, _3n);
            var _a = this, X1 = _a.px, Y1 = _a.py, Z1 = _a.pz;
            var X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            var t0 = Fp.mul(X1, X1); // step 1
            var t1 = Fp.mul(Y1, Y1);
            var t2 = Fp.mul(Z1, Z1);
            var t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        };
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        Point.prototype.add = function(other) {
            assertPrjPoint(other);
            var _a = this, X1 = _a.px, Y1 = _a.py, Z1 = _a.pz;
            var X2 = other.px, Y2 = other.py, Z2 = other.pz;
            var X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            var a = CURVE.a;
            var b3 = Fp.mul(CURVE.b, _3n);
            var t0 = Fp.mul(X1, X2); // step 1
            var t1 = Fp.mul(Y1, Y2);
            var t2 = Fp.mul(Z1, Z2);
            var t3 = Fp.add(X1, Y1);
            var t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            var t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        };
        Point.prototype.subtract = function(other) {
            return this.add(other.negate());
        };
        Point.prototype.is0 = function() {
            return this.equals(Point.ZERO);
        };
        Point.prototype.wNAF = function(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, function(comp) {
                var toInv = Fp.invertBatch(comp.map(function(p) {
                    return p.pz;
                }));
                return comp.map(function(p, i) {
                    return p.toAffine(toInv[i]);
                }).map(Point.fromAffine);
            });
        };
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */ Point.prototype.multiplyUnsafe = function(n) {
            var I = Point.ZERO;
            if (n === _0n) return I;
            assertGE(n); // Will throw on 0
            if (n === _1n) return this;
            var endo = CURVE.endo;
            if (!endo) return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            var _a = endo.splitScalar(n), k1neg = _a.k1neg, k1 = _a.k1, k2neg = _a.k2neg, k2 = _a.k2;
            var k1p = I;
            var k2p = I;
            var d = this;
            while(k1 > _0n || k2 > _0n){
                if (k1 & _1n) k1p = k1p.add(d);
                if (k2 & _1n) k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        };
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */ Point.prototype.multiply = function(scalar) {
            assertGE(scalar);
            var n = scalar;
            var point, fake; // Fake point is used to const-time mult
            var endo = CURVE.endo;
            if (endo) {
                var _a = endo.splitScalar(n), k1neg = _a.k1neg, k1 = _a.k1, k2neg = _a.k2neg, k2 = _a.k2;
                var _b = this.wNAF(k1), k1p = _b.p, f1p = _b.f;
                var _d = this.wNAF(k2), k2p = _d.p, f2p = _d.f;
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            } else {
                var _e = this.wNAF(n), p = _e.p, f = _e.f;
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([
                point,
                fake
            ])[0];
        };
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */ Point.prototype.multiplyAndAddUnsafe = function(Q, a, b) {
            var G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            var mul = function(P, a // Select faster multiply() method
            ) {
                return a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);
            };
            var sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        };
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        Point.prototype.toAffine = function(iz) {
            var _a = this, x = _a.px, y = _a.py, z = _a.pz;
            var is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
            var ax = Fp.mul(x, iz);
            var ay = Fp.mul(y, iz);
            var zz = Fp.mul(z, iz);
            if (is0) return {
                x: Fp.ZERO,
                y: Fp.ZERO
            };
            if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');
            return {
                x: ax,
                y: ay
            };
        };
        Point.prototype.isTorsionFree = function() {
            var cofactor = CURVE.h, isTorsionFree = CURVE.isTorsionFree;
            if (cofactor === _1n) return true; // No subgroups, always torsion-free
            if (isTorsionFree) return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        };
        Point.prototype.clearCofactor = function() {
            var cofactor = CURVE.h, clearCofactor = CURVE.clearCofactor;
            if (cofactor === _1n) return this; // Fast-path
            if (clearCofactor) return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        };
        Point.prototype.toRawBytes = function(isCompressed) {
            if (isCompressed === void 0) {
                isCompressed = true;
            }
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        };
        Point.prototype.toHex = function(isCompressed) {
            if (isCompressed === void 0) {
                isCompressed = true;
            }
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        };
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
        Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
        return Point;
    }();
    var _bits = CURVE.nBitLength;
    var wnaf = (0, curve_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE: CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        weierstrassEquation: weierstrassEquation,
        isWithinCurveOrder: isWithinCurveOrder
    };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
    var opts = (0, curve_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function'
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean'
    });
    return Object.freeze(__assign({
        lowS: true
    }, opts));
}
function weierstrass(curveDef) {
    var CURVE = validateOpts(curveDef);
    var Fp = CURVE.Fp, CURVE_ORDER = CURVE.n;
    var compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    var uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    var _a = weierstrassPoints(__assign(__assign({}, CURVE), {
        toBytes: function(_c, point, isCompressed) {
            var a = point.toAffine();
            var x = Fp.toBytes(a.x);
            var cat = ut.concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([
                    point.hasEvenY() ? 0x02 : 0x03
                ]), x);
            } else {
                return cat(Uint8Array.from([
                    0x04
                ]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes: function(bytes) {
            var len = bytes.length;
            var head = bytes[0];
            var tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                var x = ut.bytesToNumberBE(tail);
                if (!isValidFieldElement(x)) throw new Error('Point is not on curve');
                var y2 = weierstrassEquation(x); // y = x + ax + b
                var y = void 0;
                try {
                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                } catch (sqrtError) {
                    var suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                    throw new Error('Point is not on curve' + suffix);
                }
                var isYOdd = (y & _1n) === _1n;
                // ECDSA
                var isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd) y = Fp.neg(y);
                return {
                    x: x,
                    y: y
                };
            } else if (len === uncompressedLen && head === 0x04) {
                var x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                var y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return {
                    x: x,
                    y: y
                };
            } else {
                throw new Error("Point of length ".concat(len, " was invalid. Expected ").concat(compressedLen, " compressed bytes or ").concat(uncompressedLen, " uncompressed bytes"));
            }
        }
    })), Point = _a.ProjectivePoint, normPrivateKeyToScalar = _a.normPrivateKeyToScalar, weierstrassEquation = _a.weierstrassEquation, isWithinCurveOrder = _a.isWithinCurveOrder;
    var numToNByteStr = function(num) {
        return ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    };
    function isBiggerThanHalfOrder(number) {
        var HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    var slcNum = function(b, from, to) {
        return ut.bytesToNumberBE(b.slice(from, to));
    };
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */ var Signature = function() {
        function Signature(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        Signature.fromCompact = function(hex) {
            var l = CURVE.nByteLength;
            hex = (0, utils_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        };
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        Signature.fromDER = function(hex) {
            var _a = exports.DER.toSig((0, utils_1.ensureBytes)('DER', hex)), r = _a.r, s = _a.s;
            return new Signature(r, s);
        };
        Signature.prototype.assertValidity = function() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');
        };
        Signature.prototype.addRecoveryBit = function(recovery) {
            return new Signature(this.r, this.s, recovery);
        };
        Signature.prototype.recoverPublicKey = function(msgHash) {
            var _a = this, r = _a.r, s = _a.s, rec = _a.recovery;
            var h = bits2int_modN((0, utils_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![
                0,
                1,
                2,
                3
            ].includes(rec)) throw new Error('recovery id invalid');
            var radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');
            var prefix = (rec & 1) === 0 ? '02' : '03';
            var R = Point.fromHex(prefix + numToNByteStr(radj));
            var ir = invN(radj); // r^-1
            var u1 = modN(-h * ir); // -hr^-1
            var u2 = modN(s * ir); // sr^-1
            var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        };
        // Signatures should be low-s, to prevent malleability.
        Signature.prototype.hasHighS = function() {
            return isBiggerThanHalfOrder(this.s);
        };
        Signature.prototype.normalizeS = function() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        };
        // DER-encoded
        Signature.prototype.toDERRawBytes = function() {
            return ut.hexToBytes(this.toDERHex());
        };
        Signature.prototype.toDERHex = function() {
            return exports.DER.hexFromSig({
                r: this.r,
                s: this.s
            });
        };
        // padded bytes of r, then padded bytes of s
        Signature.prototype.toCompactRawBytes = function() {
            return ut.hexToBytes(this.toCompactHex());
        };
        Signature.prototype.toCompactHex = function() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        };
        return Signature;
    }();
    var utils = {
        isValidPrivateKey: function(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            } catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */ randomPrivateKey: function() {
            var length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */ precompute: function(windowSize, point) {
            if (windowSize === void 0) {
                windowSize = 8;
            }
            if (point === void 0) {
                point = Point.BASE;
            }
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        }
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */ function getPublicKey(privateKey, isCompressed) {
        if (isCompressed === void 0) {
            isCompressed = true;
        }
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */ function isProbPub(item) {
        var arr = ut.isBytes(item);
        var str = typeof item === 'string';
        var len = (arr || str) && item.length;
        if (arr) return len === compressedLen || len === uncompressedLen;
        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point) return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */ function getSharedSecret(privateA, publicB, isCompressed) {
        if (isCompressed === void 0) {
            isCompressed = true;
        }
        if (isProbPub(privateA)) throw new Error('first arg must be private key');
        if (!isProbPub(publicB)) throw new Error('second arg must be public key');
        var b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    var bits2int = CURVE.bits2int || function(bytes) {
        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
        // for some cases, since bytes.length * 8 is not actual bitLength.
        var num = ut.bytesToNumberBE(bytes); // check for == u8 done here
        var delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
        return delta > 0 ? num >> BigInt(delta) : num;
    };
    var bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes)); // can't use bytesToNumberBE here
    };
    // NOTE: pads output with zero as per spec
    var ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */ function int2octets(num) {
        if (typeof num !== 'bigint') throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK)) throw new Error("bigint expected < 2^".concat(CURVE.nBitLength));
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts) {
        if (opts === void 0) {
            opts = defaultSigOpts;
        }
        if ([
            'recovered',
            'canonical'
        ].some(function(k) {
            return k in opts;
        })) throw new Error('sign() legacy options not supported');
        var hash = CURVE.hash, randomBytes = CURVE.randomBytes;
        var lowS = opts.lowS, prehash = opts.prehash, ent = opts.extraEntropy; // generates low-s sigs by default
        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_1.ensureBytes)('msgHash', msgHash);
        if (prehash) msgHash = (0, utils_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        var h1int = bits2int_modN(msgHash);
        var d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        var seedArgs = [
            int2octets(d),
            int2octets(h1int)
        ];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null && ent !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            var e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        var seed = ut.concatBytes.apply(ut, __spreadArray([], __read(seedArgs), false)); // Step D of RFC6979 3.2
        var m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            var k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N
            var ik = invN(k); // k^-1 mod n
            var q = Point.BASE.multiply(k).toAffine(); // q = Gk
            var r = modN(q.x); // r = q.x mod n
            if (r === _0n) return;
            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            var s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n) return;
            var recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            var normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return {
            seed: seed,
            k2sig: k2sig
        };
    }
    var defaultSigOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    var defaultVerOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */ function sign(msgHash, privKey, opts) {
        if (opts === void 0) {
            opts = defaultSigOpts;
        }
        var _a = prepSig(msgHash, privKey, opts), seed = _a.seed, k2sig = _a.k2sig; // Steps A, D of RFC6979 3.2.
        var C = CURVE;
        var drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */ function verify(signature, msgHash, publicKey, opts) {
        var _a;
        if (opts === void 0) {
            opts = defaultVerOpts;
        }
        var sg = signature;
        msgHash = (0, utils_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts) throw new Error('options.strict was renamed to lowS');
        var lowS = opts.lowS, prehash = opts.prehash;
        var _sig = undefined;
        var P;
        try {
            if (typeof sg === 'string' || ut.isBytes(sg)) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                } catch (derError) {
                    if (!(derError instanceof exports.DER.Err)) throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                var r_1 = sg.r, s_1 = sg.s;
                _sig = new Signature(r_1, s_1);
            } else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        } catch (error) {
            if (error.message === 'PARSE') throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return false;
        }
        if (lowS && _sig.hasHighS()) return false;
        if (prehash) msgHash = CURVE.hash(msgHash);
        var r = _sig.r, s = _sig.s;
        var h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        var is = invN(s); // s^-1
        var u1 = modN(h * is); // u1 = hs^-1 mod n
        var u2 = modN(r * is); // u2 = rs^-1 mod n
        var R = (_a = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _a === void 0 ? void 0 : _a.toAffine(); // R = u1G + u2P
        if (!R) return false;
        var v = modN(R.x);
        return v === r;
    }
    return {
        CURVE: CURVE,
        getPublicKey: getPublicKey,
        getSharedSecret: getSharedSecret,
        sign: sign,
        verify: verify,
        ProjectivePoint: Point,
        Signature: Signature,
        utils: utils
    };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */ function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    var q = Fp.ORDER;
    var l = _0n;
    for(var o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;
    var c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    var _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
    var _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    var c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    var c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    var c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    var c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    var c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    var c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    var sqrtRatio = function(u, v) {
        var tv1 = c6; // 1. tv1 = c6
        var tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        var tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        var tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        var tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        var isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for(var i = c1; i > _1n; i--){
            var tv5_1 = i - _2n; // 18.    tv5 = i - 2
            tv5_1 = _2n << tv5_1 - _1n; // 19.    tv5 = 2^tv5
            var tvv5 = Fp.pow(tv4, tv5_1); // 20.    tv5 = tv4^tv5
            var e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return {
            isValid: isQR,
            value: tv3
        };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        var c1_1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        var c2_1 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = function(u, v) {
            var tv1 = Fp.sqr(v); // 1. tv1 = v^2
            var tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            var y1 = Fp.pow(tv1, c1_1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            var y2 = Fp.mul(y1, c2_1); // 6. y2 = y1 * c2
            var tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            var isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            var y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return {
                isValid: isQR,
                value: y
            }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */ function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');
    var sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return function(u) {
        // prettier-ignore
        var tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        var _a = sqrtRatio(tv2, tv6), isValid = _a.isValid, value = _a.value; // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        var e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return {
            x: x,
            y: y
        };
    };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/bls.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/bls.ts#

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bls = void 0;
var modular_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
// prettier-ignore
var hash_to_curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)");
var weierstrass_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/weierstrass.js [app-client] (ecmascript)");
// prettier-ignore
var _2n = BigInt(2), _3n = BigInt(3);
function bls(CURVE) {
    // Fields are specific for curve, so for now we'll need to pass them with opts
    var _a = CURVE.fields, Fp = _a.Fp, Fr = _a.Fr, Fp2 = _a.Fp2, Fp6 = _a.Fp6, Fp12 = _a.Fp12;
    var BLS_X_LEN = (0, utils_1.bitLen)(CURVE.params.x);
    // Pre-compute coefficients for sparse multiplication
    // Point addition and point double calculations is reused for coefficients
    function calcPairingPrecomputes(p) {
        var x = p.x, y = p.y;
        // prettier-ignore
        var Qx = x, Qy = y, Qz = Fp2.ONE;
        // prettier-ignore
        var Rx = Qx, Ry = Qy, Rz = Qz;
        var ell_coeff = [];
        for(var i = BLS_X_LEN - 2; i >= 0; i--){
            // Double
            var t0 = Fp2.sqr(Ry); // Ry
            var t1 = Fp2.sqr(Rz); // Rz
            var t2 = Fp2.multiplyByB(Fp2.mul(t1, _3n)); // 3 * T1 * B
            var t3 = Fp2.mul(t2, _3n); // 3 * T2
            var t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz) - T1 - T0
            ell_coeff.push([
                Fp2.sub(t2, t0),
                Fp2.mul(Fp2.sqr(Rx), _3n),
                Fp2.neg(t4)
            ]);
            Rx = Fp2.div(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), _2n); // ((T0 - T3) * Rx * Ry) / 2
            Ry = Fp2.sub(Fp2.sqr(Fp2.div(Fp2.add(t0, t3), _2n)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2) - 3 * T2
            Rz = Fp2.mul(t0, t4); // T0 * T4
            if ((0, utils_1.bitGet)(CURVE.params.x, i)) {
                // Addition
                var t0_1 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz
                var t1_1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz
                ell_coeff.push([
                    Fp2.sub(Fp2.mul(t0_1, Qx), Fp2.mul(t1_1, Qy)),
                    Fp2.neg(t0_1),
                    t1_1
                ]);
                var t2_1 = Fp2.sqr(t1_1); // T1
                var t3_1 = Fp2.mul(t2_1, t1_1); // T2 * T1
                var t4_1 = Fp2.mul(t2_1, Rx); // T2 * Rx
                var t5 = Fp2.add(Fp2.sub(t3_1, Fp2.mul(t4_1, _2n)), Fp2.mul(Fp2.sqr(t0_1), Rz)); // T3 - 2 * T4 + T0 * Rz
                Rx = Fp2.mul(t1_1, t5); // T1 * T5
                Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4_1, t5), t0_1), Fp2.mul(t3_1, Ry)); // (T4 - T5) * T0 - T3 * Ry
                Rz = Fp2.mul(Rz, t3_1); // Rz * T3
            }
        }
        return ell_coeff;
    }
    function millerLoop(ell, g1) {
        var x = CURVE.params.x;
        var Px = g1[0];
        var Py = g1[1];
        var f12 = Fp12.ONE;
        for(var j = 0, i = BLS_X_LEN - 2; i >= 0; i--, j++){
            var E = ell[j];
            f12 = Fp12.multiplyBy014(f12, E[0], Fp2.mul(E[1], Px), Fp2.mul(E[2], Py));
            if ((0, utils_1.bitGet)(x, i)) {
                j += 1;
                var F = ell[j];
                f12 = Fp12.multiplyBy014(f12, F[0], Fp2.mul(F[1], Px), Fp2.mul(F[2], Py));
            }
            if (i !== 0) f12 = Fp12.sqr(f12);
        }
        return Fp12.conjugate(f12);
    }
    var utils = {
        randomPrivateKey: function() {
            var length = (0, modular_1.getMinHashLength)(Fr.ORDER);
            return (0, modular_1.mapHashToField)(CURVE.randomBytes(length), Fr.ORDER);
        },
        calcPairingPrecomputes: calcPairingPrecomputes
    };
    // Point on G1 curve: (x, y)
    var G1_ = (0, weierstrass_1.weierstrassPoints)(__assign({
        n: Fr.ORDER
    }, CURVE.G1));
    var G1 = Object.assign(G1_, (0, hash_to_curve_1.createHasher)(G1_.ProjectivePoint, CURVE.G1.mapToCurve, __assign(__assign({}, CURVE.htfDefaults), CURVE.G1.htfDefaults)));
    function pairingPrecomputes(point) {
        var p = point;
        if (p._PPRECOMPUTES) return p._PPRECOMPUTES;
        p._PPRECOMPUTES = calcPairingPrecomputes(point.toAffine());
        return p._PPRECOMPUTES;
    }
    // TODO: export
    // function clearPairingPrecomputes(point: G2) {
    //   const p = point as G2 & withPairingPrecomputes;
    //   p._PPRECOMPUTES = undefined;
    // }
    // Point on G2 curve (complex numbers): (x, x+i), (y, y+i)
    var G2_ = (0, weierstrass_1.weierstrassPoints)(__assign({
        n: Fr.ORDER
    }, CURVE.G2));
    var G2 = Object.assign(G2_, (0, hash_to_curve_1.createHasher)(G2_.ProjectivePoint, CURVE.G2.mapToCurve, __assign(__assign({}, CURVE.htfDefaults), CURVE.G2.htfDefaults)));
    var ShortSignature = CURVE.G1.ShortSignature;
    var Signature = CURVE.G2.Signature;
    // Calculates bilinear pairing
    function pairing(Q, P, withFinalExponent) {
        if (withFinalExponent === void 0) {
            withFinalExponent = true;
        }
        if (Q.equals(G1.ProjectivePoint.ZERO) || P.equals(G2.ProjectivePoint.ZERO)) throw new Error('pairing is not available for ZERO point');
        Q.assertValidity();
        P.assertValidity();
        // Performance: 9ms for millerLoop and ~14ms for exp.
        var Qa = Q.toAffine();
        var looped = millerLoop(pairingPrecomputes(P), [
            Qa.x,
            Qa.y
        ]);
        return withFinalExponent ? Fp12.finalExponentiate(looped) : looped;
    }
    function normP1(point) {
        return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);
    }
    function normP1Hash(point, htfOpts) {
        return point instanceof G1.ProjectivePoint ? point : G1.hashToCurve((0, utils_1.ensureBytes)('point', point), htfOpts);
    }
    function normP2(point) {
        return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);
    }
    function normP2Hash(point, htfOpts) {
        return point instanceof G2.ProjectivePoint ? point : G2.hashToCurve((0, utils_1.ensureBytes)('point', point), htfOpts);
    }
    // Multiplies generator (G1) by private key.
    // P = pk x G
    function getPublicKey(privateKey) {
        return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
    }
    // Multiplies generator (G2) by private key.
    // P = pk x G
    function getPublicKeyForShortSignatures(privateKey) {
        return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
    }
    function sign(message, privateKey, htfOpts) {
        var msgPoint = normP2Hash(message, htfOpts);
        msgPoint.assertValidity();
        var sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
        if (message instanceof G2.ProjectivePoint) return sigPoint;
        return Signature.toRawBytes(sigPoint);
    }
    function signShortSignature(message, privateKey, htfOpts) {
        var msgPoint = normP1Hash(message, htfOpts);
        msgPoint.assertValidity();
        var sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
        if (message instanceof G1.ProjectivePoint) return sigPoint;
        return ShortSignature.toRawBytes(sigPoint);
    }
    // Checks if pairing of public key & hash is equal to pairing of generator & signature.
    // e(P, H(m)) == e(G, S)
    function verify(signature, message, publicKey, htfOpts) {
        var P = normP1(publicKey);
        var Hm = normP2Hash(message, htfOpts);
        var G = G1.ProjectivePoint.BASE;
        var S = normP2(signature);
        // Instead of doing 2 exponentiations, we use property of billinear maps
        // and do one exp after multiplying 2 points.
        var ePHm = pairing(P.negate(), Hm, false);
        var eGS = pairing(G, S, false);
        var exp = Fp12.finalExponentiate(Fp12.mul(eGS, ePHm));
        return Fp12.eql(exp, Fp12.ONE);
    }
    // Checks if pairing of public key & hash is equal to pairing of generator & signature.
    // e(S, G) == e(H(m), P)
    function verifyShortSignature(signature, message, publicKey, htfOpts) {
        var P = normP2(publicKey);
        var Hm = normP1Hash(message, htfOpts);
        var G = G2.ProjectivePoint.BASE;
        var S = normP1(signature);
        // Instead of doing 2 exponentiations, we use property of billinear maps
        // and do one exp after multiplying 2 points.
        var eHmP = pairing(Hm, P, false);
        var eSG = pairing(S, G.negate(), false);
        var exp = Fp12.finalExponentiate(Fp12.mul(eSG, eHmP));
        return Fp12.eql(exp, Fp12.ONE);
    }
    function aggregatePublicKeys(publicKeys) {
        if (!publicKeys.length) throw new Error('Expected non-empty array');
        var agg = publicKeys.map(normP1).reduce(function(sum, p) {
            return sum.add(p);
        }, G1.ProjectivePoint.ZERO);
        var aggAffine = agg; //.toAffine();
        if (publicKeys[0] instanceof G1.ProjectivePoint) {
            aggAffine.assertValidity();
            return aggAffine;
        }
        // toRawBytes ensures point validity
        return aggAffine.toRawBytes(true);
    }
    function aggregateSignatures(signatures) {
        if (!signatures.length) throw new Error('Expected non-empty array');
        var agg = signatures.map(normP2).reduce(function(sum, s) {
            return sum.add(s);
        }, G2.ProjectivePoint.ZERO);
        var aggAffine = agg; //.toAffine();
        if (signatures[0] instanceof G2.ProjectivePoint) {
            aggAffine.assertValidity();
            return aggAffine;
        }
        return Signature.toRawBytes(aggAffine);
    }
    function aggregateShortSignatures(signatures) {
        if (!signatures.length) throw new Error('Expected non-empty array');
        var agg = signatures.map(normP1).reduce(function(sum, s) {
            return sum.add(s);
        }, G1.ProjectivePoint.ZERO);
        var aggAffine = agg; //.toAffine();
        if (signatures[0] instanceof G1.ProjectivePoint) {
            aggAffine.assertValidity();
            return aggAffine;
        }
        return ShortSignature.toRawBytes(aggAffine);
    }
    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407
    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))
    function verifyBatch(signature, messages, publicKeys, htfOpts) {
        // @ts-ignore
        // console.log('verifyBatch', bytesToHex(signature as any), messages, publicKeys.map(bytesToHex));
        var e_1, _a;
        if (!messages.length) throw new Error('Expected non-empty messages array');
        if (publicKeys.length !== messages.length) throw new Error('Pubkey count should equal msg count');
        var sig = normP2(signature);
        var nMessages = messages.map(function(i) {
            return normP2Hash(i, htfOpts);
        });
        var nPublicKeys = publicKeys.map(normP1);
        try {
            var paired = [];
            var _loop_1 = function(message) {
                var groupPublicKey = nMessages.reduce(function(groupPublicKey, subMessage, i) {
                    return subMessage === message ? groupPublicKey.add(nPublicKeys[i]) : groupPublicKey;
                }, G1.ProjectivePoint.ZERO);
                // const msg = message instanceof PointG2 ? message : await PointG2.hashToCurve(message);
                // Possible to batch pairing for same msg with different groupPublicKey here
                paired.push(pairing(groupPublicKey, message, false));
            };
            try {
                for(var _b = __values(new Set(nMessages)), _c = _b.next(); !_c.done; _c = _b.next()){
                    var message = _c.value;
                    _loop_1(message);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            paired.push(pairing(G1.ProjectivePoint.BASE.negate(), sig, false));
            var product = paired.reduce(function(a, b) {
                return Fp12.mul(a, b);
            }, Fp12.ONE);
            var exp = Fp12.finalExponentiate(product);
            return Fp12.eql(exp, Fp12.ONE);
        } catch (_d) {
            return false;
        }
    }
    G1.ProjectivePoint.BASE._setWindowSize(4);
    return {
        getPublicKey: getPublicKey,
        getPublicKeyForShortSignatures: getPublicKeyForShortSignatures,
        sign: sign,
        signShortSignature: signShortSignature,
        verify: verify,
        verifyBatch: verifyBatch,
        verifyShortSignature: verifyShortSignature,
        aggregatePublicKeys: aggregatePublicKeys,
        aggregateSignatures: aggregateSignatures,
        aggregateShortSignatures: aggregateShortSignatures,
        millerLoop: millerLoop,
        pairing: pairing,
        G1: G1,
        G2: G2,
        Signature: Signature,
        ShortSignature: ShortSignature,
        fields: {
            Fr: Fr,
            Fp: Fp,
            Fp2: Fp2,
            Fp6: Fp6,
            Fp12: Fp12
        },
        params: {
            x: CURVE.params.x,
            r: CURVE.params.r,
            G1b: CURVE.G1.b,
            G2b: CURVE.G2.b
        },
        utils: utils
    };
}
exports.bls = bls;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_assert.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, not ".concat(n));
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean') throw new Error("boolean expected, not ".concat(b));
}
exports.bool = bool;
// copied from utils
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';
}
exports.isBytes = isBytes;
function bytes(b) {
    var lengths = [];
    for(var _i = 1; _i < arguments.length; _i++){
        lengths[_i - 1] = arguments[_i];
    }
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length ".concat(lengths, ", not of length=").concat(b.length));
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished) {
    if (checkFinished === void 0) {
        checkFinished = true;
    }
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    var min = instance.outputLen;
    if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least ".concat(min));
    }
}
exports.output = output;
var assert = {
    number: number,
    bool: bool,
    bytes: bytes,
    hash: hash,
    exists: exists,
    output: output
};
exports.default = assert;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_md.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HashMD = exports.Maj = exports.Chi = void 0;
var _assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_assert.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    var _32n = BigInt(32);
    var _u32_max = BigInt(0xffffffff);
    var wh = Number(value >> _32n & _u32_max);
    var wl = Number(value & _u32_max);
    var h = isLE ? 4 : 0;
    var l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Choice: a ? b : c
var Chi = function(a, b, c) {
    return a & b ^ ~a & c;
};
exports.Chi = Chi;
// Majority function, true if any two inpust is true
var Maj = function(a, b, c) {
    return a & b ^ a & c ^ b & c;
};
exports.Maj = Maj;
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */ var HashMD = function(_super) {
    __extends(HashMD, _super);
    function HashMD(blockLen, outputLen, padOffset, isLE) {
        var _this = _super.call(this) || this;
        _this.blockLen = blockLen;
        _this.outputLen = outputLen;
        _this.padOffset = padOffset;
        _this.isLE = isLE;
        _this.finished = false;
        _this.length = 0;
        _this.pos = 0;
        _this.destroyed = false;
        _this.buffer = new Uint8Array(blockLen);
        _this.view = (0, utils_1.createView)(_this.buffer);
        return _this;
    }
    HashMD.prototype.update = function(data) {
        (0, _assert_1.exists)(this);
        var _a = this, view = _a.view, buffer = _a.buffer, blockLen = _a.blockLen;
        data = (0, utils_1.toBytes)(data);
        var len = data.length;
        for(var pos = 0; pos < len;){
            var take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                var dataView = (0, utils_1.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    };
    HashMD.prototype.digestInto = function(out) {
        (0, _assert_1.exists)(this);
        (0, _assert_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        var _a = this, buffer = _a.buffer, view = _a.view, blockLen = _a.blockLen, isLE = _a.isLE;
        var pos = this.pos;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(var i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        var oview = (0, utils_1.createView)(out);
        var len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        var outLen = len / 4;
        var state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for(var i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    };
    HashMD.prototype.digest = function() {
        var _a = this, buffer = _a.buffer, outputLen = _a.outputLen;
        this.digestInto(buffer);
        var res = Uint8Array.prototype.slice.call(buffer, 0, outputLen);
        this.destroy();
        return res;
    };
    HashMD.prototype._cloneInto = function(to) {
        to || (to = new this.constructor());
        to.set.apply(to, __spreadArray([], __read(this.get()), false));
        var _a = this, blockLen = _a.blockLen, buffer = _a.buffer, length = _a.length, finished = _a.finished, destroyed = _a.destroyed, pos = _a.pos;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    };
    return HashMD;
}(utils_1.Hash);
exports.HashMD = HashMD;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/sha256.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha224 = exports.sha256 = void 0;
var _md_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_md.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
var SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = function(_super) {
    __extends(SHA256, _super);
    function SHA256() {
        var _this = _super.call(this, 64, 32, 8, false) || this;
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        _this.A = SHA256_IV[0] | 0;
        _this.B = SHA256_IV[1] | 0;
        _this.C = SHA256_IV[2] | 0;
        _this.D = SHA256_IV[3] | 0;
        _this.E = SHA256_IV[4] | 0;
        _this.F = SHA256_IV[5] | 0;
        _this.G = SHA256_IV[6] | 0;
        _this.H = SHA256_IV[7] | 0;
        return _this;
    }
    SHA256.prototype.get = function() {
        var _a = this, A = _a.A, B = _a.B, C = _a.C, D = _a.D, E = _a.E, F = _a.F, G = _a.G, H = _a.H;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    };
    // prettier-ignore
    SHA256.prototype.set = function(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    };
    SHA256.prototype.process = function(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(var i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(var i = 16; i < 64; i++){
            var W15 = SHA256_W[i - 15];
            var W2 = SHA256_W[i - 2];
            var s0 = (0, utils_1.rotr)(W15, 7) ^ (0, utils_1.rotr)(W15, 18) ^ W15 >>> 3;
            var s1 = (0, utils_1.rotr)(W2, 17) ^ (0, utils_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        var _a = this, A = _a.A, B = _a.B, C = _a.C, D = _a.D, E = _a.E, F = _a.F, G = _a.G, H = _a.H;
        for(var i = 0; i < 64; i++){
            var sigma1 = (0, utils_1.rotr)(E, 6) ^ (0, utils_1.rotr)(E, 11) ^ (0, utils_1.rotr)(E, 25);
            var T1 = H + sigma1 + (0, _md_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            var sigma0 = (0, utils_1.rotr)(A, 2) ^ (0, utils_1.rotr)(A, 13) ^ (0, utils_1.rotr)(A, 22);
            var T2 = sigma0 + (0, _md_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    };
    SHA256.prototype.roundClean = function() {
        SHA256_W.fill(0);
    };
    SHA256.prototype.destroy = function() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    };
    return SHA256;
}(_md_1.HashMD);
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
var SHA224 = function(_super) {
    __extends(SHA224, _super);
    function SHA224() {
        var _this = _super.call(this) || this;
        _this.A = 0xc1059ed8 | 0;
        _this.B = 0x367cd507 | 0;
        _this.C = 0x3070dd17 | 0;
        _this.D = 0xf70e5939 | 0;
        _this.E = 0xffc00b31 | 0;
        _this.F = 0x68581511 | 0;
        _this.G = 0x64f98fa7 | 0;
        _this.H = 0xbefa4fa4 | 0;
        _this.outputLen = 28;
        return _this;
    }
    return SHA224;
}(SHA256);
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */ exports.sha256 = (0, utils_1.wrapConstructor)(function() {
    return new SHA256();
});
exports.sha224 = (0, utils_1.wrapConstructor)(function() {
    return new SHA224();
});
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/bls12_381.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/bls12-381.ts#L1

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bls12_381 = exports.G2_mapToCurve = exports.G1_mapToCurve = exports.G1_formBytes = exports.parseMask = exports.Fp12 = exports.Fp12_ONE = exports.Fp12_eql = exports.Fp12_conjugate = exports.Fp12_finalExponentiate = exports.Fp12Multiply = exports.Fp2 = exports.Fp = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:
// - Construct zk-SNARKs at the 120-bit security
// - Efficiently verify N aggregate signatures with 1 pairing and N ec additions:
//   the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr
//
// ### Summary
// 1. BLS Relies on Bilinear Pairing (expensive)
// 2. Private Keys: 32 bytes
// 3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.
// 4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.
//     - The signature is a point on the G2 subgroup, which is defined over a finite field
//     with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the complex numbers).
// 5. The 12 stands for the Embedding degree.
//
// ### Formulas
// - `P = pk x G` - public keys
// - `S = pk x H(m)` - signing
// - `e(P, H(m)) == e(G, S)` - verification using pairings
// - `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation
//
// ### Compatibility and notes
// 1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC
//    Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.
// 2. Some projects use G2 for public keys and G1 for signatures. It's called "short signature"
// 3. Curve security level is about 120 bits as per Barbulescu-Duquesne 2017
//    https://hal.science/hal-01534101/file/main.pdf
// 4. Compatible with specs:
// [cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),
// [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05),
// [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380).
var bls_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/bls.js [app-client] (ecmascript)");
var mod = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)"));
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
// Types
var weierstrass_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/weierstrass.js [app-client] (ecmascript)");
var hash_to_curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)");
var sha256_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/sha256.js [app-client] (ecmascript)");
var utils_2 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
var _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
// prettier-ignore
var _8n = BigInt(8), _16n = BigInt(16);
// CURVE FIELDS
// Finite field over p.
var Fp_raw = BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab');
exports.Fp = mod.Field(Fp_raw);
// Finite field over r.
// This particular field is not used anywhere in bls12-381, but it is still useful.
var Fr = mod.Field(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));
var Fp2Add = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return {
        c0: exports.Fp.add(c0, r0),
        c1: exports.Fp.add(c1, r1)
    };
};
var Fp2Subtract = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return {
        c0: exports.Fp.sub(c0, r0),
        c1: exports.Fp.sub(c1, r1)
    };
};
var Fp2Multiply = function(_a, rhs) {
    var c0 = _a.c0, c1 = _a.c1;
    if (typeof rhs === 'bigint') return {
        c0: exports.Fp.mul(c0, rhs),
        c1: exports.Fp.mul(c1, rhs)
    };
    // (a+bi)(c+di) = (acbd) + (ad+bc)i
    var r0 = rhs.c0, r1 = rhs.c1;
    var t1 = exports.Fp.mul(c0, r0); // c0 * o0
    var t2 = exports.Fp.mul(c1, r1); // c1 * o1
    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i
    var o0 = exports.Fp.sub(t1, t2);
    var o1 = exports.Fp.sub(exports.Fp.mul(exports.Fp.add(c0, c1), exports.Fp.add(r0, r1)), exports.Fp.add(t1, t2));
    return {
        c0: o0,
        c1: o1
    };
};
var Fp2Square = function(_a) {
    var c0 = _a.c0, c1 = _a.c1;
    var a = exports.Fp.add(c0, c1);
    var b = exports.Fp.sub(c0, c1);
    var c = exports.Fp.add(c0, c0);
    return {
        c0: exports.Fp.mul(a, b),
        c1: exports.Fp.mul(c, c1)
    };
};
// G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),
// where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where
// G - 1
// h2q
// NOTE: ORDER was wrong!
var FP2_ORDER = Fp_raw * Fp_raw;
exports.Fp2 = {
    ORDER: FP2_ORDER,
    BITS: (0, utils_1.bitLen)(FP2_ORDER),
    BYTES: Math.ceil((0, utils_1.bitLen)(FP2_ORDER) / 8),
    MASK: (0, utils_1.bitMask)((0, utils_1.bitLen)(FP2_ORDER)),
    ZERO: {
        c0: exports.Fp.ZERO,
        c1: exports.Fp.ZERO
    },
    ONE: {
        c0: exports.Fp.ONE,
        c1: exports.Fp.ZERO
    },
    create: function(num) {
        return num;
    },
    isValid: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return typeof c0 === 'bigint' && typeof c1 === 'bigint';
    },
    is0: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return exports.Fp.is0(c0) && exports.Fp.is0(c1);
    },
    eql: function(_a, _b) {
        var c0 = _a.c0, c1 = _a.c1;
        var r0 = _b.c0, r1 = _b.c1;
        return exports.Fp.eql(c0, r0) && exports.Fp.eql(c1, r1);
    },
    neg: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: exports.Fp.neg(c0),
            c1: exports.Fp.neg(c1)
        };
    },
    pow: function(num, power) {
        return mod.FpPow(exports.Fp2, num, power);
    },
    invertBatch: function(nums) {
        return mod.FpInvertBatch(exports.Fp2, nums);
    },
    // Normalized
    add: Fp2Add,
    sub: Fp2Subtract,
    mul: Fp2Multiply,
    sqr: Fp2Square,
    // NonNormalized stuff
    addN: Fp2Add,
    subN: Fp2Subtract,
    mulN: Fp2Multiply,
    sqrN: Fp2Square,
    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?
    div: function(lhs, rhs) {
        return exports.Fp2.mul(lhs, typeof rhs === 'bigint' ? exports.Fp.inv(exports.Fp.create(rhs)) : exports.Fp2.inv(rhs));
    },
    inv: function(_a) {
        var a = _a.c0, b = _a.c1;
        // We wish to find the multiplicative inverse of a nonzero
        // element a + bu in Fp2. We leverage an identity
        //
        // (a + bu)(a - bu) = a + b
        //
        // which holds because u = -1. This can be rewritten as
        //
        // (a + bu)(a - bu)/(a + b) = 1
        //
        // because a + b = 0 has no nonzero solutions for (a, b).
        // This gives that (a - bu)/(a + b) is the inverse
        // of (a + bu). Importantly, this can be computing using
        // only a single inversion in Fp.
        var factor = exports.Fp.inv(exports.Fp.create(a * a + b * b));
        return {
            c0: exports.Fp.mul(factor, exports.Fp.create(a)),
            c1: exports.Fp.mul(factor, exports.Fp.create(-b))
        };
    },
    sqrt: function(num) {
        if (exports.Fp2.eql(num, exports.Fp2.ZERO)) return exports.Fp2.ZERO; // Algo doesn't handles this case
        // TODO: Optimize this line. It's extremely slow.
        // Speeding this up would boost aggregateSignatures.
        // https://eprint.iacr.org/2012/685.pdf applicable?
        // https://github.com/zkcrypto/bls12_381/blob/080eaa74ec0e394377caa1ba302c8c121df08b07/src/fp2.rs#L250
        // https://github.com/supranational/blst/blob/aae0c7d70b799ac269ff5edf29d8191dbd357876/src/exp2.c#L1
        // Inspired by https://github.com/dalek-cryptography/curve25519-dalek/blob/17698df9d4c834204f83a3574143abacb4fc81a5/src/field.rs#L99
        var candidateSqrt = exports.Fp2.pow(num, (exports.Fp2.ORDER + _8n) / _16n);
        var check = exports.Fp2.div(exports.Fp2.sqr(candidateSqrt), num); // candidateSqrt.square().div(this);
        var R = FP2_ROOTS_OF_UNITY;
        var divisor = [
            R[0],
            R[2],
            R[4],
            R[6]
        ].find(function(r) {
            return exports.Fp2.eql(r, check);
        });
        if (!divisor) throw new Error('No root');
        var index = R.indexOf(divisor);
        var root = R[index / 2];
        if (!root) throw new Error('Invalid root');
        var x1 = exports.Fp2.div(candidateSqrt, root);
        var x2 = exports.Fp2.neg(x1);
        var _a = exports.Fp2.reim(x1), re1 = _a.re, im1 = _a.im;
        var _b = exports.Fp2.reim(x2), re2 = _b.re, im2 = _b.im;
        if (im1 > im2 || im1 === im2 && re1 > re2) return x1;
        return x2;
    },
    // Same as sgn0_m_eq_2 in RFC 9380
    isOdd: function(x) {
        var _a = exports.Fp2.reim(x), x0 = _a.re, x1 = _a.im;
        var sign_0 = x0 % _2n;
        var zero_0 = x0 === _0n;
        var sign_1 = x1 % _2n;
        return BigInt(sign_0 || zero_0 && sign_1) == _1n;
    },
    // Bytes util
    fromBytes: function(b) {
        if (b.length !== exports.Fp2.BYTES) throw new Error("fromBytes wrong length=".concat(b.length));
        return {
            c0: exports.Fp.fromBytes(b.subarray(0, exports.Fp.BYTES)),
            c1: exports.Fp.fromBytes(b.subarray(exports.Fp.BYTES))
        };
    },
    toBytes: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return (0, utils_1.concatBytes)(exports.Fp.toBytes(c0), exports.Fp.toBytes(c1));
    },
    cmov: function(_a, _b, c) {
        var c0 = _a.c0, c1 = _a.c1;
        var r0 = _b.c0, r1 = _b.c1;
        return {
            c0: exports.Fp.cmov(c0, r0, c),
            c1: exports.Fp.cmov(c1, r1, c)
        };
    },
    // Specific utils
    // toString() {
    //   return `Fp2(${this.c0} + ${this.c1}i)`;
    // }
    reim: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            re: c0,
            im: c1
        };
    },
    // multiply by u + 1
    mulByNonresidue: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: exports.Fp.sub(c0, c1),
            c1: exports.Fp.add(c0, c1)
        };
    },
    multiplyByB: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        var t0 = exports.Fp.mul(c0, _4n); // 4 * c0
        var t1 = exports.Fp.mul(c1, _4n); // 4 * c1
        // (T0-T1) + (T0+T1)*i
        return {
            c0: exports.Fp.sub(t0, t1),
            c1: exports.Fp.add(t0, t1)
        };
    },
    fromBigTuple: function(tuple) {
        if (tuple.length !== 2) throw new Error('Invalid tuple');
        var fps = tuple.map(function(n) {
            return exports.Fp.create(n);
        });
        return {
            c0: fps[0],
            c1: fps[1]
        };
    },
    frobeniusMap: function(_a, power) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: c0,
            c1: exports.Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2])
        };
    }
};
// Finite extension field over irreducible polynominal.
// Fp(u) / (u - ) where  = -1
var FP2_FROBENIUS_COEFFICIENTS = [
    BigInt('0x1'),
    BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa')
].map(function(item) {
    return exports.Fp.create(item);
});
// For Fp2 roots of unity.
var rv1 = BigInt('0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09');
// const ev1 =
//   BigInt('0x699be3b8c6870965e5bf892ad5d2cc7b0e85a117402dfd83b7f4a947e02d978498255a2aaec0ac627b5afbdf1bf1c90');
// const ev2 =
//   BigInt('0x8157cd83046453f5dd0972b6e3949e4288020b5b8a9cc99ca07e27089a2ce2436d965026adad3ef7baba37f2183e9b5');
// const ev3 =
//   BigInt('0xab1c2ffdd6c253ca155231eb3e71ba044fd562f6f72bc5bad5ec46a0b7a3b0247cf08ce6c6317f40edbc653a72dee17');
// const ev4 =
//   BigInt('0xaa404866706722864480885d68ad0ccac1967c7544b447873cc37e0181271e006df72162a3d3e0287bf597fbf7f8fc1');
// Eighth roots of unity, used for computing square roots in Fp2.
// To verify or re-calculate:
// Array(8).fill(new Fp2([1n, 1n])).map((fp2, k) => fp2.pow(Fp2.ORDER * BigInt(k) / 8n))
var FP2_ROOTS_OF_UNITY = [
    [
        _1n,
        _0n
    ],
    [
        rv1,
        -rv1
    ],
    [
        _0n,
        _1n
    ],
    [
        rv1,
        rv1
    ],
    [
        -_1n,
        _0n
    ],
    [
        -rv1,
        rv1
    ],
    [
        _0n,
        -_1n
    ],
    [
        -rv1,
        -rv1
    ]
].map(function(pair) {
    return exports.Fp2.fromBigTuple(pair);
});
var Fp6Add = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
    var r0 = _b.c0, r1 = _b.c1, r2 = _b.c2;
    return {
        c0: exports.Fp2.add(c0, r0),
        c1: exports.Fp2.add(c1, r1),
        c2: exports.Fp2.add(c2, r2)
    };
};
var Fp6Subtract = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
    var r0 = _b.c0, r1 = _b.c1, r2 = _b.c2;
    return {
        c0: exports.Fp2.sub(c0, r0),
        c1: exports.Fp2.sub(c1, r1),
        c2: exports.Fp2.sub(c2, r2)
    };
};
var Fp6Multiply = function(_a, rhs) {
    var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
    if (typeof rhs === 'bigint') {
        return {
            c0: exports.Fp2.mul(c0, rhs),
            c1: exports.Fp2.mul(c1, rhs),
            c2: exports.Fp2.mul(c2, rhs)
        };
    }
    var r0 = rhs.c0, r1 = rhs.c1, r2 = rhs.c2;
    var t0 = exports.Fp2.mul(c0, r0); // c0 * o0
    var t1 = exports.Fp2.mul(c1, r1); // c1 * o1
    var t2 = exports.Fp2.mul(c2, r2); // c2 * o2
    return {
        // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)
        c0: exports.Fp2.add(t0, exports.Fp2.mulByNonresidue(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(c1, c2), exports.Fp2.add(r1, r2)), exports.Fp2.add(t1, t2)))),
        // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)
        c1: exports.Fp2.add(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(c0, c1), exports.Fp2.add(r0, r1)), exports.Fp2.add(t0, t1)), exports.Fp2.mulByNonresidue(t2)),
        // T1 + (c0 + c2) * (r0 + r2) - T0 + T2
        c2: exports.Fp2.sub(exports.Fp2.add(t1, exports.Fp2.mul(exports.Fp2.add(c0, c2), exports.Fp2.add(r0, r2))), exports.Fp2.add(t0, t2))
    };
};
var Fp6Square = function(_a) {
    var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
    var t0 = exports.Fp2.sqr(c0); // c0
    var t1 = exports.Fp2.mul(exports.Fp2.mul(c0, c1), _2n); // 2 * c0 * c1
    var t3 = exports.Fp2.mul(exports.Fp2.mul(c1, c2), _2n); // 2 * c1 * c2
    var t4 = exports.Fp2.sqr(c2); // c2
    return {
        c0: exports.Fp2.add(exports.Fp2.mulByNonresidue(t3), t0),
        c1: exports.Fp2.add(exports.Fp2.mulByNonresidue(t4), t1),
        // T1 + (c0 - c1 + c2) + T3 - T0 - T4
        c2: exports.Fp2.sub(exports.Fp2.sub(exports.Fp2.add(exports.Fp2.add(t1, exports.Fp2.sqr(exports.Fp2.add(exports.Fp2.sub(c0, c1), c2))), t3), t0), t4)
    };
};
var Fp6 = {
    ORDER: exports.Fp2.ORDER,
    BITS: 3 * exports.Fp2.BITS,
    BYTES: 3 * exports.Fp2.BYTES,
    MASK: (0, utils_1.bitMask)(3 * exports.Fp2.BITS),
    ZERO: {
        c0: exports.Fp2.ZERO,
        c1: exports.Fp2.ZERO,
        c2: exports.Fp2.ZERO
    },
    ONE: {
        c0: exports.Fp2.ONE,
        c1: exports.Fp2.ZERO,
        c2: exports.Fp2.ZERO
    },
    create: function(num) {
        return num;
    },
    isValid: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return exports.Fp2.isValid(c0) && exports.Fp2.isValid(c1) && exports.Fp2.isValid(c2);
    },
    is0: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return exports.Fp2.is0(c0) && exports.Fp2.is0(c1) && exports.Fp2.is0(c2);
    },
    neg: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.neg(c0),
            c1: exports.Fp2.neg(c1),
            c2: exports.Fp2.neg(c2)
        };
    },
    eql: function(_a, _b) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var r0 = _b.c0, r1 = _b.c1, r2 = _b.c2;
        return exports.Fp2.eql(c0, r0) && exports.Fp2.eql(c1, r1) && exports.Fp2.eql(c2, r2);
    },
    sqrt: function() {
        throw new Error('Not implemented');
    },
    // Do we need division by bigint at all? Should be done via order:
    div: function(lhs, rhs) {
        return Fp6.mul(lhs, typeof rhs === 'bigint' ? exports.Fp.inv(exports.Fp.create(rhs)) : Fp6.inv(rhs));
    },
    pow: function(num, power) {
        return mod.FpPow(Fp6, num, power);
    },
    invertBatch: function(nums) {
        return mod.FpInvertBatch(Fp6, nums);
    },
    // Normalized
    add: Fp6Add,
    sub: Fp6Subtract,
    mul: Fp6Multiply,
    sqr: Fp6Square,
    // NonNormalized stuff
    addN: Fp6Add,
    subN: Fp6Subtract,
    mulN: Fp6Multiply,
    sqrN: Fp6Square,
    inv: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var t0 = exports.Fp2.sub(exports.Fp2.sqr(c0), exports.Fp2.mulByNonresidue(exports.Fp2.mul(c2, c1))); // c0 - c2 * c1 * (u + 1)
        var t1 = exports.Fp2.sub(exports.Fp2.mulByNonresidue(exports.Fp2.sqr(c2)), exports.Fp2.mul(c0, c1)); // c2 * (u + 1) - c0 * c1
        var t2 = exports.Fp2.sub(exports.Fp2.sqr(c1), exports.Fp2.mul(c0, c2)); // c1 - c0 * c2
        // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)
        var t4 = exports.Fp2.inv(exports.Fp2.add(exports.Fp2.mulByNonresidue(exports.Fp2.add(exports.Fp2.mul(c2, t1), exports.Fp2.mul(c1, t2))), exports.Fp2.mul(c0, t0)));
        return {
            c0: exports.Fp2.mul(t4, t0),
            c1: exports.Fp2.mul(t4, t1),
            c2: exports.Fp2.mul(t4, t2)
        };
    },
    // Bytes utils
    fromBytes: function(b) {
        if (b.length !== Fp6.BYTES) throw new Error("fromBytes wrong length=".concat(b.length));
        return {
            c0: exports.Fp2.fromBytes(b.subarray(0, exports.Fp2.BYTES)),
            c1: exports.Fp2.fromBytes(b.subarray(exports.Fp2.BYTES, 2 * exports.Fp2.BYTES)),
            c2: exports.Fp2.fromBytes(b.subarray(2 * exports.Fp2.BYTES))
        };
    },
    toBytes: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return (0, utils_1.concatBytes)(exports.Fp2.toBytes(c0), exports.Fp2.toBytes(c1), exports.Fp2.toBytes(c2));
    },
    cmov: function(_a, _b, c) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var r0 = _b.c0, r1 = _b.c1, r2 = _b.c2;
        return {
            c0: exports.Fp2.cmov(c0, r0, c),
            c1: exports.Fp2.cmov(c1, r1, c),
            c2: exports.Fp2.cmov(c2, r2, c)
        };
    },
    // Utils
    //   fromTriple(triple: [Fp2, Fp2, Fp2]) {
    //     return new Fp6(...triple);
    //   }
    //   toString() {
    //     return `Fp6(${this.c0} + ${this.c1} * v, ${this.c2} * v^2)`;
    //   }
    fromBigSix: function(t) {
        if (!Array.isArray(t) || t.length !== 6) throw new Error('Invalid Fp6 usage');
        return {
            c0: exports.Fp2.fromBigTuple(t.slice(0, 2)),
            c1: exports.Fp2.fromBigTuple(t.slice(2, 4)),
            c2: exports.Fp2.fromBigTuple(t.slice(4, 6))
        };
    },
    frobeniusMap: function(_a, power) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.frobeniusMap(c0, power),
            c1: exports.Fp2.mul(exports.Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),
            c2: exports.Fp2.mul(exports.Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6])
        };
    },
    mulByNonresidue: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.mulByNonresidue(c2),
            c1: c0,
            c2: c1
        };
    },
    // Sparse multiplication
    multiplyBy1: function(_a, b1) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.mulByNonresidue(exports.Fp2.mul(c2, b1)),
            c1: exports.Fp2.mul(c0, b1),
            c2: exports.Fp2.mul(c1, b1)
        };
    },
    // Sparse multiplication
    multiplyBy01: function(_a, b0, b1) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var t0 = exports.Fp2.mul(c0, b0); // c0 * b0
        var t1 = exports.Fp2.mul(c1, b1); // c1 * b1
        return {
            // ((c1 + c2) * b1 - T1) * (u + 1) + T0
            c0: exports.Fp2.add(exports.Fp2.mulByNonresidue(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(c1, c2), b1), t1)), t0),
            // (b0 + b1) * (c0 + c1) - T0 - T1
            c1: exports.Fp2.sub(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(b0, b1), exports.Fp2.add(c0, c1)), t0), t1),
            // (c0 + c2) * b0 - T0 + T1
            c2: exports.Fp2.add(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(c0, c2), b0), t0), t1)
        };
    },
    multiplyByFp2: function(_a, rhs) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.mul(c0, rhs),
            c1: exports.Fp2.mul(c1, rhs),
            c2: exports.Fp2.mul(c2, rhs)
        };
    }
};
var FP6_FROBENIUS_COEFFICIENTS_1 = [
    [
        BigInt('0x1'),
        BigInt('0x0')
    ],
    [
        BigInt('0x0'),
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),
        BigInt('0x0')
    ],
    [
        BigInt('0x0'),
        BigInt('0x1')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),
        BigInt('0x0')
    ],
    [
        BigInt('0x0'),
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe')
    ]
].map(function(pair) {
    return exports.Fp2.fromBigTuple(pair);
});
var FP6_FROBENIUS_COEFFICIENTS_2 = [
    [
        BigInt('0x1'),
        BigInt('0x0')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'),
        BigInt('0x0')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),
        BigInt('0x0')
    ],
    [
        BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),
        BigInt('0x0')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),
        BigInt('0x0')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'),
        BigInt('0x0')
    ]
].map(function(pair) {
    return exports.Fp2.fromBigTuple(pair);
});
// The BLS parameter x for BLS12-381
var BLS_X = BigInt('0xd201000000010000');
var BLS_X_LEN = (0, utils_1.bitLen)(BLS_X);
var Fp12Add = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return {
        c0: Fp6.add(c0, r0),
        c1: Fp6.add(c1, r1)
    };
};
var Fp12Subtract = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return {
        c0: Fp6.sub(c0, r0),
        c1: Fp6.sub(c1, r1)
    };
};
var Fp12Multiply = function(_a, rhs) {
    var c0 = _a.c0, c1 = _a.c1;
    if (typeof rhs === 'bigint') return {
        c0: Fp6.mul(c0, rhs),
        c1: Fp6.mul(c1, rhs)
    };
    var r0 = rhs.c0, r1 = rhs.c1;
    var t1 = Fp6.mul(c0, r0); // c0 * r0
    var t2 = Fp6.mul(c1, r1); // c1 * r1
    return {
        c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)),
        // (c0 + c1) * (r0 + r1) - (T1 + T2)
        c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2))
    };
};
exports.Fp12Multiply = Fp12Multiply;
var Fp12Square = function(_a) {
    var c0 = _a.c0, c1 = _a.c1;
    var ab = Fp6.mul(c0, c1); // c0 * c1
    return {
        // (c1 * v + c0) * (c0 + c1) - AB - AB * v
        c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),
        c1: Fp6.add(ab, ab)
    }; // AB + AB
};
function Fp4Square(a, b) {
    var a2 = exports.Fp2.sqr(a);
    var b2 = exports.Fp2.sqr(b);
    return {
        first: exports.Fp2.add(exports.Fp2.mulByNonresidue(b2), a2),
        second: exports.Fp2.sub(exports.Fp2.sub(exports.Fp2.sqr(exports.Fp2.add(a, b)), a2), b2)
    };
}
var Fp12_finalExponentiate = function(num) {
    var x = BLS_X;
    // this^(q) / this
    var t0 = exports.Fp12.div(exports.Fp12.frobeniusMap(num, 6), num);
    // t0^(q) * t0
    var t1 = exports.Fp12.mul(exports.Fp12.frobeniusMap(t0, 2), t0);
    var t2 = exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t1, x));
    var t3 = exports.Fp12.mul(exports.Fp12.conjugate(exports.Fp12._cyclotomicSquare(t1)), t2);
    var t4 = exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t3, x));
    var t5 = exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t4, x));
    var t6 = exports.Fp12.mul(exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t5, x)), exports.Fp12._cyclotomicSquare(t2));
    var t7 = exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t6, x));
    var t2_t5_pow_q2 = exports.Fp12.frobeniusMap(exports.Fp12.mul(t2, t5), 2);
    var t4_t1_pow_q3 = exports.Fp12.frobeniusMap(exports.Fp12.mul(t4, t1), 3);
    var t6_t1c_pow_q1 = exports.Fp12.frobeniusMap(exports.Fp12.mul(t6, exports.Fp12.conjugate(t1)), 1);
    var t7_t3c_t1 = exports.Fp12.mul(exports.Fp12.mul(t7, exports.Fp12.conjugate(t3)), t1);
    // (t2 * t5)^(q) * (t4 * t1)^(q) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1
    return exports.Fp12.mul(exports.Fp12.mul(exports.Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);
};
exports.Fp12_finalExponentiate = Fp12_finalExponentiate;
var Fp12_conjugate = function(_a) {
    var c0 = _a.c0, c1 = _a.c1;
    return {
        c0: c0,
        c1: Fp6.neg(c1)
    };
};
exports.Fp12_conjugate = Fp12_conjugate;
var Fp12_eql = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return Fp6.eql(c0, r0) && Fp6.eql(c1, r1);
};
exports.Fp12_eql = Fp12_eql;
exports.Fp12_ONE = {
    c0: Fp6.ONE,
    c1: Fp6.ZERO
};
exports.Fp12 = {
    ORDER: exports.Fp2.ORDER,
    BITS: 2 * exports.Fp2.BITS,
    BYTES: 2 * exports.Fp2.BYTES,
    MASK: (0, utils_1.bitMask)(2 * exports.Fp2.BITS),
    ZERO: {
        c0: Fp6.ZERO,
        c1: Fp6.ZERO
    },
    ONE: {
        c0: Fp6.ONE,
        c1: Fp6.ZERO
    },
    create: function(num) {
        return num;
    },
    isValid: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return Fp6.isValid(c0) && Fp6.isValid(c1);
    },
    is0: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return Fp6.is0(c0) && Fp6.is0(c1);
    },
    neg: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: Fp6.neg(c0),
            c1: Fp6.neg(c1)
        };
    },
    eql: exports.Fp12_eql,
    sqrt: function() {
        throw new Error('Not implemented');
    },
    inv: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        var t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0 - c1 * v)
        return {
            c0: Fp6.mul(c0, t),
            c1: Fp6.neg(Fp6.mul(c1, t))
        }; // ((C0 * T) * T) + (-C1 * T) * w
    },
    div: function(lhs, rhs) {
        return exports.Fp12.mul(lhs, typeof rhs === 'bigint' ? exports.Fp.inv(exports.Fp.create(rhs)) : exports.Fp12.inv(rhs));
    },
    pow: function(num, power) {
        return mod.FpPow(exports.Fp12, num, power);
    },
    invertBatch: function(nums) {
        return mod.FpInvertBatch(exports.Fp12, nums);
    },
    // Normalized
    add: Fp12Add,
    sub: Fp12Subtract,
    mul: exports.Fp12Multiply,
    sqr: Fp12Square,
    // NonNormalized stuff
    addN: Fp12Add,
    subN: Fp12Subtract,
    mulN: exports.Fp12Multiply,
    sqrN: Fp12Square,
    // Bytes utils
    fromBytes: function(b) {
        if (b.length !== exports.Fp12.BYTES) throw new Error("fromBytes wrong length=".concat(b.length));
        return {
            c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),
            c1: Fp6.fromBytes(b.subarray(Fp6.BYTES))
        };
    },
    toBytes: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return (0, utils_1.concatBytes)(Fp6.toBytes(c0), Fp6.toBytes(c1));
    },
    cmov: function(_a, _b, c) {
        var c0 = _a.c0, c1 = _a.c1;
        var r0 = _b.c0, r1 = _b.c1;
        return {
            c0: Fp6.cmov(c0, r0, c),
            c1: Fp6.cmov(c1, r1, c)
        };
    },
    // Utils
    // toString() {
    //   return `Fp12(${this.c0} + ${this.c1} * w)`;
    // },
    // fromTuple(c: [Fp6, Fp6]) {
    //   return new Fp12(...c);
    // }
    fromBigTwelve: function(t) {
        return {
            c0: Fp6.fromBigSix(t.slice(0, 6)),
            c1: Fp6.fromBigSix(t.slice(6, 12))
        };
    },
    // Raises to q**i -th power
    frobeniusMap: function(lhs, power) {
        var r0 = Fp6.frobeniusMap(lhs.c0, power);
        var _a = Fp6.frobeniusMap(lhs.c1, power), c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];
        return {
            c0: r0,
            c1: Fp6.create({
                c0: exports.Fp2.mul(c0, coeff),
                c1: exports.Fp2.mul(c1, coeff),
                c2: exports.Fp2.mul(c2, coeff)
            })
        };
    },
    // Sparse multiplication
    multiplyBy014: function(_a, o0, o1, o4) {
        var c0 = _a.c0, c1 = _a.c1;
        var t0 = Fp6.multiplyBy01(c0, o0, o1);
        var t1 = Fp6.multiplyBy1(c1, o4);
        return {
            c0: Fp6.add(Fp6.mulByNonresidue(t1), t0),
            // (c1 + c0) * [o0, o1+o4] - T0 - T1
            c1: Fp6.sub(Fp6.sub(Fp6.multiplyBy01(Fp6.add(c1, c0), o0, exports.Fp2.add(o1, o4)), t0), t1)
        };
    },
    multiplyByFp2: function(_a, rhs) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: Fp6.multiplyByFp2(c0, rhs),
            c1: Fp6.multiplyByFp2(c1, rhs)
        };
    },
    conjugate: exports.Fp12_conjugate,
    // A cyclotomic group is a subgroup of Fp^n defined by
    //   G(p) = {  Fp : ^(p) = 1}
    // The result of any pairing is in a cyclotomic subgroup
    // https://eprint.iacr.org/2009/565.pdf
    _cyclotomicSquare: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        var c0c0 = c0.c0, c0c1 = c0.c1, c0c2 = c0.c2;
        var c1c0 = c1.c0, c1c1 = c1.c1, c1c2 = c1.c2;
        var _b = Fp4Square(c0c0, c1c1), t3 = _b.first, t4 = _b.second;
        var _d = Fp4Square(c1c0, c0c2), t5 = _d.first, t6 = _d.second;
        var _e = Fp4Square(c0c1, c1c2), t7 = _e.first, t8 = _e.second;
        var t9 = exports.Fp2.mulByNonresidue(t8); // T8 * (u + 1)
        return {
            c0: Fp6.create({
                c0: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.sub(t3, c0c0), _2n), t3),
                c1: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.sub(t5, c0c1), _2n), t5),
                c2: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.sub(t7, c0c2), _2n), t7)
            }),
            c1: Fp6.create({
                c0: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.add(t9, c1c0), _2n), t9),
                c1: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.add(t4, c1c1), _2n), t4),
                c2: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.add(t6, c1c2), _2n), t6)
            })
        }; // 2 * (T6 + c1c2) + T6
    },
    _cyclotomicExp: function(num, n) {
        var z = exports.Fp12.ONE;
        for(var i = BLS_X_LEN - 1; i >= 0; i--){
            z = exports.Fp12._cyclotomicSquare(z);
            if ((0, utils_1.bitGet)(n, i)) z = exports.Fp12.mul(z, num);
        }
        return z;
    },
    // https://eprint.iacr.org/2010/354.pdf
    // https://eprint.iacr.org/2009/565.pdf
    finalExponentiate: exports.Fp12_finalExponentiate
};
var FP12_FROBENIUS_COEFFICIENTS = [
    [
        BigInt('0x1'),
        BigInt('0x0')
    ],
    [
        BigInt('0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8'),
        BigInt('0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'),
        BigInt('0x0')
    ],
    [
        BigInt('0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2'),
        BigInt('0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),
        BigInt('0x0')
    ],
    [
        BigInt('0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995'),
        BigInt('0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116')
    ],
    [
        BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),
        BigInt('0x0')
    ],
    [
        BigInt('0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3'),
        BigInt('0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),
        BigInt('0x0')
    ],
    [
        BigInt('0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09'),
        BigInt('0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'),
        BigInt('0x0')
    ],
    [
        BigInt('0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116'),
        BigInt('0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995')
    ]
].map(function(n) {
    return exports.Fp2.fromBigTuple(n);
});
// END OF CURVE FIELDS
// HashToCurve
// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3
var isogenyMapG2 = (0, hash_to_curve_1.isogenyMap)(exports.Fp2, [
    // xNum
    [
        [
            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',
            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6'
        ],
        [
            '0x0',
            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a'
        ],
        [
            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',
            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d'
        ],
        [
            '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',
            '0x0'
        ]
    ],
    // xDen
    [
        [
            '0x0',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63'
        ],
        [
            '0xc',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f'
        ],
        [
            '0x1',
            '0x0'
        ]
    ],
    // yNum
    [
        [
            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',
            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706'
        ],
        [
            '0x0',
            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be'
        ],
        [
            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',
            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f'
        ],
        [
            '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',
            '0x0'
        ]
    ],
    // yDen
    [
        [
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb'
        ],
        [
            '0x0',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3'
        ],
        [
            '0x12',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99'
        ],
        [
            '0x1',
            '0x0'
        ]
    ]
].map(function(i) {
    return i.map(function(pair) {
        return exports.Fp2.fromBigTuple(pair.map(BigInt));
    });
}));
// 11-isogeny map from E' to E
var isogenyMapG1 = (0, hash_to_curve_1.isogenyMap)(exports.Fp, [
    // xNum
    [
        '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',
        '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',
        '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',
        '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',
        '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',
        '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',
        '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',
        '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',
        '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',
        '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',
        '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',
        '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229'
    ],
    // xDen
    [
        '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',
        '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',
        '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',
        '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',
        '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',
        '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',
        '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',
        '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',
        '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',
        '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',
        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001'
    ],
    // yNum
    [
        '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',
        '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',
        '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',
        '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',
        '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',
        '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',
        '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',
        '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',
        '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',
        '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',
        '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',
        '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',
        '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',
        '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',
        '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',
        '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604'
    ],
    // yDen
    [
        '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',
        '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',
        '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',
        '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',
        '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',
        '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',
        '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',
        '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',
        '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',
        '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',
        '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',
        '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',
        '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',
        '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',
        '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',
        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001'
    ]
].map(function(i) {
    return i.map(function(j) {
        return BigInt(j);
    });
}));
// SWU Map - Fp2 to G2': y = x + 240i * x + 1012 + 1012i
var G2_SWU = (0, weierstrass_1.mapToCurveSimpleSWU)(exports.Fp2, {
    A: exports.Fp2.create({
        c0: exports.Fp.create(_0n),
        c1: exports.Fp.create(BigInt(240))
    }),
    B: exports.Fp2.create({
        c0: exports.Fp.create(BigInt(1012)),
        c1: exports.Fp.create(BigInt(1012))
    }),
    Z: exports.Fp2.create({
        c0: exports.Fp.create(BigInt(-2)),
        c1: exports.Fp.create(BigInt(-1))
    })
});
// Optimized SWU Map - Fp to G1
var G1_SWU = (0, weierstrass_1.mapToCurveSimpleSWU)(exports.Fp, {
    A: exports.Fp.create(BigInt('0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d')),
    B: exports.Fp.create(BigInt('0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0')),
    Z: exports.Fp.create(BigInt(11))
});
// Endomorphisms (for fast cofactor clearing)
// (P) endomorphism
var ut_root = Fp6.create({
    c0: exports.Fp2.ZERO,
    c1: exports.Fp2.ONE,
    c2: exports.Fp2.ZERO
});
var wsq = exports.Fp12.create({
    c0: ut_root,
    c1: Fp6.ZERO
});
var wcu = exports.Fp12.create({
    c0: Fp6.ZERO,
    c1: ut_root
});
var _a = __read(exports.Fp12.invertBatch([
    wsq,
    wcu
]), 2), wsq_inv = _a[0], wcu_inv = _a[1];
function psi(x, y) {
    // Untwist Fp2->Fp12 && frobenius(1) && twist back
    var x2 = exports.Fp12.mul(exports.Fp12.frobeniusMap(exports.Fp12.multiplyByFp2(wsq_inv, x), 1), wsq).c0.c0;
    var y2 = exports.Fp12.mul(exports.Fp12.frobeniusMap(exports.Fp12.multiplyByFp2(wcu_inv, y), 1), wcu).c0.c0;
    return [
        x2,
        y2
    ];
}
//  endomorphism
function G2psi(c, P) {
    var affine = P.toAffine();
    var p = psi(affine.x, affine.y);
    return new c(p[0], p[1], exports.Fp2.ONE);
}
// (P) endomorphism
// 1 / F2(2)^((p-1)/3) in GF(p)
var PSI2_C1 = BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac');
function psi2(x, y) {
    return [
        exports.Fp2.mul(x, PSI2_C1),
        exports.Fp2.neg(y)
    ];
}
function G2psi2(c, P) {
    var affine = P.toAffine();
    var p = psi2(affine.x, affine.y);
    return new c(p[0], p[1], exports.Fp2.ONE);
}
// Default hash_to_field options are for hash to G2.
//
// Parameter definitions are in section 5.3 of the spec unless otherwise noted.
// Parameter values come from section 8.8.2 of the spec.
// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2
//
// Base field F is GF(p^m)
// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
// m = 2 (or 1 for G1 see section 8.8.1)
// k = 128
var htfDefaults = Object.freeze({
    // DST: a domain separation tag
    // defined in section 2.2.5
    // Use utils.getDSTLabel(), utils.setDSTLabel(value)
    DST: "",
    encodeDST: "",
    // p: the characteristic of F
    //    where F is a finite field of characteristic p and order q = p^m
    p: exports.Fp.ORDER,
    // m: the extension degree of F, m >= 1
    //     where F is a finite field of characteristic p and order q = p^m
    m: 2,
    // k: the target security level for the suite in bits
    // defined in section 5.1
    k: 128,
    // option to use a message that has already been processed by
    // expand_message_xmd
    expand: 'xmd',
    // Hash functions for: expand_message_xmd is appropriate for use with a
    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.
    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247
    hash: sha256_1.sha256
});
// Encoding utils
// Point on G1 curve: (x, y)
// Compressed point of infinity
var COMPRESSED_ZERO = setMask(exports.Fp.toBytes(_0n), {
    infinity: true,
    compressed: true
}); // set compressed & point-at-infinity bits
function parseMask(bytes) {
    // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.
    bytes = bytes.slice();
    var mask = bytes[0] & 224;
    var compressed = !!(mask >> 7 & 1); // compression bit (0b1000_0000)
    var infinity = !!(mask >> 6 & 1); // point at infinity bit (0b0100_0000)
    var sort = !!(mask >> 5 & 1); // sort bit (0b0010_0000)
    bytes[0] &= 31; // clear mask (zero first 3 bits)
    return {
        compressed: compressed,
        infinity: infinity,
        sort: sort,
        value: bytes
    };
}
exports.parseMask = parseMask;
function setMask(bytes, mask) {
    if (bytes[0] & 224) throw new Error('setMask: non-empty mask');
    if (mask.compressed) bytes[0] |= 128;
    if (mask.infinity) bytes[0] |= 64;
    if (mask.sort) bytes[0] |= 32;
    return bytes;
}
function signatureG1ToRawBytes(point) {
    point.assertValidity();
    var isZero = point.equals(exports.bls12_381.G1.ProjectivePoint.ZERO);
    var _a = point.toAffine(), x = _a.x, y = _a.y;
    if (isZero) return COMPRESSED_ZERO.slice();
    var P = exports.Fp.ORDER;
    var sort = Boolean(y * _2n / P);
    return setMask((0, utils_1.numberToBytesBE)(x, exports.Fp.BYTES), {
        compressed: true,
        sort: sort
    });
}
function signatureG2ToRawBytes(point) {
    // NOTE: by some reasons it was missed in bls12-381, looks like bug
    point.assertValidity();
    var len = exports.Fp.BYTES;
    if (point.equals(exports.bls12_381.G2.ProjectivePoint.ZERO)) return (0, utils_1.concatBytes)(COMPRESSED_ZERO, (0, utils_1.numberToBytesBE)(_0n, len));
    var _a = point.toAffine(), x = _a.x, y = _a.y;
    var _b = exports.Fp2.reim(x), x0 = _b.re, x1 = _b.im;
    var _d = exports.Fp2.reim(y), y0 = _d.re, y1 = _d.im;
    var tmp = y1 > _0n ? y1 * _2n : y0 * _2n;
    var sort = Boolean(tmp / exports.Fp.ORDER & _1n);
    var z2 = x0;
    return (0, utils_1.concatBytes)(setMask((0, utils_1.numberToBytesBE)(x1, len), {
        sort: sort,
        compressed: true
    }), (0, utils_1.numberToBytesBE)(z2, len));
}
var G1_formBytes = function(bytes) {
    var _a = parseMask(bytes), compressed = _a.compressed, infinity = _a.infinity, sort = _a.sort, value = _a.value;
    if (value.length === 48 && compressed) {
        // TODO: Fp.bytes
        var P = exports.Fp.ORDER;
        var compressedValue = (0, utils_1.bytesToNumberBE)(value);
        // Zero
        var x = exports.Fp.create(compressedValue & exports.Fp.MASK);
        if (infinity) {
            if (x !== _0n) throw new Error('G1: non-empty compressed point at infinity');
            return {
                x: _0n,
                y: _0n
            };
        }
        var right = exports.Fp.add(exports.Fp.pow(x, _3n), exports.Fp.create(exports.bls12_381.params.G1b)); // y = x + b
        var y = exports.Fp.sqrt(right);
        if (!y) throw new Error('Invalid compressed G1 point');
        if (y * _2n / P !== BigInt(sort)) y = exports.Fp.neg(y);
        return {
            x: exports.Fp.create(x),
            y: exports.Fp.create(y)
        };
    } else if (value.length === 96 && !compressed) {
        // Check if the infinity flag is set
        var x = (0, utils_1.bytesToNumberBE)(value.subarray(0, exports.Fp.BYTES));
        var y = (0, utils_1.bytesToNumberBE)(value.subarray(exports.Fp.BYTES));
        if (infinity) {
            if (x !== _0n || y !== _0n) throw new Error('G1: non-empty point at infinity');
            return exports.bls12_381.G1.ProjectivePoint.ZERO.toAffine();
        }
        return {
            x: exports.Fp.create(x),
            y: exports.Fp.create(y)
        };
    } else {
        throw new Error('Invalid point G1, expected 48/96 bytes');
    }
};
exports.G1_formBytes = G1_formBytes;
var G1_mapToCurve = function(scalars) {
    var _a = G1_SWU(exports.Fp.create(scalars[0])), x = _a.x, y = _a.y;
    return isogenyMapG1(x, y);
};
exports.G1_mapToCurve = G1_mapToCurve;
var G2_mapToCurve = function(scalars) {
    var _a = G2_SWU(exports.Fp2.fromBigTuple(scalars)), x = _a.x, y = _a.y;
    return isogenyMapG2(x, y);
};
exports.G2_mapToCurve = G2_mapToCurve;
// To verify curve parameters, see pairing-friendly-curves spec:
// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11
// Basic math is done over finite fields over p.
// More complicated math is done over polynominal extension fields.
// To simplify calculations in Fp12, we construct extension tower:
// Fp = Fp => Fp
// Fp(u) / (u - ) where  = -1
// Fp(v) / (v - ) where  = u + 1
// Fp(w) / (w - ) where  = v
// Here goes constants && point encoding format
exports.bls12_381 = (0, bls_1.bls)({
    // Fields
    fields: {
        Fp: exports.Fp,
        Fp2: exports.Fp2,
        Fp6: Fp6,
        Fp12: exports.Fp12,
        Fr: Fr
    },
    // G1 is the order-q subgroup of E1(Fp) : y = x + 4, #E1(Fp) = h1q, where
    // characteristic; z + (z - z + 1)(z - 1)/3
    G1: {
        Fp: exports.Fp,
        // cofactor; (z - 1)/3
        h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),
        // generator's coordinates
        // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507
        // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569
        Gx: BigInt('0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'),
        Gy: BigInt('0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'),
        a: exports.Fp.ZERO,
        b: _4n,
        htfDefaults: __assign(__assign({}, htfDefaults), {
            m: 1,
            DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_'
        }),
        wrapPrivateKey: true,
        allowInfinityPoint: true,
        // Checks is the point resides in prime-order subgroup.
        // point.isTorsionFree() should return true for valid points
        // It returns false for shitty points.
        // https://eprint.iacr.org/2021/1130.pdf
        isTorsionFree: function(c, point) {
            //  endomorphism
            var cubicRootOfUnityModP = BigInt('0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe');
            var phi = new c(exports.Fp.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);
            // todo: unroll
            var xP = point.multiplyUnsafe(exports.bls12_381.params.x).negate(); // [x]P
            var u2P = xP.multiplyUnsafe(exports.bls12_381.params.x); // [u2]P
            return u2P.equals(phi);
        // https://eprint.iacr.org/2019/814.pdf
        // (z  1)/3
        // const c1 = BigInt('0x396c8c005555e1560000000055555555');
        // const P = this;
        // const S = P.sigma();
        // const Q = S.double();
        // const S2 = S.sigma();
        // // [(z  1)/3](2(P)  P  (P))  (P) = O
        // const left = Q.subtract(P).subtract(S2).multiplyUnsafe(c1);
        // const C = left.subtract(S2);
        // return C.isZero();
        },
        // Clear cofactor of G1
        // https://eprint.iacr.org/2019/403
        clearCofactor: function(_c, point) {
            // return this.multiplyUnsafe(CURVE.h);
            return point.multiplyUnsafe(exports.bls12_381.params.x).add(point); // x*P + P
        },
        mapToCurve: exports.G1_mapToCurve,
        fromBytes: exports.G1_formBytes,
        toBytes: function(c, point, isCompressed) {
            var isZero = point.equals(c.ZERO);
            var _a = point.toAffine(), x = _a.x, y = _a.y;
            if (isCompressed) {
                if (isZero) return COMPRESSED_ZERO.slice();
                var P = exports.Fp.ORDER;
                var sort = Boolean(y * _2n / P);
                return setMask((0, utils_1.numberToBytesBE)(x, exports.Fp.BYTES), {
                    compressed: true,
                    sort: sort
                });
            } else {
                if (isZero) {
                    // 2x PUBLIC_KEY_LENGTH
                    var x_2 = (0, utils_1.concatBytes)(new Uint8Array([
                        0x40
                    ]), new Uint8Array(2 * exports.Fp.BYTES - 1));
                    return x_2;
                } else {
                    return (0, utils_1.concatBytes)((0, utils_1.numberToBytesBE)(x, exports.Fp.BYTES), (0, utils_1.numberToBytesBE)(y, exports.Fp.BYTES));
                }
            }
        },
        ShortSignature: {
            fromHex: function(hex) {
                var _a = parseMask((0, utils_1.ensureBytes)('signatureHex', hex, 48)), infinity = _a.infinity, sort = _a.sort, value = _a.value;
                var P = exports.Fp.ORDER;
                var compressedValue = (0, utils_1.bytesToNumberBE)(value);
                // Zero
                if (infinity) return exports.bls12_381.G1.ProjectivePoint.ZERO;
                var x = exports.Fp.create(compressedValue & exports.Fp.MASK);
                var right = exports.Fp.add(exports.Fp.pow(x, _3n), exports.Fp.create(exports.bls12_381.params.G1b)); // y = x + b
                var y = exports.Fp.sqrt(right);
                if (!y) throw new Error('Invalid compressed G1 point');
                var aflag = BigInt(sort);
                if (y * _2n / P !== aflag) y = exports.Fp.neg(y);
                var point = exports.bls12_381.G1.ProjectivePoint.fromAffine({
                    x: x,
                    y: y
                });
                point.assertValidity();
                return point;
            },
            toRawBytes: function(point) {
                return signatureG1ToRawBytes(point);
            },
            toHex: function(point) {
                return (0, utils_1.bytesToHex)(signatureG1ToRawBytes(point));
            }
        }
    },
    // G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),
    // where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where
    // G - 1
    // h2q
    G2: {
        Fp: exports.Fp2,
        // cofactor
        h: BigInt('0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'),
        Gx: exports.Fp2.fromBigTuple([
            BigInt('0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'),
            BigInt('0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e')
        ]),
        // y =
        // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,
        // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905
        Gy: exports.Fp2.fromBigTuple([
            BigInt('0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'),
            BigInt('0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be')
        ]),
        a: exports.Fp2.ZERO,
        b: exports.Fp2.fromBigTuple([
            _4n,
            _4n
        ]),
        hEff: BigInt('0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'),
        htfDefaults: __assign({}, htfDefaults),
        wrapPrivateKey: true,
        allowInfinityPoint: true,
        mapToCurve: exports.G2_mapToCurve,
        // Checks is the point resides in prime-order subgroup.
        // point.isTorsionFree() should return true for valid points
        // It returns false for shitty points.
        // https://eprint.iacr.org/2021/1130.pdf
        isTorsionFree: function(c, P) {
            return P.multiplyUnsafe(exports.bls12_381.params.x).negate().equals(G2psi(c, P)); // (P) == [u](P)
        // Older version: https://eprint.iacr.org/2019/814.pdf
        // (P) => (P) => [z](P) where z = -x => [z](P) - (P) + P == O
        // return P.psi2().psi().mulNegX().subtract(psi2).add(P).isZero();
        },
        // Maps the point into the prime-order subgroup G2.
        // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11
        // https://eprint.iacr.org/2017/419.pdf
        // prettier-ignore
        clearCofactor: function(c, P) {
            var x = exports.bls12_381.params.x;
            var t1 = P.multiplyUnsafe(x).negate(); // [-x]P
            var t2 = G2psi(c, P); // (P)
            var t3 = P.double(); // 2P
            t3 = G2psi2(c, t3); // (2P)
            t3 = t3.subtract(t2); // (2P) - (P)
            t2 = t1.add(t2); // [-x]P + (P)
            t2 = t2.multiplyUnsafe(x).negate(); // [x]P - [x](P)
            t3 = t3.add(t2); // (2P) - (P) + [x]P - [x](P)
            t3 = t3.subtract(t1); // (2P) - (P) + [x]P - [x](P) + [x]P
            var Q = t3.subtract(P); // (2P) - (P) + [x]P - [x](P) + [x]P - 1P
            return Q; // [x-x-1]P + [x-1](P) + (2P)
        },
        fromBytes: function(bytes) {
            var _a = parseMask(bytes), compressed = _a.compressed, infinity = _a.infinity, sort = _a.sort, value = _a.value;
            if (!compressed && !infinity && sort || !compressed && infinity && sort || sort && infinity && compressed // 11100000
            ) {
                throw new Error('Invalid encoding flag: ' + (bytes[0] & 224));
            }
            var L = exports.Fp.BYTES;
            var slc = function(b, from, to) {
                return (0, utils_1.bytesToNumberBE)(b.slice(from, to));
            };
            if (value.length === 96 && compressed) {
                var b = exports.bls12_381.params.G2b;
                var P = exports.Fp.ORDER;
                if (infinity) {
                    // check that all bytes are 0
                    if (value.reduce(function(p, c) {
                        return p !== 0 ? c + 1 : c;
                    }, 0) > 0) {
                        throw new Error('Invalid compressed G2 point');
                    }
                    return {
                        x: exports.Fp2.ZERO,
                        y: exports.Fp2.ZERO
                    };
                }
                var x_1 = slc(value, 0, L);
                var x_0 = slc(value, L, 2 * L);
                var x = exports.Fp2.create({
                    c0: exports.Fp.create(x_0),
                    c1: exports.Fp.create(x_1)
                });
                var right = exports.Fp2.add(exports.Fp2.pow(x, _3n), b); // y = x + 4 * (u+1) = x + b
                var y = exports.Fp2.sqrt(right);
                var Y_bit = y.c1 === _0n ? y.c0 * _2n / P : y.c1 * _2n / P ? _1n : _0n;
                y = sort && Y_bit > 0 ? y : exports.Fp2.neg(y);
                return {
                    x: x,
                    y: y
                };
            } else if (value.length === 192 && !compressed) {
                if (infinity) {
                    if (value.reduce(function(p, c) {
                        return p !== 0 ? c + 1 : c;
                    }, 0) > 0) {
                        throw new Error('Invalid uncompressed G2 point');
                    }
                    return {
                        x: exports.Fp2.ZERO,
                        y: exports.Fp2.ZERO
                    };
                }
                var x1 = slc(value, 0, L);
                var x0 = slc(value, L, 2 * L);
                var y1 = slc(value, 2 * L, 3 * L);
                var y0 = slc(value, 3 * L, 4 * L);
                return {
                    x: exports.Fp2.fromBigTuple([
                        x0,
                        x1
                    ]),
                    y: exports.Fp2.fromBigTuple([
                        y0,
                        y1
                    ])
                };
            } else {
                throw new Error('Invalid point G2, expected 96/192 bytes');
            }
        },
        toBytes: function(c, point, isCompressed) {
            var len = exports.Fp.BYTES, P = exports.Fp.ORDER;
            var isZero = point.equals(c.ZERO);
            var _a = point.toAffine(), x = _a.x, y = _a.y;
            if (isCompressed) {
                if (isZero) return (0, utils_1.concatBytes)(COMPRESSED_ZERO, (0, utils_1.numberToBytesBE)(_0n, len));
                var flag = Boolean(y.c1 === _0n ? y.c0 * _2n / P : y.c1 * _2n / P);
                return (0, utils_1.concatBytes)(setMask((0, utils_1.numberToBytesBE)(x.c1, len), {
                    compressed: true,
                    sort: flag
                }), (0, utils_1.numberToBytesBE)(x.c0, len));
            } else {
                if (isZero) return (0, utils_1.concatBytes)(new Uint8Array([
                    0x40
                ]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;
                var _b = exports.Fp2.reim(x), x0 = _b.re, x1 = _b.im;
                var _d = exports.Fp2.reim(y), y0 = _d.re, y1 = _d.im;
                return (0, utils_1.concatBytes)((0, utils_1.numberToBytesBE)(x1, len), (0, utils_1.numberToBytesBE)(x0, len), (0, utils_1.numberToBytesBE)(y1, len), (0, utils_1.numberToBytesBE)(y0, len));
            }
        },
        Signature: {
            // TODO: Optimize, it's very slow because of sqrt.
            fromHex: function(hex) {
                var _a = parseMask((0, utils_1.ensureBytes)('signatureHex', hex)), infinity = _a.infinity, sort = _a.sort, value = _a.value;
                var P = exports.Fp.ORDER;
                var half = hex.length / 2;
                if (half !== 48 && half !== 96) throw new Error('Invalid compressed signature length, must be 96 or 192');
                var z1 = (0, utils_1.bytesToNumberBE)(value.slice(0, half));
                var z2 = (0, utils_1.bytesToNumberBE)(value.slice(half));
                // Indicates the infinity point
                if (infinity) return exports.bls12_381.G2.ProjectivePoint.ZERO;
                var x1 = exports.Fp.create(z1 & exports.Fp.MASK);
                var x2 = exports.Fp.create(z2);
                var x = exports.Fp2.create({
                    c0: x2,
                    c1: x1
                });
                var y2 = exports.Fp2.add(exports.Fp2.pow(x, _3n), exports.bls12_381.params.G2b); // y = x + 4
                // The slow part
                var y = exports.Fp2.sqrt(y2);
                if (!y) throw new Error('Failed to find a square root');
                // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1
                // If y1 happens to be zero, then use the bit of y0
                var _b = exports.Fp2.reim(y), y0 = _b.re, y1 = _b.im;
                var aflag1 = BigInt(sort);
                var isGreater = y1 > _0n && y1 * _2n / P !== aflag1;
                var isZero = y1 === _0n && y0 * _2n / P !== aflag1;
                if (isGreater || isZero) y = exports.Fp2.neg(y);
                var point = exports.bls12_381.G2.ProjectivePoint.fromAffine({
                    x: x,
                    y: y
                });
                point.assertValidity();
                return point;
            },
            toRawBytes: function(point) {
                return signatureG2ToRawBytes(point);
            },
            toHex: function(point) {
                return (0, utils_1.bytesToHex)(signatureG2ToRawBytes(point));
            }
        }
    },
    params: {
        x: BLS_X,
        r: Fr.ORDER
    },
    htfDefaults: htfDefaults,
    hash: sha256_1.sha256,
    randomBytes: utils_2.randomBytes
});
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/keccak.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/bls12_381.js [app-client] (ecmascript)"), exports); // DO NOT export "./_u64";
 // DO NOT export "./utils";
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/bls12_318.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFp6 = exports.isBlsResult = exports.bls12_381_finalVerify = exports.bls12_381_eqMlResult = exports.bls12_381_mulMlResult = exports.bls12_381_millerLoop = exports.bls12_381_G2_uncompress = exports.bls12_381_G2_compress = exports.bls12_381_G2_hashToGroup = exports.bls12_381_G2_equal = exports.bls12_381_G2_scalarMul = exports.bls12_381_G2_neg = exports.bls12_381_G2_add = exports.bls12_381_G1_uncompress = exports.bls12_381_G1_compress = exports.bls12_381_G1_hashToGroup = exports.bls12_381_G1_equal = exports.bls12_381_G1_scalarMul = exports.bls12_381_G1_neg = exports.bls12_381_G1_add = exports.isFp2 = exports.isBlsG2 = exports.isBlsG1 = exports.BlsG2 = exports.BlsG1 = void 0;
var noble_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/index.js [app-client] (ecmascript)");
var hash_to_curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
var sha256_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/sha256.js [app-client] (ecmascript)");
exports.BlsG1 = noble_1.bls12_381.G1.ProjectivePoint;
exports.BlsG2 = noble_1.bls12_381.G2.ProjectivePoint;
function isBlsG1(stuff) {
    return stuff instanceof exports.BlsG1 && typeof stuff.px === "bigint" && typeof stuff.py === "bigint" && typeof stuff.pz === "bigint";
}
exports.isBlsG1 = isBlsG1;
function isBlsG2(stuff) {
    return stuff instanceof exports.BlsG2 && isFp2(stuff.px) && isFp2(stuff.py) && isFp2(stuff.pz);
}
exports.isBlsG2 = isBlsG2;
function isFp2(stuff) {
    return typeof stuff === "object" && stuff !== null && !Array.isArray(stuff) && typeof stuff.c0 === "bigint" && typeof stuff.c1 === "bigint";
}
exports.isFp2 = isFp2;
var curveOrder = BigInt("52435875175126190479447740508185965837690552500527637822603658699938581184513");
var htfDefaults = Object.freeze({
    // DST: a domain separation tag
    // defined in section 2.2.5
    // Use utils.getDSTLabel(), utils.setDSTLabel(value)
    DST: "",
    encodeDST: "",
    // p: the characteristic of F
    //    where F is a finite field of characteristic p and order q = p^m
    p: noble_1.Fp.ORDER,
    // m: the extension degree of F, m >= 1
    //     where F is a finite field of characteristic p and order q = p^m
    m: 2,
    // k: the target security level for the suite in bits
    // defined in section 5.1
    k: 128,
    // option to use a message that has already been processed by
    // expand_message_xmd
    expand: 'xmd',
    // Hash functions for: expand_message_xmd is appropriate for use with a
    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.
    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247
    hash: sha256_1.sha256
});
var G2_Hasher = (0, hash_to_curve_1.createHasher)(exports.BlsG2, noble_1.G2_mapToCurve, __assign({}, htfDefaults));
var G1_Hasher = (0, hash_to_curve_1.createHasher)(exports.BlsG1, noble_1.G1_mapToCurve, __assign(__assign({}, htfDefaults), {
    m: 1,
    DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_'
}));
function bls12_381_G1_add(a, b) {
    // if( bls12_381_G1_equal( a, BlsG1.ZERO ) ) return b;
    // if( bls12_381_G1_equal( b, BlsG1.ZERO ) ) return a;
    return a.add(b);
}
exports.bls12_381_G1_add = bls12_381_G1_add;
function bls12_381_G1_neg(elem) {
    return elem.negate();
}
exports.bls12_381_G1_neg = bls12_381_G1_neg;
function bls12_381_G1_scalarMul(n, g1) {
    if (n < 0) return bls12_381_G1_scalarMul(-n, bls12_381_G1_neg(g1));
    n = BigInt(n);
    if (n >= curveOrder) n = n % curveOrder;
    if (n === BigInt(0)) return exports.BlsG1.ZERO;
    return g1.multiply(n);
}
exports.bls12_381_G1_scalarMul = bls12_381_G1_scalarMul;
function bls12_381_G1_equal(a, b) {
    return a.equals(b);
}
exports.bls12_381_G1_equal = bls12_381_G1_equal;
function bls12_381_G1_hashToGroup(a, b) {
    // noble-curves can handle that but the plutus-machine doesn't
    // so we artificially throw an error here
    if (b.length > 255) throw new Error("DST length can not be greater than 255");
    return exports.BlsG1.fromAffine(G1_Hasher.hashToCurve(a, {
        DST: b
    }).toAffine());
}
exports.bls12_381_G1_hashToGroup = bls12_381_G1_hashToGroup;
function bls12_381_G1_compress(elem) {
    return elem.toRawBytes();
}
exports.bls12_381_G1_compress = bls12_381_G1_compress;
function bls12_381_G1_uncompress(compressed) {
    var _a = (0, noble_1.parseMask)(compressed), compressed_bit = _a.compressed, infinity = _a.infinity, sort = _a.sort, value = _a.value;
    // point zero edge case
    if (compressed_bit && infinity && sort && value.every(function(n) {
        return n === 0;
    })) throw new Error("sign bit set on pont ZERO, we don't like it");
    // not compressed bytes would be totally fine for the library but we artificially fail here
    // https://github.com/IntersectMBO/plutus/blob/master/plutus-conformance/test-cases/uplc/evaluation/builtin/semantics/bls12_381_G1_uncompress/on-curve-serialised-not-compressed/on-curve-serialised-not-compressed.uplc
    if (!compressed_bit) throw new Error("uncompress only works with compressed byets");
    return exports.BlsG1.fromHex(compressed);
}
exports.bls12_381_G1_uncompress = bls12_381_G1_uncompress;
function bls12_381_G2_add(a, b) {
    // if( bls12_381_G2_equal( a, BlsG2.ZERO ) ) return b;
    // if( bls12_381_G2_equal( b, BlsG2.ZERO ) ) return a;
    return a.add(b);
}
exports.bls12_381_G2_add = bls12_381_G2_add;
function bls12_381_G2_neg(elem) {
    return elem.negate();
}
exports.bls12_381_G2_neg = bls12_381_G2_neg;
function bls12_381_G2_scalarMul(n, g2) {
    if (n < 0) return bls12_381_G2_scalarMul(-n, bls12_381_G2_neg(g2));
    n = BigInt(n);
    if (n >= curveOrder) n = n % curveOrder;
    if (n === BigInt(0)) return exports.BlsG2.ZERO;
    return g2.multiply(BigInt(n));
}
exports.bls12_381_G2_scalarMul = bls12_381_G2_scalarMul;
function bls12_381_G2_equal(a, b) {
    return a.equals(b);
}
exports.bls12_381_G2_equal = bls12_381_G2_equal;
function bls12_381_G2_hashToGroup(a, b) {
    // noble-curves can handle that but the plutus-machine doesn't
    // so we artificially throw an error here
    if (b.length > 255) throw new Error("DST length can not be greater than 255");
    return exports.BlsG2.fromAffine(G2_Hasher.hashToCurve(a, {
        DST: b
    }).toAffine());
}
exports.bls12_381_G2_hashToGroup = bls12_381_G2_hashToGroup;
function bls12_381_G2_compress(elem) {
    return elem.toRawBytes();
}
exports.bls12_381_G2_compress = bls12_381_G2_compress;
function bls12_381_G2_uncompress(compressed) {
    var compressed_bit = (0, noble_1.parseMask)(compressed).compressed;
    // not compressed bytes would be totally fine for the library but we artificially fail here
    // https://github.com/IntersectMBO/plutus/blob/master/plutus-conformance/test-cases/uplc/evaluation/builtin/semantics/bls12_381_G2_uncompress/on-curve-serialised-not-compressed/on-curve-serialised-not-compressed.uplc
    if (!compressed_bit) throw new Error("uncompress only works with compressed byets");
    return exports.BlsG2.fromHex(compressed);
}
exports.bls12_381_G2_uncompress = bls12_381_G2_uncompress;
function bls12_381_millerLoop(g1, g2) {
    var _a = g1.toAffine(), x = _a.x, y = _a.y;
    return millerLoop(pairingPrecomputes(g2), [
        x,
        y
    ]);
}
exports.bls12_381_millerLoop = bls12_381_millerLoop;
function bls12_381_mulMlResult(a, b) {
    return (0, noble_1.Fp12Multiply)(a, b);
}
exports.bls12_381_mulMlResult = bls12_381_mulMlResult;
exports.bls12_381_eqMlResult = noble_1.Fp12_eql;
function bls12_381_finalVerify(a, b) {
    // blst implementation https://github.com/supranational/blst/blob/0d46eefa45fc1e57aceb42bba0e84eab3a7a9725/src/aggregate.c#L506
    var GT = (0, noble_1.Fp12_conjugate)(a);
    GT = (0, noble_1.Fp12Multiply)(GT, b);
    GT = (0, noble_1.Fp12_finalExponentiate)(GT);
    return (0, noble_1.Fp12_eql)(GT, noble_1.Fp12_ONE);
}
exports.bls12_381_finalVerify = bls12_381_finalVerify;
// The BLS parameter x for BLS12-381
var BLS_X = BigInt('0xd201000000010000');
var BLS_X_LEN = (0, utils_1.bitLen)(BLS_X);
var _2n = BigInt(2), _3n = BigInt(3);
// Pre-compute coefficients for sparse multiplication
// Point addition and point double calculations is reused for coefficients
function calcPairingPrecomputes(p) {
    var x = p.x, y = p.y;
    // prettier-ignore
    var Qx = x, Qy = y, Qz = noble_1.Fp2.ONE;
    // prettier-ignore
    var Rx = Qx, Ry = Qy, Rz = Qz;
    var ell_coeff = [];
    for(var i = BLS_X_LEN - 2; i >= 0; i--){
        // Double
        var t0 = noble_1.Fp2.sqr(Ry); // Ry
        var t1 = noble_1.Fp2.sqr(Rz); // Rz
        var t2 = noble_1.Fp2.multiplyByB(noble_1.Fp2.mul(t1, _3n)); // 3 * T1 * B
        var t3 = noble_1.Fp2.mul(t2, _3n); // 3 * T2
        var t4 = noble_1.Fp2.sub(noble_1.Fp2.sub(noble_1.Fp2.sqr(noble_1.Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz) - T1 - T0
        ell_coeff.push([
            noble_1.Fp2.sub(t2, t0),
            noble_1.Fp2.mul(noble_1.Fp2.sqr(Rx), _3n),
            noble_1.Fp2.neg(t4)
        ]);
        Rx = noble_1.Fp2.div(noble_1.Fp2.mul(noble_1.Fp2.mul(noble_1.Fp2.sub(t0, t3), Rx), Ry), _2n); // ((T0 - T3) * Rx * Ry) / 2
        Ry = noble_1.Fp2.sub(noble_1.Fp2.sqr(noble_1.Fp2.div(noble_1.Fp2.add(t0, t3), _2n)), noble_1.Fp2.mul(noble_1.Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2) - 3 * T2
        Rz = noble_1.Fp2.mul(t0, t4); // T0 * T4
        if ((0, utils_1.bitGet)(BLS_X /*CURVE.params.x*/ , i)) {
            // Addition
            var t0_1 = noble_1.Fp2.sub(Ry, noble_1.Fp2.mul(Qy, Rz)); // Ry - Qy * Rz
            var t1_1 = noble_1.Fp2.sub(Rx, noble_1.Fp2.mul(Qx, Rz)); // Rx - Qx * Rz
            ell_coeff.push([
                noble_1.Fp2.sub(noble_1.Fp2.mul(t0_1, Qx), noble_1.Fp2.mul(t1_1, Qy)),
                noble_1.Fp2.neg(t0_1),
                t1_1
            ]);
            var t2_1 = noble_1.Fp2.sqr(t1_1); // T1
            var t3_1 = noble_1.Fp2.mul(t2_1, t1_1); // T2 * T1
            var t4_1 = noble_1.Fp2.mul(t2_1, Rx); // T2 * Rx
            var t5 = noble_1.Fp2.add(noble_1.Fp2.sub(t3_1, noble_1.Fp2.mul(t4_1, _2n)), noble_1.Fp2.mul(noble_1.Fp2.sqr(t0_1), Rz)); // T3 - 2 * T4 + T0 * Rz
            Rx = noble_1.Fp2.mul(t1_1, t5); // T1 * T5
            Ry = noble_1.Fp2.sub(noble_1.Fp2.mul(noble_1.Fp2.sub(t4_1, t5), t0_1), noble_1.Fp2.mul(t3_1, Ry)); // (T4 - T5) * T0 - T3 * Ry
            Rz = noble_1.Fp2.mul(Rz, t3_1); // Rz * T3
        }
    }
    return ell_coeff;
}
function pairingPrecomputes(point) {
    var p = point;
    if (p._PPRECOMPUTES) return p._PPRECOMPUTES;
    p._PPRECOMPUTES = calcPairingPrecomputes(point.toAffine());
    return p._PPRECOMPUTES;
}
function millerLoop(ell, g1) {
    var x = BLS_X;
    var Px = g1[0];
    var Py = g1[1];
    var f12 = noble_1.Fp12.ONE;
    for(var j = 0, i = BLS_X_LEN - 2; i >= 0; i--, j++){
        var E = ell[j];
        f12 = noble_1.Fp12.multiplyBy014(f12, E[0], noble_1.Fp2.mul(E[1], Px), noble_1.Fp2.mul(E[2], Py));
        if ((0, utils_1.bitGet)(x, i)) {
            j += 1;
            var F = ell[j];
            f12 = noble_1.Fp12.multiplyBy014(f12, F[0], noble_1.Fp2.mul(F[1], Px), noble_1.Fp2.mul(F[2], Py));
        }
        if (i !== 0) f12 = noble_1.Fp12.sqr(f12);
    }
    return noble_1.Fp12.conjugate(f12);
}
function isBlsResult(stuff) {
    return typeof stuff === "object" && stuff !== null && !Array.isArray(stuff) && isFp6(stuff.c0) && isFp6(stuff.c1);
}
exports.isBlsResult = isBlsResult;
function isFp6(stuff) {
    return typeof stuff === "object" && stuff !== null && !Array.isArray(stuff) && isFp2(stuff.c0) && isFp2(stuff.c1) && isFp2(stuff.c2);
}
exports.isFp6 = isFp6;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha2_512 = exports._sha2_512_pad = void 0;
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
/**
 * Pad a bytearray so its size is a multiple of 128 (1024 bits).
 * Internal method.
 */ function _sha2_512_pad(src) {
    var nBits = src.length * 8;
    // clone
    var dst = src.slice();
    dst.push(0x80);
    var nZeroes = 128 - dst.length % 128 - 8;
    if (nZeroes < 0) {
        nZeroes += 128;
    }
    for(var i = 0; i < nZeroes; i++){
        dst.push(0);
    }
    // assume nBits fits in 32 bits
    dst.push(0);
    dst.push(0);
    dst.push(0);
    dst.push(0);
    dst.push(nBits >> 24 & 0xff);
    dst.push(nBits >> 16 & 0xff);
    dst.push(nBits >> 8 & 0xff);
    dst.push(nBits >> 0 & 0xff);
    return dst;
}
exports._sha2_512_pad = _sha2_512_pad;
var _sha2_512_k = Object.freeze([
    (0, types_1.uint64)("0x428a2f98d728ae22"),
    (0, types_1.uint64)("0x7137449123ef65cd"),
    (0, types_1.uint64)("0xb5c0fbcfec4d3b2f"),
    (0, types_1.uint64)("0xe9b5dba58189dbbc"),
    (0, types_1.uint64)("0x3956c25bf348b538"),
    (0, types_1.uint64)("0x59f111f1b605d019"),
    (0, types_1.uint64)("0x923f82a4af194f9b"),
    (0, types_1.uint64)("0xab1c5ed5da6d8118"),
    (0, types_1.uint64)("0xd807aa98a3030242"),
    (0, types_1.uint64)("0x12835b0145706fbe"),
    (0, types_1.uint64)("0x243185be4ee4b28c"),
    (0, types_1.uint64)("0x550c7dc3d5ffb4e2"),
    (0, types_1.uint64)("0x72be5d74f27b896f"),
    (0, types_1.uint64)("0x80deb1fe3b1696b1"),
    (0, types_1.uint64)("0x9bdc06a725c71235"),
    (0, types_1.uint64)("0xc19bf174cf692694"),
    (0, types_1.uint64)("0xe49b69c19ef14ad2"),
    (0, types_1.uint64)("0xefbe4786384f25e3"),
    (0, types_1.uint64)("0x0fc19dc68b8cd5b5"),
    (0, types_1.uint64)("0x240ca1cc77ac9c65"),
    (0, types_1.uint64)("0x2de92c6f592b0275"),
    (0, types_1.uint64)("0x4a7484aa6ea6e483"),
    (0, types_1.uint64)("0x5cb0a9dcbd41fbd4"),
    (0, types_1.uint64)("0x76f988da831153b5"),
    (0, types_1.uint64)("0x983e5152ee66dfab"),
    (0, types_1.uint64)("0xa831c66d2db43210"),
    (0, types_1.uint64)("0xb00327c898fb213f"),
    (0, types_1.uint64)("0xbf597fc7beef0ee4"),
    (0, types_1.uint64)("0xc6e00bf33da88fc2"),
    (0, types_1.uint64)("0xd5a79147930aa725"),
    (0, types_1.uint64)("0x06ca6351e003826f"),
    (0, types_1.uint64)("0x142929670a0e6e70"),
    (0, types_1.uint64)("0x27b70a8546d22ffc"),
    (0, types_1.uint64)("0x2e1b21385c26c926"),
    (0, types_1.uint64)("0x4d2c6dfc5ac42aed"),
    (0, types_1.uint64)("0x53380d139d95b3df"),
    (0, types_1.uint64)("0x650a73548baf63de"),
    (0, types_1.uint64)("0x766a0abb3c77b2a8"),
    (0, types_1.uint64)("0x81c2c92e47edaee6"),
    (0, types_1.uint64)("0x92722c851482353b"),
    (0, types_1.uint64)("0xa2bfe8a14cf10364"),
    (0, types_1.uint64)("0xa81a664bbc423001"),
    (0, types_1.uint64)("0xc24b8b70d0f89791"),
    (0, types_1.uint64)("0xc76c51a30654be30"),
    (0, types_1.uint64)("0xd192e819d6ef5218"),
    (0, types_1.uint64)("0xd69906245565a910"),
    (0, types_1.uint64)("0xf40e35855771202a"),
    (0, types_1.uint64)("0x106aa07032bbd1b8"),
    (0, types_1.uint64)("0x19a4c116b8d2d0c8"),
    (0, types_1.uint64)("0x1e376c085141ab53"),
    (0, types_1.uint64)("0x2748774cdf8eeb99"),
    (0, types_1.uint64)("0x34b0bcb5e19b48a8"),
    (0, types_1.uint64)("0x391c0cb3c5c95a63"),
    (0, types_1.uint64)("0x4ed8aa4ae3418acb"),
    (0, types_1.uint64)("0x5b9cca4f7763e373"),
    (0, types_1.uint64)("0x682e6ff3d6b2b8a3"),
    (0, types_1.uint64)("0x748f82ee5defb2fc"),
    (0, types_1.uint64)("0x78a5636f43172f60"),
    (0, types_1.uint64)("0x84c87814a1f0ab72"),
    (0, types_1.uint64)("0x8cc702081a6439ec"),
    (0, types_1.uint64)("0x90befffa23631e28"),
    (0, types_1.uint64)("0xa4506cebde82bde9"),
    (0, types_1.uint64)("0xbef9a3f7b2c67915"),
    (0, types_1.uint64)("0xc67178f2e372532b"),
    (0, types_1.uint64)("0xca273eceea26619c"),
    (0, types_1.uint64)("0xd186b8c721c0c207"),
    (0, types_1.uint64)("0xeada7dd6cde0eb1e"),
    (0, types_1.uint64)("0xf57d4f7fee6ed178"),
    (0, types_1.uint64)("0x06f067aa72176fba"),
    (0, types_1.uint64)("0x0a637dc5a2c898a6"),
    (0, types_1.uint64)("0x113f9804bef90dae"),
    (0, types_1.uint64)("0x1b710b35131c471b"),
    (0, types_1.uint64)("0x28db77f523047d84"),
    (0, types_1.uint64)("0x32caab7b40c72493"),
    (0, types_1.uint64)("0x3c9ebe0a15c9bebc"),
    (0, types_1.uint64)("0x431d67c49c100d4c"),
    (0, types_1.uint64)("0x4cc5d4becb3e42b6"),
    (0, types_1.uint64)("0x597f299cfc657e2a"),
    (0, types_1.uint64)("0x5fcb6fab3ad6faec"),
    (0, types_1.uint64)("0x6c44198c4a475817")
]);
/**
 * getulates sha2-512 (64bytes) hash of a list of uint8 numbers.
 * Result is also a list of uint8 number.
 * @example
 * bytesToHex(sha2_512([0x61, 0x62, 0x63])) => "ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"
 * @example
 * bytesToHex(sha2_512([])) => "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"
 * @param {number[]} bytes - list of uint8 numbers
 * @returns {number[]} - list of uint8 numbers
 */ function sha2_512(bytes) {
    if (bytes instanceof Uint8Array) bytes = Array.from(bytes);
    // initial has; updated later
    var hash = [
        (0, types_1.uint64)("0x6a09e667f3bcc908"),
        (0, types_1.uint64)("0xbb67ae8584caa73b"),
        (0, types_1.uint64)("0x3c6ef372fe94f82b"),
        (0, types_1.uint64)("0xa54ff53a5f1d36f1"),
        (0, types_1.uint64)("0x510e527fade682d1"),
        (0, types_1.uint64)("0x9b05688c2b3e6c1f"),
        (0, types_1.uint64)("0x1f83d9abfb41bd6b"),
        (0, types_1.uint64)("0x5be0cd19137e2179")
    ];
    function sigma0(x) {
        return (0, types_1.forceUint64)((0, types_1.uint64Rotr)(x, 1) ^ (0, types_1.uint64Rotr)(x, 8) ^ x >> BigInt(7));
    }
    function sigma1(x) {
        return (0, types_1.forceUint64)((0, types_1.uint64Rotr)(x, 19) ^ (0, types_1.uint64Rotr)(x, 61) ^ x >> BigInt(6));
    }
    bytes = _sha2_512_pad(bytes);
    // break message in successive 64 byte chunks
    for(var chunkStart = 0; chunkStart < bytes.length; chunkStart += 128){
        var chunk = bytes.slice(chunkStart, chunkStart + 128);
        var w = new Array(80).fill(BigInt(0)); // array of 32 bit numbers!
        // copy chunk into first 16 hi/lo positions of w (i.e. into first 32 uint32 positions)
        for(var i = 0; i < 16; i++){
            w[i] = (0, types_1.uint64)("0x" + (0, types_1.byteArrToHex)(chunk.slice(i * 8, i * 8 + 8)));
        }
        // extends the first 16 positions into the remaining 80 positions
        for(var i = 16; i < 80; i++){
            w[i] = (0, types_1.forceUint64)(sigma1(w[i - 2]) + w[i - 7] + sigma0(w[i - 15]) + w[i - 16]);
        }
        // intialize working variables to current hash value
        var a = hash[0];
        var b = hash[1];
        var c = hash[2];
        var d = hash[3];
        var e = hash[4];
        var f = hash[5];
        var g = hash[6];
        var h = hash[7];
        // compression function main loop
        for(var i = 0; i < 80; i++){
            var S1 = (0, types_1.uint64Rotr)(e, 14) ^ (0, types_1.uint64Rotr)(e, 18) ^ (0, types_1.uint64Rotr)(e, 41);
            var ch = e & f ^ ~e & g;
            var temp1 = (0, types_1.forceUint64)(h + S1 + ch + _sha2_512_k[i] + w[i]);
            var S0 = (0, types_1.uint64Rotr)(a, 28) ^ (0, types_1.uint64Rotr)(a, 34) ^ (0, types_1.uint64Rotr)(a, 39);
            var maj = a & b ^ a & c ^ b & c;
            var temp2 = (0, types_1.forceUint64)(S0 + maj);
            h = g;
            g = f;
            f = e;
            e = (0, types_1.forceUint64)(d + temp1);
            d = c;
            c = b;
            b = a;
            a = (0, types_1.forceUint64)(temp1 + temp2);
        }
        // update the hash
        hash[0] = (0, types_1.forceUint64)(hash[0] + a);
        hash[1] = (0, types_1.forceUint64)(hash[1] + b);
        hash[2] = (0, types_1.forceUint64)(hash[2] + c);
        hash[3] = (0, types_1.forceUint64)(hash[3] + d);
        hash[4] = (0, types_1.forceUint64)(hash[4] + e);
        hash[5] = (0, types_1.forceUint64)(hash[5] + f);
        hash[6] = (0, types_1.forceUint64)(hash[6] + g);
        hash[7] = (0, types_1.forceUint64)(hash[7] + h);
    }
    // produce the final digest of uint8 numbers
    var result = [];
    for(var i = 0; i < 8; i++){
        result.push.apply(result, __spreadArray([], __read((0, types_1.uint64ToBytesBE)(hash[i])), false));
    }
    return new Uint8Array(result);
}
exports.sha2_512 = sha2_512;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/positiveMod.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.positiveMod = void 0;
function positiveMod(x, n) {
    var _n = BigInt(n);
    var res = BigInt(x) % _n;
    return res < BigInt(0) ? res + _n : res;
}
exports.positiveMod = positiveMod;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/bigintToBuffer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bigintToBuffer = void 0;
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
function bigintToBuffer(bigint, nBytes) {
    if (nBytes === void 0) {
        nBytes = undefined;
    }
    (0, assert_1.assert)(bigint >= BigInt(0), "cannot convert negative bigint to buffer");
    if (bigint == BigInt(0)) {
        if (nBytes === undefined) {
            return Uint8Array.from([]);
        }
        return new Uint8Array(nBytes);
    }
    var buffHexString = bigint.toString(16);
    buffHexString = buffHexString.length % 2 === 0 ? buffHexString : '0' + buffHexString;
    if (nBytes !== undefined) {
        (0, assert_1.assert)(Math.round(Math.abs(nBytes)) === nBytes, "cannot construct a buffer of length " + nBytes + ", while using BigIntUtils.toBufferOfNBytesBE");
        // pads with zeroes so that the final length is of nBytes*2 (2 hex digits per byte)
        // String.prototype.padStart docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
        buffHexString = buffHexString.padStart(nBytes * 2, "00");
        if (buffHexString.length > nBytes * 2) {
            console.warn("required buffer size is smaller than the one used effectively by the given bigint, truncating the initial bytes as overflow");
            buffHexString = buffHexString.slice(buffHexString.length - nBytes * 2);
        }
    }
    return (0, uint8array_utils_1.fromHex)(buffHexString);
}
exports.bigintToBuffer = bigintToBuffer;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/ed25519.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __generator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ed25519bigint = exports.verifyEd25519Signature = exports.getEd25519Signature = exports.signExtendedEd25519 = exports.signEd25519 = exports.extendedToPublic = exports.deriveEd25519PublicKey = exports.extendEd25519PrivateKey = exports.scalarMultBase = exports.scalarFromBytes = exports.pointFromBytes = exports.bigpointToUint8Array = exports.encodeInt = exports.scalarMul = exports.addPointsEdwards = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var sha2_512_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)");
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var positiveMod_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/positiveMod.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
var bigintToBuffer_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/bigintToBuffer.js [app-client] (ecmascript)");
var Q = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"); // ipowi(255) - 19
var Q38 = BigInt("7237005577332262213973186563042994240829374041602535252466099000494570602494"); // (Q + 3)/8
var CURVE_ORDER = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"); // ipow2(252) + 27742317777372353535851937790883648493;
var D = -BigInt("4513249062541557337682894930092624173785641285191125241628941591882900924598840740"); // -121665 * invert(121666);
var I = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"); // expMod(BigInt( 2 ), (Q - BigInt( 1 ))/4, Q);
var BASE = Object.freeze([
    BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960") // (4*invert(5)) % Q
]);
/**
 *
 * @param {bigint} b
 * @param {bigint} e
 * @param {bigint} m
 * @returns {bigint}
 */ function expMod(b, e, m) {
    if (e == BigInt(0)) {
        return BigInt(1);
    } else {
        var t = expMod(b, e / BigInt(2), m);
        t = t * t % m;
        if (e % BigInt(2) != BigInt(0)) {
            t = (0, positiveMod_1.positiveMod)(t * b, m);
        }
        return t;
    }
}
function invert(n) {
    var a = (0, positiveMod_1.positiveMod)(n, Q);
    var b = Q;
    var x = BigInt(0);
    var y = BigInt(1);
    var u = BigInt(1);
    var v = BigInt(0);
    while(a !== BigInt(0)){
        var q = b / a;
        var r = b % a;
        var m = x - u * q;
        var n_1 = y - v * q;
        b = a;
        a = r;
        x = u;
        y = v;
        u = m;
        v = n_1;
    }
    return (0, positiveMod_1.positiveMod)(x, Q);
}
/**
 * @param {bigint} y
 * @returns {bigint}
 */ function recoverX(y) {
    var yy = y * y;
    var xx = (yy - BigInt(1)) * invert(D * yy + BigInt(1));
    var x = expMod(xx, Q38, Q);
    if ((x * x - xx) % Q !== BigInt(0)) {
        x = x * I % Q;
    }
    if (x % BigInt(2) !== BigInt(0)) {
        x = Q - x;
    }
    return x;
}
/**
 * Curve point 'addition'
 * Note: this is probably the bottleneck of this Ed25519 implementation
 */ function addPointsEdwards(a, b) {
    var x1 = a[0];
    var y1 = a[1];
    var x2 = b[0];
    var y2 = b[1];
    var dxxyy = D * x1 * x2 * y1 * y2;
    var x3 = (x1 * y2 + x2 * y1) * invert(BigInt(1) + dxxyy);
    var y3 = (y1 * y2 + x1 * x2) * invert(BigInt(1) - dxxyy);
    return [
        (0, positiveMod_1.positiveMod)(x3, Q),
        (0, positiveMod_1.positiveMod)(y3, Q)
    ];
}
exports.addPointsEdwards = addPointsEdwards;
function scalarMul(point, n) {
    if (n === BigInt(0)) {
        return [
            BigInt(0),
            BigInt(1)
        ];
    } else {
        var sum = scalarMul(point, n / BigInt(2));
        sum = addPointsEdwards(sum, sum);
        if (n % BigInt(2) !== BigInt(0)) {
            sum = addPointsEdwards(sum, point);
        }
        return sum;
    }
}
exports.scalarMul = scalarMul;
/**
 * Curve point 'multiplication'
 */ function encodeInt(y) {
    var bytes = Array.from((0, bigintToBuffer_1.bigintToBuffer)(y)).reverse();
    while(bytes.length < 32){
        bytes.push(0);
    }
    return bytes;
}
exports.encodeInt = encodeInt;
function decodeInt(s) {
    return BigInt("0x" + (0, types_1.byteArrToHex)(s.reverse()));
}
function bigpointToByteArray(point) {
    var _a = __read(point, 2), x = _a[0], y = _a[1];
    var bytes = encodeInt(y);
    // last bit is determined by x
    bytes[31] = bytes[31] & 255 | Number(x & BigInt(1)) * 128;
    return bytes;
}
function bigpointToUint8Array(point) {
    return new Uint8Array(bigpointToByteArray(point));
}
exports.bigpointToUint8Array = bigpointToUint8Array;
function getBit(bytes, i) {
    return bytes[Math.floor(i / 8)] >> i % 8 & 1;
}
function isOnCurve(point) {
    var x = point[0];
    var y = point[1];
    var xx = x * x;
    var yy = y * y;
    return (-xx + yy - BigInt(1) - D * xx * yy) % Q == BigInt(0);
}
function pointFromBytes(s) {
    if (s instanceof Uint8Array) s = asBytes(s);
    (0, assert_1.assert)(s.length == 32, "point must have length of 32");
    var bytes = s.slice();
    bytes[31] = bytes[31] & 127;
    var y = decodeInt(bytes);
    var x = recoverX(y);
    if (Number(x & BigInt(1)) != getBit(s, 255)) {
        x = Q - x;
    }
    var point = [
        x,
        y
    ];
    if (!isOnCurve(point)) {
        throw new Error("point isn't on curve");
    }
    return point;
}
exports.pointFromBytes = pointFromBytes;
var ipow2_253 = BigInt("28948022309329048855892746252171976963317496166410141009864396001978282409984"); // ipow2(253)
function scalarFromBytes(h) {
    var bytes = h.slice(0, 32);
    bytes[0] = bytes[0] & 248;
    bytes[31] = bytes[31] & 63;
    return ipow2_253 + BigInt("0x" + (0, types_1.byteArrToHex)(bytes.reverse()));
}
exports.scalarFromBytes = scalarFromBytes;
function ihash(m) {
    return decodeInt((0, sha2_512_1.sha2_512)(m));
}
function forceUint8Array(stuff) {
    if (typeof stuff === "string") return (0, uint8array_utils_1.fromHex)(stuff);
    return (0, uint8array_utils_1.isUint8Array)(stuff) ? stuff : new Uint8Array(stuff);
}
function scalarMultBase(scalar) {
    return scalarMul(BASE, scalar);
}
exports.scalarMultBase = scalarMultBase;
function extendEd25519PrivateKey(privateKey) {
    var extended = (0, sha2_512_1.sha2_512)(privateKey);
    var extension = extended.slice(32, 64);
    var a = scalarFromBytes(extended.slice(0, 32));
    return [
        a,
        extension
    ];
}
exports.extendEd25519PrivateKey = extendEd25519PrivateKey;
function deriveEd25519PublicKey(privateKey) {
    var extended = (0, sha2_512_1.sha2_512)(privateKey);
    var a = scalarFromBytes(extended);
    var A = scalarMul(BASE, a);
    return bigpointToByteArray(A);
}
exports.deriveEd25519PublicKey = deriveEd25519PublicKey;
function extendedToPublic(extended) {
    if (extended instanceof Uint8Array) extended = Array.from(extended);
    var a = scalarFromBytes(extended);
    var A = scalarMul(BASE, a);
    return new Uint8Array(bigpointToByteArray(A));
}
exports.extendedToPublic = extendedToPublic;
function asBytes(stuff) {
    if (typeof stuff === "string") return asBytes((0, uint8array_utils_1.fromHex)(stuff));
    return Array.from(stuff);
}
function signEd25519(message, privateKey) {
    message = forceUint8Array(message);
    privateKey = forceUint8Array(privateKey);
    return signExtendedEd25519(message, (0, sha2_512_1.sha2_512)(asBytes(privateKey)));
}
exports.signEd25519 = signEd25519;
function signExtendedEd25519(message, extendedKey) {
    var _a;
    message = forceUint8Array(message);
    extendedKey = forceUint8Array(extendedKey);
    if (extendedKey.length !== 64) throw new Error('signExtendedEd25519:: extended key must have length 64');
    var privateKeyHash = asBytes(extendedKey);
    var a = scalarFromBytes(privateKeyHash);
    // for convenience getulate publicKey here:
    var publicKey = bigpointToByteArray(scalarMul(BASE, a));
    var r = ihash(privateKeyHash.slice(32, 64).concat(asBytes(message)));
    var R = scalarMul(BASE, r);
    var S = (0, positiveMod_1.positiveMod)(r + ihash(bigpointToByteArray(R).concat(publicKey).concat(asBytes(message))) * a, CURVE_ORDER);
    var pubKey = new Uint8Array(publicKey);
    var signature = new Uint8Array(bigpointToByteArray(R).concat(encodeInt(S)));
    return _a = {
        0: pubKey,
        1: signature,
        length: 2
    }, _a[Symbol.iterator] = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        pubKey
                    ];
                case 1:
                    _a.sent();
                    return [
                        4 /*yield*/ ,
                        signature
                    ];
                case 2:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    }, _a.pubKey = pubKey, _a.signature = signature, _a;
}
exports.signExtendedEd25519 = signExtendedEd25519;
function getEd25519Signature(message, privateKey) {
    return signEd25519(message, privateKey).signature;
}
exports.getEd25519Signature = getEd25519Signature;
function verifyEd25519Signature(signature, message, publicKey) {
    if (signature.length !== 64 || publicKey.length != 32) {
        throw new Error("unexpected signature length ".concat(signature.length));
    }
    if ((0, uint8array_utils_1.isUint8Array)(signature)) {
        signature = (0, types_1.buffToByteArr)(signature);
    }
    if ((0, uint8array_utils_1.isUint8Array)(message)) {
        message = (0, types_1.buffToByteArr)(message);
    }
    if ((0, uint8array_utils_1.isUint8Array)(publicKey)) {
        publicKey = (0, types_1.buffToByteArr)(publicKey);
    }
    var R = pointFromBytes(asBytes(signature).slice(0, 32));
    var A = pointFromBytes(asBytes(publicKey));
    var S = decodeInt(asBytes(signature).slice(32, 64));
    var h = ihash(asBytes(signature).slice(0, 32).concat(asBytes(publicKey)).concat(asBytes(message)));
    var left = scalarMul(BASE, S);
    var right = addPointsEdwards(R, scalarMul(A, h));
    return left[0] == right[0] && left[1] == right[1];
}
exports.verifyEd25519Signature = verifyEd25519Signature;
var _0n = BigInt(0);
var ED25519_ORDER = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');
function mod(a, b) {
    var result = a % b;
    return result >= _0n ? result : b + result;
}
function ed25519bigint(n) {
    return mod(n, ED25519_ORDER);
}
exports.ed25519bigint = ed25519bigint;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/hmac.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hmac = exports.HMAC = void 0;
var _assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_assert.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// HMAC (RFC 2104)
var HMAC = function(_super) {
    __extends(HMAC, _super);
    function HMAC(hash, _key) {
        var _this = _super.call(this) || this;
        _this.finished = false;
        _this.destroyed = false;
        (0, _assert_1.hash)(hash);
        var key = (0, utils_1.toBytes)(_key);
        _this.iHash = hash.create();
        if (typeof _this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
        _this.blockLen = _this.iHash.blockLen;
        _this.outputLen = _this.iHash.outputLen;
        var blockLen = _this.blockLen;
        var pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(var i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        _this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        _this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(var i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;
        _this.oHash.update(pad);
        pad.fill(0);
        return _this;
    }
    HMAC.prototype.update = function(buf) {
        (0, _assert_1.exists)(this);
        this.iHash.update(buf);
        return this;
    };
    HMAC.prototype.digestInto = function(out) {
        (0, _assert_1.exists)(this);
        (0, _assert_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    };
    HMAC.prototype.digest = function() {
        var out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    };
    HMAC.prototype._cloneInto = function(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        var _a = this, oHash = _a.oHash, iHash = _a.iHash, finished = _a.finished, destroyed = _a.destroyed, blockLen = _a.blockLen, outputLen = _a.outputLen;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    };
    HMAC.prototype.destroy = function() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    };
    return HMAC;
}(utils_1.Hash);
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */ var hmac = function(hash, key, message) {
    return new HMAC(hash, key).update(message).digest();
};
exports.hmac = hmac;
exports.hmac.create = function(hash, key) {
    return new HMAC(hash, key);
};
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/sha512.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
var _md_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_md.js [app-client] (ecmascript)");
var u64 = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_u64.js [app-client] (ecmascript)"));
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
var _a = __read(/* @__PURE__ */ function() {
    return u64.split([
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
    ].map(function(n) {
        return BigInt(n);
    }));
}(), 2), SHA512_Kh = _a[0], SHA512_Kl = _a[1];
// Temporary buffer, not used to store anything between runs
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = function(_super) {
    __extends(SHA512, _super);
    function SHA512() {
        var _this = _super.call(this, 128, 64, 16, false) || this;
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        _this.Ah = 0x6a09e667 | 0;
        _this.Al = 0xf3bcc908 | 0;
        _this.Bh = 0xbb67ae85 | 0;
        _this.Bl = 0x84caa73b | 0;
        _this.Ch = 0x3c6ef372 | 0;
        _this.Cl = 0xfe94f82b | 0;
        _this.Dh = 0xa54ff53a | 0;
        _this.Dl = 0x5f1d36f1 | 0;
        _this.Eh = 0x510e527f | 0;
        _this.El = 0xade682d1 | 0;
        _this.Fh = 0x9b05688c | 0;
        _this.Fl = 0x2b3e6c1f | 0;
        _this.Gh = 0x1f83d9ab | 0;
        _this.Gl = 0xfb41bd6b | 0;
        _this.Hh = 0x5be0cd19 | 0;
        _this.Hl = 0x137e2179 | 0;
        return _this;
    }
    // prettier-ignore
    SHA512.prototype.get = function() {
        var _a = this, Ah = _a.Ah, Al = _a.Al, Bh = _a.Bh, Bl = _a.Bl, Ch = _a.Ch, Cl = _a.Cl, Dh = _a.Dh, Dl = _a.Dl, Eh = _a.Eh, El = _a.El, Fh = _a.Fh, Fl = _a.Fl, Gh = _a.Gh, Gl = _a.Gl, Hh = _a.Hh, Hl = _a.Hl;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    };
    // prettier-ignore
    SHA512.prototype.set = function(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    };
    SHA512.prototype.process = function(view, offset) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(var i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(var i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            var W15h = SHA512_W_H[i - 15] | 0;
            var W15l = SHA512_W_L[i - 15] | 0;
            var s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            var s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            var W2h = SHA512_W_H[i - 2] | 0;
            var W2l = SHA512_W_L[i - 2] | 0;
            var s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            var s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            var SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            var SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        var _k = this, Ah = _k.Ah, Al = _k.Al, Bh = _k.Bh, Bl = _k.Bl, Ch = _k.Ch, Cl = _k.Cl, Dh = _k.Dh, Dl = _k.Dl, Eh = _k.Eh, El = _k.El, Fh = _k.Fh, Fl = _k.Fl, Gh = _k.Gh, Gl = _k.Gl, Hh = _k.Hh, Hl = _k.Hl;
        // Compression function main loop, 80 rounds
        for(var i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            var sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            var sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            var CHIh = Eh & Fh ^ ~Eh & Gh;
            var CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            var T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            var T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            var T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            var sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            var sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            var MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            var MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            _a = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0), Eh = _a.h, El = _a.l;
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            var All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        _b = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0), Ah = _b.h, Al = _b.l;
        _c = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0), Bh = _c.h, Bl = _c.l;
        _d = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0), Ch = _d.h, Cl = _d.l;
        _e = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0), Dh = _e.h, Dl = _e.l;
        _f = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0), Eh = _f.h, El = _f.l;
        _g = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0), Fh = _g.h, Fl = _g.l;
        _h = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0), Gh = _h.h, Gl = _h.l;
        _j = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0), Hh = _j.h, Hl = _j.l;
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    };
    SHA512.prototype.roundClean = function() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    };
    SHA512.prototype.destroy = function() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    };
    return SHA512;
}(_md_1.HashMD);
exports.SHA512 = SHA512;
var SHA512_224 = function(_super) {
    __extends(SHA512_224, _super);
    function SHA512_224() {
        var _this = _super.call(this) || this;
        // h -- high 32 bits, l -- low 32 bits
        _this.Ah = 0x8c3d37c8 | 0;
        _this.Al = 0x19544da2 | 0;
        _this.Bh = 0x73e19966 | 0;
        _this.Bl = 0x89dcd4d6 | 0;
        _this.Ch = 0x1dfab7ae | 0;
        _this.Cl = 0x32ff9c82 | 0;
        _this.Dh = 0x679dd514 | 0;
        _this.Dl = 0x582f9fcf | 0;
        _this.Eh = 0x0f6d2b69 | 0;
        _this.El = 0x7bd44da8 | 0;
        _this.Fh = 0x77e36f73 | 0;
        _this.Fl = 0x04c48942 | 0;
        _this.Gh = 0x3f9d85a8 | 0;
        _this.Gl = 0x6a1d36c8 | 0;
        _this.Hh = 0x1112e6ad | 0;
        _this.Hl = 0x91d692a1 | 0;
        _this.outputLen = 28;
        return _this;
    }
    return SHA512_224;
}(SHA512);
var SHA512_256 = function(_super) {
    __extends(SHA512_256, _super);
    function SHA512_256() {
        var _this = _super.call(this) || this;
        // h -- high 32 bits, l -- low 32 bits
        _this.Ah = 0x22312194 | 0;
        _this.Al = 0xfc2bf72c | 0;
        _this.Bh = 0x9f555fa3 | 0;
        _this.Bl = 0xc84c64c2 | 0;
        _this.Ch = 0x2393b86b | 0;
        _this.Cl = 0x6f53b151 | 0;
        _this.Dh = 0x96387719 | 0;
        _this.Dl = 0x5940eabd | 0;
        _this.Eh = 0x96283ee2 | 0;
        _this.El = 0xa88effe3 | 0;
        _this.Fh = 0xbe5e1e25 | 0;
        _this.Fl = 0x53863992 | 0;
        _this.Gh = 0x2b0199fc | 0;
        _this.Gl = 0x2c85b8aa | 0;
        _this.Hh = 0x0eb72ddc | 0;
        _this.Hl = 0x81c52ca2 | 0;
        _this.outputLen = 32;
        return _this;
    }
    return SHA512_256;
}(SHA512);
var SHA384 = function(_super) {
    __extends(SHA384, _super);
    function SHA384() {
        var _this = _super.call(this) || this;
        // h -- high 32 bits, l -- low 32 bits
        _this.Ah = 0xcbbb9d5d | 0;
        _this.Al = 0xc1059ed8 | 0;
        _this.Bh = 0x629a292a | 0;
        _this.Bl = 0x367cd507 | 0;
        _this.Ch = 0x9159015a | 0;
        _this.Cl = 0x3070dd17 | 0;
        _this.Dh = 0x152fecd8 | 0;
        _this.Dl = 0xf70e5939 | 0;
        _this.Eh = 0x67332667 | 0;
        _this.El = 0xffc00b31 | 0;
        _this.Fh = 0x8eb44a87 | 0;
        _this.Fl = 0x68581511 | 0;
        _this.Gh = 0xdb0c2e0d | 0;
        _this.Gl = 0x64f98fa7 | 0;
        _this.Hh = 0x47b5481d | 0;
        _this.Hl = 0xbefa4fa4 | 0;
        _this.outputLen = 48;
        return _this;
    }
    return SHA384;
}(SHA512);
exports.sha512 = (0, utils_1.wrapConstructor)(function() {
    return new SHA512();
});
exports.sha512_224 = (0, utils_1.wrapConstructor)(function() {
    return new SHA512_224();
});
exports.sha512_256 = (0, utils_1.wrapConstructor)(function() {
    return new SHA512_256();
});
exports.sha384 = (0, utils_1.wrapConstructor)(function() {
    return new SHA384();
});
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/hmacSHA512.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hmacSHA512 = void 0;
var hmac_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/hmac.js [app-client] (ecmascript)");
var sha512_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/sha512.js [app-client] (ecmascript)");
function hmacSHA512(key, data) {
    return new Uint8Array((0, hmac_1.hmac)(sha512_1.sha512, key, data));
}
exports.hmacSHA512 = hmacSHA512;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/keccak.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.keccak_512 = exports.keccak_384 = exports.keccak_224 = exports.keccak_256 = void 0;
var noble = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/keccak.js [app-client] (ecmascript)"));
function keccak_256(msg) {
    return noble.keccak_256(msg);
}
exports.keccak_256 = keccak_256;
function keccak_224(msg) {
    return noble.keccak_224(msg);
}
exports.keccak_224 = keccak_224;
function keccak_384(msg) {
    return noble.keccak_384(msg);
}
exports.keccak_384 = keccak_384;
function keccak_512(msg) {
    return noble.keccak_512(msg);
}
exports.keccak_512 = keccak_512;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_shortw_utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createCurve = exports.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var hmac_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/hmac.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
var weierstrass_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/weierstrass.js [app-client] (ecmascript)");
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash: hash,
        hmac: function(key) {
            var msgs = [];
            for(var _i = 1; _i < arguments.length; _i++){
                msgs[_i - 1] = arguments[_i];
            }
            return (0, hmac_1.hmac)(hash, key, utils_1.concatBytes.apply(void 0, __spreadArray([], __read(msgs), false)));
        },
        randomBytes: utils_1.randomBytes
    };
}
exports.getHash = getHash;
function createCurve(curveDef, defHash) {
    var create = function(hash) {
        return (0, weierstrass_1.weierstrass)(__assign(__assign({}, curveDef), getHash(hash)));
    };
    return Object.freeze(__assign(__assign({}, create(defHash)), {
        create: create
    }));
}
exports.createCurve = createCurve;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/secp256k1.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifySecp256k1 = exports.signSecp256k1 = exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.verifySchnorr = exports.signSchnorr = exports.Secp256k1Point = exports.secp256k1PointToBytes = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var sha256_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/sha256.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
var modular_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)");
var weierstrass_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/weierstrass.js [app-client] (ecmascript)");
var utils_2 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
var hash_to_curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)");
var _shortw_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_shortw_utils.js [app-client] (ecmascript)");
var secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
var secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
var _1n = BigInt(1);
var _2n = BigInt(2);
var divNearest = function(a, b) {
    return (a + b / _2n) / b;
};
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */ function sqrtMod(y) {
    var P = secp256k1P;
    var _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    var _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    var b2 = y * y * y % P; // x^3, 11
    var b3 = b2 * b2 * y % P; // x^7
    var b6 = (0, modular_1.pow2)(b3, _3n, P) * b3 % P;
    var b9 = (0, modular_1.pow2)(b6, _3n, P) * b3 % P;
    var b11 = (0, modular_1.pow2)(b9, _2n, P) * b2 % P;
    var b22 = (0, modular_1.pow2)(b11, _11n, P) * b11 % P;
    var b44 = (0, modular_1.pow2)(b22, _22n, P) * b22 % P;
    var b88 = (0, modular_1.pow2)(b44, _44n, P) * b44 % P;
    var b176 = (0, modular_1.pow2)(b88, _88n, P) * b88 % P;
    var b220 = (0, modular_1.pow2)(b176, _44n, P) * b44 % P;
    var b223 = (0, modular_1.pow2)(b220, _3n, P) * b3 % P;
    var t1 = (0, modular_1.pow2)(b223, _23n, P) * b22 % P;
    var t2 = (0, modular_1.pow2)(t1, _6n, P) * b2 % P;
    var root = (0, modular_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');
    return root;
}
var Fp = (0, modular_1.Field)(secp256k1P, undefined, undefined, {
    sqrt: sqrtMod
});
exports.secp256k1 = (0, _shortw_utils_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */ endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: function(k) {
            var n = secp256k1N;
            var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            var b2 = a1;
            var POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            var c1 = divNearest(b2 * k, n);
            var c2 = divNearest(-b1 * k, n);
            var k1 = (0, modular_1.mod)(k - c1 * a1 - c2 * a2, n);
            var k2 = (0, modular_1.mod)(-c1 * b1 - c2 * b2, n);
            var k1neg = k1 > POW_2_128;
            var k2neg = k2 > POW_2_128;
            if (k1neg) k1 = n - k1;
            if (k2neg) k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
                throw new Error('splitScalar: Endomorphism failed, k=' + k);
            }
            return {
                k1neg: k1neg,
                k1: k1,
                k2neg: k2neg,
                k2: k2
            };
        }
    }
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
var _0n = BigInt(0);
var fe = function(x) {
    return typeof x === 'bigint' && _0n < x && x < secp256k1P;
};
var ge = function(x) {
    return typeof x === 'bigint' && _0n < x && x < secp256k1N;
};
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag) {
    var messages = [];
    for(var _i = 1; _i < arguments.length; _i++){
        messages[_i - 1] = arguments[_i];
    }
    var tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        var tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, function(c) {
            return c.charCodeAt(0);
        }));
        tagP = (0, utils_2.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)(utils_2.concatBytes.apply(void 0, __spreadArray([
        tagP
    ], __read(messages), false)));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
var pointToBytes = function(point) {
    return point.toRawBytes(true).slice(1);
};
exports.secp256k1PointToBytes = pointToBytes;
var numTo32b = function(n) {
    return (0, utils_2.numberToBytesBE)(n, 32);
};
var modP = function(x) {
    return (0, modular_1.mod)(x, secp256k1P);
};
var modN = function(x) {
    return (0, modular_1.mod)(x, secp256k1N);
};
var Point = exports.secp256k1.ProjectivePoint;
exports.Secp256k1Point = exports.secp256k1.ProjectivePoint;
var GmulAdd = function(Q, a, b) {
    return Point.BASE.multiplyAndAddUnsafe(Q, a, b);
};
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    var d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    var p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside
    var scalar = p.hasEvenY() ? d_ : modN(-d_);
    return {
        scalar: scalar,
        bytes: pointToBytes(p)
    };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */ function lift_x(x) {
    if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x  p.
    var xx = modP(x * x);
    var c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.
    var y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and
    var p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */ function challenge() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++){
        args[_i] = arguments[_i];
    }
    return modN((0, utils_2.bytesToNumberBE)(taggedHash.apply(void 0, __spreadArray([
        'BIP0340/challenge'
    ], __read(args), false))));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */ function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */ function schnorrSign(message, privateKey, auxRand) {
    if (auxRand === void 0) {
        auxRand = (0, utils_1.randomBytes)(32);
    }
    var m = (0, utils_2.ensureBytes)('message', message);
    var _a = schnorrGetExtPubKey(privateKey), px = _a.bytes, d = _a.scalar; // checks for isWithinCurveOrder
    var a = (0, utils_2.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    var t = numTo32b(d ^ (0, utils_2.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    var rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    var k_ = modN((0, utils_2.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.
    var _b = schnorrGetExtPubKey(k_), rx = _b.bytes, k = _b.scalar; // Let R = k'G.
    var e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    var sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */ function schnorrVerify(signature, message, publicKey) {
    var sig = (0, utils_2.ensureBytes)('signature', signature, 64);
    var m = (0, utils_2.ensureBytes)('message', message);
    var pub = (0, utils_2.ensureBytes)('publicKey', publicKey, 32);
    try {
        var P = lift_x((0, utils_2.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        var r = (0, utils_2.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
        if (!fe(r)) return false;
        var s = (0, utils_2.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
        if (!ge(s)) return false;
        var e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        var R = GmulAdd(P, s, modN(-e)); // R = sG - eP
        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
    } catch (error) {
        return false;
    }
}
exports.signSchnorr = schnorrSign;
exports.verifySchnorr = schnorrVerify;
exports.schnorr = function() {
    return {
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
            randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
            lift_x: lift_x,
            pointToBytes: pointToBytes,
            numberToBytesBE: utils_2.numberToBytesBE,
            bytesToNumberBE: utils_2.bytesToNumberBE,
            taggedHash: taggedHash,
            mod: modular_1.mod
        }
    };
}();
var isoMap = /* @__PURE__ */ function() {
    return (0, hash_to_curve_1.isogenyMap)(Fp, [
        // xNum
        [
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
            '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
            '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'
        ],
        // xDen
        [
            '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
            '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
        ],
        // yNum
        [
            '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
            '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
            '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
            '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'
        ],
        // yDen
        [
            '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
            '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
            '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
        ]
    ].map(function(i) {
        return i.map(function(j) {
            return BigInt(j);
        });
    }));
}();
var mapSWU = /* @__PURE__ */ function() {
    return (0, weierstrass_1.mapToCurveSimpleSWU)(Fp, {
        A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
        B: BigInt('1771'),
        Z: Fp.create(BigInt('-11'))
    });
}();
var htf = /* @__PURE__ */ function() {
    return (0, hash_to_curve_1.createHasher)(exports.secp256k1.ProjectivePoint, function(scalars) {
        var _a = mapSWU(Fp.create(scalars[0])), x = _a.x, y = _a.y;
        return isoMap(x, y);
    }, {
        DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
        encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: sha256_1.sha256
    });
}();
exports.hashToCurve = function() {
    return htf.hashToCurve;
}();
exports.encodeToCurve = function() {
    return htf.encodeToCurve;
}();
function signSecp256k1(data, privateKey, extraEntropy) {
    return exports.secp256k1.sign(data, privateKey, {
        extraEntropy: extraEntropy
    }).toCompactRawBytes();
}
exports.signSecp256k1 = signSecp256k1;
var myDefaultVerOpts = {
    lowS: true,
    prehash: false
};
function verifySecp256k1(sig, msgHash, pubKey) {
    return exports.secp256k1.verify(sig, msgHash, pubKey, myDefaultVerOpts);
}
exports.verifySecp256k1 = verifySecp256k1;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/secp256k1.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifySchnorrSecp256k1Signature = exports.verifyEcdsaSecp256k1Signature = void 0;
var secp256k1_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/secp256k1.js [app-client] (ecmascript)");
function verifyEcdsaSecp256k1Signature(vk, messageHash, signature) {
    if (!(vk instanceof Uint8Array && messageHash instanceof Uint8Array && signature instanceof Uint8Array && vk.length === 33 && messageHash.length === 32 && signature.length === 64)) throw new TypeError("invalid arguments passed to 'verifyEcdsaSecp256k1Signature'");
    var vkHead = vk[0];
    if (!(vkHead === 0x02 || vkHead === 0x03)) throw new Error("plutus-machine only supports compressed public keys for 'verifyEcdsaSecp256k1Signature'");
    return (0, secp256k1_1.verifySecp256k1)(signature, messageHash, vk);
}
exports.verifyEcdsaSecp256k1Signature = verifyEcdsaSecp256k1Signature;
function verifySchnorrSecp256k1Signature(pubKey, messageHash, signature) {
    if (!(pubKey instanceof Uint8Array && messageHash instanceof Uint8Array && signature instanceof Uint8Array && pubKey.length === 32 && signature.length === 64)) throw new TypeError("invalid arguments passed to 'verifyEcdsaSecp256k1Signature'");
    // signature 64
    // pubKey 32
    return (0, secp256k1_1.verifySchnorr)(signature, messageHash, pubKey);
}
exports.verifySchnorrSecp256k1Signature = verifySchnorrSecp256k1Signature;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/rotr32.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rotr32 = void 0;
function rotr32(x, by) {
    return x >>> by | x << 32 - by | 0;
}
exports.rotr32 = rotr32;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/sha2_256.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha2_256 = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var rotr32_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/rotr32.js [app-client] (ecmascript)");
/**
     * Pad a bytearray so its size is a multiple of 64 (512 bits).
     * Internal method.
     */ function pad(src) {
    var nBits = src.length * 8;
    var dst = src.slice();
    dst.push(0x80);
    var nZeroes = 64 - dst.length % 64 - 8;
    if (nZeroes < 0) {
        nZeroes += 64;
    }
    for(var i = 0; i < nZeroes; i++){
        dst.push(0);
    }
    // assume nBits fits in 32 bits
    dst.push(0);
    dst.push(0);
    dst.push(0);
    dst.push(0);
    dst.push(nBits >> 24 & 0xff);
    dst.push(nBits >> 16 & 0xff);
    dst.push(nBits >> 8 & 0xff);
    dst.push(nBits >> 0 & 0xff);
    return dst;
}
var k = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
];
function sigma0(x) {
    return (0, rotr32_1.rotr32)(x, 7) ^ (0, rotr32_1.rotr32)(x, 18) ^ x >>> 3;
}
function sigma1(x) {
    return (0, rotr32_1.rotr32)(x, 17) ^ (0, rotr32_1.rotr32)(x, 19) ^ x >>> 10;
}
/**
 * getulates sha2-256 (32bytes) hash of a list of uint8 numbers.
 * Result is also a list of uint8 number.
 * @example
 * bytesToHex(sha2_256([0x61, 0x62, 0x63])) => "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
 * @example
 * sha2_256(textToBytes("Hello, World!")) => [223, 253, 96, 33, 187, 43, 213, 176, 175, 103, 98, 144, 128, 158, 195, 165, 49, 145, 221, 129, 199, 247, 10, 75, 40, 104, 138, 54, 33, 130, 152, 111]
 * @param {uint5[]} bytes - list of uint8 numbers
 * @returns {number[]} - list of uint8 numbers
 */ function sha2_256(bytes) {
    if ((0, uint8array_utils_1.isUint8Array)(bytes)) {
        bytes = (0, types_1.buffToByteArr)(bytes);
    }
    /**
     * Initial hash (updated during compression phase)
     */ var hash = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19
    ];
    bytes = pad(bytes);
    // break message in successive 64 byte chunks
    for(var chunkStart = 0; chunkStart < bytes.length; chunkStart += 64){
        var chunk = bytes.slice(chunkStart, chunkStart + 64);
        var w = new Array(64).fill(0); // array of 32 bit numbers!
        // copy chunk into first 16 positions of w
        for(var i = 0; i < 16; i++){
            w[i] = chunk[i * 4 + 0] << 24 | chunk[i * 4 + 1] << 16 | chunk[i * 4 + 2] << 8 | chunk[i * 4 + 3];
        }
        // extends the first 16 positions into the remaining 48 positions
        for(var i = 16; i < 64; i++){
            w[i] = w[i - 16] + sigma0(w[i - 15]) + w[i - 7] + sigma1(w[i - 2]) | 0;
        }
        // intialize working variables to current hash value
        var a = hash[0];
        var b = hash[1];
        var c = hash[2];
        var d = hash[3];
        var e = hash[4];
        var f = hash[5];
        var g = hash[6];
        var h = hash[7];
        // compression function main loop
        for(var i = 0; i < 64; i++){
            var S1 = (0, rotr32_1.rotr32)(e, 6) ^ (0, rotr32_1.rotr32)(e, 11) ^ (0, rotr32_1.rotr32)(e, 25);
            var ch = e & f ^ ~e & g;
            var temp1 = h + S1 + ch + k[i] + w[i] | 0;
            var S0 = (0, rotr32_1.rotr32)(a, 2) ^ (0, rotr32_1.rotr32)(a, 13) ^ (0, rotr32_1.rotr32)(a, 22);
            var maj = a & b ^ a & c ^ b & c;
            var temp2 = S0 + maj | 0;
            h = g;
            g = f;
            f = e;
            e = d + temp1 | 0;
            d = c;
            c = b;
            b = a;
            a = temp1 + temp2 | 0;
        }
        // update the hash
        hash[0] = hash[0] + a | 0;
        hash[1] = hash[1] + b | 0;
        hash[2] = hash[2] + c | 0;
        hash[3] = hash[3] + d | 0;
        hash[4] = hash[4] + e | 0;
        hash[5] = hash[5] + f | 0;
        hash[6] = hash[6] + g | 0;
        hash[7] = hash[7] + h | 0;
    }
    // produce the final digest of uint8 numbers
    var result = [];
    for(var i = 0; i < 8; i++){
        var item = hash[i];
        result.push(item >> 24 & 0xff);
        result.push(item >> 16 & 0xff);
        result.push(item >> 8 & 0xff);
        result.push(item >> 0 & 0xff);
    }
    return new Uint8Array(result);
}
exports.sha2_256 = sha2_256;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/sha3.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha3 = void 0;
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var types_2 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
/**
 * state width (1600 bits, )
 */ var WIDTH = 200;
/**
 * rate (1088 bits, 136 bytes)
 */ var RATE = 136;
/**
 * capacity
 */ var CAP = WIDTH - RATE;
/**
 * Apply 1000...1 padding until size is multiple of r.
 * If already multiple of r then add a whole block of padding.
 * @param {number[]} src - list of uint8 numbers
 * @returns {number[]} - list of uint8 numbers
 */ function pad(src) {
    var dst = src.slice();
    var nZeroes = RATE - 2 - dst.length % RATE;
    if (nZeroes < -1) {
        nZeroes += RATE - 2;
    }
    if (nZeroes == -1) {
        dst.push(0x86);
    } else {
        dst.push(0x06);
        for(var i = 0; i < nZeroes; i++){
            dst.push(0);
        }
        dst.push(0x80);
    }
    (0, assert_1.assert)(dst.length % RATE === 0, "wrong destination length");
    return dst;
}
/**
 * 24 numbers used in the sha3 permute function
 */ var OFFSETS = Object.freeze([
    6,
    12,
    18,
    24,
    3,
    9,
    10,
    16,
    22,
    1,
    7,
    13,
    19,
    20,
    4,
    5,
    11,
    17,
    23,
    2,
    8,
    14,
    15,
    21
]);
/**
 * 24 numbers used in the sha3 permute function
 */ var SHIFTS = Object.freeze([
    -12,
    -11,
    21,
    14,
    28,
    20,
    3,
    -13,
    -29,
    1,
    6,
    25,
    8,
    18,
    27,
    -4,
    10,
    15,
    -24,
    -30,
    -23,
    -7,
    -9,
    2
]);
/**
 * Round constants used in the sha3 permute function
 */ var RC = Object.freeze([
    (0, types_2.uint64)("0x0000000000000001"),
    (0, types_2.uint64)("0x0000000000008082"),
    (0, types_2.uint64)("0x800000000000808a"),
    (0, types_2.uint64)("0x8000000080008000"),
    (0, types_2.uint64)("0x000000000000808b"),
    (0, types_2.uint64)("0x0000000080000001"),
    (0, types_2.uint64)("0x8000000080008081"),
    (0, types_2.uint64)("0x8000000000008009"),
    (0, types_2.uint64)("0x000000000000008a"),
    (0, types_2.uint64)("0x0000000000000088"),
    (0, types_2.uint64)("0x0000000080008009"),
    (0, types_2.uint64)("0x000000008000000a"),
    (0, types_2.uint64)("0x000000008000808b"),
    (0, types_2.uint64)("0x800000000000008b"),
    (0, types_2.uint64)("0x8000000000008089"),
    (0, types_2.uint64)("0x8000000000008003"),
    (0, types_2.uint64)("0x8000000000008002"),
    (0, types_2.uint64)("0x8000000000000080"),
    (0, types_2.uint64)("0x000000000000800a"),
    (0, types_2.uint64)("0x800000008000000a"),
    (0, types_2.uint64)("0x8000000080008081"),
    (0, types_2.uint64)("0x8000000000008080"),
    (0, types_2.uint64)("0x0000000080000001"),
    (0, types_2.uint64)("0x8000000080008008")
]);
function permute(s) {
    var c = new Array(5);
    var b = new Array(25);
    for(var round = 0; round < 24; round++){
        for(var i = 0; i < 5; i++){
            c[i] = (0, types_2.uint64)(s[i] ^ s[i + 5] ^ s[i + 10] ^ s[i + 15] ^ s[i + 20]);
        }
        for(var i = 0; i < 5; i++){
            var tmp = (0, types_2.uint64)(c[(i + 4) % 5] ^ (0, types_2.uint64Rotr)(c[(i + 1) % 5], 63));
            for(var j = 0; j < 5; j++){
                s[i + 5 * j] = (0, types_2.uint64)(s[i + 5 * j] ^ tmp);
            }
        }
        b[0] = s[0];
        for(var i = 1; i < 25; i++){
            var offset = OFFSETS[i - 1];
            var left = Math.abs(SHIFTS[i - 1]);
            var right = 32 - left;
            if (SHIFTS[i - 1] < 0) {
                b[i] = (0, types_2.uint64Rotr)(s[offset], right);
            } else {
                b[i] = (0, types_2.uint64Rotr)(s[offset], right + 32);
            }
        }
        for(var i = 0; i < 5; i++){
            for(var j = 0; j < 5; j++){
                s[i * 5 + j] = (0, types_2.uint64)(b[i * 5 + j] ^ ~b[i * 5 + (j + 1) % 5] & b[i * 5 + (j + 2) % 5]);
            }
        }
        s[0] = s[0] ^ RC[round];
    }
}
/**
 * getulates sha3-256 (32bytes) hash of a list of uint8 numbers.
 * Result is also a list of uint8 number.
 * Sha3 only bit-wise operations, so 64-bit operations can easily be replicated using 2 32-bit operations instead
 * @example
 * bytesToHex(sha3(textToBytes("abc"))) => "3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532"
 * @example
 * bytesToHex(sha3((new Array(136)).fill(1))) => "b36dc2167c4d9dda1a58b87046c8d76a6359afe3612c4de8a38857e09117b2db"
 * @example
 * bytesToHex(sha3((new Array(135)).fill(2))) => "5bdf5d815d29a9d7161c66520efc17c2edd7898f2b99a029e8d2e4ff153407f4"
 * @example
 * bytesToHex(sha3((new Array(134)).fill(3))) => "8e6575663dfb75a88f94a32c5b363c410278b65020734560d968aadd6896a621"
 * @example
 * bytesToHex(sha3((new Array(137)).fill(4))) => "f10b39c3e455006aa42120b9751faa0f35c821211c9d086beb28bf3c4134c6c6"
 */ function sha3(bytes) {
    if ((0, uint8array_utils_1.isUint8Array)(bytes)) {
        bytes = (0, types_1.buffToByteArr)(bytes);
    }
    bytes = pad(bytes);
    // initialize the state
    var state = new Array(WIDTH / 8).fill((0, types_2.uint64)(0));
    for(var chunkStart = 0; chunkStart < bytes.length; chunkStart += RATE){
        // extend the chunk to become length WIDTH
        var chunk = bytes.slice(chunkStart, chunkStart + RATE).concat(new Array(CAP).fill(0));
        // element-wise xor with 'state'
        for(var i = 0; i < WIDTH; i += 8){
            state[i / 8] = (0, types_2.uint64)(state[i / 8] ^ (0, types_2.uint64)("0x" + (0, types_2.byteArrToHex)(chunk.slice(i, i + 8).reverse())));
        // beware: a uint32 is stored as little endian, but a pair of uint32s that form a uin64 are stored in big endian format!
        //state[i/4] ^= (chunk[i] << 0) | (chunk[i+1] << 8) | (chunk[i+2] << 16) | (chunk[i+3] << 24);
        }
        // apply block permutations
        permute(state);
    }
    var hash = [];
    for(var i = 0; i < 4; i++){
        hash.push.apply(hash, __spreadArray([], __read((0, types_2.uint64ToBytesLE)(state[i])), false));
    }
    return hash;
}
exports.sha3 = sha3;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/base32.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/positiveMod.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/rotr32.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/vrf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.vrf_ed25519_sha512_ell2_challenge_generation = exports.vrf_ed25519_sha512_ell2_nonce_generation = exports.vrf_ed25519_sha512_ell2_hash_to_curve = exports.vrf_ed25519_sha512_ell2_prove = void 0;
var ed25519_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/ed25519.js [app-client] (ecmascript)");
var sha2_512_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)");
/**
4.4. RSA-FDH-VRF Ciphersuites

This document defines RSA-FDH-VRF-SHA256 as follows:

suite_string = 0x01.
The hash function Hash is SHA-256 as specified in [RFC6234], with hLen = 32.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA384 as follows:

suite_string = 0x02.
The hash function Hash is SHA-384 as specified in [RFC6234], with hLen = 48.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA512 as follows:

suite_string = 0x03.
The hash function Hash is SHA-512 as specified in [RFC6234], with hLen = 64.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

 */ var SUITE = 0x03;
var ONE = 0x01;
var TWO = 0x02;
/**
 * https://datatracker.ietf.org/doc/html/rfc9381#section-5.1
 */ function vrf_ed25519_sha512_ell2_prove(sk, alpha) {
    var _a = __read((0, ed25519_1.extendEd25519PrivateKey)(sk), 2), scalar = _a[0], extension = _a[1];
    // 1. Use SK to derive the VRF secret scalar x and the VRF public key Y = x*B
    var pk = new Uint8Array((0, ed25519_1.deriveEd25519PublicKey)(Array.from(sk)));
    var H = vrf_ed25519_sha512_ell2_hash_to_curve(pk, alpha);
    var H_point = (0, ed25519_1.pointFromBytes)(H);
    var gamma = (0, ed25519_1.scalarMul)(H_point, scalar);
    var compressed_gamma = (0, ed25519_1.bigpointToUint8Array)(gamma);
    var k = vrf_ed25519_sha512_ell2_nonce_generation(extension, H);
    var announcement_1 = (0, ed25519_1.bigpointToUint8Array)((0, ed25519_1.scalarMultBase)(k));
    var announcement_2 = (0, ed25519_1.bigpointToUint8Array)((0, ed25519_1.scalarMul)(H_point, k));
    var challange = (0, ed25519_1.scalarFromBytes)(vrf_ed25519_sha512_ell2_challenge_generation(H, compressed_gamma, announcement_1, announcement_2));
    var response = k + challange * scalar;
    return {
        gamma: gamma,
        challange: challange,
        response: response
    };
}
exports.vrf_ed25519_sha512_ell2_prove = vrf_ed25519_sha512_ell2_prove;
function vrf_ed25519_sha512_ell2_hash_to_curve(public_key, alpha_string) {
    var input = new Uint8Array(2 + public_key.length + alpha_string.length);
    input[0] = SUITE;
    input[1] = ONE;
    input.set(public_key, 2);
    input.set(alpha_string, 2 + public_key.length);
    //return pointFromBytes(sha2_512(input))
    return (0, sha2_512_1.sha2_512)(input);
}
exports.vrf_ed25519_sha512_ell2_hash_to_curve = vrf_ed25519_sha512_ell2_hash_to_curve;
function vrf_ed25519_sha512_ell2_nonce_generation(secret_extension, H) {
    var input = new Uint8Array(64);
    input.set(secret_extension, 0);
    input.set(H, 32);
    //return pointFromBytes(sha2_512(input))
    return (0, ed25519_1.scalarFromBytes)((0, sha2_512_1.sha2_512)(input));
}
exports.vrf_ed25519_sha512_ell2_nonce_generation = vrf_ed25519_sha512_ell2_nonce_generation;
function vrf_ed25519_sha512_ell2_challenge_generation(H, gamma, announcement_1, announcement_2) {
    var input = new Uint8Array(2 + H.length + gamma.length + announcement_1.length + announcement_2.length);
    input[0] = SUITE;
    input[1] = TWO;
    input.set(H, 2);
    input.set(gamma, 2 + H.length);
    input.set(announcement_1, 2 + H.length + gamma.length);
    input.set(announcement_2, 2 + H.length + gamma.length + announcement_1.length);
    return (0, sha2_512_1.sha2_512)(input).slice(0, 16);
}
exports.vrf_ed25519_sha512_ell2_challenge_generation = vrf_ed25519_sha512_ell2_challenge_generation;
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/ripemd_160.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var e_1, _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RIPEMD160 = void 0;
/**
 * RIPEMD-160 legacy hash function.
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 * @module
 */ var _md_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/_md.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
var Rho = /* @__PURE__ */ new Uint8Array([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]);
var Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map(function(_, i) {
    return i;
}));
var Pi = /* @__PURE__ */ Id.map(function(i) {
    return (9 * i + 5) % 16;
});
var idxL = [
    Id
];
var idxR = [
    Pi
];
for(var i = 0; i < 4; i++)try {
    for(var _b = (e_1 = void 0, __values([
        idxL,
        idxR
    ])), _c = _b.next(); !_c.done; _c = _b.next()){
        var j = _c.value;
        j.push(j[i].map(function(k) {
            return Rho[k];
        }));
    }
} catch (e_1_1) {
    e_1 = {
        error: e_1_1
    };
} finally{
    try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally{
        if (e_1) throw e_1.error;
    }
}
var shifts = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map(function(i) {
    return new Uint8Array(i);
});
var shiftsL = /* @__PURE__ */ idxL.map(function(idx, i) {
    return idx.map(function(j) {
        return shifts[i][j];
    });
});
var shiftsR = /* @__PURE__ */ idxR.map(function(idx, i) {
    return idx.map(function(j) {
        return shifts[i][j];
    });
});
var Kl = /* @__PURE__ */ new Uint32Array([
    0x00000000,
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc,
    0xa953fd4e
]);
var Kr = /* @__PURE__ */ new Uint32Array([
    0x50a28be6,
    0x5c4dd124,
    0x6d703ef3,
    0x7a6d76e9,
    0x00000000
]);
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0) return x ^ y ^ z;
    else if (group === 1) return x & y | ~x & z;
    else if (group === 2) return (x | ~y) ^ z;
    else if (group === 3) return x & z | y & ~z;
    else return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
var R_BUF = /* @__PURE__ */ new Uint32Array(16);
var RIPEMD160 = function(_super) {
    __extends(RIPEMD160, _super);
    function RIPEMD160() {
        var _this = _super.call(this, 64, 20, 8, true) || this;
        _this.h0 = 0x67452301 | 0;
        _this.h1 = 0xefcdab89 | 0;
        _this.h2 = 0x98badcfe | 0;
        _this.h3 = 0x10325476 | 0;
        _this.h4 = 0xc3d2e1f0 | 0;
        return _this;
    }
    RIPEMD160.prototype.get = function() {
        var _a = this, h0 = _a.h0, h1 = _a.h1, h2 = _a.h2, h3 = _a.h3, h4 = _a.h4;
        return [
            h0,
            h1,
            h2,
            h3,
            h4
        ];
    };
    RIPEMD160.prototype.set = function(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    };
    RIPEMD160.prototype.process = function(view, offset) {
        for(var i = 0; i < 16; i++, offset += 4)R_BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        var al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for(var group = 0; group < 5; group++){
            var rGroup = 4 - group;
            var hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            var rl = idxL[group], rr = idxR[group]; // prettier-ignore
            var sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for(var i = 0; i < 16; i++){
                var tl = (0, utils_1.rotl)(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el | 0;
                al = el, el = dl, dl = (0, utils_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for(var i = 0; i < 16; i++){
                var tr = (0, utils_1.rotl)(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er | 0;
                ar = er, er = dr, dr = (0, utils_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    };
    RIPEMD160.prototype.roundClean = function() {
        R_BUF.fill(0);
    };
    RIPEMD160.prototype.destroy = function() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    };
    return RIPEMD160;
}(_md_1.HashMD);
exports.RIPEMD160 = RIPEMD160;
/** RIPEMD-160 - a legacy hash function from 1990s. */ var _ripemd160 = /* @__PURE__ */ (0, utils_1.wrapConstructor)(function() {
    return new RIPEMD160();
});
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/ripemd_160.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ripemd160 = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var ripemd_160_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/noble/ripemd_160.js [app-client] (ecmascript)");
function ripemd160(input) {
    if (typeof input === "string") {
        if (input.startsWith("0x")) input = (0, uint8array_utils_1.fromHex)(input.toLowerCase().slice(2));
        else if (isHex(input)) input = (0, uint8array_utils_1.fromHex)(input.toLowerCase());
        else input = (0, uint8array_utils_1.fromUtf8)(input);
    }
    if (!(input instanceof Uint8Array)) throw new Error("ripemd160: input must be Uint8Array or string");
    return new ripemd_160_1.RIPEMD160().update(input).digest();
}
exports.ripemd160 = ripemd160;
function isHex(str) {
    return /^[0-9A-Fa-f]*$/.test(str);
}
}),
"[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/bech32.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/blake2b.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/bls12_318.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/ed25519.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/hmacSHA512.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/keccak.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/secp256k1.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/sha2_256.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/sha3.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/utils/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/vrf.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/plutus-data/node_modules/@harmoniclabs/crypto/dist/ripemd_160.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertBytes = exports.assertPostiveInteger = exports.assert = void 0;
function assert(condition, errorMessage, addInfos) {
    var args = [];
    for(var _i = 3; _i < arguments.length; _i++){
        args[_i - 3] = arguments[_i];
    }
    if (condition) return;
    args.length > 0 && console.error.apply(console, __spreadArray([], __read(args), false));
    addInfos && console.error(addInfos);
    if (errorMessage instanceof Error) {
        throw errorMessage;
    }
    ;
    throw new Error(errorMessage);
}
exports.assert = assert;
// keccak asserts
function assertPostiveInteger(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, not ".concat(n));
}
exports.assertPostiveInteger = assertPostiveInteger;
function assertBytes(stuff) {
    if (!(stuff instanceof Uint8Array)) throw new Error("Uint8Array expected");
}
exports.assertBytes = assertBytes;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uint64Rotr = exports.uint64ToBytesBE = exports.uint64ToBytesLE = exports.isUint64 = exports.forceUint64 = exports.uint64 = exports.buffToUint5Arr = exports.byteArrToBin = exports.byteArrToHex = exports.buffToByteArr = exports.isByteArr = exports.isByte = exports.byte = exports.isUint6 = exports.isUint5 = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
function isUint5(n) {
    return typeof n === "number" && n >= 0 && n <= 31 && n === Math.round(n);
}
exports.isUint5 = isUint5;
function isUint6(n) {
    return typeof n === "number" && n >= 0 && n <= 63 && n === Math.round(n);
}
exports.isUint6 = isUint6;
function byte(bint) {
    return Number(bint) & 0xff;
}
exports.byte = byte;
function isByte(n) {
    return typeof n === "number" && n >= 0 && n <= 255 && n === Math.round(n);
}
exports.isByte = isByte;
function isByteArr(something) {
    return Array.isArray(something) && something.every(isByte);
}
exports.isByteArr = isByteArr;
function buffToByteArr(buff) {
    if (!(0, uint8array_utils_1.isUint8Array)(buff)) {
        if (isByteArr(buff)) return buff.slice();
        throw new Error("can't convert non-buffer to byte array");
    }
    return Array.from(buff);
}
exports.buffToByteArr = buffToByteArr;
function byteArrToHex(bytes) {
    if (bytes instanceof Uint8Array) bytes = Array.from(bytes);
    return bytes.reduce(function(acc, val) {
        return acc + val.toString(16).slice(0, 2).padStart(2, '0');
    }, '');
}
exports.byteArrToHex = byteArrToHex;
function byteArrToBin(bytes) {
    return bytes.reduce(function(acc, val) {
        return acc + val.toString(2).slice(0, 8).padStart(8, '0');
    }, '');
}
exports.byteArrToBin = byteArrToBin;
/**
 * Internal method
 *
 * `bytes` is **padded at the end** to be a multiple of 5
 */ function buffToUint5Arr(bytes) {
    var result = [];
    var bits = (0, uint8array_utils_1.isUint8Array)(bytes) ? Array.from(bytes).reduce(function(acc, n) {
        return acc + n.toString(2).padStart(8, '0');
    }, "") : isByteArr(bytes) ? byteArrToBin(bytes) : undefined;
    if (bits === undefined) {
        throw new Error("invalid input to convert ot uint5 array");
    }
    var mod5Len = bits.length % 5;
    if (mod5Len !== 0) {
        bits = bits.padEnd(bits.length + (5 - mod5Len), '0');
    }
    bits = bits.split('');
    for(var i = 0; i < bits.length;){
        result.push(Number("0b".concat(bits[i++]).concat(bits[i++]).concat(bits[i++]).concat(bits[i++]).concat(bits[i++])));
    }
    return result;
}
exports.buffToUint5Arr = buffToUint5Arr;
function uint64(n) {
    var _n = BigInt(n);
    if (!isUint64(_n)) throw new Error("can't convert " + n + " to uint64");
    return _n;
}
exports.uint64 = uint64;
function forceUint64(n) {
    return BigInt(n) & BigInt("0x" + "ff".repeat(8));
}
exports.forceUint64 = forceUint64;
function isUint64(n) {
    return typeof n === "bigint" && n >= BigInt(0) && n < BigInt("0x1" + "00".repeat(8)) // n < (1 << 64)
    ;
}
exports.isUint64 = isUint64;
function uint64ToBytesLE(uint) {
    return [
        byte(BigInt("0x00000000000000ff") & uint),
        byte((BigInt("0x000000000000ff00") & uint) >> BigInt(8)),
        byte((BigInt("0x0000000000ff0000") & uint) >> BigInt(16)),
        byte((BigInt("0x00000000ff000000") & uint) >> BigInt(24)),
        byte((BigInt("0x000000ff00000000") & uint) >> BigInt(32)),
        byte((BigInt("0x0000ff0000000000") & uint) >> BigInt(40)),
        byte((BigInt("0x00ff000000000000") & uint) >> BigInt(48)),
        byte((BigInt("0xff00000000000000") & uint) >> BigInt(56))
    ];
}
exports.uint64ToBytesLE = uint64ToBytesLE;
function uint64ToBytesBE(uint) {
    return uint64ToBytesLE(uint).reverse();
}
exports.uint64ToBytesBE = uint64ToBytesBE;
function uint64Rotr(a, b) {
    (0, assert_1.assert)(isUint64(a) && isUint6(b), "invalid args for 'uint64And'");
    if (b === 0) return a;
    var n = BigInt(b);
    return forceUint64(forceUint64(a >> n) | forceUint64(a << BigInt(64) - n));
}
exports.uint64Rotr = uint64Rotr;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/utils/base32.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeBase32Bech32 = exports.decodeBase32rfc4648 = exports.encodeBase32rfc4648 = exports.BECH32_BASE32_ALPHABET = exports.rfc4648_ALPHABET = void 0;
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var bitstream_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/bitstream/dist/index.js [app-client] (ecmascript)");
exports.rfc4648_ALPHABET = Object.freeze([
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'g',
    'h',
    'i',
    'j',
    'k',
    'l',
    'm',
    'n',
    'o',
    'p',
    'q',
    'r',
    's',
    't',
    'u',
    'v',
    'w',
    'x',
    'y',
    'z',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7'
]);
exports.BECH32_BASE32_ALPHABET = Object.freeze([
    'q',
    'p',
    'z',
    'r',
    'y',
    '9',
    'x',
    '8',
    'g',
    'f',
    '2',
    't',
    'v',
    'd',
    'w',
    '0',
    's',
    '3',
    'j',
    'n',
    '5',
    '4',
    'k',
    'h',
    'c',
    'e',
    '6',
    'm',
    'u',
    'a',
    '7',
    'l'
]);
function encodeBase32rfc4648(bytes) {
    return (0, types_1.buffToUint5Arr)(bytes).map(function(c) {
        return exports.rfc4648_ALPHABET[c];
    }).join("");
}
exports.encodeBase32rfc4648 = encodeBase32rfc4648;
function decodeBase32(base32Str, alpabeth) {
    if (!Array.from(base32Str).every(function(ch) {
        return alpabeth.includes(ch);
    })) throw new Error("can't decode base32 a string that is not in base32 (rfc 4648); string was: " + base32Str);
    var len = base32Str.length;
    var bits = '';
    for(var i = 0; i < len - 1; i++){
        var num_1 = alpabeth.indexOf(base32Str[i].toLowerCase());
        bits += num_1.toString(2).padStart(5, '0');
    }
    // last, make sure we align to byte
    var nCut = len * 5 - 8 * Math.floor(len * 5 / 8);
    var num = alpabeth.indexOf(base32Str[len - 1].toLowerCase());
    var lastbits = num.toString(2).padStart(5, '0');
    bits += lastbits.slice(0, 5 - nCut);
    return bitstream_1.BitStream.fromBinStr(bits).toBuffer().buffer;
}
function decodeBase32rfc4648(base32Str) {
    return decodeBase32(base32Str, exports.rfc4648_ALPHABET);
}
exports.decodeBase32rfc4648 = decodeBase32rfc4648;
function decodeBase32Bech32(base32Str) {
    return decodeBase32(base32Str, exports.BECH32_BASE32_ALPHABET);
}
exports.decodeBase32Bech32 = decodeBase32Bech32;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/bech32.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeBech32 = exports.isBech32 = exports.encodeBech32 = exports.getBech32Checksum = exports.getBech32Polymod = exports.expandBech32HumanReadablePart = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var base32_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/base32.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
/**
 * Expand human readable prefix of the bech32 encoding so it can be used in the checkSum
 */ function expandBech32HumanReadablePart(hrp) {
    var e_1, _a, e_2, _b;
    var bytes = [];
    try {
        for(var hrp_1 = __values(hrp), hrp_1_1 = hrp_1.next(); !hrp_1_1.done; hrp_1_1 = hrp_1.next()){
            var c = hrp_1_1.value;
            bytes.push(c.charCodeAt(0) >> 5);
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (hrp_1_1 && !hrp_1_1.done && (_a = hrp_1.return)) _a.call(hrp_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    bytes.push(0);
    try {
        for(var hrp_2 = __values(hrp), hrp_2_1 = hrp_2.next(); !hrp_2_1.done; hrp_2_1 = hrp_2.next()){
            var c = hrp_2_1.value;
            bytes.push(c.charCodeAt(0) & 31);
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (hrp_2_1 && !hrp_2_1.done && (_b = hrp_2.return)) _b.call(hrp_2);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return bytes;
}
exports.expandBech32HumanReadablePart = expandBech32HumanReadablePart;
var BECH32_POLYMOD_GEN = Object.freeze([
    0x3b6a57b2,
    0x26508e6d,
    0x1ea119fa,
    0x3d4233dd,
    0x2a1462b3
]);
/**
 * Used as part of the bech32 checksum.
 */ function getBech32Polymod(bytes) {
    var e_3, _a;
    var checksum = 1;
    try {
        for(var bytes_1 = __values(bytes), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()){
            var byte_1 = bytes_1_1.value;
            var c = checksum >> 25;
            checksum = (checksum & 0x1fffffff) << 5 ^ byte_1;
            for(var i = 0; i < 5; i++){
                if ((c >> i & 1) != 0) {
                    checksum ^= BECH32_POLYMOD_GEN[i];
                }
            }
        }
    } catch (e_3_1) {
        e_3 = {
            error: e_3_1
        };
    } finally{
        try {
            if (bytes_1_1 && !bytes_1_1.done && (_a = bytes_1.return)) _a.call(bytes_1);
        } finally{
            if (e_3) throw e_3.error;
        }
    }
    return checksum;
}
exports.getBech32Polymod = getBech32Polymod;
/**
 * Generate the bech32 checksum
 */ function getBech32Checksum(humanReadablePart, data) {
    var checksum = getBech32Polymod(expandBech32HumanReadablePart(humanReadablePart).concat(data).concat([
        0,
        0,
        0,
        0,
        0,
        0
    ])) ^ 1;
    var chkSum = [];
    for(var i = 0; i < 6; i++){
        chkSum.push(checksum >> 5 * (5 - i) & 31);
    }
    return chkSum;
}
exports.getBech32Checksum = getBech32Checksum;
/**
 * Creates a bech32 checksummed string (used to represent Cardano addresses)
 * @example
 * encodeBech32("foo", textToBytes("foobar")) => "foo1vehk7cnpwgry9h96"
 * @example
 * encodeBech32("addr_test", hexToBytes("70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539")) => "addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld"
 * @param {byte[]} data - uint8 0 - 256
 */ function encodeBech32(humanReadablePart, data) {
    (0, assert_1.assert)(humanReadablePart.length > 0, "human-readable-part must have non-zero length");
    var _data = (0, types_1.buffToUint5Arr)((0, uint8array_utils_1.isUint8Array)(data) ? data : new Uint8Array(data));
    return humanReadablePart + "1" + _data.concat(getBech32Checksum(humanReadablePart, _data)).map(function(val) {
        return base32_1.BECH32_BASE32_ALPHABET[val];
    }).join("");
}
exports.encodeBech32 = encodeBech32;
/**
 * Verify a bech32 checksum
 * @example
 * isBech32("foo1vehk7cnpwgry9h96") => true
 * @example
 * isBech32("foo1vehk7cnpwgry9h97") => false
 * @example
 * isBech32("a12uel5l") => true
 * @example
 * isBech32("mm1crxm3i") => false
 * @example
 * isBech32("A1G7SGD8") => false
 * @example
 * isBech32("abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw") => true
 * @example
 * isBech32("?1ezyfcl") => true
 * @example
 * isBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld") => true
 * @param {string} addr
 * @returns {boolean}
 */ function isBech32(addr) {
    var e_4, _a;
    var i = addr.indexOf("1");
    if (i == -1 || i == 0) {
        return false;
    }
    var hrp = addr.slice(0, i);
    addr = addr.slice(i + 1);
    var data = [];
    try {
        for(var addr_1 = __values(addr), addr_1_1 = addr_1.next(); !addr_1_1.done; addr_1_1 = addr_1.next()){
            var ch = addr_1_1.value;
            var j = base32_1.BECH32_BASE32_ALPHABET.indexOf(ch);
            if (j == -1) {
                return false;
            }
            data.push(j);
        }
    } catch (e_4_1) {
        e_4 = {
            error: e_4_1
        };
    } finally{
        try {
            if (addr_1_1 && !addr_1_1.done && (_a = addr_1.return)) _a.call(addr_1);
        } finally{
            if (e_4) throw e_4.error;
        }
    }
    var chkSumA = data.slice(data.length - 6);
    var chkSumB = getBech32Checksum(hrp, data.slice(0, data.length - 6));
    for(var i_1 = 0; i_1 < 6; i_1++){
        if (chkSumA[i_1] != chkSumB[i_1]) {
            return false;
        }
    }
    return true;
}
exports.isBech32 = isBech32;
/**
 * Decomposes a bech32 checksummed string (i.e. Cardano address), and returns the human readable part and the original bytes
 * Throws an error if checksum is invalid.
 * @example
 * bytesToHex(decodeBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld")[1]) => "70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539"
 * @param {string} addr
 * @returns {[humanReadablePart: string, bytes: byte[]]}
 */ function decodeBech32(addr) {
    (0, assert_1.assert)(isBech32(addr), "invalid bech32 addr");
    var i = addr.indexOf("1");
    (0, assert_1.assert)(i != -1, "bech32 address missing the '1' separator");
    var hrp = addr.slice(0, i);
    addr = addr.slice(i + 1);
    var data = (0, base32_1.decodeBase32Bech32)(addr.slice(0, addr.length - 6));
    return [
        hrp,
        Array.from(data)
    ];
}
exports.decodeBech32 = decodeBech32;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/blake2b.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.blake2b_512 = exports.blake2b_256 = exports.blake2b_224 = exports.blake2b_128 = exports.blake2b = void 0;
/**
 * 64-bit unsigned addition
 * Sets v[a,a+1] += v[b,b+1]
 * v should be a Uint32Array
 */ function ADD64AA(v, a, b) {
    var o0 = v[a] + v[b];
    var o1 = v[a + 1] + v[b + 1];
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC(v, a, b0, b1) {
    var o0 = v[a] + b0;
    if (b0 < 0) {
        o0 += 0x100000000;
    }
    var o1 = v[a + 1] + b1;
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// Little-endian byte access
function B2B_GET32(arr, i) {
    return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
}
// G Mixing function
// The ROTRs are inlined for speed
function B2B_G(a, b, c, d, ix, iy) {
    var x0 = m[ix];
    var x1 = m[ix + 1];
    var y0 = m[iy];
    var y1 = m[iy + 1];
    ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
    ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
    var xor0 = v[d] ^ v[a];
    var xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor1;
    v[d + 1] = xor0;
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor0 >>> 24 ^ xor1 << 8;
    v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v, a, b);
    ADD64AC(v, a, y0, y1);
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
    xor0 = v[d] ^ v[a];
    xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor0 >>> 16 ^ xor1 << 16;
    v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor1 >>> 31 ^ xor0 << 1;
    v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
}
// Initialization Vector
var BLAKE2B_IV32 = new Uint32Array([
    0xf3bcc908,
    0x6a09e667,
    0x84caa73b,
    0xbb67ae85,
    0xfe94f82b,
    0x3c6ef372,
    0x5f1d36f1,
    0xa54ff53a,
    0xade682d1,
    0x510e527f,
    0x2b3e6c1f,
    0x9b05688c,
    0xfb41bd6b,
    0x1f83d9ab,
    0x137e2179,
    0x5be0cd19
]);
var SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
];
// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
var SIGMA82 = new Uint8Array(SIGMA8.map(function(x) {
    return x * 2;
}));
// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
var v = new Uint32Array(32);
var m = new Uint32Array(32);
function blake2bCompress(ctx, last) {
    var i = 0;
    // init work variables
    for(i = 0; i < 16; i++){
        v[i] = ctx.h[i];
        v[i + 16] = BLAKE2B_IV32[i];
    }
    // low 64 bits of offset
    v[24] = v[24] ^ ctx.t;
    v[25] = v[25] ^ ctx.t / 0x100000000;
    // high 64 bits not supported, offset may not be higher than 2**53-1
    // last block flag set ?
    if (last) {
        v[28] = ~v[28];
        v[29] = ~v[29];
    }
    // get little-endian words
    for(i = 0; i < 32; i++){
        m[i] = B2B_GET32(ctx.b, 4 * i);
    }
    // twelve rounds of mixing
    // uncomment the DebugPrint calls to log the computation
    // and match the RFC sample documentation
    // util.debugPrint('          m[16]', m, 64)
    for(i = 0; i < 12; i++){
        // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
        B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    // util.debugPrint('   (i=12) v[16]', v, 64)
    for(i = 0; i < 16; i++){
        ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
    }
// util.debugPrint('h[8]', ctx.h, 64)
}
/** reusable parameterBlock */ var parameterBlock = new Uint8Array(64).fill(0);
function blake2bInit(digestSize) {
    // state, 'param block'
    var ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        c: 0,
        digestSize: digestSize // output length in bytes
    };
    // initialize parameterBlock before usage
    parameterBlock.fill(0);
    parameterBlock[0] = digestSize;
    parameterBlock[2] = 1; // fanout
    parameterBlock[3] = 1; // depth
    // initialize hash state
    for(var i = 0; i < 16; i++){
        ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
    }
    return ctx;
}
// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate(ctx, input) {
    for(var i = 0; i < input.length; i++){
        if (ctx.c === 128) {
            // buffer full ?
            ctx.t += ctx.c; // add counters
            blake2bCompress(ctx, false); // compress (not last)
            ctx.c = 0; // counter to zero
        }
        ctx.b[ctx.c++] = input[i];
    }
}
// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal(ctx) {
    ctx.t += ctx.c; // mark last block offset
    while(ctx.c < 128){
        // fill up with zeros
        ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true); // final block flag = 1
    // little endian convert and store
    var out = new Uint8Array(ctx.digestSize);
    for(var i = 0; i < ctx.digestSize; i++){
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
    }
    return out;
}
function blake2b(data, digestSize) {
    if (digestSize === void 0) {
        digestSize = 32;
    }
    data = new Uint8Array(data);
    var ctx = blake2bInit(digestSize);
    blake2bUpdate(ctx, data);
    return blake2bFinal(ctx);
}
exports.blake2b = blake2b;
function blake2b_128(data) {
    return blake2b(data, 16);
}
exports.blake2b_128 = blake2b_128;
function blake2b_224(data) {
    return blake2b(data, 28);
}
exports.blake2b_224 = blake2b_224;
function blake2b_256(data) {
    return blake2b(data, 32);
}
exports.blake2b_256 = blake2b_256;
function blake2b_512(data) {
    return blake2b(data, 64);
}
exports.blake2b_512 = blake2b_512;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/_u64.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.add5H = exports.add5L = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-hashes/blob/6ae82e75d4c354d53a488e95b1bfe9cba90bd6ff/src/_u64.ts#L1

it was modified and adapted to this repository to re-use already defined stuff

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var U32_MASK64 = /* @__PURE__ */ BigInt(Math.pow(2, 32) - 1);
var _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le) {
    if (le === void 0) {
        le = false;
    }
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
exports.fromBig = fromBig;
function split(lst, le) {
    var _a;
    if (le === void 0) {
        le = false;
    }
    var Ah = new Uint32Array(lst.length);
    var Al = new Uint32Array(lst.length);
    for(var i = 0; i < lst.length; i++){
        var _b = fromBig(lst[i], le), h = _b.h, l = _b.l;
        _a = __read([
            h,
            l
        ], 2), Ah[i] = _a[0], Al[i] = _a[1];
    }
    return [
        Ah,
        Al
    ];
}
exports.split = split;
var toBig = function(h, l) {
    return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
};
exports.toBig = toBig;
// for Shift in [0, 32)
var shrSH = function(h, _l, s) {
    return h >>> s;
};
exports.shrSH = shrSH;
var shrSL = function(h, l, s) {
    return h << 32 - s | l >>> s;
};
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
var rotrSH = function(h, l, s) {
    return h >>> s | l << 32 - s;
};
exports.rotrSH = rotrSH;
var rotrSL = function(h, l, s) {
    return h << 32 - s | l >>> s;
};
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotrBH = function(h, l, s) {
    return h << 64 - s | l >>> s - 32;
};
exports.rotrBH = rotrBH;
var rotrBL = function(h, l, s) {
    return h >>> s - 32 | l << 64 - s;
};
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
var rotr32H = function(_h, l) {
    return l;
};
exports.rotr32H = rotr32H;
var rotr32L = function(h, _l) {
    return h;
};
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
var rotlSH = function(h, l, s) {
    return h << s | l >>> 32 - s;
};
exports.rotlSH = rotlSH;
var rotlSL = function(h, l, s) {
    return l << s | h >>> 32 - s;
};
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotlBH = function(h, l, s) {
    return l << s - 32 | h >>> 64 - s;
};
exports.rotlBH = rotlBH;
var rotlBL = function(h, l, s) {
    return h << s - 32 | l >>> 64 - s;
};
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    var l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,
        l: l | 0
    };
}
exports.add = add;
// Addition with more than 2 elements
var add3L = function(Al, Bl, Cl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
};
exports.add3L = add3L;
var add3H = function(low, Ah, Bh, Ch) {
    return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add3H = add3H;
var add4L = function(Al, Bl, Cl, Dl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
};
exports.add4L = add4L;
var add4H = function(low, Ah, Bh, Ch, Dh) {
    return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add4H = add4H;
var add5L = function(Al, Bl, Cl, Dl, El) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
};
exports.add5L = add5L;
var add5H = function(low, Ah, Bh, Ch, Dh, Eh) {
    return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add5H = add5H;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/crypto.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-hashes/blob/6ae82e75d4c354d53a488e95b1bfe9cba90bd6ff/src/utils.ts#L1

it was modified and adapted to this repository to re-use already defined stuff

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
var crypto_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/crypto.js [app-client] (ecmascript)");
// Cast array to different type
var u8 = function(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
};
exports.u8 = u8;
var u32 = function(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
};
exports.u32 = u32;
// Cast array to view
var createView = function(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
};
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
var rotr = function(word, shift) {
    return word << 32 - shift | word >>> shift;
};
exports.rotr = rotr;
// The rotate left (circular left shift) operation for uint32
var rotl = function(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
};
exports.rotl = rotl;
exports.isLE = new Uint8Array(new Uint32Array([
    0x11223344
]).buffer)[0] === 0x44;
// The byte swap operation for uint32
var byteSwap = function(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
};
exports.byteSwap = byteSwap;
// Conditionally byte swap if on a big-endian platform
exports.byteSwapIfBE = exports.isLE ? function(n) {
    return n;
} : function(n) {
    return (0, exports.byteSwap)(n);
};
// In place byte swap for Uint32Array
function byteSwap32(arr) {
    for(var i = 0; i < arr.length; i++){
        arr[i] = (0, exports.byteSwap)(arr[i]);
    }
}
exports.byteSwap32 = byteSwap32;
// Array where index 0xf0 (240) is mapped to string 'f0'
var hexes = /* @__PURE__ */ Array.from({
    length: 256
}, function(_, i) {
    return i.toString(16).padStart(2, '0');
});
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    (0, assert_1.assertBytes)(bytes);
    // pre-caching improves the speed 6x
    var hex = '';
    for(var i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
// We use optimized technique to convert hex string to byte array
var asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    var hl = hex.length;
    var al = hl / 2;
    if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    var array = new Uint8Array(al);
    for(var ai = 0, hi = 0; ai < al; ai++, hi += 2){
        var n1 = asciiToBase16(hex.charCodeAt(hi));
        var n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            var char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
var nextTick = function() {
    return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_b) {
            return [
                2 /*return*/ 
            ];
        });
    });
};
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
function asyncLoop(iters, tick, cb) {
    return __awaiter(this, void 0, void 0, function() {
        var ts, i, diff;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    ts = Date.now();
                    i = 0;
                    _b.label = 1;
                case 1:
                    if (!(i < iters)) return [
                        3 /*break*/ ,
                        4
                    ];
                    cb(i);
                    diff = Date.now() - ts;
                    if (diff >= 0 && diff < tick) return [
                        3 /*break*/ ,
                        3
                    ];
                    return [
                        4 /*yield*/ ,
                        (0, exports.nextTick)()
                    ];
                case 2:
                    _b.sent();
                    ts += diff;
                    _b.label = 3;
                case 3:
                    i++;
                    return [
                        3 /*break*/ ,
                        1
                    ];
                case 4:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}
exports.asyncLoop = asyncLoop;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ function toBytes(data) {
    if (typeof data === 'string') data = (0, uint8array_utils_1.fromUtf8)(data);
    (0, assert_1.assertBytes)(data);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */ function concatBytes() {
    var arrays = [];
    for(var _i = 0; _i < arguments.length; _i++){
        arrays[_i] = arguments[_i];
    }
    var sum = 0;
    for(var i = 0; i < arrays.length; i++){
        var a = arrays[i];
        (0, assert_1.assertBytes)(a);
        sum += a.length;
    }
    var res = new Uint8Array(sum);
    for(var i = 0, pad = 0; i < arrays.length; i++){
        var a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
var Hash = function() {
    function Hash() {}
    // Safe version that clones internal state
    Hash.prototype.clone = function() {
        return this._cloneInto();
    };
    return Hash;
}();
exports.Hash = Hash;
var toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
    var merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    var hashC = function(msg) {
        return hashCons().update(toBytes(msg)).digest();
    };
    var tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function() {
        return hashCons();
    };
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    var hashC = function(msg, opts) {
        return hashCons(opts).update(toBytes(msg)).digest();
    };
    var tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function(opts) {
        return hashCons(opts);
    };
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    var hashC = function(msg, opts) {
        return hashCons(opts).update(toBytes(msg)).digest();
    };
    var tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function(opts) {
        return hashCons(opts);
    };
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */ function randomBytes(bytesLength) {
    if (bytesLength === void 0) {
        bytesLength = 32;
    }
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    var bytes = new Uint8Array(bytesLength);
    for(var i = 0; i < bytesLength; i++){
        bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
}
exports.randomBytes = randomBytes;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/keccak.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.Keccak = exports.keccakP = void 0;
/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-hashes/blob/6ae82e75d4c354d53a488e95b1bfe9cba90bd6ff/src/sha3.ts#L1

it was modified and adapted to this repository to re-use already defined stuff

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var _u64_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/_u64.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n = /** @__PURE__ */ BigInt(0);
var _1n = /** @__PURE__ */ BigInt(1);
var _2n = /** @__PURE__ */ BigInt(2);
var _7n = /** @__PURE__ */ BigInt(7);
var _256n = /** @__PURE__ */ BigInt(256);
var _0x71n = /** @__PURE__ */ BigInt(0x71);
for(var round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    _a = __read([
        y,
        (2 * x + 3 * y) % 5
    ], 2), x = _a[0], y = _a[1];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    var t = _0n;
    for(var j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /** @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
var _b = __read(/** @__PURE__ */ (0, _u64_1.split)(_SHA3_IOTA, true), 2), SHA3_IOTA_H = _b[0], SHA3_IOTA_L = _b[1];
// Left rotation (without 0, 32, 64)
var rotlH = function(h, l, s) {
    return s > 32 ? (0, _u64_1.rotlBH)(h, l, s) : (0, _u64_1.rotlSH)(h, l, s);
};
var rotlL = function(h, l, s) {
    return s > 32 ? (0, _u64_1.rotlBL)(h, l, s) : (0, _u64_1.rotlSL)(h, l, s);
};
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds) {
    if (rounds === void 0) {
        rounds = 24;
    }
    var B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(var round = 24 - rounds; round < 24; round++){
        // Theta 
        for(var x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(var x = 0; x < 10; x += 2){
            var idx1 = (x + 8) % 10;
            var idx0 = (x + 2) % 10;
            var B0 = B[idx0];
            var B1 = B[idx0 + 1];
            var Th = rotlH(B0, B1, 1) ^ B[idx1];
            var Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(var y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        var curH = s[2];
        var curL = s[3];
        for(var t = 0; t < 24; t++){
            var shift = SHA3_ROTL[t];
            var Th = rotlH(curH, curL, shift);
            var Tl = rotlL(curH, curL, shift);
            var PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for(var y = 0; y < 50; y += 10){
            for(var x = 0; x < 10; x++)B[x] = s[y + x];
            for(var x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
var Keccak = function(_super) {
    __extends(Keccak, _super);
    // NOTE: we accept arguments in bytes instead of bits here.
    function Keccak(blockLen, suffix, outputLen, enableXOF, rounds) {
        if (enableXOF === void 0) {
            enableXOF = false;
        }
        if (rounds === void 0) {
            rounds = 24;
        }
        var _this = _super.call(this) || this;
        _this.blockLen = blockLen;
        _this.suffix = suffix;
        _this.outputLen = outputLen;
        _this.enableXOF = enableXOF;
        _this.rounds = rounds;
        _this.pos = 0;
        _this.posOut = 0;
        _this.finished = false;
        _this.destroyed = false;
        // Can be passed from user as dkLen
        (0, assert_1.assertPostiveInteger)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= _this.blockLen || _this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
        _this.state = new Uint8Array(200);
        _this.state32 = (0, utils_1.u32)(_this.state);
        return _this;
    }
    Keccak.prototype.keccak = function() {
        if (!utils_1.isLE) (0, utils_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_1.isLE) (0, utils_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    };
    Keccak.prototype.update = function(data) {
        this.assertExists();
        var _a = this, blockLen = _a.blockLen, state = _a.state;
        data = (0, utils_1.toBytes)(data);
        var len = data.length;
        for(var pos = 0; pos < len;){
            var take = Math.min(blockLen - this.pos, len - pos);
            for(var i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    };
    Keccak.prototype.finish = function() {
        if (this.finished) return;
        this.finished = true;
        var _a = this, state = _a.state, suffix = _a.suffix, pos = _a.pos, blockLen = _a.blockLen;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    };
    Keccak.prototype.writeInto = function(out) {
        this.assertExists(false);
        if (!(out instanceof Uint8Array)) throw new Error("Uint8Array expected");
        this.finish();
        var bufferOut = this.state;
        var blockLen = this.blockLen;
        for(var pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            var take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    };
    Keccak.prototype.xofInto = function(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    };
    Keccak.prototype.xof = function(bytes) {
        (0, assert_1.assertPostiveInteger)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    };
    Keccak.prototype.digestInto = function(out) {
        // output(out, this);
        if (!(out instanceof Uint8Array)) throw new Error("Uint8Array expected");
        var min = this.outputLen;
        if (out.length < min) throw new Error("digestInto() expects output buffer of length at least ".concat(min));
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    };
    Keccak.prototype.digest = function() {
        return this.digestInto(new Uint8Array(this.outputLen));
    };
    Keccak.prototype.destroy = function() {
        this.destroyed = true;
        this.state.fill(0);
    };
    Keccak.prototype._cloneInto = function(to) {
        var _a = this, blockLen = _a.blockLen, suffix = _a.suffix, outputLen = _a.outputLen, rounds = _a.rounds, enableXOF = _a.enableXOF;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    };
    Keccak.prototype.assertExists = function(checkFinished) {
        if (checkFinished === void 0) {
            checkFinished = true;
        }
        if (this.destroyed) throw new Error('Hash instance has been destroyed');
        if (checkFinished && this.finished) throw new Error('Hash#digest() has already been called');
    };
    return Keccak;
}(utils_1.Hash);
exports.Keccak = Keccak;
var gen = function(suffix, blockLen, outputLen) {
    return (0, utils_1.wrapConstructor)(function() {
        return new Keccak(blockLen, suffix, outputLen);
    });
};
// export const sha3_224 = /** @__PURE__ */ gen(0x06, 144, 224 / 8);
// /**
//  * SHA3-256 hash function
//  * @param message - that would be hashed
//  */
// export const sha3_256 = /** @__PURE__ */ gen(0x06, 136, 256 / 8);
// export const sha3_384 = /** @__PURE__ */ gen(0x06, 104, 384 / 8);
// export const sha3_512 = /** @__PURE__ */ gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */ exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8); // const genShake = (suffix: number, blockLen: number, outputLen: number) =>
 //   wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(
 //     (opts: ShakeOpts = {}) =>
 //       new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)
 //   );
 // 
 // export const shake128 = /** @__PURE__ */ genShake(0x1f, 168, 128 / 8);
 // export const shake256 = /** @__PURE__ */ genShake(0x1f, 136, 256 / 8);
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/utils.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.aInRange = exports.inRange = exports.isBytes = exports.abool = exports.memoized = exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = exports.abytes = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function abytes(item) {
    if (!isBytes(item)) throw new Error('Uint8Array expected');
}
exports.abytes = abytes;
// Array where index 0xf0 (240) is mapped to string 'f0'
var hexes = /* @__PURE__ */ Array.from({
    length: 256
}, function(_, i) {
    return i.toString(16).padStart(2, '0');
});
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // pre-caching improves the speed 6x
    var hex = '';
    for(var i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    var hex = num.toString(16);
    return hex.length & 1 ? "0".concat(hex) : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : "0x".concat(hex));
}
exports.hexToNumber = hexToNumber;
// We use optimized technique to convert hex string to byte array
var asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    var hl = hex.length;
    var al = hl / 2;
    if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    var array = new Uint8Array(al);
    for(var ai = 0, hi = 0; ai < al; ai++, hi += 2){
        var n1 = asciiToBase16(hex.charCodeAt(hi));
        var n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            var char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    abytes(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */ function ensureBytes(title, hex, expectedLength) {
    var res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        } catch (e) {
            throw new Error("".concat(title, " must be valid hex string, got \"").concat(hex, "\". Cause: ").concat(e));
        }
    } else if (isBytes(hex)) {
        // Uint8Array.from() instead of hash.slice() because node Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    } else {
        throw new Error("".concat(title, " must be hex string or Uint8Array"));
    }
    var len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error("".concat(title, " expected ").concat(expectedLength, " bytes, got ").concat(len));
    return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */ function concatBytes() {
    var arrays = [];
    for(var _i = 0; _i < arguments.length; _i++){
        arrays[_i] = arguments[_i];
    }
    var sum = 0;
    for(var i = 0; i < arrays.length; i++){
        var a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    var res = new Uint8Array(sum);
    for(var i = 0, pad = 0; i < arrays.length; i++){
        var a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
exports.concatBytes = concatBytes;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    var diff = 0;
    for(var i = 0; i < a.length; i++)diff |= a[i] ^ b[i];
    return diff === 0;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error("utf8ToBytes expected string, got ".concat(typeof str));
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */ function bitLen(n) {
    var len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */ function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */ function bitSet(n, pos, value) {
    return n | (value ? _1n : _0n) << BigInt(pos);
}
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */ var bitMask = function(n) {
    return (_2n << BigInt(n - 1)) - _1n;
};
exports.bitMask = bitMask;
// DRBG
var u8n = function(data) {
    return new Uint8Array(data);
}; // creates Uint8Array
var u8fr = function(arr) {
    return Uint8Array.from(arr);
}; // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    var v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    var k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    var i = 0; // Iterations counter, will throw when over 1000
    var reset = function() {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    var h = function() {
        var b = [];
        for(var _i = 0; _i < arguments.length; _i++){
            b[_i] = arguments[_i];
        }
        return hmacFn.apply(void 0, __spreadArray([
            k,
            v
        ], __read(b), false));
    }; // hmac(k)(v, ...values)
    var reseed = function(seed) {
        if (seed === void 0) {
            seed = u8n();
        }
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([
            0x00
        ]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8fr([
            0x01
        ]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    var gen = function() {
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error('drbg: tried 1000 values');
        var len = 0;
        var out = [];
        while(len < qByteLen){
            v = h();
            var sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes.apply(void 0, __spreadArray([], __read(out), false));
    };
    var genUntil = function(seed, pred) {
        reset();
        reseed(seed); // Steps D-G
        var res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
var validatorFns = {
    bigint: function(val) {
        return typeof val === 'bigint';
    },
    function: function(val) {
        return typeof val === 'function';
    },
    boolean: function(val) {
        return typeof val === 'boolean';
    },
    string: function(val) {
        return typeof val === 'string';
    },
    stringOrUint8Array: function(val) {
        return typeof val === 'string' || isBytes(val);
    },
    isSafeInteger: function(val) {
        return Number.isSafeInteger(val);
    },
    array: function(val) {
        return Array.isArray(val);
    },
    field: function(val, object) {
        return object.Fp.isValid(val);
    },
    hash: function(val) {
        return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
    }
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators) {
    var e_1, _b, e_2, _c;
    if (optValidators === void 0) {
        optValidators = {};
    }
    var checkField = function(fieldName, type, isOptional) {
        var checkVal = validatorFns[type];
        if (typeof checkVal !== 'function') throw new Error("Invalid validator \"".concat(type, "\", expected function"));
        var val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) {
            throw new Error("Invalid param ".concat(String(fieldName), "=").concat(val, " (").concat(typeof val, "), expected ").concat(type));
        }
    };
    try {
        for(var _d = __values(Object.entries(validators)), _e = _d.next(); !_e.done; _e = _d.next()){
            var _g = __read(_e.value, 2), fieldName = _g[0], type = _g[1];
            checkField(fieldName, type, false);
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    try {
        for(var _h = __values(Object.entries(optValidators)), _j = _h.next(); !_j.done; _j = _h.next()){
            var _k = __read(_j.value, 2), fieldName = _k[0], type = _k[1];
            checkField(fieldName, type, true);
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return object;
}
exports.validateObject = validateObject;
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */ function memoized(fn) {
    var map = new WeakMap();
    return function(arg) {
        var args = [];
        for(var _i = 1; _i < arguments.length; _i++){
            args[_i - 1] = arguments[_i];
        }
        var val = map.get(arg);
        if (val !== undefined) return val;
        var computed = fn.apply(void 0, __spreadArray([
            arg
        ], __read(args), false));
        map.set(arg, computed);
        return computed;
    };
}
exports.memoized = memoized;
function abool(title, value) {
    if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);
}
exports.abool = abool;
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
exports.isBytes = isBytes;
var isPosBig = function(n) {
    return typeof n === 'bigint' && _0n <= n;
};
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
exports.inRange = inRange;
/**
* Asserts min <= n < max. NOTE: It's < max and not <= max.
* @example
* aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
*/ function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max)) throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
exports.aInRange = aInRange;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/modular.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
// prettier-ignore
var _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
var _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
var _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    var result = a % b;
    return result >= _0n ? result : b + result;
}
exports.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */ // TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');
    if (modulo === _1n) return _0n;
    var res = _1n;
    while(power > _0n){
        if (power & _1n) res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
    }
    return res;
}
exports.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    var res = x;
    while(power-- > _0n){
        res *= res;
        res %= modulo;
    }
    return res;
}
exports.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
        throw new Error("invert: expected positive integers, got n=".concat(number, " mod=").concat(modulo));
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    var a = mod(number, modulo);
    var b = modulo;
    // prettier-ignore
    var x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        // JIT applies optimization if those two lines follow each other
        var q = b / a;
        var r = b % a;
        var m = x - u * q;
        var n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    var gcd = b;
    if (gcd !== _1n) throw new Error('invert: does not exist');
    return mod(x, modulo);
}
exports.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */ function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p)  1    if a is a square (mod p)
    // (a | p)  -1   if a is not a square (mod p)
    // (a | p)  0    if a  0 (mod p)
    var legendreC = (P - _1n) / _2n;
    var Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);
    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);
    // Fast-path
    if (S === 1) {
        var p1div4_1 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            var root = Fp.pow(n, p1div4_1);
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    var Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be  -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');
        var r = S;
        // TODO: will fail at Fp2/etc
        var g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        var x = Fp.pow(n, Q1div2); // first guess at the square root
        var b = Fp.pow(n, Q); // first guess at the fudge factor
        while(!Fp.eql(b, Fp.ONE)){
            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            var m = 1;
            for(var t2 = Fp.sqr(b); m < r; m++){
                if (Fp.eql(t2, Fp.ONE)) break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            var ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
exports.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P  3 (mod 4)
    // n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        var p1div4_2 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            var root = Fp.pow(n, p1div4_2);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        var c1_1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            var n2 = Fp.mul(n, _2n);
            var v = Fp.pow(n2, c1_1);
            var nv = Fp.mul(n, v);
            var i = Fp.mul(Fp.mul(nv, _2n), v);
            var root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
            return root;
        };
    }
    // P  9 (mod 16)
    if (P % _16n === _9n) {
    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
    // Means we cannot use sqrt for constants at all!
    //
    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
    // sqrt = (x) => {
    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
    // }
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
exports.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
var isNegativeLE = function(num, modulo) {
    return (mod(num, modulo) & _1n) === _1n;
};
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
var FIELD_FIELDS = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
];
function validateField(field) {
    var initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger'
    };
    var opts = FIELD_FIELDS.reduce(function(map, val) {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_1.validateObject)(field, opts);
}
exports.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */ function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n) throw new Error('Expected power > 0');
    if (power === _0n) return f.ONE;
    if (power === _1n) return num;
    var p = f.ONE;
    var d = num;
    while(power > _0n){
        if (power & _1n) p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
exports.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */ function FpInvertBatch(f, nums) {
    var tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    var lastMultiplied = nums.reduce(function(acc, num, i) {
        if (f.is0(num)) return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    var inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight(function(acc, num, i) {
        if (f.is0(num)) return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
exports.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
exports.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    var legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return function(x) {
        var p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
exports.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    var _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    var nByteLength = Math.ceil(_nBitLength / 8);
    return {
        nBitLength: _nBitLength,
        nByteLength: nByteLength
    };
}
exports.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */ function Field(ORDER, bitLen, isLE, redef) {
    if (isLE === void 0) {
        isLE = false;
    }
    if (redef === void 0) {
        redef = {};
    }
    if (ORDER <= _0n) throw new Error("Expected Field ORDER > 0, got ".concat(ORDER));
    var _a = nLength(ORDER, bitLen), BITS = _a.nBitLength, BYTES = _a.nByteLength;
    if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');
    var sqrtP = FpSqrt(ORDER);
    var f = Object.freeze({
        ORDER: ORDER,
        BITS: BITS,
        BYTES: BYTES,
        MASK: (0, utils_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: function(num) {
            return mod(num, ORDER);
        },
        isValid: function(num) {
            if (typeof num !== 'bigint') throw new Error("Invalid field element: expected bigint, got ".concat(typeof num));
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: function(num) {
            return num === _0n;
        },
        isOdd: function(num) {
            return (num & _1n) === _1n;
        },
        neg: function(num) {
            return mod(-num, ORDER);
        },
        eql: function(lhs, rhs) {
            return lhs === rhs;
        },
        sqr: function(num) {
            return mod(num * num, ORDER);
        },
        add: function(lhs, rhs) {
            return mod(lhs + rhs, ORDER);
        },
        sub: function(lhs, rhs) {
            return mod(lhs - rhs, ORDER);
        },
        mul: function(lhs, rhs) {
            return mod(lhs * rhs, ORDER);
        },
        pow: function(num, power) {
            return FpPow(f, num, power);
        },
        div: function(lhs, rhs) {
            return mod(lhs * invert(rhs, ORDER), ORDER);
        },
        // Same as above, but doesn't normalize
        sqrN: function(num) {
            return num * num;
        },
        addN: function(lhs, rhs) {
            return lhs + rhs;
        },
        subN: function(lhs, rhs) {
            return lhs - rhs;
        },
        mulN: function(lhs, rhs) {
            return lhs * rhs;
        },
        inv: function(num) {
            return invert(num, ORDER);
        },
        sqrt: redef.sqrt || function(n) {
            return sqrtP(f, n);
        },
        invertBatch: function(lst) {
            return FpInvertBatch(f, lst);
        },
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: function(a, b, c) {
            return c ? b : a;
        },
        toBytes: function(num) {
            return isLE ? (0, utils_1.numberToBytesLE)(num, BYTES) : (0, utils_1.numberToBytesBE)(num, BYTES);
        },
        fromBytes: function(bytes) {
            if (bytes.length !== BYTES) throw new Error("Fp.fromBytes: expected ".concat(BYTES, ", got ").concat(bytes.length));
            return isLE ? (0, utils_1.bytesToNumberLE)(bytes) : (0, utils_1.bytesToNumberBE)(bytes);
        }
    });
    return Object.freeze(f);
}
exports.Field = Field;
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    var root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
exports.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    var root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
exports.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */ function hashToPrivateScalar(hash, groupOrder, isLE) {
    if (isLE === void 0) {
        isLE = false;
    }
    hash = (0, utils_1.ensureBytes)('privateHash', hash);
    var hashLen = hash.length;
    var minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error("hashToPrivateScalar: expected ".concat(minLen, "-1024 bytes of input, got ").concat(hashLen));
    var num = isLE ? (0, utils_1.bytesToNumberLE)(hash) : (0, utils_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
exports.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */ function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');
    var bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
exports.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */ function getMinHashLength(fieldOrder) {
    var length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
exports.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */ function mapHashToField(key, fieldOrder, isLE) {
    if (isLE === void 0) {
        isLE = false;
    }
    var len = key.length;
    var fieldLen = getFieldBytesLength(fieldOrder);
    var minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024) throw new Error("expected ".concat(minLen, "-1024 bytes of input, got ").concat(len));
    var num = isLE ? (0, utils_1.bytesToNumberBE)(key) : (0, utils_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    var reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_1.numberToBytesBE)(reduced, fieldLen);
}
exports.mapHashToField = mapHashToField;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/hash-to-curve.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
var modular_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
var os2ip = utils_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << 8 * length) {
        throw new Error("bad I2OSP call: value=".concat(value, " length=").concat(length));
    }
    var res = Array.from({
        length: length
    }).fill(0);
    for(var i = length - 1; i >= 0; i--){
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    var arr = new Uint8Array(a.length);
    for(var i = 0; i < a.length; i++){
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item)) throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_1.abytes)(msg);
    (0, utils_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255) DST = H((0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    var b_in_bytes = H.outputLen, r_in_bytes = H.blockLen;
    var ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255) throw new Error('Invalid xmd length');
    var DST_prime = (0, utils_1.concatBytes)(DST, i2osp(DST.length, 1));
    var Z_pad = i2osp(0, r_in_bytes);
    var l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    var b = new Array(ell);
    var b_0 = H((0, utils_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for(var i = 1; i <= ell; i++){
        var args = [
            strxor(b_0, b[i - 1]),
            i2osp(i + 1, 1),
            DST_prime
        ];
        b[i] = H(utils_1.concatBytes.apply(void 0, __spreadArray([], __read(args), false)));
    }
    var pseudo_random_bytes = utils_1.concatBytes.apply(void 0, __spreadArray([], __read(b), false));
    return pseudo_random_bytes.slice(0, lenInBytes);
}
exports.expand_message_xmd = expand_message_xmd;
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_1.abytes)(msg);
    (0, utils_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        var dkLen = Math.ceil(2 * k / 8);
        DST = H.create({
            dkLen: dkLen
        }).update((0, utils_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');
    return H.create({
        dkLen: lenInBytes
    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)
    .update(DST).update(i2osp(DST.length, 1)).digest();
}
exports.expand_message_xof = expand_message_xof;
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */ function hash_to_field(msg, count, options) {
    (0, utils_1.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash'
    });
    var p = options.p, k = options.k, m = options.m, hash = options.hash, expand = options.expand, _DST = options.DST;
    (0, utils_1.abytes)(msg);
    anum(count);
    var DST = typeof _DST === 'string' ? (0, utils_1.utf8ToBytes)(_DST) : _DST;
    var log2p = p.toString(2).length;
    var L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    var len_in_bytes = count * m * L;
    var prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    } else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    } else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    } else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    var u = new Array(count);
    for(var i = 0; i < count; i++){
        var e = new Array(m);
        for(var j = 0; j < m; j++){
            var elm_offset = L * (j + i * m);
            var tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
exports.hash_to_field = hash_to_field;
function isogenyMap(field, map) {
    // Make same order as in spec
    var COEFF = map.map(function(i) {
        return Array.from(i).reverse();
    });
    return function(x, y) {
        var _a = __read(COEFF.map(function(val) {
            return val.reduce(function(acc, i) {
                return field.add(field.mul(acc, x), i);
            });
        }), 4), xNum = _a[0], xDen = _a[1], yNum = _a[2], yDen = _a[3];
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return {
            x: x,
            y: y
        };
    };
}
exports.isogenyMap = isogenyMap;
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve: function(msg, options) {
            var u = hash_to_field(msg, 2, __assign(__assign(__assign({}, def), {
                DST: def.DST
            }), options));
            var u0 = Point.fromAffine(mapToCurve(u[0]));
            var u1 = Point.fromAffine(mapToCurve(u[1]));
            var P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve: function(msg, options) {
            var u = hash_to_field(msg, 1, __assign(__assign(__assign({}, def), {
                DST: def.encodeDST
            }), options));
            var P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        }
    };
}
exports.createHasher = createHasher;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/curve.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/curve.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pippenger = exports.validateBasic = exports.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities
var modular_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
var _0n = BigInt(0);
var _1n = BigInt(1);
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes
var pointPrecomputes = new WeakMap();
var pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)
function getW(P) {
    return pointWindowSizes.get(P) || 1;
}
function constTimeNegate(condition, item) {
    var neg = item.negate();
    return condition ? neg : item;
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, bits) {
    validateW(W, bits);
    var windows = Math.ceil(bits / W) + 1; // +1, because
    var windowSize = Math.pow(2, W - 1); // -1 because we skip zero
    return {
        windows: windows,
        windowSize: windowSize
    };
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */ function wNAF(c, bits) {
    return {
        constTimeNegate: constTimeNegate,
        hasPrecomputes: function(elm) {
            return getW(elm) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder: function(elm, n, p) {
            if (p === void 0) {
                p = c.ZERO;
            }
            var d = elm;
            while(n > _0n){
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param elm Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */ precomputeWindow: function(elm, W) {
            var _a = calcWOpts(W, bits), windows = _a.windows, windowSize = _a.windowSize;
            var points = [];
            var p = elm;
            var base = p;
            for(var window_1 = 0; window_1 < windows; window_1++){
                base = p;
                points.push(base);
                // =1, because we skip zero
                for(var i = 1; i < windowSize; i++){
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */ wNAF: function(W, precomputes, n) {
            n = BigInt(n);
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            var _a = calcWOpts(W, bits), windows = _a.windows, windowSize = _a.windowSize;
            var p = c.ZERO;
            var f = c.BASE;
            var mask = BigInt(Math.pow(2, W) - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            var maxNumber = Math.pow(2, W);
            var shiftBy = BigInt(W);
            for(var window_2 = 0; window_2 < windows; window_2++){
                var offset = window_2 * windowSize;
                // Extract W bits.
                var wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                var offset1 = offset;
                var offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                var cond1 = window_2 % 2 !== 0;
                var cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                } else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return {
                p: p,
                f: f
            };
        },
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */ wNAFUnsafe: function(W, precomputes, n, acc) {
            if (acc === void 0) {
                acc = c.ZERO;
            }
            var _a = calcWOpts(W, bits), windows = _a.windows, windowSize = _a.windowSize;
            var mask = BigInt(Math.pow(2, W) - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            var maxNumber = Math.pow(2, W);
            var shiftBy = BigInt(W);
            for(var window_3 = 0; window_3 < windows; window_3++){
                var offset = window_3 * windowSize;
                if (n === _0n) break; // No need to go over empty scalar
                // Extract W bits.
                var wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                if (wbits === 0) continue;
                var curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero
                if (wbits < 0) curr = curr.negate();
                // NOTE: by re-using acc, we can save a lot of additions in case of MSM
                acc = acc.add(curr);
            }
            return acc;
        },
        getPrecomputes: function(W, P, transform) {
            // Calculate precomputes on a first run, reuse them after
            var comp = pointPrecomputes.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) pointPrecomputes.set(P, transform(comp));
            }
            return comp;
        },
        wNAFCached: function(P, n, transform) {
            var W = getW(P);
            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
        },
        wNAFCachedUnsafe: function(P, n, transform, prev) {
            var W = getW(P);
            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster
            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize: function(P, W) {
            validateW(W, bits);
            pointWindowSizes.set(P, W);
            pointPrecomputes.delete(P);
        }
    };
}
exports.wNAF = wNAF;
function validateBasic(curve) {
    (0, modular_1.validateField)(curve.Fp);
    (0, utils_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field'
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger'
    });
    // Set defaults
    return Object.freeze(__assign(__assign(__assign({}, (0, modular_1.nLength)(curve.n, curve.nBitLength)), curve), {
        p: curve.Fp.ORDER
    }));
}
exports.validateBasic = validateBasic;
function validateMSMPoints(points, c) {
    if (!Array.isArray(points)) throw new Error('array expected');
    points.forEach(function(p, i) {
        if (!(p instanceof c)) throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars)) throw new Error('array of scalars expected');
    scalars.forEach(function(s, i) {
        if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);
    });
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster with precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka private keys / bigints)
 */ function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    if (points.length !== scalars.length) throw new Error('arrays of points and scalars must have equal length');
    var zero = c.ZERO;
    var wbits = (0, utils_1.bitLen)(BigInt(points.length));
    var windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits
    var MASK = (1 << windowSize) - 1;
    var buckets = new Array(MASK + 1).fill(zero); // +1 for zero array
    var lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    var sum = zero;
    for(var i = lastBits; i >= 0; i -= windowSize){
        buckets.fill(zero);
        for(var j = 0; j < scalars.length; j++){
            var scalar = scalars[j];
            var wbits_1 = Number(scalar >> BigInt(i) & BigInt(MASK));
            buckets[wbits_1] = buckets[wbits_1].add(points[j]);
        }
        var resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for(var j = buckets.length - 1, sumI = zero; j > 0; j--){
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0) for(var j = 0; j < windowSize; j++)sum = sum.double();
    }
    return sum;
}
exports.pippenger = pippenger;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = exports.abytes = exports.isBytes = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';
}
exports.isBytes = isBytes;
function abytes(item) {
    if (!isBytes(item)) throw new Error('Uint8Array expected');
}
exports.abytes = abytes;
// Array where index 0xf0 (240) is mapped to string 'f0'
var hexes = /* @__PURE__ */ Array.from({
    length: 256
}, function(_, i) {
    return i.toString(16).padStart(2, '0');
});
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // pre-caching improves the speed 6x
    var hex = '';
    for(var i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    var hex = num.toString(16);
    return hex.length & 1 ? "0".concat(hex) : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : "0x".concat(hex));
}
exports.hexToNumber = hexToNumber;
// We use optimized technique to convert hex string to byte array
var asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    var hl = hex.length;
    var al = hl / 2;
    if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    var array = new Uint8Array(al);
    for(var ai = 0, hi = 0; ai < al; ai++, hi += 2){
        var n1 = asciiToBase16(hex.charCodeAt(hi));
        var n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            var char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    abytes(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */ function ensureBytes(title, hex, expectedLength) {
    var res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        } catch (e) {
            throw new Error("".concat(title, " must be valid hex string, got \"").concat(hex, "\". Cause: ").concat(e));
        }
    } else if (isBytes(hex)) {
        // Uint8Array.from() instead of hash.slice() because node Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    } else {
        throw new Error("".concat(title, " must be hex string or Uint8Array"));
    }
    var len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error("".concat(title, " expected ").concat(expectedLength, " bytes, got ").concat(len));
    return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */ function concatBytes() {
    var arrays = [];
    for(var _i = 0; _i < arguments.length; _i++){
        arrays[_i] = arguments[_i];
    }
    var sum = 0;
    for(var i = 0; i < arrays.length; i++){
        var a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    var res = new Uint8Array(sum);
    for(var i = 0, pad = 0; i < arrays.length; i++){
        var a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
exports.concatBytes = concatBytes;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    var diff = 0;
    for(var i = 0; i < a.length; i++)diff |= a[i] ^ b[i];
    return diff === 0;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error("utf8ToBytes expected string, got ".concat(typeof str));
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */ function bitLen(n) {
    var len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */ function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */ function bitSet(n, pos, value) {
    return n | (value ? _1n : _0n) << BigInt(pos);
}
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */ var bitMask = function(n) {
    return (_2n << BigInt(n - 1)) - _1n;
};
exports.bitMask = bitMask;
// DRBG
var u8n = function(data) {
    return new Uint8Array(data);
}; // creates Uint8Array
var u8fr = function(arr) {
    return Uint8Array.from(arr);
}; // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    var v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    var k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    var i = 0; // Iterations counter, will throw when over 1000
    var reset = function() {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    var h = function() {
        var b = [];
        for(var _i = 0; _i < arguments.length; _i++){
            b[_i] = arguments[_i];
        }
        return hmacFn.apply(void 0, __spreadArray([
            k,
            v
        ], __read(b), false));
    }; // hmac(k)(v, ...values)
    var reseed = function(seed) {
        if (seed === void 0) {
            seed = u8n();
        }
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([
            0x00
        ]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8fr([
            0x01
        ]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    var gen = function() {
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error('drbg: tried 1000 values');
        var len = 0;
        var out = [];
        while(len < qByteLen){
            v = h();
            var sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes.apply(void 0, __spreadArray([], __read(out), false));
    };
    var genUntil = function(seed, pred) {
        reset();
        reseed(seed); // Steps D-G
        var res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
var validatorFns = {
    bigint: function(val) {
        return typeof val === 'bigint';
    },
    function: function(val) {
        return typeof val === 'function';
    },
    boolean: function(val) {
        return typeof val === 'boolean';
    },
    string: function(val) {
        return typeof val === 'string';
    },
    stringOrUint8Array: function(val) {
        return typeof val === 'string' || isBytes(val);
    },
    isSafeInteger: function(val) {
        return Number.isSafeInteger(val);
    },
    array: function(val) {
        return Array.isArray(val);
    },
    field: function(val, object) {
        return object.Fp.isValid(val);
    },
    hash: function(val) {
        return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
    }
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators) {
    var e_1, _b, e_2, _c;
    if (optValidators === void 0) {
        optValidators = {};
    }
    var checkField = function(fieldName, type, isOptional) {
        var checkVal = validatorFns[type];
        if (typeof checkVal !== 'function') throw new Error("Invalid validator \"".concat(type, "\", expected function"));
        var val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) {
            throw new Error("Invalid param ".concat(String(fieldName), "=").concat(val, " (").concat(typeof val, "), expected ").concat(type));
        }
    };
    try {
        for(var _d = __values(Object.entries(validators)), _e = _d.next(); !_e.done; _e = _d.next()){
            var _g = __read(_e.value, 2), fieldName = _g[0], type = _g[1];
            checkField(fieldName, type, false);
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    try {
        for(var _h = __values(Object.entries(optValidators)), _j = _h.next(); !_j.done; _j = _h.next()){
            var _k = __read(_j.value, 2), fieldName = _k[0], type = _k[1];
            checkField(fieldName, type, true);
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return object;
}
exports.validateObject = validateObject; // validate type tests
 // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
 // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
 // // Should fail type-check
 // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
 // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
 // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
 // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/modular.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/utils.js [app-client] (ecmascript)");
// prettier-ignore
var _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
var _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
var _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    var result = a % b;
    return result >= _0n ? result : b + result;
}
exports.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */ // TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');
    if (modulo === _1n) return _0n;
    var res = _1n;
    while(power > _0n){
        if (power & _1n) res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
    }
    return res;
}
exports.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    var res = x;
    while(power-- > _0n){
        res *= res;
        res %= modulo;
    }
    return res;
}
exports.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
        throw new Error("invert: expected positive integers, got n=".concat(number, " mod=").concat(modulo));
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    var a = mod(number, modulo);
    var b = modulo;
    // prettier-ignore
    var x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        // JIT applies optimization if those two lines follow each other
        var q = b / a;
        var r = b % a;
        var m = x - u * q;
        var n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    var gcd = b;
    if (gcd !== _1n) throw new Error('invert: does not exist');
    return mod(x, modulo);
}
exports.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */ function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p)  1    if a is a square (mod p)
    // (a | p)  -1   if a is not a square (mod p)
    // (a | p)  0    if a  0 (mod p)
    var legendreC = (P - _1n) / _2n;
    var Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);
    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);
    // Fast-path
    if (S === 1) {
        var p1div4_1 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            var root = Fp.pow(n, p1div4_1);
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    var Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be  -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');
        var r = S;
        // TODO: will fail at Fp2/etc
        var g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        var x = Fp.pow(n, Q1div2); // first guess at the square root
        var b = Fp.pow(n, Q); // first guess at the fudge factor
        while(!Fp.eql(b, Fp.ONE)){
            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            var m = 1;
            for(var t2 = Fp.sqr(b); m < r; m++){
                if (Fp.eql(t2, Fp.ONE)) break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            var ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
exports.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P  3 (mod 4)
    // n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        var p1div4_2 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            var root = Fp.pow(n, p1div4_2);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        var c1_1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            var n2 = Fp.mul(n, _2n);
            var v = Fp.pow(n2, c1_1);
            var nv = Fp.mul(n, v);
            var i = Fp.mul(Fp.mul(nv, _2n), v);
            var root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
            return root;
        };
    }
    // P  9 (mod 16)
    if (P % _16n === _9n) {
    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
    // Means we cannot use sqrt for constants at all!
    //
    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
    // sqrt = (x) => {
    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
    // }
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
exports.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
var isNegativeLE = function(num, modulo) {
    return (mod(num, modulo) & _1n) === _1n;
};
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
var FIELD_FIELDS = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
];
function validateField(field) {
    var initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger'
    };
    var opts = FIELD_FIELDS.reduce(function(map, val) {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_1.validateObject)(field, opts);
}
exports.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */ function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n) throw new Error('Expected power > 0');
    if (power === _0n) return f.ONE;
    if (power === _1n) return num;
    var p = f.ONE;
    var d = num;
    while(power > _0n){
        if (power & _1n) p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
exports.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */ function FpInvertBatch(f, nums) {
    var tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    var lastMultiplied = nums.reduce(function(acc, num, i) {
        if (f.is0(num)) return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    var inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight(function(acc, num, i) {
        if (f.is0(num)) return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
exports.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
exports.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    var legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return function(x) {
        var p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
exports.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    var _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    var nByteLength = Math.ceil(_nBitLength / 8);
    return {
        nBitLength: _nBitLength,
        nByteLength: nByteLength
    };
}
exports.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */ function Field(ORDER, bitLen, isLE, redef) {
    if (isLE === void 0) {
        isLE = false;
    }
    if (redef === void 0) {
        redef = {};
    }
    if (ORDER <= _0n) throw new Error("Expected Field ORDER > 0, got ".concat(ORDER));
    var _a = nLength(ORDER, bitLen), BITS = _a.nBitLength, BYTES = _a.nByteLength;
    if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');
    var sqrtP = FpSqrt(ORDER);
    var f = Object.freeze({
        ORDER: ORDER,
        BITS: BITS,
        BYTES: BYTES,
        MASK: (0, utils_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: function(num) {
            return mod(num, ORDER);
        },
        isValid: function(num) {
            if (typeof num !== 'bigint') throw new Error("Invalid field element: expected bigint, got ".concat(typeof num));
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: function(num) {
            return num === _0n;
        },
        isOdd: function(num) {
            return (num & _1n) === _1n;
        },
        neg: function(num) {
            return mod(-num, ORDER);
        },
        eql: function(lhs, rhs) {
            return lhs === rhs;
        },
        sqr: function(num) {
            return mod(num * num, ORDER);
        },
        add: function(lhs, rhs) {
            return mod(lhs + rhs, ORDER);
        },
        sub: function(lhs, rhs) {
            return mod(lhs - rhs, ORDER);
        },
        mul: function(lhs, rhs) {
            return mod(lhs * rhs, ORDER);
        },
        pow: function(num, power) {
            return FpPow(f, num, power);
        },
        div: function(lhs, rhs) {
            return mod(lhs * invert(rhs, ORDER), ORDER);
        },
        // Same as above, but doesn't normalize
        sqrN: function(num) {
            return num * num;
        },
        addN: function(lhs, rhs) {
            return lhs + rhs;
        },
        subN: function(lhs, rhs) {
            return lhs - rhs;
        },
        mulN: function(lhs, rhs) {
            return lhs * rhs;
        },
        inv: function(num) {
            return invert(num, ORDER);
        },
        sqrt: redef.sqrt || function(n) {
            return sqrtP(f, n);
        },
        invertBatch: function(lst) {
            return FpInvertBatch(f, lst);
        },
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: function(a, b, c) {
            return c ? b : a;
        },
        toBytes: function(num) {
            return isLE ? (0, utils_1.numberToBytesLE)(num, BYTES) : (0, utils_1.numberToBytesBE)(num, BYTES);
        },
        fromBytes: function(bytes) {
            if (bytes.length !== BYTES) throw new Error("Fp.fromBytes: expected ".concat(BYTES, ", got ").concat(bytes.length));
            return isLE ? (0, utils_1.bytesToNumberLE)(bytes) : (0, utils_1.bytesToNumberBE)(bytes);
        }
    });
    return Object.freeze(f);
}
exports.Field = Field;
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    var root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
exports.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    var root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
exports.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */ function hashToPrivateScalar(hash, groupOrder, isLE) {
    if (isLE === void 0) {
        isLE = false;
    }
    hash = (0, utils_1.ensureBytes)('privateHash', hash);
    var hashLen = hash.length;
    var minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error("hashToPrivateScalar: expected ".concat(minLen, "-1024 bytes of input, got ").concat(hashLen));
    var num = isLE ? (0, utils_1.bytesToNumberLE)(hash) : (0, utils_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
exports.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */ function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');
    var bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
exports.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */ function getMinHashLength(fieldOrder) {
    var length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
exports.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */ function mapHashToField(key, fieldOrder, isLE) {
    if (isLE === void 0) {
        isLE = false;
    }
    var len = key.length;
    var fieldLen = getFieldBytesLength(fieldOrder);
    var minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024) throw new Error("expected ".concat(minLen, "-1024 bytes of input, got ").concat(len));
    var num = isLE ? (0, utils_1.bytesToNumberBE)(key) : (0, utils_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    var reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_1.numberToBytesBE)(reduced, fieldLen);
}
exports.mapHashToField = mapHashToField;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/curve.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateBasic = exports.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities
var modular_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/modular.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/utils.js [app-client] (ecmascript)");
var _0n = BigInt(0);
var _1n = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    var constTimeNegate = function(condition, item) {
        var neg = item.negate();
        return condition ? neg : item;
    };
    var opts = function(W) {
        var windows = Math.ceil(bits / W) + 1; // +1, because
        var windowSize = Math.pow(2, W - 1); // -1 because we skip zero
        return {
            windows: windows,
            windowSize: windowSize
        };
    };
    return {
        constTimeNegate: constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder: function(elm, n) {
            var p = c.ZERO;
            var d = elm;
            while(n > _0n){
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */ precomputeWindow: function(elm, W) {
            var _a = opts(W), windows = _a.windows, windowSize = _a.windowSize;
            var points = [];
            var p = elm;
            var base = p;
            for(var window_1 = 0; window_1 < windows; window_1++){
                base = p;
                points.push(base);
                // =1, because we skip zero
                for(var i = 1; i < windowSize; i++){
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */ wNAF: function(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            var _a = opts(W), windows = _a.windows, windowSize = _a.windowSize;
            var p = c.ZERO;
            var f = c.BASE;
            var mask = BigInt(Math.pow(2, W) - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            var maxNumber = Math.pow(2, W);
            var shiftBy = BigInt(W);
            for(var window_2 = 0; window_2 < windows; window_2++){
                var offset = window_2 * windowSize;
                // Extract W bits.
                var wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                var offset1 = offset;
                var offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                var cond1 = window_2 % 2 !== 0;
                var cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                } else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return {
                p: p,
                f: f
            };
        },
        wNAFCached: function(P, precomputesMap, n, transform) {
            // @ts-ignore
            var W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            var comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    precomputesMap.set(P, transform(comp));
                }
            }
            return this.wNAF(W, comp, n);
        }
    };
}
exports.wNAF = wNAF;
function validateBasic(curve) {
    (0, modular_1.validateField)(curve.Fp);
    (0, utils_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field'
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger'
    });
    // Set defaults
    return Object.freeze(__assign(__assign(__assign({}, (0, modular_1.nLength)(curve.n, curve.nBitLength)), curve), {
        p: curve.Fp.ORDER
    }));
}
exports.validateBasic = validateBasic;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/weierstrass.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/weierstrass.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfigon`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y = x + ax + b
var mod = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)"));
var ut = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)"));
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
var curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/curve.js [app-client] (ecmascript)");
var curve_2 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/curve.js [app-client] (ecmascript)");
function validatePointOpts(curve) {
    var opts = (0, curve_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field'
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function'
    });
    var endo = opts.endo, Fp = opts.Fp, a = opts.a;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze(__assign({}, opts));
}
// ASN.1 DER encoding utilities
var b2n = ut.bytesToNumberBE, h2b = ut.hexToBytes;
exports.DER = {
    // asn.1 DER encoding utils
    Err: function(_super) {
        __extends(DERErr, _super);
        function DERErr(m) {
            if (m === void 0) {
                m = '';
            }
            return _super.call(this, m) || this;
        }
        return DERErr;
    }(Error),
    _parseInt: function(data) {
        var E = exports.DER.Err;
        if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');
        var len = data[1];
        var res = data.subarray(2, len + 2);
        if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 128) throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 128)) throw new E('Invalid signature integer: unnecessary leading zero');
        return {
            d: b2n(res),
            l: data.subarray(len + 2)
        }; // d is data, l is left
    },
    toSig: function(hex) {
        // parse DER signature
        var E = exports.DER.Err;
        var data = typeof hex === 'string' ? h2b(hex) : hex;
        ut.abytes(data);
        var l = data.length;
        if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');
        if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');
        var _a = exports.DER._parseInt(data.subarray(2)), r = _a.d, sBytes = _a.l;
        var _b = exports.DER._parseInt(sBytes), s = _b.d, rBytesLeft = _b.l;
        if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');
        return {
            r: r,
            s: s
        };
    },
    hexFromSig: function(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        var slice = function(s) {
            return Number.parseInt(s[0], 16) & 8 ? '00' + s : s;
        };
        var h = function(num) {
            var hex = num.toString(16);
            return hex.length & 1 ? "0".concat(hex) : hex;
        };
        var s = slice(h(sig.s));
        var r = slice(h(sig.r));
        var shl = s.length / 2;
        var rhl = r.length / 2;
        var sl = h(shl);
        var rl = h(rhl);
        return "30".concat(h(rhl + shl + 4), "02").concat(rl).concat(r, "02").concat(sl).concat(s);
    }
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
var _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    var CURVE = validatePointOpts(opts);
    var Fp = CURVE.Fp; // All curves has same field / group length as for now, but they can differ
    var toBytes = CURVE.toBytes || function(_c, point, _isCompressed) {
        var a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([
            0x04
        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    };
    var fromBytes = CURVE.fromBytes || function(bytes) {
        // const head = bytes[0];
        var tail = bytes.subarray(1);
        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
        var x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        var y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return {
            x: x,
            y: y
        };
    };
    /**
     * y = x + ax + b: Short weierstrass curve formula
     * @returns y
     */ function weierstrassEquation(x) {
        var a = CURVE.a, b = CURVE.b;
        var x2 = Fp.sqr(x); // x * x
        var x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        var lengths = CURVE.allowedPrivateKeyLengths, nByteLength = CURVE.nByteLength, wrapPrivateKey = CURVE.wrapPrivateKey, n = CURVE.n;
        if (lengths && typeof key !== 'bigint') {
            if (ut.isBytes(key)) key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        var num;
        try {
            num = typeof key === 'bigint' ? key : ut.bytesToNumberBE((0, utils_1.ensureBytes)('private key', key, nByteLength));
        } catch (error) {
            throw new Error("private key must be ".concat(nByteLength, " bytes, hex or bigint, not ").concat(typeof key));
        }
        if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    var pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */ var Point = function() {
        function Point(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px)) throw new Error('x required');
            if (py == null || !Fp.isValid(py)) throw new Error('y required');
            if (pz == null || !Fp.isValid(pz)) throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        Point.fromAffine = function(p) {
            var _a = p || {}, x = _a.x, y = _a.y;
            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');
            if (p instanceof Point) throw new Error('projective point not allowed');
            var is0 = function(i) {
                return Fp.eql(i, Fp.ZERO);
            };
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y)) return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        };
        Object.defineProperty(Point.prototype, "x", {
            get: function() {
                return this.toAffine().x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Point.prototype, "y", {
            get: function() {
                return this.toAffine().y;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */ Point.normalizeZ = function(points) {
            var toInv = Fp.invertBatch(points.map(function(p) {
                return p.pz;
            }));
            return points.map(function(p, i) {
                return p.toAffine(toInv[i]);
            }).map(Point.fromAffine);
        };
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */ Point.fromHex = function(hex) {
            var P = Point.fromAffine(fromBytes((0, utils_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        };
        // Multiplies generator point by privateKey.
        Point.fromPrivateKey = function(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        };
        // "Private method", don't use it directly
        Point.prototype._setWindowSize = function(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        };
        // A point on curve is valid if it conforms to equation.
        Point.prototype.assertValidity = function() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            var _a = this.toAffine(), x = _a.x, y = _a.y;
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');
            var left = Fp.sqr(y); // y
            var right = weierstrassEquation(x); // x + ax + b
            if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
        };
        Point.prototype.hasEvenY = function() {
            var y = this.toAffine().y;
            if (Fp.isOdd) return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        };
        /**
         * Compare one point to another.
         */ Point.prototype.equals = function(other) {
            assertPrjPoint(other);
            var _a = this, X1 = _a.px, Y1 = _a.py, Z1 = _a.pz;
            var X2 = other.px, Y2 = other.py, Z2 = other.pz;
            var U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            var U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        };
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */ Point.prototype.negate = function() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        };
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        Point.prototype.double = function() {
            var a = CURVE.a, b = CURVE.b;
            var b3 = Fp.mul(b, _3n);
            var _a = this, X1 = _a.px, Y1 = _a.py, Z1 = _a.pz;
            var X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            var t0 = Fp.mul(X1, X1); // step 1
            var t1 = Fp.mul(Y1, Y1);
            var t2 = Fp.mul(Z1, Z1);
            var t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        };
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        Point.prototype.add = function(other) {
            assertPrjPoint(other);
            var _a = this, X1 = _a.px, Y1 = _a.py, Z1 = _a.pz;
            var X2 = other.px, Y2 = other.py, Z2 = other.pz;
            var X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            var a = CURVE.a;
            var b3 = Fp.mul(CURVE.b, _3n);
            var t0 = Fp.mul(X1, X2); // step 1
            var t1 = Fp.mul(Y1, Y2);
            var t2 = Fp.mul(Z1, Z2);
            var t3 = Fp.add(X1, Y1);
            var t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            var t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        };
        Point.prototype.subtract = function(other) {
            return this.add(other.negate());
        };
        Point.prototype.is0 = function() {
            return this.equals(Point.ZERO);
        };
        Point.prototype.wNAF = function(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, function(comp) {
                var toInv = Fp.invertBatch(comp.map(function(p) {
                    return p.pz;
                }));
                return comp.map(function(p, i) {
                    return p.toAffine(toInv[i]);
                }).map(Point.fromAffine);
            });
        };
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */ Point.prototype.multiplyUnsafe = function(n) {
            var I = Point.ZERO;
            if (n === _0n) return I;
            assertGE(n); // Will throw on 0
            if (n === _1n) return this;
            var endo = CURVE.endo;
            if (!endo) return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            var _a = endo.splitScalar(n), k1neg = _a.k1neg, k1 = _a.k1, k2neg = _a.k2neg, k2 = _a.k2;
            var k1p = I;
            var k2p = I;
            var d = this;
            while(k1 > _0n || k2 > _0n){
                if (k1 & _1n) k1p = k1p.add(d);
                if (k2 & _1n) k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        };
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */ Point.prototype.multiply = function(scalar) {
            assertGE(scalar);
            var n = BigInt(scalar);
            var point, fake; // Fake point is used to const-time mult
            var endo = CURVE.endo;
            if (endo) {
                var _a = endo.splitScalar(n), k1neg = _a.k1neg, k1 = _a.k1, k2neg = _a.k2neg, k2 = _a.k2;
                var _b = this.wNAF(k1), k1p = _b.p, f1p = _b.f;
                var _d = this.wNAF(k2), k2p = _d.p, f2p = _d.f;
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            } else {
                var _e = this.wNAF(n), p = _e.p, f = _e.f;
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([
                point,
                fake
            ])[0];
        };
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */ Point.prototype.multiplyAndAddUnsafe = function(Q, a, b) {
            var G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            var mul = function(P, a // Select faster multiply() method
            ) {
                return a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);
            };
            var sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        };
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        Point.prototype.toAffine = function(iz) {
            var _a = this, x = _a.px, y = _a.py, z = _a.pz;
            var is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
            var ax = Fp.mul(x, iz);
            var ay = Fp.mul(y, iz);
            var zz = Fp.mul(z, iz);
            if (is0) return {
                x: Fp.ZERO,
                y: Fp.ZERO
            };
            if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');
            return {
                x: ax,
                y: ay
            };
        };
        Point.prototype.isTorsionFree = function() {
            var cofactor = CURVE.h, isTorsionFree = CURVE.isTorsionFree;
            if (cofactor === _1n) return true; // No subgroups, always torsion-free
            if (isTorsionFree) return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        };
        Point.prototype.clearCofactor = function() {
            var cofactor = CURVE.h, clearCofactor = CURVE.clearCofactor;
            if (cofactor === _1n) return this; // Fast-path
            if (clearCofactor) return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        };
        Point.prototype.toRawBytes = function(isCompressed) {
            if (isCompressed === void 0) {
                isCompressed = true;
            }
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        };
        Point.prototype.toHex = function(isCompressed) {
            if (isCompressed === void 0) {
                isCompressed = true;
            }
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        };
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
        Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
        return Point;
    }();
    var _bits = CURVE.nBitLength;
    var wnaf = (0, curve_2.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE: CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        weierstrassEquation: weierstrassEquation,
        isWithinCurveOrder: isWithinCurveOrder
    };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
    var opts = (0, curve_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function'
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean'
    });
    return Object.freeze(__assign({
        lowS: true
    }, opts));
}
function weierstrass(curveDef) {
    var CURVE = validateOpts(curveDef);
    var Fp = CURVE.Fp, CURVE_ORDER = CURVE.n;
    var compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    var uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    var _a = weierstrassPoints(__assign(__assign({}, CURVE), {
        toBytes: function(_c, point, isCompressed) {
            var a = point.toAffine();
            var x = Fp.toBytes(a.x);
            var cat = ut.concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([
                    point.hasEvenY() ? 0x02 : 0x03
                ]), x);
            } else {
                return cat(Uint8Array.from([
                    0x04
                ]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes: function(bytes) {
            var len = bytes.length;
            var head = bytes[0];
            var tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                var x = ut.bytesToNumberBE(tail);
                if (!isValidFieldElement(x)) throw new Error('Point is not on curve');
                var y2 = weierstrassEquation(x); // y = x + ax + b
                var y = void 0;
                try {
                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                } catch (sqrtError) {
                    var suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                    throw new Error('Point is not on curve' + suffix);
                }
                var isYOdd = (y & _1n) === _1n;
                // ECDSA
                var isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd) y = Fp.neg(y);
                return {
                    x: x,
                    y: y
                };
            } else if (len === uncompressedLen && head === 0x04) {
                var x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                var y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return {
                    x: x,
                    y: y
                };
            } else {
                throw new Error("Point of length ".concat(len, " was invalid. Expected ").concat(compressedLen, " compressed bytes or ").concat(uncompressedLen, " uncompressed bytes"));
            }
        }
    })), Point = _a.ProjectivePoint, normPrivateKeyToScalar = _a.normPrivateKeyToScalar, weierstrassEquation = _a.weierstrassEquation, isWithinCurveOrder = _a.isWithinCurveOrder;
    var numToNByteStr = function(num) {
        return ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    };
    function isBiggerThanHalfOrder(number) {
        var HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    var slcNum = function(b, from, to) {
        return ut.bytesToNumberBE(b.slice(from, to));
    };
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */ var Signature = function() {
        function Signature(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        Signature.fromCompact = function(hex) {
            var l = CURVE.nByteLength;
            hex = (0, utils_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        };
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        Signature.fromDER = function(hex) {
            var _a = exports.DER.toSig((0, utils_1.ensureBytes)('DER', hex)), r = _a.r, s = _a.s;
            return new Signature(r, s);
        };
        Signature.prototype.assertValidity = function() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');
        };
        Signature.prototype.addRecoveryBit = function(recovery) {
            return new Signature(this.r, this.s, recovery);
        };
        Signature.prototype.recoverPublicKey = function(msgHash) {
            var _a = this, r = _a.r, s = _a.s, rec = _a.recovery;
            var h = bits2int_modN((0, utils_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![
                0,
                1,
                2,
                3
            ].includes(rec)) throw new Error('recovery id invalid');
            var radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');
            var prefix = (rec & 1) === 0 ? '02' : '03';
            var R = Point.fromHex(prefix + numToNByteStr(radj));
            var ir = invN(radj); // r^-1
            var u1 = modN(-h * ir); // -hr^-1
            var u2 = modN(s * ir); // sr^-1
            var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        };
        // Signatures should be low-s, to prevent malleability.
        Signature.prototype.hasHighS = function() {
            return isBiggerThanHalfOrder(this.s);
        };
        Signature.prototype.normalizeS = function() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        };
        // DER-encoded
        Signature.prototype.toDERRawBytes = function() {
            return ut.hexToBytes(this.toDERHex());
        };
        Signature.prototype.toDERHex = function() {
            return exports.DER.hexFromSig({
                r: this.r,
                s: this.s
            });
        };
        // padded bytes of r, then padded bytes of s
        Signature.prototype.toCompactRawBytes = function() {
            return ut.hexToBytes(this.toCompactHex());
        };
        Signature.prototype.toCompactHex = function() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        };
        return Signature;
    }();
    var utils = {
        isValidPrivateKey: function(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            } catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */ randomPrivateKey: function() {
            var length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */ precompute: function(windowSize, point) {
            if (windowSize === void 0) {
                windowSize = 8;
            }
            if (point === void 0) {
                point = Point.BASE;
            }
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        }
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */ function getPublicKey(privateKey, isCompressed) {
        if (isCompressed === void 0) {
            isCompressed = true;
        }
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */ function isProbPub(item) {
        var arr = ut.isBytes(item);
        var str = typeof item === 'string';
        var len = (arr || str) && item.length;
        if (arr) return len === compressedLen || len === uncompressedLen;
        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point) return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */ function getSharedSecret(privateA, publicB, isCompressed) {
        if (isCompressed === void 0) {
            isCompressed = true;
        }
        if (isProbPub(privateA)) throw new Error('first arg must be private key');
        if (!isProbPub(publicB)) throw new Error('second arg must be public key');
        var b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    var bits2int = CURVE.bits2int || function(bytes) {
        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
        // for some cases, since bytes.length * 8 is not actual bitLength.
        var num = ut.bytesToNumberBE(bytes); // check for == u8 done here
        var delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
        return delta > 0 ? num >> BigInt(delta) : num;
    };
    var bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes)); // can't use bytesToNumberBE here
    };
    // NOTE: pads output with zero as per spec
    var ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */ function int2octets(num) {
        if (typeof num !== 'bigint') throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK)) throw new Error("bigint expected < 2^".concat(CURVE.nBitLength));
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts) {
        if (opts === void 0) {
            opts = defaultSigOpts;
        }
        if ([
            'recovered',
            'canonical'
        ].some(function(k) {
            return k in opts;
        })) throw new Error('sign() legacy options not supported');
        var hash = CURVE.hash, randomBytes = CURVE.randomBytes;
        var lowS = opts.lowS, prehash = opts.prehash, ent = opts.extraEntropy; // generates low-s sigs by default
        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_1.ensureBytes)('msgHash', msgHash);
        if (prehash) msgHash = (0, utils_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        var h1int = bits2int_modN(msgHash);
        var d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        var seedArgs = [
            int2octets(d),
            int2octets(h1int)
        ];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null && ent !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            var e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        var seed = ut.concatBytes.apply(ut, __spreadArray([], __read(seedArgs), false)); // Step D of RFC6979 3.2
        var m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            var k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N
            var ik = invN(k); // k^-1 mod n
            var q = Point.BASE.multiply(k).toAffine(); // q = Gk
            var r = modN(q.x); // r = q.x mod n
            if (r === _0n) return;
            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            var s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n) return;
            var recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            var normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return {
            seed: seed,
            k2sig: k2sig
        };
    }
    var defaultSigOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    var defaultVerOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */ function sign(msgHash, privKey, opts) {
        if (opts === void 0) {
            opts = defaultSigOpts;
        }
        var _a = prepSig(msgHash, privKey, opts), seed = _a.seed, k2sig = _a.k2sig; // Steps A, D of RFC6979 3.2.
        var C = CURVE;
        var drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */ function verify(signature, msgHash, publicKey, opts) {
        var _a;
        if (opts === void 0) {
            opts = defaultVerOpts;
        }
        var sg = signature;
        msgHash = (0, utils_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts) throw new Error('options.strict was renamed to lowS');
        var lowS = opts.lowS, prehash = opts.prehash;
        var _sig = undefined;
        var P;
        try {
            if (typeof sg === 'string' || ut.isBytes(sg)) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                } catch (derError) {
                    if (!(derError instanceof exports.DER.Err)) throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                var r_1 = sg.r, s_1 = sg.s;
                _sig = new Signature(r_1, s_1);
            } else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        } catch (error) {
            if (error.message === 'PARSE') throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return false;
        }
        if (lowS && _sig.hasHighS()) return false;
        if (prehash) msgHash = CURVE.hash(msgHash);
        var r = _sig.r, s = _sig.s;
        var h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        var is = invN(s); // s^-1
        var u1 = modN(h * is); // u1 = hs^-1 mod n
        var u2 = modN(r * is); // u2 = rs^-1 mod n
        var R = (_a = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _a === void 0 ? void 0 : _a.toAffine(); // R = u1G + u2P
        if (!R) return false;
        var v = modN(R.x);
        return v === r;
    }
    return {
        CURVE: CURVE,
        getPublicKey: getPublicKey,
        getSharedSecret: getSharedSecret,
        sign: sign,
        verify: verify,
        ProjectivePoint: Point,
        Signature: Signature,
        utils: utils
    };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */ function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    var q = Fp.ORDER;
    var l = _0n;
    for(var o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;
    var c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    var _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
    var _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    var c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    var c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    var c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    var c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    var c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    var c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    var sqrtRatio = function(u, v) {
        var tv1 = c6; // 1. tv1 = c6
        var tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        var tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        var tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        var tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        var isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for(var i = c1; i > _1n; i--){
            var tv5_1 = i - _2n; // 18.    tv5 = i - 2
            tv5_1 = _2n << tv5_1 - _1n; // 19.    tv5 = 2^tv5
            var tvv5 = Fp.pow(tv4, tv5_1); // 20.    tv5 = tv4^tv5
            var e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return {
            isValid: isQR,
            value: tv3
        };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        var c1_1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        var c2_1 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = function(u, v) {
            var tv1 = Fp.sqr(v); // 1. tv1 = v^2
            var tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            var y1 = Fp.pow(tv1, c1_1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            var y2 = Fp.mul(y1, c2_1); // 6. y2 = y1 * c2
            var tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            var isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            var y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return {
                isValid: isQR,
                value: y
            }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */ function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');
    var sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return function(u) {
        // prettier-ignore
        var tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        var _a = sqrtRatio(tv2, tv6), isValid = _a.isValid, value = _a.value; // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        var e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return {
            x: x,
            y: y
        };
    };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/bls.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/bls.ts#

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bls = void 0;
var modular_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
// prettier-ignore
var hash_to_curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)");
var weierstrass_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/weierstrass.js [app-client] (ecmascript)");
// prettier-ignore
var _2n = BigInt(2), _3n = BigInt(3);
function bls(CURVE) {
    // Fields are specific for curve, so for now we'll need to pass them with opts
    var _a = CURVE.fields, Fp = _a.Fp, Fr = _a.Fr, Fp2 = _a.Fp2, Fp6 = _a.Fp6, Fp12 = _a.Fp12;
    var BLS_X_LEN = (0, utils_1.bitLen)(CURVE.params.x);
    // Pre-compute coefficients for sparse multiplication
    // Point addition and point double calculations is reused for coefficients
    function calcPairingPrecomputes(p) {
        var x = p.x, y = p.y;
        // prettier-ignore
        var Qx = x, Qy = y, Qz = Fp2.ONE;
        // prettier-ignore
        var Rx = Qx, Ry = Qy, Rz = Qz;
        var ell_coeff = [];
        for(var i = BLS_X_LEN - 2; i >= 0; i--){
            // Double
            var t0 = Fp2.sqr(Ry); // Ry
            var t1 = Fp2.sqr(Rz); // Rz
            var t2 = Fp2.multiplyByB(Fp2.mul(t1, _3n)); // 3 * T1 * B
            var t3 = Fp2.mul(t2, _3n); // 3 * T2
            var t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz) - T1 - T0
            ell_coeff.push([
                Fp2.sub(t2, t0),
                Fp2.mul(Fp2.sqr(Rx), _3n),
                Fp2.neg(t4)
            ]);
            Rx = Fp2.div(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), _2n); // ((T0 - T3) * Rx * Ry) / 2
            Ry = Fp2.sub(Fp2.sqr(Fp2.div(Fp2.add(t0, t3), _2n)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2) - 3 * T2
            Rz = Fp2.mul(t0, t4); // T0 * T4
            if ((0, utils_1.bitGet)(CURVE.params.x, i)) {
                // Addition
                var t0_1 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz
                var t1_1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz
                ell_coeff.push([
                    Fp2.sub(Fp2.mul(t0_1, Qx), Fp2.mul(t1_1, Qy)),
                    Fp2.neg(t0_1),
                    t1_1
                ]);
                var t2_1 = Fp2.sqr(t1_1); // T1
                var t3_1 = Fp2.mul(t2_1, t1_1); // T2 * T1
                var t4_1 = Fp2.mul(t2_1, Rx); // T2 * Rx
                var t5 = Fp2.add(Fp2.sub(t3_1, Fp2.mul(t4_1, _2n)), Fp2.mul(Fp2.sqr(t0_1), Rz)); // T3 - 2 * T4 + T0 * Rz
                Rx = Fp2.mul(t1_1, t5); // T1 * T5
                Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4_1, t5), t0_1), Fp2.mul(t3_1, Ry)); // (T4 - T5) * T0 - T3 * Ry
                Rz = Fp2.mul(Rz, t3_1); // Rz * T3
            }
        }
        return ell_coeff;
    }
    function millerLoop(ell, g1) {
        var x = CURVE.params.x;
        var Px = g1[0];
        var Py = g1[1];
        var f12 = Fp12.ONE;
        for(var j = 0, i = BLS_X_LEN - 2; i >= 0; i--, j++){
            var E = ell[j];
            f12 = Fp12.multiplyBy014(f12, E[0], Fp2.mul(E[1], Px), Fp2.mul(E[2], Py));
            if ((0, utils_1.bitGet)(x, i)) {
                j += 1;
                var F = ell[j];
                f12 = Fp12.multiplyBy014(f12, F[0], Fp2.mul(F[1], Px), Fp2.mul(F[2], Py));
            }
            if (i !== 0) f12 = Fp12.sqr(f12);
        }
        return Fp12.conjugate(f12);
    }
    var utils = {
        randomPrivateKey: function() {
            var length = (0, modular_1.getMinHashLength)(Fr.ORDER);
            return (0, modular_1.mapHashToField)(CURVE.randomBytes(length), Fr.ORDER);
        },
        calcPairingPrecomputes: calcPairingPrecomputes
    };
    // Point on G1 curve: (x, y)
    var G1_ = (0, weierstrass_1.weierstrassPoints)(__assign({
        n: Fr.ORDER
    }, CURVE.G1));
    var G1 = Object.assign(G1_, (0, hash_to_curve_1.createHasher)(G1_.ProjectivePoint, CURVE.G1.mapToCurve, __assign(__assign({}, CURVE.htfDefaults), CURVE.G1.htfDefaults)));
    function pairingPrecomputes(point) {
        var p = point;
        if (p._PPRECOMPUTES) return p._PPRECOMPUTES;
        p._PPRECOMPUTES = calcPairingPrecomputes(point.toAffine());
        return p._PPRECOMPUTES;
    }
    // TODO: export
    // function clearPairingPrecomputes(point: G2) {
    //   const p = point as G2 & withPairingPrecomputes;
    //   p._PPRECOMPUTES = undefined;
    // }
    // Point on G2 curve (complex numbers): (x, x+i), (y, y+i)
    var G2_ = (0, weierstrass_1.weierstrassPoints)(__assign({
        n: Fr.ORDER
    }, CURVE.G2));
    var G2 = Object.assign(G2_, (0, hash_to_curve_1.createHasher)(G2_.ProjectivePoint, CURVE.G2.mapToCurve, __assign(__assign({}, CURVE.htfDefaults), CURVE.G2.htfDefaults)));
    var ShortSignature = CURVE.G1.ShortSignature;
    var Signature = CURVE.G2.Signature;
    // Calculates bilinear pairing
    function pairing(Q, P, withFinalExponent) {
        if (withFinalExponent === void 0) {
            withFinalExponent = true;
        }
        if (Q.equals(G1.ProjectivePoint.ZERO) || P.equals(G2.ProjectivePoint.ZERO)) throw new Error('pairing is not available for ZERO point');
        Q.assertValidity();
        P.assertValidity();
        // Performance: 9ms for millerLoop and ~14ms for exp.
        var Qa = Q.toAffine();
        var looped = millerLoop(pairingPrecomputes(P), [
            Qa.x,
            Qa.y
        ]);
        return withFinalExponent ? Fp12.finalExponentiate(looped) : looped;
    }
    function normP1(point) {
        return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);
    }
    function normP1Hash(point, htfOpts) {
        return point instanceof G1.ProjectivePoint ? point : G1.hashToCurve((0, utils_1.ensureBytes)('point', point), htfOpts);
    }
    function normP2(point) {
        return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);
    }
    function normP2Hash(point, htfOpts) {
        return point instanceof G2.ProjectivePoint ? point : G2.hashToCurve((0, utils_1.ensureBytes)('point', point), htfOpts);
    }
    // Multiplies generator (G1) by private key.
    // P = pk x G
    function getPublicKey(privateKey) {
        return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
    }
    // Multiplies generator (G2) by private key.
    // P = pk x G
    function getPublicKeyForShortSignatures(privateKey) {
        return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
    }
    function sign(message, privateKey, htfOpts) {
        var msgPoint = normP2Hash(message, htfOpts);
        msgPoint.assertValidity();
        var sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
        if (message instanceof G2.ProjectivePoint) return sigPoint;
        return Signature.toRawBytes(sigPoint);
    }
    function signShortSignature(message, privateKey, htfOpts) {
        var msgPoint = normP1Hash(message, htfOpts);
        msgPoint.assertValidity();
        var sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
        if (message instanceof G1.ProjectivePoint) return sigPoint;
        return ShortSignature.toRawBytes(sigPoint);
    }
    // Checks if pairing of public key & hash is equal to pairing of generator & signature.
    // e(P, H(m)) == e(G, S)
    function verify(signature, message, publicKey, htfOpts) {
        var P = normP1(publicKey);
        var Hm = normP2Hash(message, htfOpts);
        var G = G1.ProjectivePoint.BASE;
        var S = normP2(signature);
        // Instead of doing 2 exponentiations, we use property of billinear maps
        // and do one exp after multiplying 2 points.
        var ePHm = pairing(P.negate(), Hm, false);
        var eGS = pairing(G, S, false);
        var exp = Fp12.finalExponentiate(Fp12.mul(eGS, ePHm));
        return Fp12.eql(exp, Fp12.ONE);
    }
    // Checks if pairing of public key & hash is equal to pairing of generator & signature.
    // e(S, G) == e(H(m), P)
    function verifyShortSignature(signature, message, publicKey, htfOpts) {
        var P = normP2(publicKey);
        var Hm = normP1Hash(message, htfOpts);
        var G = G2.ProjectivePoint.BASE;
        var S = normP1(signature);
        // Instead of doing 2 exponentiations, we use property of billinear maps
        // and do one exp after multiplying 2 points.
        var eHmP = pairing(Hm, P, false);
        var eSG = pairing(S, G.negate(), false);
        var exp = Fp12.finalExponentiate(Fp12.mul(eSG, eHmP));
        return Fp12.eql(exp, Fp12.ONE);
    }
    function aggregatePublicKeys(publicKeys) {
        if (!publicKeys.length) throw new Error('Expected non-empty array');
        var agg = publicKeys.map(normP1).reduce(function(sum, p) {
            return sum.add(p);
        }, G1.ProjectivePoint.ZERO);
        var aggAffine = agg; //.toAffine();
        if (publicKeys[0] instanceof G1.ProjectivePoint) {
            aggAffine.assertValidity();
            return aggAffine;
        }
        // toRawBytes ensures point validity
        return aggAffine.toRawBytes(true);
    }
    function aggregateSignatures(signatures) {
        if (!signatures.length) throw new Error('Expected non-empty array');
        var agg = signatures.map(normP2).reduce(function(sum, s) {
            return sum.add(s);
        }, G2.ProjectivePoint.ZERO);
        var aggAffine = agg; //.toAffine();
        if (signatures[0] instanceof G2.ProjectivePoint) {
            aggAffine.assertValidity();
            return aggAffine;
        }
        return Signature.toRawBytes(aggAffine);
    }
    function aggregateShortSignatures(signatures) {
        if (!signatures.length) throw new Error('Expected non-empty array');
        var agg = signatures.map(normP1).reduce(function(sum, s) {
            return sum.add(s);
        }, G1.ProjectivePoint.ZERO);
        var aggAffine = agg; //.toAffine();
        if (signatures[0] instanceof G1.ProjectivePoint) {
            aggAffine.assertValidity();
            return aggAffine;
        }
        return ShortSignature.toRawBytes(aggAffine);
    }
    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407
    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))
    function verifyBatch(signature, messages, publicKeys, htfOpts) {
        // @ts-ignore
        // console.log('verifyBatch', bytesToHex(signature as any), messages, publicKeys.map(bytesToHex));
        var e_1, _a;
        if (!messages.length) throw new Error('Expected non-empty messages array');
        if (publicKeys.length !== messages.length) throw new Error('Pubkey count should equal msg count');
        var sig = normP2(signature);
        var nMessages = messages.map(function(i) {
            return normP2Hash(i, htfOpts);
        });
        var nPublicKeys = publicKeys.map(normP1);
        try {
            var paired = [];
            var _loop_1 = function(message) {
                var groupPublicKey = nMessages.reduce(function(groupPublicKey, subMessage, i) {
                    return subMessage === message ? groupPublicKey.add(nPublicKeys[i]) : groupPublicKey;
                }, G1.ProjectivePoint.ZERO);
                // const msg = message instanceof PointG2 ? message : await PointG2.hashToCurve(message);
                // Possible to batch pairing for same msg with different groupPublicKey here
                paired.push(pairing(groupPublicKey, message, false));
            };
            try {
                for(var _b = __values(new Set(nMessages)), _c = _b.next(); !_c.done; _c = _b.next()){
                    var message = _c.value;
                    _loop_1(message);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            paired.push(pairing(G1.ProjectivePoint.BASE.negate(), sig, false));
            var product = paired.reduce(function(a, b) {
                return Fp12.mul(a, b);
            }, Fp12.ONE);
            var exp = Fp12.finalExponentiate(product);
            return Fp12.eql(exp, Fp12.ONE);
        } catch (_d) {
            return false;
        }
    }
    G1.ProjectivePoint.BASE._setWindowSize(4);
    return {
        getPublicKey: getPublicKey,
        getPublicKeyForShortSignatures: getPublicKeyForShortSignatures,
        sign: sign,
        signShortSignature: signShortSignature,
        verify: verify,
        verifyBatch: verifyBatch,
        verifyShortSignature: verifyShortSignature,
        aggregatePublicKeys: aggregatePublicKeys,
        aggregateSignatures: aggregateSignatures,
        aggregateShortSignatures: aggregateShortSignatures,
        millerLoop: millerLoop,
        pairing: pairing,
        G1: G1,
        G2: G2,
        Signature: Signature,
        ShortSignature: ShortSignature,
        fields: {
            Fr: Fr,
            Fp: Fp,
            Fp2: Fp2,
            Fp6: Fp6,
            Fp12: Fp12
        },
        params: {
            x: CURVE.params.x,
            r: CURVE.params.r,
            G1b: CURVE.G1.b,
            G2b: CURVE.G2.b
        },
        utils: utils
    };
}
exports.bls = bls;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/_assert.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, not ".concat(n));
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean') throw new Error("boolean expected, not ".concat(b));
}
exports.bool = bool;
// copied from utils
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';
}
exports.isBytes = isBytes;
function bytes(b) {
    var lengths = [];
    for(var _i = 1; _i < arguments.length; _i++){
        lengths[_i - 1] = arguments[_i];
    }
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length ".concat(lengths, ", not of length=").concat(b.length));
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished) {
    if (checkFinished === void 0) {
        checkFinished = true;
    }
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    var min = instance.outputLen;
    if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least ".concat(min));
    }
}
exports.output = output;
var assert = {
    number: number,
    bool: bool,
    bytes: bytes,
    hash: hash,
    exists: exists,
    output: output
};
exports.default = assert;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/_md.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HashMD = exports.Maj = exports.Chi = void 0;
var _assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/_assert.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    var _32n = BigInt(32);
    var _u32_max = BigInt(0xffffffff);
    var wh = Number(value >> _32n & _u32_max);
    var wl = Number(value & _u32_max);
    var h = isLE ? 4 : 0;
    var l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Choice: a ? b : c
var Chi = function(a, b, c) {
    return a & b ^ ~a & c;
};
exports.Chi = Chi;
// Majority function, true if any two inpust is true
var Maj = function(a, b, c) {
    return a & b ^ a & c ^ b & c;
};
exports.Maj = Maj;
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */ var HashMD = function(_super) {
    __extends(HashMD, _super);
    function HashMD(blockLen, outputLen, padOffset, isLE) {
        var _this = _super.call(this) || this;
        _this.blockLen = blockLen;
        _this.outputLen = outputLen;
        _this.padOffset = padOffset;
        _this.isLE = isLE;
        _this.finished = false;
        _this.length = 0;
        _this.pos = 0;
        _this.destroyed = false;
        _this.buffer = new Uint8Array(blockLen);
        _this.view = (0, utils_1.createView)(_this.buffer);
        return _this;
    }
    HashMD.prototype.update = function(data) {
        (0, _assert_1.exists)(this);
        var _a = this, view = _a.view, buffer = _a.buffer, blockLen = _a.blockLen;
        data = (0, utils_1.toBytes)(data);
        var len = data.length;
        for(var pos = 0; pos < len;){
            var take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                var dataView = (0, utils_1.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    };
    HashMD.prototype.digestInto = function(out) {
        (0, _assert_1.exists)(this);
        (0, _assert_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        var _a = this, buffer = _a.buffer, view = _a.view, blockLen = _a.blockLen, isLE = _a.isLE;
        var pos = this.pos;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(var i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        var oview = (0, utils_1.createView)(out);
        var len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        var outLen = len / 4;
        var state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for(var i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    };
    HashMD.prototype.digest = function() {
        var _a = this, buffer = _a.buffer, outputLen = _a.outputLen;
        this.digestInto(buffer);
        var res = Uint8Array.prototype.slice.call(buffer, 0, outputLen);
        this.destroy();
        return res;
    };
    HashMD.prototype._cloneInto = function(to) {
        to || (to = new this.constructor());
        to.set.apply(to, __spreadArray([], __read(this.get()), false));
        var _a = this, blockLen = _a.blockLen, buffer = _a.buffer, length = _a.length, finished = _a.finished, destroyed = _a.destroyed, pos = _a.pos;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    };
    return HashMD;
}(utils_1.Hash);
exports.HashMD = HashMD;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/sha256.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha224 = exports.sha256 = void 0;
var _md_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/_md.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
var SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = function(_super) {
    __extends(SHA256, _super);
    function SHA256() {
        var _this = _super.call(this, 64, 32, 8, false) || this;
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        _this.A = SHA256_IV[0] | 0;
        _this.B = SHA256_IV[1] | 0;
        _this.C = SHA256_IV[2] | 0;
        _this.D = SHA256_IV[3] | 0;
        _this.E = SHA256_IV[4] | 0;
        _this.F = SHA256_IV[5] | 0;
        _this.G = SHA256_IV[6] | 0;
        _this.H = SHA256_IV[7] | 0;
        return _this;
    }
    SHA256.prototype.get = function() {
        var _a = this, A = _a.A, B = _a.B, C = _a.C, D = _a.D, E = _a.E, F = _a.F, G = _a.G, H = _a.H;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    };
    // prettier-ignore
    SHA256.prototype.set = function(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    };
    SHA256.prototype.process = function(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(var i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(var i = 16; i < 64; i++){
            var W15 = SHA256_W[i - 15];
            var W2 = SHA256_W[i - 2];
            var s0 = (0, utils_1.rotr)(W15, 7) ^ (0, utils_1.rotr)(W15, 18) ^ W15 >>> 3;
            var s1 = (0, utils_1.rotr)(W2, 17) ^ (0, utils_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        var _a = this, A = _a.A, B = _a.B, C = _a.C, D = _a.D, E = _a.E, F = _a.F, G = _a.G, H = _a.H;
        for(var i = 0; i < 64; i++){
            var sigma1 = (0, utils_1.rotr)(E, 6) ^ (0, utils_1.rotr)(E, 11) ^ (0, utils_1.rotr)(E, 25);
            var T1 = H + sigma1 + (0, _md_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            var sigma0 = (0, utils_1.rotr)(A, 2) ^ (0, utils_1.rotr)(A, 13) ^ (0, utils_1.rotr)(A, 22);
            var T2 = sigma0 + (0, _md_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    };
    SHA256.prototype.roundClean = function() {
        SHA256_W.fill(0);
    };
    SHA256.prototype.destroy = function() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    };
    return SHA256;
}(_md_1.HashMD);
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
var SHA224 = function(_super) {
    __extends(SHA224, _super);
    function SHA224() {
        var _this = _super.call(this) || this;
        _this.A = 0xc1059ed8 | 0;
        _this.B = 0x367cd507 | 0;
        _this.C = 0x3070dd17 | 0;
        _this.D = 0xf70e5939 | 0;
        _this.E = 0xffc00b31 | 0;
        _this.F = 0x68581511 | 0;
        _this.G = 0x64f98fa7 | 0;
        _this.H = 0xbefa4fa4 | 0;
        _this.outputLen = 28;
        return _this;
    }
    return SHA224;
}(SHA256);
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */ exports.sha256 = (0, utils_1.wrapConstructor)(function() {
    return new SHA256();
});
exports.sha224 = (0, utils_1.wrapConstructor)(function() {
    return new SHA224();
});
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/bls12_381.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/bls12-381.ts#L1

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/ var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bls12_381 = exports.G2_mapToCurve = exports.G1_mapToCurve = exports.G1_formBytes = exports.parseMask = exports.Fp12 = exports.Fp12_ONE = exports.Fp12_eql = exports.Fp12_conjugate = exports.Fp12_finalExponentiate = exports.Fp12Multiply = exports.Fp2 = exports.Fp = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:
// - Construct zk-SNARKs at the 120-bit security
// - Efficiently verify N aggregate signatures with 1 pairing and N ec additions:
//   the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr
//
// ### Summary
// 1. BLS Relies on Bilinear Pairing (expensive)
// 2. Private Keys: 32 bytes
// 3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.
// 4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.
//     - The signature is a point on the G2 subgroup, which is defined over a finite field
//     with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the complex numbers).
// 5. The 12 stands for the Embedding degree.
//
// ### Formulas
// - `P = pk x G` - public keys
// - `S = pk x H(m)` - signing
// - `e(P, H(m)) == e(G, S)` - verification using pairings
// - `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation
//
// ### Compatibility and notes
// 1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC
//    Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.
// 2. Some projects use G2 for public keys and G1 for signatures. It's called "short signature"
// 3. Curve security level is about 120 bits as per Barbulescu-Duquesne 2017
//    https://hal.science/hal-01534101/file/main.pdf
// 4. Compatible with specs:
// [cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),
// [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05),
// [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380).
var bls_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/bls.js [app-client] (ecmascript)");
var mod = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)"));
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
// Types
var weierstrass_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/weierstrass.js [app-client] (ecmascript)");
var hash_to_curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)");
var sha256_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/sha256.js [app-client] (ecmascript)");
var utils_2 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
var _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
// prettier-ignore
var _8n = BigInt(8), _16n = BigInt(16);
// CURVE FIELDS
// Finite field over p.
var Fp_raw = BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab');
exports.Fp = mod.Field(Fp_raw);
// Finite field over r.
// This particular field is not used anywhere in bls12-381, but it is still useful.
var Fr = mod.Field(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));
var Fp2Add = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return {
        c0: exports.Fp.add(c0, r0),
        c1: exports.Fp.add(c1, r1)
    };
};
var Fp2Subtract = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return {
        c0: exports.Fp.sub(c0, r0),
        c1: exports.Fp.sub(c1, r1)
    };
};
var Fp2Multiply = function(_a, rhs) {
    var c0 = _a.c0, c1 = _a.c1;
    if (typeof rhs === 'bigint') return {
        c0: exports.Fp.mul(c0, rhs),
        c1: exports.Fp.mul(c1, rhs)
    };
    // (a+bi)(c+di) = (acbd) + (ad+bc)i
    var r0 = rhs.c0, r1 = rhs.c1;
    var t1 = exports.Fp.mul(c0, r0); // c0 * o0
    var t2 = exports.Fp.mul(c1, r1); // c1 * o1
    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i
    var o0 = exports.Fp.sub(t1, t2);
    var o1 = exports.Fp.sub(exports.Fp.mul(exports.Fp.add(c0, c1), exports.Fp.add(r0, r1)), exports.Fp.add(t1, t2));
    return {
        c0: o0,
        c1: o1
    };
};
var Fp2Square = function(_a) {
    var c0 = _a.c0, c1 = _a.c1;
    var a = exports.Fp.add(c0, c1);
    var b = exports.Fp.sub(c0, c1);
    var c = exports.Fp.add(c0, c0);
    return {
        c0: exports.Fp.mul(a, b),
        c1: exports.Fp.mul(c, c1)
    };
};
// G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),
// where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where
// G - 1
// h2q
// NOTE: ORDER was wrong!
var FP2_ORDER = Fp_raw * Fp_raw;
exports.Fp2 = {
    ORDER: FP2_ORDER,
    BITS: (0, utils_1.bitLen)(FP2_ORDER),
    BYTES: Math.ceil((0, utils_1.bitLen)(FP2_ORDER) / 8),
    MASK: (0, utils_1.bitMask)((0, utils_1.bitLen)(FP2_ORDER)),
    ZERO: {
        c0: exports.Fp.ZERO,
        c1: exports.Fp.ZERO
    },
    ONE: {
        c0: exports.Fp.ONE,
        c1: exports.Fp.ZERO
    },
    create: function(num) {
        return num;
    },
    isValid: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return typeof c0 === 'bigint' && typeof c1 === 'bigint';
    },
    is0: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return exports.Fp.is0(c0) && exports.Fp.is0(c1);
    },
    eql: function(_a, _b) {
        var c0 = _a.c0, c1 = _a.c1;
        var r0 = _b.c0, r1 = _b.c1;
        return exports.Fp.eql(c0, r0) && exports.Fp.eql(c1, r1);
    },
    neg: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: exports.Fp.neg(c0),
            c1: exports.Fp.neg(c1)
        };
    },
    pow: function(num, power) {
        return mod.FpPow(exports.Fp2, num, power);
    },
    invertBatch: function(nums) {
        return mod.FpInvertBatch(exports.Fp2, nums);
    },
    // Normalized
    add: Fp2Add,
    sub: Fp2Subtract,
    mul: Fp2Multiply,
    sqr: Fp2Square,
    // NonNormalized stuff
    addN: Fp2Add,
    subN: Fp2Subtract,
    mulN: Fp2Multiply,
    sqrN: Fp2Square,
    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?
    div: function(lhs, rhs) {
        return exports.Fp2.mul(lhs, typeof rhs === 'bigint' ? exports.Fp.inv(exports.Fp.create(rhs)) : exports.Fp2.inv(rhs));
    },
    inv: function(_a) {
        var a = _a.c0, b = _a.c1;
        // We wish to find the multiplicative inverse of a nonzero
        // element a + bu in Fp2. We leverage an identity
        //
        // (a + bu)(a - bu) = a + b
        //
        // which holds because u = -1. This can be rewritten as
        //
        // (a + bu)(a - bu)/(a + b) = 1
        //
        // because a + b = 0 has no nonzero solutions for (a, b).
        // This gives that (a - bu)/(a + b) is the inverse
        // of (a + bu). Importantly, this can be computing using
        // only a single inversion in Fp.
        var factor = exports.Fp.inv(exports.Fp.create(a * a + b * b));
        return {
            c0: exports.Fp.mul(factor, exports.Fp.create(a)),
            c1: exports.Fp.mul(factor, exports.Fp.create(-b))
        };
    },
    sqrt: function(num) {
        if (exports.Fp2.eql(num, exports.Fp2.ZERO)) return exports.Fp2.ZERO; // Algo doesn't handles this case
        // TODO: Optimize this line. It's extremely slow.
        // Speeding this up would boost aggregateSignatures.
        // https://eprint.iacr.org/2012/685.pdf applicable?
        // https://github.com/zkcrypto/bls12_381/blob/080eaa74ec0e394377caa1ba302c8c121df08b07/src/fp2.rs#L250
        // https://github.com/supranational/blst/blob/aae0c7d70b799ac269ff5edf29d8191dbd357876/src/exp2.c#L1
        // Inspired by https://github.com/dalek-cryptography/curve25519-dalek/blob/17698df9d4c834204f83a3574143abacb4fc81a5/src/field.rs#L99
        var candidateSqrt = exports.Fp2.pow(num, (exports.Fp2.ORDER + _8n) / _16n);
        var check = exports.Fp2.div(exports.Fp2.sqr(candidateSqrt), num); // candidateSqrt.square().div(this);
        var R = FP2_ROOTS_OF_UNITY;
        var divisor = [
            R[0],
            R[2],
            R[4],
            R[6]
        ].find(function(r) {
            return exports.Fp2.eql(r, check);
        });
        if (!divisor) throw new Error('No root');
        var index = R.indexOf(divisor);
        var root = R[index / 2];
        if (!root) throw new Error('Invalid root');
        var x1 = exports.Fp2.div(candidateSqrt, root);
        var x2 = exports.Fp2.neg(x1);
        var _a = exports.Fp2.reim(x1), re1 = _a.re, im1 = _a.im;
        var _b = exports.Fp2.reim(x2), re2 = _b.re, im2 = _b.im;
        if (im1 > im2 || im1 === im2 && re1 > re2) return x1;
        return x2;
    },
    // Same as sgn0_m_eq_2 in RFC 9380
    isOdd: function(x) {
        var _a = exports.Fp2.reim(x), x0 = _a.re, x1 = _a.im;
        var sign_0 = x0 % _2n;
        var zero_0 = x0 === _0n;
        var sign_1 = x1 % _2n;
        return BigInt(sign_0 || zero_0 && sign_1) == _1n;
    },
    // Bytes util
    fromBytes: function(b) {
        if (b.length !== exports.Fp2.BYTES) throw new Error("fromBytes wrong length=".concat(b.length));
        return {
            c0: exports.Fp.fromBytes(b.subarray(0, exports.Fp.BYTES)),
            c1: exports.Fp.fromBytes(b.subarray(exports.Fp.BYTES))
        };
    },
    toBytes: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return (0, utils_1.concatBytes)(exports.Fp.toBytes(c0), exports.Fp.toBytes(c1));
    },
    cmov: function(_a, _b, c) {
        var c0 = _a.c0, c1 = _a.c1;
        var r0 = _b.c0, r1 = _b.c1;
        return {
            c0: exports.Fp.cmov(c0, r0, c),
            c1: exports.Fp.cmov(c1, r1, c)
        };
    },
    // Specific utils
    // toString() {
    //   return `Fp2(${this.c0} + ${this.c1}i)`;
    // }
    reim: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            re: c0,
            im: c1
        };
    },
    // multiply by u + 1
    mulByNonresidue: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: exports.Fp.sub(c0, c1),
            c1: exports.Fp.add(c0, c1)
        };
    },
    multiplyByB: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        var t0 = exports.Fp.mul(c0, _4n); // 4 * c0
        var t1 = exports.Fp.mul(c1, _4n); // 4 * c1
        // (T0-T1) + (T0+T1)*i
        return {
            c0: exports.Fp.sub(t0, t1),
            c1: exports.Fp.add(t0, t1)
        };
    },
    fromBigTuple: function(tuple) {
        if (tuple.length !== 2) throw new Error('Invalid tuple');
        var fps = tuple.map(function(n) {
            return exports.Fp.create(n);
        });
        return {
            c0: fps[0],
            c1: fps[1]
        };
    },
    frobeniusMap: function(_a, power) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: c0,
            c1: exports.Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2])
        };
    }
};
// Finite extension field over irreducible polynominal.
// Fp(u) / (u - ) where  = -1
var FP2_FROBENIUS_COEFFICIENTS = [
    BigInt('0x1'),
    BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa')
].map(function(item) {
    return exports.Fp.create(item);
});
// For Fp2 roots of unity.
var rv1 = BigInt('0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09');
// const ev1 =
//   BigInt('0x699be3b8c6870965e5bf892ad5d2cc7b0e85a117402dfd83b7f4a947e02d978498255a2aaec0ac627b5afbdf1bf1c90');
// const ev2 =
//   BigInt('0x8157cd83046453f5dd0972b6e3949e4288020b5b8a9cc99ca07e27089a2ce2436d965026adad3ef7baba37f2183e9b5');
// const ev3 =
//   BigInt('0xab1c2ffdd6c253ca155231eb3e71ba044fd562f6f72bc5bad5ec46a0b7a3b0247cf08ce6c6317f40edbc653a72dee17');
// const ev4 =
//   BigInt('0xaa404866706722864480885d68ad0ccac1967c7544b447873cc37e0181271e006df72162a3d3e0287bf597fbf7f8fc1');
// Eighth roots of unity, used for computing square roots in Fp2.
// To verify or re-calculate:
// Array(8).fill(new Fp2([1n, 1n])).map((fp2, k) => fp2.pow(Fp2.ORDER * BigInt(k) / 8n))
var FP2_ROOTS_OF_UNITY = [
    [
        _1n,
        _0n
    ],
    [
        rv1,
        -rv1
    ],
    [
        _0n,
        _1n
    ],
    [
        rv1,
        rv1
    ],
    [
        -_1n,
        _0n
    ],
    [
        -rv1,
        rv1
    ],
    [
        _0n,
        -_1n
    ],
    [
        -rv1,
        -rv1
    ]
].map(function(pair) {
    return exports.Fp2.fromBigTuple(pair);
});
var Fp6Add = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
    var r0 = _b.c0, r1 = _b.c1, r2 = _b.c2;
    return {
        c0: exports.Fp2.add(c0, r0),
        c1: exports.Fp2.add(c1, r1),
        c2: exports.Fp2.add(c2, r2)
    };
};
var Fp6Subtract = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
    var r0 = _b.c0, r1 = _b.c1, r2 = _b.c2;
    return {
        c0: exports.Fp2.sub(c0, r0),
        c1: exports.Fp2.sub(c1, r1),
        c2: exports.Fp2.sub(c2, r2)
    };
};
var Fp6Multiply = function(_a, rhs) {
    var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
    if (typeof rhs === 'bigint') {
        return {
            c0: exports.Fp2.mul(c0, rhs),
            c1: exports.Fp2.mul(c1, rhs),
            c2: exports.Fp2.mul(c2, rhs)
        };
    }
    var r0 = rhs.c0, r1 = rhs.c1, r2 = rhs.c2;
    var t0 = exports.Fp2.mul(c0, r0); // c0 * o0
    var t1 = exports.Fp2.mul(c1, r1); // c1 * o1
    var t2 = exports.Fp2.mul(c2, r2); // c2 * o2
    return {
        // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)
        c0: exports.Fp2.add(t0, exports.Fp2.mulByNonresidue(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(c1, c2), exports.Fp2.add(r1, r2)), exports.Fp2.add(t1, t2)))),
        // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)
        c1: exports.Fp2.add(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(c0, c1), exports.Fp2.add(r0, r1)), exports.Fp2.add(t0, t1)), exports.Fp2.mulByNonresidue(t2)),
        // T1 + (c0 + c2) * (r0 + r2) - T0 + T2
        c2: exports.Fp2.sub(exports.Fp2.add(t1, exports.Fp2.mul(exports.Fp2.add(c0, c2), exports.Fp2.add(r0, r2))), exports.Fp2.add(t0, t2))
    };
};
var Fp6Square = function(_a) {
    var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
    var t0 = exports.Fp2.sqr(c0); // c0
    var t1 = exports.Fp2.mul(exports.Fp2.mul(c0, c1), _2n); // 2 * c0 * c1
    var t3 = exports.Fp2.mul(exports.Fp2.mul(c1, c2), _2n); // 2 * c1 * c2
    var t4 = exports.Fp2.sqr(c2); // c2
    return {
        c0: exports.Fp2.add(exports.Fp2.mulByNonresidue(t3), t0),
        c1: exports.Fp2.add(exports.Fp2.mulByNonresidue(t4), t1),
        // T1 + (c0 - c1 + c2) + T3 - T0 - T4
        c2: exports.Fp2.sub(exports.Fp2.sub(exports.Fp2.add(exports.Fp2.add(t1, exports.Fp2.sqr(exports.Fp2.add(exports.Fp2.sub(c0, c1), c2))), t3), t0), t4)
    };
};
var Fp6 = {
    ORDER: exports.Fp2.ORDER,
    BITS: 3 * exports.Fp2.BITS,
    BYTES: 3 * exports.Fp2.BYTES,
    MASK: (0, utils_1.bitMask)(3 * exports.Fp2.BITS),
    ZERO: {
        c0: exports.Fp2.ZERO,
        c1: exports.Fp2.ZERO,
        c2: exports.Fp2.ZERO
    },
    ONE: {
        c0: exports.Fp2.ONE,
        c1: exports.Fp2.ZERO,
        c2: exports.Fp2.ZERO
    },
    create: function(num) {
        return num;
    },
    isValid: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return exports.Fp2.isValid(c0) && exports.Fp2.isValid(c1) && exports.Fp2.isValid(c2);
    },
    is0: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return exports.Fp2.is0(c0) && exports.Fp2.is0(c1) && exports.Fp2.is0(c2);
    },
    neg: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.neg(c0),
            c1: exports.Fp2.neg(c1),
            c2: exports.Fp2.neg(c2)
        };
    },
    eql: function(_a, _b) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var r0 = _b.c0, r1 = _b.c1, r2 = _b.c2;
        return exports.Fp2.eql(c0, r0) && exports.Fp2.eql(c1, r1) && exports.Fp2.eql(c2, r2);
    },
    sqrt: function() {
        throw new Error('Not implemented');
    },
    // Do we need division by bigint at all? Should be done via order:
    div: function(lhs, rhs) {
        return Fp6.mul(lhs, typeof rhs === 'bigint' ? exports.Fp.inv(exports.Fp.create(rhs)) : Fp6.inv(rhs));
    },
    pow: function(num, power) {
        return mod.FpPow(Fp6, num, power);
    },
    invertBatch: function(nums) {
        return mod.FpInvertBatch(Fp6, nums);
    },
    // Normalized
    add: Fp6Add,
    sub: Fp6Subtract,
    mul: Fp6Multiply,
    sqr: Fp6Square,
    // NonNormalized stuff
    addN: Fp6Add,
    subN: Fp6Subtract,
    mulN: Fp6Multiply,
    sqrN: Fp6Square,
    inv: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var t0 = exports.Fp2.sub(exports.Fp2.sqr(c0), exports.Fp2.mulByNonresidue(exports.Fp2.mul(c2, c1))); // c0 - c2 * c1 * (u + 1)
        var t1 = exports.Fp2.sub(exports.Fp2.mulByNonresidue(exports.Fp2.sqr(c2)), exports.Fp2.mul(c0, c1)); // c2 * (u + 1) - c0 * c1
        var t2 = exports.Fp2.sub(exports.Fp2.sqr(c1), exports.Fp2.mul(c0, c2)); // c1 - c0 * c2
        // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)
        var t4 = exports.Fp2.inv(exports.Fp2.add(exports.Fp2.mulByNonresidue(exports.Fp2.add(exports.Fp2.mul(c2, t1), exports.Fp2.mul(c1, t2))), exports.Fp2.mul(c0, t0)));
        return {
            c0: exports.Fp2.mul(t4, t0),
            c1: exports.Fp2.mul(t4, t1),
            c2: exports.Fp2.mul(t4, t2)
        };
    },
    // Bytes utils
    fromBytes: function(b) {
        if (b.length !== Fp6.BYTES) throw new Error("fromBytes wrong length=".concat(b.length));
        return {
            c0: exports.Fp2.fromBytes(b.subarray(0, exports.Fp2.BYTES)),
            c1: exports.Fp2.fromBytes(b.subarray(exports.Fp2.BYTES, 2 * exports.Fp2.BYTES)),
            c2: exports.Fp2.fromBytes(b.subarray(2 * exports.Fp2.BYTES))
        };
    },
    toBytes: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return (0, utils_1.concatBytes)(exports.Fp2.toBytes(c0), exports.Fp2.toBytes(c1), exports.Fp2.toBytes(c2));
    },
    cmov: function(_a, _b, c) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var r0 = _b.c0, r1 = _b.c1, r2 = _b.c2;
        return {
            c0: exports.Fp2.cmov(c0, r0, c),
            c1: exports.Fp2.cmov(c1, r1, c),
            c2: exports.Fp2.cmov(c2, r2, c)
        };
    },
    // Utils
    //   fromTriple(triple: [Fp2, Fp2, Fp2]) {
    //     return new Fp6(...triple);
    //   }
    //   toString() {
    //     return `Fp6(${this.c0} + ${this.c1} * v, ${this.c2} * v^2)`;
    //   }
    fromBigSix: function(t) {
        if (!Array.isArray(t) || t.length !== 6) throw new Error('Invalid Fp6 usage');
        return {
            c0: exports.Fp2.fromBigTuple(t.slice(0, 2)),
            c1: exports.Fp2.fromBigTuple(t.slice(2, 4)),
            c2: exports.Fp2.fromBigTuple(t.slice(4, 6))
        };
    },
    frobeniusMap: function(_a, power) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.frobeniusMap(c0, power),
            c1: exports.Fp2.mul(exports.Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),
            c2: exports.Fp2.mul(exports.Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6])
        };
    },
    mulByNonresidue: function(_a) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.mulByNonresidue(c2),
            c1: c0,
            c2: c1
        };
    },
    // Sparse multiplication
    multiplyBy1: function(_a, b1) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.mulByNonresidue(exports.Fp2.mul(c2, b1)),
            c1: exports.Fp2.mul(c0, b1),
            c2: exports.Fp2.mul(c1, b1)
        };
    },
    // Sparse multiplication
    multiplyBy01: function(_a, b0, b1) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var t0 = exports.Fp2.mul(c0, b0); // c0 * b0
        var t1 = exports.Fp2.mul(c1, b1); // c1 * b1
        return {
            // ((c1 + c2) * b1 - T1) * (u + 1) + T0
            c0: exports.Fp2.add(exports.Fp2.mulByNonresidue(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(c1, c2), b1), t1)), t0),
            // (b0 + b1) * (c0 + c1) - T0 - T1
            c1: exports.Fp2.sub(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(b0, b1), exports.Fp2.add(c0, c1)), t0), t1),
            // (c0 + c2) * b0 - T0 + T1
            c2: exports.Fp2.add(exports.Fp2.sub(exports.Fp2.mul(exports.Fp2.add(c0, c2), b0), t0), t1)
        };
    },
    multiplyByFp2: function(_a, rhs) {
        var c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        return {
            c0: exports.Fp2.mul(c0, rhs),
            c1: exports.Fp2.mul(c1, rhs),
            c2: exports.Fp2.mul(c2, rhs)
        };
    }
};
var FP6_FROBENIUS_COEFFICIENTS_1 = [
    [
        BigInt('0x1'),
        BigInt('0x0')
    ],
    [
        BigInt('0x0'),
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),
        BigInt('0x0')
    ],
    [
        BigInt('0x0'),
        BigInt('0x1')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),
        BigInt('0x0')
    ],
    [
        BigInt('0x0'),
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe')
    ]
].map(function(pair) {
    return exports.Fp2.fromBigTuple(pair);
});
var FP6_FROBENIUS_COEFFICIENTS_2 = [
    [
        BigInt('0x1'),
        BigInt('0x0')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'),
        BigInt('0x0')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),
        BigInt('0x0')
    ],
    [
        BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),
        BigInt('0x0')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),
        BigInt('0x0')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'),
        BigInt('0x0')
    ]
].map(function(pair) {
    return exports.Fp2.fromBigTuple(pair);
});
// The BLS parameter x for BLS12-381
var BLS_X = BigInt('0xd201000000010000');
var BLS_X_LEN = (0, utils_1.bitLen)(BLS_X);
var Fp12Add = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return {
        c0: Fp6.add(c0, r0),
        c1: Fp6.add(c1, r1)
    };
};
var Fp12Subtract = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return {
        c0: Fp6.sub(c0, r0),
        c1: Fp6.sub(c1, r1)
    };
};
var Fp12Multiply = function(_a, rhs) {
    var c0 = _a.c0, c1 = _a.c1;
    if (typeof rhs === 'bigint') return {
        c0: Fp6.mul(c0, rhs),
        c1: Fp6.mul(c1, rhs)
    };
    var r0 = rhs.c0, r1 = rhs.c1;
    var t1 = Fp6.mul(c0, r0); // c0 * r0
    var t2 = Fp6.mul(c1, r1); // c1 * r1
    return {
        c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)),
        // (c0 + c1) * (r0 + r1) - (T1 + T2)
        c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2))
    };
};
exports.Fp12Multiply = Fp12Multiply;
var Fp12Square = function(_a) {
    var c0 = _a.c0, c1 = _a.c1;
    var ab = Fp6.mul(c0, c1); // c0 * c1
    return {
        // (c1 * v + c0) * (c0 + c1) - AB - AB * v
        c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),
        c1: Fp6.add(ab, ab)
    }; // AB + AB
};
function Fp4Square(a, b) {
    var a2 = exports.Fp2.sqr(a);
    var b2 = exports.Fp2.sqr(b);
    return {
        first: exports.Fp2.add(exports.Fp2.mulByNonresidue(b2), a2),
        second: exports.Fp2.sub(exports.Fp2.sub(exports.Fp2.sqr(exports.Fp2.add(a, b)), a2), b2)
    };
}
var Fp12_finalExponentiate = function(num) {
    var x = BLS_X;
    // this^(q) / this
    var t0 = exports.Fp12.div(exports.Fp12.frobeniusMap(num, 6), num);
    // t0^(q) * t0
    var t1 = exports.Fp12.mul(exports.Fp12.frobeniusMap(t0, 2), t0);
    var t2 = exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t1, x));
    var t3 = exports.Fp12.mul(exports.Fp12.conjugate(exports.Fp12._cyclotomicSquare(t1)), t2);
    var t4 = exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t3, x));
    var t5 = exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t4, x));
    var t6 = exports.Fp12.mul(exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t5, x)), exports.Fp12._cyclotomicSquare(t2));
    var t7 = exports.Fp12.conjugate(exports.Fp12._cyclotomicExp(t6, x));
    var t2_t5_pow_q2 = exports.Fp12.frobeniusMap(exports.Fp12.mul(t2, t5), 2);
    var t4_t1_pow_q3 = exports.Fp12.frobeniusMap(exports.Fp12.mul(t4, t1), 3);
    var t6_t1c_pow_q1 = exports.Fp12.frobeniusMap(exports.Fp12.mul(t6, exports.Fp12.conjugate(t1)), 1);
    var t7_t3c_t1 = exports.Fp12.mul(exports.Fp12.mul(t7, exports.Fp12.conjugate(t3)), t1);
    // (t2 * t5)^(q) * (t4 * t1)^(q) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1
    return exports.Fp12.mul(exports.Fp12.mul(exports.Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);
};
exports.Fp12_finalExponentiate = Fp12_finalExponentiate;
var Fp12_conjugate = function(_a) {
    var c0 = _a.c0, c1 = _a.c1;
    return {
        c0: c0,
        c1: Fp6.neg(c1)
    };
};
exports.Fp12_conjugate = Fp12_conjugate;
var Fp12_eql = function(_a, _b) {
    var c0 = _a.c0, c1 = _a.c1;
    var r0 = _b.c0, r1 = _b.c1;
    return Fp6.eql(c0, r0) && Fp6.eql(c1, r1);
};
exports.Fp12_eql = Fp12_eql;
exports.Fp12_ONE = {
    c0: Fp6.ONE,
    c1: Fp6.ZERO
};
exports.Fp12 = {
    ORDER: exports.Fp2.ORDER,
    BITS: 2 * exports.Fp2.BITS,
    BYTES: 2 * exports.Fp2.BYTES,
    MASK: (0, utils_1.bitMask)(2 * exports.Fp2.BITS),
    ZERO: {
        c0: Fp6.ZERO,
        c1: Fp6.ZERO
    },
    ONE: {
        c0: Fp6.ONE,
        c1: Fp6.ZERO
    },
    create: function(num) {
        return num;
    },
    isValid: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return Fp6.isValid(c0) && Fp6.isValid(c1);
    },
    is0: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return Fp6.is0(c0) && Fp6.is0(c1);
    },
    neg: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: Fp6.neg(c0),
            c1: Fp6.neg(c1)
        };
    },
    eql: exports.Fp12_eql,
    sqrt: function() {
        throw new Error('Not implemented');
    },
    inv: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        var t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0 - c1 * v)
        return {
            c0: Fp6.mul(c0, t),
            c1: Fp6.neg(Fp6.mul(c1, t))
        }; // ((C0 * T) * T) + (-C1 * T) * w
    },
    div: function(lhs, rhs) {
        return exports.Fp12.mul(lhs, typeof rhs === 'bigint' ? exports.Fp.inv(exports.Fp.create(rhs)) : exports.Fp12.inv(rhs));
    },
    pow: function(num, power) {
        return mod.FpPow(exports.Fp12, num, power);
    },
    invertBatch: function(nums) {
        return mod.FpInvertBatch(exports.Fp12, nums);
    },
    // Normalized
    add: Fp12Add,
    sub: Fp12Subtract,
    mul: exports.Fp12Multiply,
    sqr: Fp12Square,
    // NonNormalized stuff
    addN: Fp12Add,
    subN: Fp12Subtract,
    mulN: exports.Fp12Multiply,
    sqrN: Fp12Square,
    // Bytes utils
    fromBytes: function(b) {
        if (b.length !== exports.Fp12.BYTES) throw new Error("fromBytes wrong length=".concat(b.length));
        return {
            c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),
            c1: Fp6.fromBytes(b.subarray(Fp6.BYTES))
        };
    },
    toBytes: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        return (0, utils_1.concatBytes)(Fp6.toBytes(c0), Fp6.toBytes(c1));
    },
    cmov: function(_a, _b, c) {
        var c0 = _a.c0, c1 = _a.c1;
        var r0 = _b.c0, r1 = _b.c1;
        return {
            c0: Fp6.cmov(c0, r0, c),
            c1: Fp6.cmov(c1, r1, c)
        };
    },
    // Utils
    // toString() {
    //   return `Fp12(${this.c0} + ${this.c1} * w)`;
    // },
    // fromTuple(c: [Fp6, Fp6]) {
    //   return new Fp12(...c);
    // }
    fromBigTwelve: function(t) {
        return {
            c0: Fp6.fromBigSix(t.slice(0, 6)),
            c1: Fp6.fromBigSix(t.slice(6, 12))
        };
    },
    // Raises to q**i -th power
    frobeniusMap: function(lhs, power) {
        var r0 = Fp6.frobeniusMap(lhs.c0, power);
        var _a = Fp6.frobeniusMap(lhs.c1, power), c0 = _a.c0, c1 = _a.c1, c2 = _a.c2;
        var coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];
        return {
            c0: r0,
            c1: Fp6.create({
                c0: exports.Fp2.mul(c0, coeff),
                c1: exports.Fp2.mul(c1, coeff),
                c2: exports.Fp2.mul(c2, coeff)
            })
        };
    },
    // Sparse multiplication
    multiplyBy014: function(_a, o0, o1, o4) {
        var c0 = _a.c0, c1 = _a.c1;
        var t0 = Fp6.multiplyBy01(c0, o0, o1);
        var t1 = Fp6.multiplyBy1(c1, o4);
        return {
            c0: Fp6.add(Fp6.mulByNonresidue(t1), t0),
            // (c1 + c0) * [o0, o1+o4] - T0 - T1
            c1: Fp6.sub(Fp6.sub(Fp6.multiplyBy01(Fp6.add(c1, c0), o0, exports.Fp2.add(o1, o4)), t0), t1)
        };
    },
    multiplyByFp2: function(_a, rhs) {
        var c0 = _a.c0, c1 = _a.c1;
        return {
            c0: Fp6.multiplyByFp2(c0, rhs),
            c1: Fp6.multiplyByFp2(c1, rhs)
        };
    },
    conjugate: exports.Fp12_conjugate,
    // A cyclotomic group is a subgroup of Fp^n defined by
    //   G(p) = {  Fp : ^(p) = 1}
    // The result of any pairing is in a cyclotomic subgroup
    // https://eprint.iacr.org/2009/565.pdf
    _cyclotomicSquare: function(_a) {
        var c0 = _a.c0, c1 = _a.c1;
        var c0c0 = c0.c0, c0c1 = c0.c1, c0c2 = c0.c2;
        var c1c0 = c1.c0, c1c1 = c1.c1, c1c2 = c1.c2;
        var _b = Fp4Square(c0c0, c1c1), t3 = _b.first, t4 = _b.second;
        var _d = Fp4Square(c1c0, c0c2), t5 = _d.first, t6 = _d.second;
        var _e = Fp4Square(c0c1, c1c2), t7 = _e.first, t8 = _e.second;
        var t9 = exports.Fp2.mulByNonresidue(t8); // T8 * (u + 1)
        return {
            c0: Fp6.create({
                c0: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.sub(t3, c0c0), _2n), t3),
                c1: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.sub(t5, c0c1), _2n), t5),
                c2: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.sub(t7, c0c2), _2n), t7)
            }),
            c1: Fp6.create({
                c0: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.add(t9, c1c0), _2n), t9),
                c1: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.add(t4, c1c1), _2n), t4),
                c2: exports.Fp2.add(exports.Fp2.mul(exports.Fp2.add(t6, c1c2), _2n), t6)
            })
        }; // 2 * (T6 + c1c2) + T6
    },
    _cyclotomicExp: function(num, n) {
        var z = exports.Fp12.ONE;
        for(var i = BLS_X_LEN - 1; i >= 0; i--){
            z = exports.Fp12._cyclotomicSquare(z);
            if ((0, utils_1.bitGet)(n, i)) z = exports.Fp12.mul(z, num);
        }
        return z;
    },
    // https://eprint.iacr.org/2010/354.pdf
    // https://eprint.iacr.org/2009/565.pdf
    finalExponentiate: exports.Fp12_finalExponentiate
};
var FP12_FROBENIUS_COEFFICIENTS = [
    [
        BigInt('0x1'),
        BigInt('0x0')
    ],
    [
        BigInt('0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8'),
        BigInt('0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'),
        BigInt('0x0')
    ],
    [
        BigInt('0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2'),
        BigInt('0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09')
    ],
    [
        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),
        BigInt('0x0')
    ],
    [
        BigInt('0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995'),
        BigInt('0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116')
    ],
    [
        BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),
        BigInt('0x0')
    ],
    [
        BigInt('0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3'),
        BigInt('0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),
        BigInt('0x0')
    ],
    [
        BigInt('0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09'),
        BigInt('0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2')
    ],
    [
        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'),
        BigInt('0x0')
    ],
    [
        BigInt('0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116'),
        BigInt('0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995')
    ]
].map(function(n) {
    return exports.Fp2.fromBigTuple(n);
});
// END OF CURVE FIELDS
// HashToCurve
// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3
var isogenyMapG2 = (0, hash_to_curve_1.isogenyMap)(exports.Fp2, [
    // xNum
    [
        [
            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',
            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6'
        ],
        [
            '0x0',
            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a'
        ],
        [
            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',
            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d'
        ],
        [
            '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',
            '0x0'
        ]
    ],
    // xDen
    [
        [
            '0x0',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63'
        ],
        [
            '0xc',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f'
        ],
        [
            '0x1',
            '0x0'
        ]
    ],
    // yNum
    [
        [
            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',
            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706'
        ],
        [
            '0x0',
            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be'
        ],
        [
            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',
            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f'
        ],
        [
            '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',
            '0x0'
        ]
    ],
    // yDen
    [
        [
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb'
        ],
        [
            '0x0',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3'
        ],
        [
            '0x12',
            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99'
        ],
        [
            '0x1',
            '0x0'
        ]
    ]
].map(function(i) {
    return i.map(function(pair) {
        return exports.Fp2.fromBigTuple(pair.map(BigInt));
    });
}));
// 11-isogeny map from E' to E
var isogenyMapG1 = (0, hash_to_curve_1.isogenyMap)(exports.Fp, [
    // xNum
    [
        '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',
        '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',
        '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',
        '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',
        '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',
        '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',
        '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',
        '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',
        '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',
        '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',
        '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',
        '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229'
    ],
    // xDen
    [
        '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',
        '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',
        '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',
        '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',
        '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',
        '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',
        '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',
        '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',
        '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',
        '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',
        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001'
    ],
    // yNum
    [
        '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',
        '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',
        '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',
        '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',
        '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',
        '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',
        '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',
        '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',
        '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',
        '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',
        '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',
        '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',
        '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',
        '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',
        '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',
        '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604'
    ],
    // yDen
    [
        '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',
        '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',
        '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',
        '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',
        '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',
        '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',
        '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',
        '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',
        '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',
        '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',
        '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',
        '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',
        '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',
        '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',
        '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',
        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001'
    ]
].map(function(i) {
    return i.map(function(j) {
        return BigInt(j);
    });
}));
// SWU Map - Fp2 to G2': y = x + 240i * x + 1012 + 1012i
var G2_SWU = (0, weierstrass_1.mapToCurveSimpleSWU)(exports.Fp2, {
    A: exports.Fp2.create({
        c0: exports.Fp.create(_0n),
        c1: exports.Fp.create(BigInt(240))
    }),
    B: exports.Fp2.create({
        c0: exports.Fp.create(BigInt(1012)),
        c1: exports.Fp.create(BigInt(1012))
    }),
    Z: exports.Fp2.create({
        c0: exports.Fp.create(BigInt(-2)),
        c1: exports.Fp.create(BigInt(-1))
    })
});
// Optimized SWU Map - Fp to G1
var G1_SWU = (0, weierstrass_1.mapToCurveSimpleSWU)(exports.Fp, {
    A: exports.Fp.create(BigInt('0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d')),
    B: exports.Fp.create(BigInt('0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0')),
    Z: exports.Fp.create(BigInt(11))
});
// Endomorphisms (for fast cofactor clearing)
// (P) endomorphism
var ut_root = Fp6.create({
    c0: exports.Fp2.ZERO,
    c1: exports.Fp2.ONE,
    c2: exports.Fp2.ZERO
});
var wsq = exports.Fp12.create({
    c0: ut_root,
    c1: Fp6.ZERO
});
var wcu = exports.Fp12.create({
    c0: Fp6.ZERO,
    c1: ut_root
});
var _a = __read(exports.Fp12.invertBatch([
    wsq,
    wcu
]), 2), wsq_inv = _a[0], wcu_inv = _a[1];
function psi(x, y) {
    // Untwist Fp2->Fp12 && frobenius(1) && twist back
    var x2 = exports.Fp12.mul(exports.Fp12.frobeniusMap(exports.Fp12.multiplyByFp2(wsq_inv, x), 1), wsq).c0.c0;
    var y2 = exports.Fp12.mul(exports.Fp12.frobeniusMap(exports.Fp12.multiplyByFp2(wcu_inv, y), 1), wcu).c0.c0;
    return [
        x2,
        y2
    ];
}
//  endomorphism
function G2psi(c, P) {
    var affine = P.toAffine();
    var p = psi(affine.x, affine.y);
    return new c(p[0], p[1], exports.Fp2.ONE);
}
// (P) endomorphism
// 1 / F2(2)^((p-1)/3) in GF(p)
var PSI2_C1 = BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac');
function psi2(x, y) {
    return [
        exports.Fp2.mul(x, PSI2_C1),
        exports.Fp2.neg(y)
    ];
}
function G2psi2(c, P) {
    var affine = P.toAffine();
    var p = psi2(affine.x, affine.y);
    return new c(p[0], p[1], exports.Fp2.ONE);
}
// Default hash_to_field options are for hash to G2.
//
// Parameter definitions are in section 5.3 of the spec unless otherwise noted.
// Parameter values come from section 8.8.2 of the spec.
// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2
//
// Base field F is GF(p^m)
// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
// m = 2 (or 1 for G1 see section 8.8.1)
// k = 128
var htfDefaults = Object.freeze({
    // DST: a domain separation tag
    // defined in section 2.2.5
    // Use utils.getDSTLabel(), utils.setDSTLabel(value)
    DST: "",
    encodeDST: "",
    // p: the characteristic of F
    //    where F is a finite field of characteristic p and order q = p^m
    p: exports.Fp.ORDER,
    // m: the extension degree of F, m >= 1
    //     where F is a finite field of characteristic p and order q = p^m
    m: 2,
    // k: the target security level for the suite in bits
    // defined in section 5.1
    k: 128,
    // option to use a message that has already been processed by
    // expand_message_xmd
    expand: 'xmd',
    // Hash functions for: expand_message_xmd is appropriate for use with a
    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.
    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247
    hash: sha256_1.sha256
});
// Encoding utils
// Point on G1 curve: (x, y)
// Compressed point of infinity
var COMPRESSED_ZERO = setMask(exports.Fp.toBytes(_0n), {
    infinity: true,
    compressed: true
}); // set compressed & point-at-infinity bits
function parseMask(bytes) {
    // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.
    bytes = bytes.slice();
    var mask = bytes[0] & 224;
    var compressed = !!(mask >> 7 & 1); // compression bit (0b1000_0000)
    var infinity = !!(mask >> 6 & 1); // point at infinity bit (0b0100_0000)
    var sort = !!(mask >> 5 & 1); // sort bit (0b0010_0000)
    bytes[0] &= 31; // clear mask (zero first 3 bits)
    return {
        compressed: compressed,
        infinity: infinity,
        sort: sort,
        value: bytes
    };
}
exports.parseMask = parseMask;
function setMask(bytes, mask) {
    if (bytes[0] & 224) throw new Error('setMask: non-empty mask');
    if (mask.compressed) bytes[0] |= 128;
    if (mask.infinity) bytes[0] |= 64;
    if (mask.sort) bytes[0] |= 32;
    return bytes;
}
function signatureG1ToRawBytes(point) {
    point.assertValidity();
    var isZero = point.equals(exports.bls12_381.G1.ProjectivePoint.ZERO);
    var _a = point.toAffine(), x = _a.x, y = _a.y;
    if (isZero) return COMPRESSED_ZERO.slice();
    var P = exports.Fp.ORDER;
    var sort = Boolean(y * _2n / P);
    return setMask((0, utils_1.numberToBytesBE)(x, exports.Fp.BYTES), {
        compressed: true,
        sort: sort
    });
}
function signatureG2ToRawBytes(point) {
    // NOTE: by some reasons it was missed in bls12-381, looks like bug
    point.assertValidity();
    var len = exports.Fp.BYTES;
    if (point.equals(exports.bls12_381.G2.ProjectivePoint.ZERO)) return (0, utils_1.concatBytes)(COMPRESSED_ZERO, (0, utils_1.numberToBytesBE)(_0n, len));
    var _a = point.toAffine(), x = _a.x, y = _a.y;
    var _b = exports.Fp2.reim(x), x0 = _b.re, x1 = _b.im;
    var _d = exports.Fp2.reim(y), y0 = _d.re, y1 = _d.im;
    var tmp = y1 > _0n ? y1 * _2n : y0 * _2n;
    var sort = Boolean(tmp / exports.Fp.ORDER & _1n);
    var z2 = x0;
    return (0, utils_1.concatBytes)(setMask((0, utils_1.numberToBytesBE)(x1, len), {
        sort: sort,
        compressed: true
    }), (0, utils_1.numberToBytesBE)(z2, len));
}
var G1_formBytes = function(bytes) {
    var _a = parseMask(bytes), compressed = _a.compressed, infinity = _a.infinity, sort = _a.sort, value = _a.value;
    if (value.length === 48 && compressed) {
        // TODO: Fp.bytes
        var P = exports.Fp.ORDER;
        var compressedValue = (0, utils_1.bytesToNumberBE)(value);
        // Zero
        var x = exports.Fp.create(compressedValue & exports.Fp.MASK);
        if (infinity) {
            if (x !== _0n) throw new Error('G1: non-empty compressed point at infinity');
            return {
                x: _0n,
                y: _0n
            };
        }
        var right = exports.Fp.add(exports.Fp.pow(x, _3n), exports.Fp.create(exports.bls12_381.params.G1b)); // y = x + b
        var y = exports.Fp.sqrt(right);
        if (!y) throw new Error('Invalid compressed G1 point');
        if (y * _2n / P !== BigInt(sort)) y = exports.Fp.neg(y);
        return {
            x: exports.Fp.create(x),
            y: exports.Fp.create(y)
        };
    } else if (value.length === 96 && !compressed) {
        // Check if the infinity flag is set
        var x = (0, utils_1.bytesToNumberBE)(value.subarray(0, exports.Fp.BYTES));
        var y = (0, utils_1.bytesToNumberBE)(value.subarray(exports.Fp.BYTES));
        if (infinity) {
            if (x !== _0n || y !== _0n) throw new Error('G1: non-empty point at infinity');
            return exports.bls12_381.G1.ProjectivePoint.ZERO.toAffine();
        }
        return {
            x: exports.Fp.create(x),
            y: exports.Fp.create(y)
        };
    } else {
        throw new Error('Invalid point G1, expected 48/96 bytes');
    }
};
exports.G1_formBytes = G1_formBytes;
var G1_mapToCurve = function(scalars) {
    var _a = G1_SWU(exports.Fp.create(scalars[0])), x = _a.x, y = _a.y;
    return isogenyMapG1(x, y);
};
exports.G1_mapToCurve = G1_mapToCurve;
var G2_mapToCurve = function(scalars) {
    var _a = G2_SWU(exports.Fp2.fromBigTuple(scalars)), x = _a.x, y = _a.y;
    return isogenyMapG2(x, y);
};
exports.G2_mapToCurve = G2_mapToCurve;
// To verify curve parameters, see pairing-friendly-curves spec:
// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11
// Basic math is done over finite fields over p.
// More complicated math is done over polynominal extension fields.
// To simplify calculations in Fp12, we construct extension tower:
// Fp = Fp => Fp
// Fp(u) / (u - ) where  = -1
// Fp(v) / (v - ) where  = u + 1
// Fp(w) / (w - ) where  = v
// Here goes constants && point encoding format
exports.bls12_381 = (0, bls_1.bls)({
    // Fields
    fields: {
        Fp: exports.Fp,
        Fp2: exports.Fp2,
        Fp6: Fp6,
        Fp12: exports.Fp12,
        Fr: Fr
    },
    // G1 is the order-q subgroup of E1(Fp) : y = x + 4, #E1(Fp) = h1q, where
    // characteristic; z + (z - z + 1)(z - 1)/3
    G1: {
        Fp: exports.Fp,
        // cofactor; (z - 1)/3
        h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),
        // generator's coordinates
        // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507
        // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569
        Gx: BigInt('0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'),
        Gy: BigInt('0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'),
        a: exports.Fp.ZERO,
        b: _4n,
        htfDefaults: __assign(__assign({}, htfDefaults), {
            m: 1,
            DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_'
        }),
        wrapPrivateKey: true,
        allowInfinityPoint: true,
        // Checks is the point resides in prime-order subgroup.
        // point.isTorsionFree() should return true for valid points
        // It returns false for shitty points.
        // https://eprint.iacr.org/2021/1130.pdf
        isTorsionFree: function(c, point) {
            //  endomorphism
            var cubicRootOfUnityModP = BigInt('0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe');
            var phi = new c(exports.Fp.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);
            // todo: unroll
            var xP = point.multiplyUnsafe(exports.bls12_381.params.x).negate(); // [x]P
            var u2P = xP.multiplyUnsafe(exports.bls12_381.params.x); // [u2]P
            return u2P.equals(phi);
        // https://eprint.iacr.org/2019/814.pdf
        // (z  1)/3
        // const c1 = BigInt('0x396c8c005555e1560000000055555555');
        // const P = this;
        // const S = P.sigma();
        // const Q = S.double();
        // const S2 = S.sigma();
        // // [(z  1)/3](2(P)  P  (P))  (P) = O
        // const left = Q.subtract(P).subtract(S2).multiplyUnsafe(c1);
        // const C = left.subtract(S2);
        // return C.isZero();
        },
        // Clear cofactor of G1
        // https://eprint.iacr.org/2019/403
        clearCofactor: function(_c, point) {
            // return this.multiplyUnsafe(CURVE.h);
            return point.multiplyUnsafe(exports.bls12_381.params.x).add(point); // x*P + P
        },
        mapToCurve: exports.G1_mapToCurve,
        fromBytes: exports.G1_formBytes,
        toBytes: function(c, point, isCompressed) {
            var isZero = point.equals(c.ZERO);
            var _a = point.toAffine(), x = _a.x, y = _a.y;
            if (isCompressed) {
                if (isZero) return COMPRESSED_ZERO.slice();
                var P = exports.Fp.ORDER;
                var sort = Boolean(y * _2n / P);
                return setMask((0, utils_1.numberToBytesBE)(x, exports.Fp.BYTES), {
                    compressed: true,
                    sort: sort
                });
            } else {
                if (isZero) {
                    // 2x PUBLIC_KEY_LENGTH
                    var x_2 = (0, utils_1.concatBytes)(new Uint8Array([
                        0x40
                    ]), new Uint8Array(2 * exports.Fp.BYTES - 1));
                    return x_2;
                } else {
                    return (0, utils_1.concatBytes)((0, utils_1.numberToBytesBE)(x, exports.Fp.BYTES), (0, utils_1.numberToBytesBE)(y, exports.Fp.BYTES));
                }
            }
        },
        ShortSignature: {
            fromHex: function(hex) {
                var _a = parseMask((0, utils_1.ensureBytes)('signatureHex', hex, 48)), infinity = _a.infinity, sort = _a.sort, value = _a.value;
                var P = exports.Fp.ORDER;
                var compressedValue = (0, utils_1.bytesToNumberBE)(value);
                // Zero
                if (infinity) return exports.bls12_381.G1.ProjectivePoint.ZERO;
                var x = exports.Fp.create(compressedValue & exports.Fp.MASK);
                var right = exports.Fp.add(exports.Fp.pow(x, _3n), exports.Fp.create(exports.bls12_381.params.G1b)); // y = x + b
                var y = exports.Fp.sqrt(right);
                if (!y) throw new Error('Invalid compressed G1 point');
                var aflag = BigInt(sort);
                if (y * _2n / P !== aflag) y = exports.Fp.neg(y);
                var point = exports.bls12_381.G1.ProjectivePoint.fromAffine({
                    x: x,
                    y: y
                });
                point.assertValidity();
                return point;
            },
            toRawBytes: function(point) {
                return signatureG1ToRawBytes(point);
            },
            toHex: function(point) {
                return (0, utils_1.bytesToHex)(signatureG1ToRawBytes(point));
            }
        }
    },
    // G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),
    // where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where
    // G - 1
    // h2q
    G2: {
        Fp: exports.Fp2,
        // cofactor
        h: BigInt('0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'),
        Gx: exports.Fp2.fromBigTuple([
            BigInt('0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'),
            BigInt('0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e')
        ]),
        // y =
        // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,
        // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905
        Gy: exports.Fp2.fromBigTuple([
            BigInt('0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'),
            BigInt('0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be')
        ]),
        a: exports.Fp2.ZERO,
        b: exports.Fp2.fromBigTuple([
            _4n,
            _4n
        ]),
        hEff: BigInt('0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'),
        htfDefaults: __assign({}, htfDefaults),
        wrapPrivateKey: true,
        allowInfinityPoint: true,
        mapToCurve: exports.G2_mapToCurve,
        // Checks is the point resides in prime-order subgroup.
        // point.isTorsionFree() should return true for valid points
        // It returns false for shitty points.
        // https://eprint.iacr.org/2021/1130.pdf
        isTorsionFree: function(c, P) {
            return P.multiplyUnsafe(exports.bls12_381.params.x).negate().equals(G2psi(c, P)); // (P) == [u](P)
        // Older version: https://eprint.iacr.org/2019/814.pdf
        // (P) => (P) => [z](P) where z = -x => [z](P) - (P) + P == O
        // return P.psi2().psi().mulNegX().subtract(psi2).add(P).isZero();
        },
        // Maps the point into the prime-order subgroup G2.
        // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11
        // https://eprint.iacr.org/2017/419.pdf
        // prettier-ignore
        clearCofactor: function(c, P) {
            var x = exports.bls12_381.params.x;
            var t1 = P.multiplyUnsafe(x).negate(); // [-x]P
            var t2 = G2psi(c, P); // (P)
            var t3 = P.double(); // 2P
            t3 = G2psi2(c, t3); // (2P)
            t3 = t3.subtract(t2); // (2P) - (P)
            t2 = t1.add(t2); // [-x]P + (P)
            t2 = t2.multiplyUnsafe(x).negate(); // [x]P - [x](P)
            t3 = t3.add(t2); // (2P) - (P) + [x]P - [x](P)
            t3 = t3.subtract(t1); // (2P) - (P) + [x]P - [x](P) + [x]P
            var Q = t3.subtract(P); // (2P) - (P) + [x]P - [x](P) + [x]P - 1P
            return Q; // [x-x-1]P + [x-1](P) + (2P)
        },
        fromBytes: function(bytes) {
            var _a = parseMask(bytes), compressed = _a.compressed, infinity = _a.infinity, sort = _a.sort, value = _a.value;
            if (!compressed && !infinity && sort || !compressed && infinity && sort || sort && infinity && compressed // 11100000
            ) {
                throw new Error('Invalid encoding flag: ' + (bytes[0] & 224));
            }
            var L = exports.Fp.BYTES;
            var slc = function(b, from, to) {
                return (0, utils_1.bytesToNumberBE)(b.slice(from, to));
            };
            if (value.length === 96 && compressed) {
                var b = exports.bls12_381.params.G2b;
                var P = exports.Fp.ORDER;
                if (infinity) {
                    // check that all bytes are 0
                    if (value.reduce(function(p, c) {
                        return p !== 0 ? c + 1 : c;
                    }, 0) > 0) {
                        throw new Error('Invalid compressed G2 point');
                    }
                    return {
                        x: exports.Fp2.ZERO,
                        y: exports.Fp2.ZERO
                    };
                }
                var x_1 = slc(value, 0, L);
                var x_0 = slc(value, L, 2 * L);
                var x = exports.Fp2.create({
                    c0: exports.Fp.create(x_0),
                    c1: exports.Fp.create(x_1)
                });
                var right = exports.Fp2.add(exports.Fp2.pow(x, _3n), b); // y = x + 4 * (u+1) = x + b
                var y = exports.Fp2.sqrt(right);
                var Y_bit = y.c1 === _0n ? y.c0 * _2n / P : y.c1 * _2n / P ? _1n : _0n;
                y = sort && Y_bit > 0 ? y : exports.Fp2.neg(y);
                return {
                    x: x,
                    y: y
                };
            } else if (value.length === 192 && !compressed) {
                if (infinity) {
                    if (value.reduce(function(p, c) {
                        return p !== 0 ? c + 1 : c;
                    }, 0) > 0) {
                        throw new Error('Invalid uncompressed G2 point');
                    }
                    return {
                        x: exports.Fp2.ZERO,
                        y: exports.Fp2.ZERO
                    };
                }
                var x1 = slc(value, 0, L);
                var x0 = slc(value, L, 2 * L);
                var y1 = slc(value, 2 * L, 3 * L);
                var y0 = slc(value, 3 * L, 4 * L);
                return {
                    x: exports.Fp2.fromBigTuple([
                        x0,
                        x1
                    ]),
                    y: exports.Fp2.fromBigTuple([
                        y0,
                        y1
                    ])
                };
            } else {
                throw new Error('Invalid point G2, expected 96/192 bytes');
            }
        },
        toBytes: function(c, point, isCompressed) {
            var len = exports.Fp.BYTES, P = exports.Fp.ORDER;
            var isZero = point.equals(c.ZERO);
            var _a = point.toAffine(), x = _a.x, y = _a.y;
            if (isCompressed) {
                if (isZero) return (0, utils_1.concatBytes)(COMPRESSED_ZERO, (0, utils_1.numberToBytesBE)(_0n, len));
                var flag = Boolean(y.c1 === _0n ? y.c0 * _2n / P : y.c1 * _2n / P);
                return (0, utils_1.concatBytes)(setMask((0, utils_1.numberToBytesBE)(x.c1, len), {
                    compressed: true,
                    sort: flag
                }), (0, utils_1.numberToBytesBE)(x.c0, len));
            } else {
                if (isZero) return (0, utils_1.concatBytes)(new Uint8Array([
                    0x40
                ]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;
                var _b = exports.Fp2.reim(x), x0 = _b.re, x1 = _b.im;
                var _d = exports.Fp2.reim(y), y0 = _d.re, y1 = _d.im;
                return (0, utils_1.concatBytes)((0, utils_1.numberToBytesBE)(x1, len), (0, utils_1.numberToBytesBE)(x0, len), (0, utils_1.numberToBytesBE)(y1, len), (0, utils_1.numberToBytesBE)(y0, len));
            }
        },
        Signature: {
            // TODO: Optimize, it's very slow because of sqrt.
            fromHex: function(hex) {
                var _a = parseMask((0, utils_1.ensureBytes)('signatureHex', hex)), infinity = _a.infinity, sort = _a.sort, value = _a.value;
                var P = exports.Fp.ORDER;
                var half = hex.length / 2;
                if (half !== 48 && half !== 96) throw new Error('Invalid compressed signature length, must be 96 or 192');
                var z1 = (0, utils_1.bytesToNumberBE)(value.slice(0, half));
                var z2 = (0, utils_1.bytesToNumberBE)(value.slice(half));
                // Indicates the infinity point
                if (infinity) return exports.bls12_381.G2.ProjectivePoint.ZERO;
                var x1 = exports.Fp.create(z1 & exports.Fp.MASK);
                var x2 = exports.Fp.create(z2);
                var x = exports.Fp2.create({
                    c0: x2,
                    c1: x1
                });
                var y2 = exports.Fp2.add(exports.Fp2.pow(x, _3n), exports.bls12_381.params.G2b); // y = x + 4
                // The slow part
                var y = exports.Fp2.sqrt(y2);
                if (!y) throw new Error('Failed to find a square root');
                // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1
                // If y1 happens to be zero, then use the bit of y0
                var _b = exports.Fp2.reim(y), y0 = _b.re, y1 = _b.im;
                var aflag1 = BigInt(sort);
                var isGreater = y1 > _0n && y1 * _2n / P !== aflag1;
                var isZero = y1 === _0n && y0 * _2n / P !== aflag1;
                if (isGreater || isZero) y = exports.Fp2.neg(y);
                var point = exports.bls12_381.G2.ProjectivePoint.fromAffine({
                    x: x,
                    y: y
                });
                point.assertValidity();
                return point;
            },
            toRawBytes: function(point) {
                return signatureG2ToRawBytes(point);
            },
            toHex: function(point) {
                return (0, utils_1.bytesToHex)(signatureG2ToRawBytes(point));
            }
        }
    },
    params: {
        x: BLS_X,
        r: Fr.ORDER
    },
    htfDefaults: htfDefaults,
    hash: sha256_1.sha256,
    randomBytes: utils_2.randomBytes
});
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/keccak.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/bls12_381.js [app-client] (ecmascript)"), exports); // DO NOT export "./_u64";
 // DO NOT export "./utils";
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/bls12_318.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFp6 = exports.isBlsResult = exports.bls12_381_finalVerify = exports.bls12_381_eqMlResult = exports.bls12_381_mulMlResult = exports.bls12_381_millerLoop = exports.bls12_381_G2_uncompress = exports.bls12_381_G2_compress = exports.bls12_381_G2_hashToGroup = exports.bls12_381_G2_equal = exports.bls12_381_G2_scalarMul = exports.bls12_381_G2_neg = exports.bls12_381_G2_add = exports.bls12_381_G1_uncompress = exports.bls12_381_G1_compress = exports.bls12_381_G1_hashToGroup = exports.bls12_381_G1_equal = exports.bls12_381_G1_scalarMul = exports.bls12_381_G1_neg = exports.bls12_381_G1_add = exports.isFp2 = exports.isBlsG2 = exports.isBlsG1 = exports.BlsG2 = exports.BlsG1 = void 0;
var noble_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/index.js [app-client] (ecmascript)");
var hash_to_curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
var sha256_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/sha256.js [app-client] (ecmascript)");
exports.BlsG1 = noble_1.bls12_381.G1.ProjectivePoint;
exports.BlsG2 = noble_1.bls12_381.G2.ProjectivePoint;
function isBlsG1(stuff) {
    return stuff instanceof exports.BlsG1 && typeof stuff.px === "bigint" && typeof stuff.py === "bigint" && typeof stuff.pz === "bigint";
}
exports.isBlsG1 = isBlsG1;
function isBlsG2(stuff) {
    return stuff instanceof exports.BlsG2 && isFp2(stuff.px) && isFp2(stuff.py) && isFp2(stuff.pz);
}
exports.isBlsG2 = isBlsG2;
function isFp2(stuff) {
    return typeof stuff === "object" && stuff !== null && !Array.isArray(stuff) && typeof stuff.c0 === "bigint" && typeof stuff.c1 === "bigint";
}
exports.isFp2 = isFp2;
var curveOrder = BigInt("52435875175126190479447740508185965837690552500527637822603658699938581184513");
var htfDefaults = Object.freeze({
    // DST: a domain separation tag
    // defined in section 2.2.5
    // Use utils.getDSTLabel(), utils.setDSTLabel(value)
    DST: "",
    encodeDST: "",
    // p: the characteristic of F
    //    where F is a finite field of characteristic p and order q = p^m
    p: noble_1.Fp.ORDER,
    // m: the extension degree of F, m >= 1
    //     where F is a finite field of characteristic p and order q = p^m
    m: 2,
    // k: the target security level for the suite in bits
    // defined in section 5.1
    k: 128,
    // option to use a message that has already been processed by
    // expand_message_xmd
    expand: 'xmd',
    // Hash functions for: expand_message_xmd is appropriate for use with a
    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.
    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247
    hash: sha256_1.sha256
});
var G2_Hasher = (0, hash_to_curve_1.createHasher)(exports.BlsG2, noble_1.G2_mapToCurve, __assign({}, htfDefaults));
var G1_Hasher = (0, hash_to_curve_1.createHasher)(exports.BlsG1, noble_1.G1_mapToCurve, __assign(__assign({}, htfDefaults), {
    m: 1,
    DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_'
}));
function bls12_381_G1_add(a, b) {
    // if( bls12_381_G1_equal( a, BlsG1.ZERO ) ) return b;
    // if( bls12_381_G1_equal( b, BlsG1.ZERO ) ) return a;
    return a.add(b);
}
exports.bls12_381_G1_add = bls12_381_G1_add;
function bls12_381_G1_neg(elem) {
    return elem.negate();
}
exports.bls12_381_G1_neg = bls12_381_G1_neg;
function bls12_381_G1_scalarMul(n, g1) {
    if (n < 0) return bls12_381_G1_scalarMul(-n, bls12_381_G1_neg(g1));
    n = BigInt(n);
    if (n >= curveOrder) n = n % curveOrder;
    if (n === BigInt(0)) return exports.BlsG1.ZERO;
    return g1.multiply(n);
}
exports.bls12_381_G1_scalarMul = bls12_381_G1_scalarMul;
function bls12_381_G1_equal(a, b) {
    return a.equals(b);
}
exports.bls12_381_G1_equal = bls12_381_G1_equal;
function bls12_381_G1_hashToGroup(a, b) {
    // noble-curves can handle that but the plutus-machine doesn't
    // so we artificially throw an error here
    if (b.length > 255) throw new Error("DST length can not be greater than 255");
    return exports.BlsG1.fromAffine(G1_Hasher.hashToCurve(a, {
        DST: b
    }).toAffine());
}
exports.bls12_381_G1_hashToGroup = bls12_381_G1_hashToGroup;
function bls12_381_G1_compress(elem) {
    return elem.toRawBytes();
}
exports.bls12_381_G1_compress = bls12_381_G1_compress;
function bls12_381_G1_uncompress(compressed) {
    var _a = (0, noble_1.parseMask)(compressed), compressed_bit = _a.compressed, infinity = _a.infinity, sort = _a.sort, value = _a.value;
    // point zero edge case
    if (compressed_bit && infinity && sort && value.every(function(n) {
        return n === 0;
    })) throw new Error("sign bit set on pont ZERO, we don't like it");
    // not compressed bytes would be totally fine for the library but we artificially fail here
    // https://github.com/IntersectMBO/plutus/blob/master/plutus-conformance/test-cases/uplc/evaluation/builtin/semantics/bls12_381_G1_uncompress/on-curve-serialised-not-compressed/on-curve-serialised-not-compressed.uplc
    if (!compressed_bit) throw new Error("uncompress only works with compressed byets");
    return exports.BlsG1.fromHex(compressed);
}
exports.bls12_381_G1_uncompress = bls12_381_G1_uncompress;
function bls12_381_G2_add(a, b) {
    // if( bls12_381_G2_equal( a, BlsG2.ZERO ) ) return b;
    // if( bls12_381_G2_equal( b, BlsG2.ZERO ) ) return a;
    return a.add(b);
}
exports.bls12_381_G2_add = bls12_381_G2_add;
function bls12_381_G2_neg(elem) {
    return elem.negate();
}
exports.bls12_381_G2_neg = bls12_381_G2_neg;
function bls12_381_G2_scalarMul(n, g2) {
    if (n < 0) return bls12_381_G2_scalarMul(-n, bls12_381_G2_neg(g2));
    n = BigInt(n);
    if (n >= curveOrder) n = n % curveOrder;
    if (n === BigInt(0)) return exports.BlsG2.ZERO;
    return g2.multiply(BigInt(n));
}
exports.bls12_381_G2_scalarMul = bls12_381_G2_scalarMul;
function bls12_381_G2_equal(a, b) {
    return a.equals(b);
}
exports.bls12_381_G2_equal = bls12_381_G2_equal;
function bls12_381_G2_hashToGroup(a, b) {
    // noble-curves can handle that but the plutus-machine doesn't
    // so we artificially throw an error here
    if (b.length > 255) throw new Error("DST length can not be greater than 255");
    return exports.BlsG2.fromAffine(G2_Hasher.hashToCurve(a, {
        DST: b
    }).toAffine());
}
exports.bls12_381_G2_hashToGroup = bls12_381_G2_hashToGroup;
function bls12_381_G2_compress(elem) {
    return elem.toRawBytes();
}
exports.bls12_381_G2_compress = bls12_381_G2_compress;
function bls12_381_G2_uncompress(compressed) {
    var compressed_bit = (0, noble_1.parseMask)(compressed).compressed;
    // not compressed bytes would be totally fine for the library but we artificially fail here
    // https://github.com/IntersectMBO/plutus/blob/master/plutus-conformance/test-cases/uplc/evaluation/builtin/semantics/bls12_381_G2_uncompress/on-curve-serialised-not-compressed/on-curve-serialised-not-compressed.uplc
    if (!compressed_bit) throw new Error("uncompress only works with compressed byets");
    return exports.BlsG2.fromHex(compressed);
}
exports.bls12_381_G2_uncompress = bls12_381_G2_uncompress;
function bls12_381_millerLoop(g1, g2) {
    var _a = g1.toAffine(), x = _a.x, y = _a.y;
    return millerLoop(pairingPrecomputes(g2), [
        x,
        y
    ]);
}
exports.bls12_381_millerLoop = bls12_381_millerLoop;
function bls12_381_mulMlResult(a, b) {
    return (0, noble_1.Fp12Multiply)(a, b);
}
exports.bls12_381_mulMlResult = bls12_381_mulMlResult;
exports.bls12_381_eqMlResult = noble_1.Fp12_eql;
function bls12_381_finalVerify(a, b) {
    // blst implementation https://github.com/supranational/blst/blob/0d46eefa45fc1e57aceb42bba0e84eab3a7a9725/src/aggregate.c#L506
    var GT = (0, noble_1.Fp12_conjugate)(a);
    GT = (0, noble_1.Fp12Multiply)(GT, b);
    GT = (0, noble_1.Fp12_finalExponentiate)(GT);
    return (0, noble_1.Fp12_eql)(GT, noble_1.Fp12_ONE);
}
exports.bls12_381_finalVerify = bls12_381_finalVerify;
// The BLS parameter x for BLS12-381
var BLS_X = BigInt('0xd201000000010000');
var BLS_X_LEN = (0, utils_1.bitLen)(BLS_X);
var _2n = BigInt(2), _3n = BigInt(3);
// Pre-compute coefficients for sparse multiplication
// Point addition and point double calculations is reused for coefficients
function calcPairingPrecomputes(p) {
    var x = p.x, y = p.y;
    // prettier-ignore
    var Qx = x, Qy = y, Qz = noble_1.Fp2.ONE;
    // prettier-ignore
    var Rx = Qx, Ry = Qy, Rz = Qz;
    var ell_coeff = [];
    for(var i = BLS_X_LEN - 2; i >= 0; i--){
        // Double
        var t0 = noble_1.Fp2.sqr(Ry); // Ry
        var t1 = noble_1.Fp2.sqr(Rz); // Rz
        var t2 = noble_1.Fp2.multiplyByB(noble_1.Fp2.mul(t1, _3n)); // 3 * T1 * B
        var t3 = noble_1.Fp2.mul(t2, _3n); // 3 * T2
        var t4 = noble_1.Fp2.sub(noble_1.Fp2.sub(noble_1.Fp2.sqr(noble_1.Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz) - T1 - T0
        ell_coeff.push([
            noble_1.Fp2.sub(t2, t0),
            noble_1.Fp2.mul(noble_1.Fp2.sqr(Rx), _3n),
            noble_1.Fp2.neg(t4)
        ]);
        Rx = noble_1.Fp2.div(noble_1.Fp2.mul(noble_1.Fp2.mul(noble_1.Fp2.sub(t0, t3), Rx), Ry), _2n); // ((T0 - T3) * Rx * Ry) / 2
        Ry = noble_1.Fp2.sub(noble_1.Fp2.sqr(noble_1.Fp2.div(noble_1.Fp2.add(t0, t3), _2n)), noble_1.Fp2.mul(noble_1.Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2) - 3 * T2
        Rz = noble_1.Fp2.mul(t0, t4); // T0 * T4
        if ((0, utils_1.bitGet)(BLS_X /*CURVE.params.x*/ , i)) {
            // Addition
            var t0_1 = noble_1.Fp2.sub(Ry, noble_1.Fp2.mul(Qy, Rz)); // Ry - Qy * Rz
            var t1_1 = noble_1.Fp2.sub(Rx, noble_1.Fp2.mul(Qx, Rz)); // Rx - Qx * Rz
            ell_coeff.push([
                noble_1.Fp2.sub(noble_1.Fp2.mul(t0_1, Qx), noble_1.Fp2.mul(t1_1, Qy)),
                noble_1.Fp2.neg(t0_1),
                t1_1
            ]);
            var t2_1 = noble_1.Fp2.sqr(t1_1); // T1
            var t3_1 = noble_1.Fp2.mul(t2_1, t1_1); // T2 * T1
            var t4_1 = noble_1.Fp2.mul(t2_1, Rx); // T2 * Rx
            var t5 = noble_1.Fp2.add(noble_1.Fp2.sub(t3_1, noble_1.Fp2.mul(t4_1, _2n)), noble_1.Fp2.mul(noble_1.Fp2.sqr(t0_1), Rz)); // T3 - 2 * T4 + T0 * Rz
            Rx = noble_1.Fp2.mul(t1_1, t5); // T1 * T5
            Ry = noble_1.Fp2.sub(noble_1.Fp2.mul(noble_1.Fp2.sub(t4_1, t5), t0_1), noble_1.Fp2.mul(t3_1, Ry)); // (T4 - T5) * T0 - T3 * Ry
            Rz = noble_1.Fp2.mul(Rz, t3_1); // Rz * T3
        }
    }
    return ell_coeff;
}
function pairingPrecomputes(point) {
    var p = point;
    if (p._PPRECOMPUTES) return p._PPRECOMPUTES;
    p._PPRECOMPUTES = calcPairingPrecomputes(point.toAffine());
    return p._PPRECOMPUTES;
}
function millerLoop(ell, g1) {
    var x = BLS_X;
    var Px = g1[0];
    var Py = g1[1];
    var f12 = noble_1.Fp12.ONE;
    for(var j = 0, i = BLS_X_LEN - 2; i >= 0; i--, j++){
        var E = ell[j];
        f12 = noble_1.Fp12.multiplyBy014(f12, E[0], noble_1.Fp2.mul(E[1], Px), noble_1.Fp2.mul(E[2], Py));
        if ((0, utils_1.bitGet)(x, i)) {
            j += 1;
            var F = ell[j];
            f12 = noble_1.Fp12.multiplyBy014(f12, F[0], noble_1.Fp2.mul(F[1], Px), noble_1.Fp2.mul(F[2], Py));
        }
        if (i !== 0) f12 = noble_1.Fp12.sqr(f12);
    }
    return noble_1.Fp12.conjugate(f12);
}
function isBlsResult(stuff) {
    return typeof stuff === "object" && stuff !== null && !Array.isArray(stuff) && isFp6(stuff.c0) && isFp6(stuff.c1);
}
exports.isBlsResult = isBlsResult;
function isFp6(stuff) {
    return typeof stuff === "object" && stuff !== null && !Array.isArray(stuff) && isFp2(stuff.c0) && isFp2(stuff.c1) && isFp2(stuff.c2);
}
exports.isFp6 = isFp6;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/hasGlobalWebCrypto.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hasGlobalWebCrypto = void 0;
var hasGlobalThis = true;
try {
    hasGlobalThis = typeof globalThis !== "undefined";
} catch (_a) {
    hasGlobalThis = false;
}
var _hasGlobalWebCrypto = hasGlobalThis;
if (hasGlobalThis) {
    try {
        _hasGlobalWebCrypto = typeof globalThis.crypto !== "undefined" && typeof globalThis.crypto.subtle !== "undefined";
    } catch (_b) {
        _hasGlobalWebCrypto = false;
    }
}
exports.hasGlobalWebCrypto = _hasGlobalWebCrypto;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/sha512.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
var _md_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/_md.js [app-client] (ecmascript)");
var u64 = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/_u64.js [app-client] (ecmascript)"));
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
var _a = __read(/* @__PURE__ */ function() {
    return u64.split([
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
    ].map(function(n) {
        return BigInt(n);
    }));
}(), 2), SHA512_Kh = _a[0], SHA512_Kl = _a[1];
// Temporary buffer, not used to store anything between runs
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = function(_super) {
    __extends(SHA512, _super);
    function SHA512() {
        var _this = _super.call(this, 128, 64, 16, false) || this;
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        _this.Ah = 0x6a09e667 | 0;
        _this.Al = 0xf3bcc908 | 0;
        _this.Bh = 0xbb67ae85 | 0;
        _this.Bl = 0x84caa73b | 0;
        _this.Ch = 0x3c6ef372 | 0;
        _this.Cl = 0xfe94f82b | 0;
        _this.Dh = 0xa54ff53a | 0;
        _this.Dl = 0x5f1d36f1 | 0;
        _this.Eh = 0x510e527f | 0;
        _this.El = 0xade682d1 | 0;
        _this.Fh = 0x9b05688c | 0;
        _this.Fl = 0x2b3e6c1f | 0;
        _this.Gh = 0x1f83d9ab | 0;
        _this.Gl = 0xfb41bd6b | 0;
        _this.Hh = 0x5be0cd19 | 0;
        _this.Hl = 0x137e2179 | 0;
        return _this;
    }
    // prettier-ignore
    SHA512.prototype.get = function() {
        var _a = this, Ah = _a.Ah, Al = _a.Al, Bh = _a.Bh, Bl = _a.Bl, Ch = _a.Ch, Cl = _a.Cl, Dh = _a.Dh, Dl = _a.Dl, Eh = _a.Eh, El = _a.El, Fh = _a.Fh, Fl = _a.Fl, Gh = _a.Gh, Gl = _a.Gl, Hh = _a.Hh, Hl = _a.Hl;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    };
    // prettier-ignore
    SHA512.prototype.set = function(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    };
    SHA512.prototype.process = function(view, offset) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(var i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(var i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            var W15h = SHA512_W_H[i - 15] | 0;
            var W15l = SHA512_W_L[i - 15] | 0;
            var s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            var s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            var W2h = SHA512_W_H[i - 2] | 0;
            var W2l = SHA512_W_L[i - 2] | 0;
            var s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            var s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            var SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            var SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        var _k = this, Ah = _k.Ah, Al = _k.Al, Bh = _k.Bh, Bl = _k.Bl, Ch = _k.Ch, Cl = _k.Cl, Dh = _k.Dh, Dl = _k.Dl, Eh = _k.Eh, El = _k.El, Fh = _k.Fh, Fl = _k.Fl, Gh = _k.Gh, Gl = _k.Gl, Hh = _k.Hh, Hl = _k.Hl;
        // Compression function main loop, 80 rounds
        for(var i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            var sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            var sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            var CHIh = Eh & Fh ^ ~Eh & Gh;
            var CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            var T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            var T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            var T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            var sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            var sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            var MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            var MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            _a = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0), Eh = _a.h, El = _a.l;
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            var All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        _b = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0), Ah = _b.h, Al = _b.l;
        _c = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0), Bh = _c.h, Bl = _c.l;
        _d = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0), Ch = _d.h, Cl = _d.l;
        _e = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0), Dh = _e.h, Dl = _e.l;
        _f = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0), Eh = _f.h, El = _f.l;
        _g = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0), Fh = _g.h, Fl = _g.l;
        _h = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0), Gh = _h.h, Gl = _h.l;
        _j = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0), Hh = _j.h, Hl = _j.l;
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    };
    SHA512.prototype.roundClean = function() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    };
    SHA512.prototype.destroy = function() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    };
    return SHA512;
}(_md_1.HashMD);
exports.SHA512 = SHA512;
var SHA512_224 = function(_super) {
    __extends(SHA512_224, _super);
    function SHA512_224() {
        var _this = _super.call(this) || this;
        // h -- high 32 bits, l -- low 32 bits
        _this.Ah = 0x8c3d37c8 | 0;
        _this.Al = 0x19544da2 | 0;
        _this.Bh = 0x73e19966 | 0;
        _this.Bl = 0x89dcd4d6 | 0;
        _this.Ch = 0x1dfab7ae | 0;
        _this.Cl = 0x32ff9c82 | 0;
        _this.Dh = 0x679dd514 | 0;
        _this.Dl = 0x582f9fcf | 0;
        _this.Eh = 0x0f6d2b69 | 0;
        _this.El = 0x7bd44da8 | 0;
        _this.Fh = 0x77e36f73 | 0;
        _this.Fl = 0x04c48942 | 0;
        _this.Gh = 0x3f9d85a8 | 0;
        _this.Gl = 0x6a1d36c8 | 0;
        _this.Hh = 0x1112e6ad | 0;
        _this.Hl = 0x91d692a1 | 0;
        _this.outputLen = 28;
        return _this;
    }
    return SHA512_224;
}(SHA512);
var SHA512_256 = function(_super) {
    __extends(SHA512_256, _super);
    function SHA512_256() {
        var _this = _super.call(this) || this;
        // h -- high 32 bits, l -- low 32 bits
        _this.Ah = 0x22312194 | 0;
        _this.Al = 0xfc2bf72c | 0;
        _this.Bh = 0x9f555fa3 | 0;
        _this.Bl = 0xc84c64c2 | 0;
        _this.Ch = 0x2393b86b | 0;
        _this.Cl = 0x6f53b151 | 0;
        _this.Dh = 0x96387719 | 0;
        _this.Dl = 0x5940eabd | 0;
        _this.Eh = 0x96283ee2 | 0;
        _this.El = 0xa88effe3 | 0;
        _this.Fh = 0xbe5e1e25 | 0;
        _this.Fl = 0x53863992 | 0;
        _this.Gh = 0x2b0199fc | 0;
        _this.Gl = 0x2c85b8aa | 0;
        _this.Hh = 0x0eb72ddc | 0;
        _this.Hl = 0x81c52ca2 | 0;
        _this.outputLen = 32;
        return _this;
    }
    return SHA512_256;
}(SHA512);
var SHA384 = function(_super) {
    __extends(SHA384, _super);
    function SHA384() {
        var _this = _super.call(this) || this;
        // h -- high 32 bits, l -- low 32 bits
        _this.Ah = 0xcbbb9d5d | 0;
        _this.Al = 0xc1059ed8 | 0;
        _this.Bh = 0x629a292a | 0;
        _this.Bl = 0x367cd507 | 0;
        _this.Ch = 0x9159015a | 0;
        _this.Cl = 0x3070dd17 | 0;
        _this.Dh = 0x152fecd8 | 0;
        _this.Dl = 0xf70e5939 | 0;
        _this.Eh = 0x67332667 | 0;
        _this.El = 0xffc00b31 | 0;
        _this.Fh = 0x8eb44a87 | 0;
        _this.Fl = 0x68581511 | 0;
        _this.Gh = 0xdb0c2e0d | 0;
        _this.Gl = 0x64f98fa7 | 0;
        _this.Hh = 0x47b5481d | 0;
        _this.Hl = 0xbefa4fa4 | 0;
        _this.outputLen = 48;
        return _this;
    }
    return SHA384;
}(SHA512);
exports.sha512 = (0, utils_1.wrapConstructor)(function() {
    return new SHA512();
});
exports.sha512_224 = (0, utils_1.wrapConstructor)(function() {
    return new SHA512_224();
});
exports.sha512_256 = (0, utils_1.wrapConstructor)(function() {
    return new SHA512_256();
});
exports.sha384 = (0, utils_1.wrapConstructor)(function() {
    return new SHA384();
});
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha2_512 = exports.sha2_512_sync = void 0;
var hasGlobalWebCrypto_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/hasGlobalWebCrypto.js [app-client] (ecmascript)");
var sha512_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/sha512.js [app-client] (ecmascript)");
var __hasNativeSupport = hasGlobalWebCrypto_1.hasGlobalWebCrypto && typeof globalThis.crypto.subtle.digest === "function";
var NATIVE_ALGO = "SHA-512";
var digest = __hasNativeSupport ? globalThis.crypto.subtle.digest.bind(globalThis.crypto.subtle) : function() {
    return Promise.resolve(new ArrayBuffer(0));
};
function _test_nativeSha2_512(data) {
    return __awaiter(this, void 0, void 0, function() {
        var _a;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    _a = Uint8Array.bind;
                    return [
                        4 /*yield*/ ,
                        digest(NATIVE_ALGO, data)
                    ];
                case 1:
                    // await ensureNativeSupport();
                    // if( !__hasNativeSupport ) return sha2_512_sync( data );
                    return [
                        2 /*return*/ ,
                        new (_a.apply(Uint8Array, [
                            void 0,
                            _b.sent()
                        ]))()
                    ];
            }
        });
    });
}
function nativeSha2_512(data) {
    return __awaiter(this, void 0, void 0, function() {
        var _a;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        ensureNativeSupport()
                    ];
                case 1:
                    _b.sent();
                    if (!__hasNativeSupport) return [
                        2 /*return*/ ,
                        sha2_512_sync(data)
                    ];
                    _a = Uint8Array.bind;
                    return [
                        4 /*yield*/ ,
                        digest(NATIVE_ALGO, data)
                    ];
                case 2:
                    return [
                        2 /*return*/ ,
                        new (_a.apply(Uint8Array, [
                            void 0,
                            _b.sent()
                        ]))()
                    ];
            }
        });
    });
}
function _test(data, uint8ArrayEq) {
    return __awaiter(this, void 0, void 0, function() {
        var start, end, nativeResult, _a, nativeTime, result, jsTime, _b;
        return __generator(this, function(_c) {
            switch(_c.label){
                case 0:
                    if (!__hasNativeSupport) return [
                        2 /*return*/ ,
                        [
                            50,
                            1
                        ]
                    ];
                    start = 0;
                    end = 0;
                    _c.label = 1;
                case 1:
                    _c.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    start = performance.now();
                    _a = Uint8Array.bind;
                    return [
                        4 /*yield*/ ,
                        _test_nativeSha2_512(data)
                    ];
                case 2:
                    nativeResult = new (_a.apply(Uint8Array, [
                        void 0,
                        _c.sent()
                    ]))();
                    end = performance.now();
                    nativeTime = end - start;
                    start = performance.now();
                    result = sha2_512_sync(data);
                    end = performance.now();
                    jsTime = end - start;
                    __hasNativeSupport = __hasNativeSupport && uint8ArrayEq(nativeResult, result);
                    return [
                        2 /*return*/ ,
                        [
                            nativeTime,
                            jsTime
                        ]
                    ];
                case 3:
                    _b = _c.sent();
                    __hasNativeSupport = false;
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 4:
                    return [
                        2 /*return*/ ,
                        [
                            50,
                            1
                        ]
                    ];
            }
        });
    });
}
var _support_was_tested = false;
function _test_support() {
    return __awaiter(this, void 0, void 0, function() {
        var repeatArr, eqU8Arr_1, bench, sum, _a;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    if (_support_was_tested || !__hasNativeSupport) return [
                        2 /*return*/ 
                    ];
                    _b.label = 1;
                case 1:
                    _b.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    repeatArr = function(arr, n) {
                        for(var i = 0; i < n; i++)arr = arr.concat.apply(arr, __spreadArray([], __read(arr), false));
                        return arr;
                    };
                    eqU8Arr_1 = function(a, b) {
                        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) return false;
                        if (a.length !== b.length) return false;
                        for(var i = 0; i < a.length; i++)if (a[i] !== b[i]) return false;
                        return true;
                    };
                    return [
                        4 /*yield*/ ,
                        Promise.all(repeatArr([
                            new Uint8Array(0),
                            new Uint8Array(10),
                            new Uint8Array([
                                0xde,
                                0xad,
                                0xbe,
                                0xef
                            ]),
                            new Uint8Array(repeatArr([
                                0xaa
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xbb
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xcc
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xdd
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xee
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xff
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xaa,
                                0xbb
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xbb,
                                0xcc
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xcc,
                                0xdd
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xdd,
                                0xee
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xee,
                                0xff
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xff,
                                0x00
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xde,
                                0xad,
                                0xbe,
                                0xef
                            ], 30))
                        ], 10).map(function(data) {
                            return _test(data, eqU8Arr_1);
                        }))
                    ];
                case 2:
                    bench = _b.sent();
                    if (!__hasNativeSupport) return [
                        2 /*return*/ 
                    ];
                    sum = bench.reduce(function(acc, _a) {
                        var _b = __read(_a, 2), native = _b[0], js = _b[1];
                        acc[0] += native;
                        acc[1] += js;
                        return acc;
                    }, [
                        0,
                        0
                    ]);
                    __hasNativeSupport = __hasNativeSupport && sum[0] < sum[1];
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 3:
                    _a = _b.sent();
                    __hasNativeSupport = false;
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 4:
                    _support_was_tested = true;
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}
if (__hasNativeSupport) {
    _test_support();
} else {
    _support_was_tested = true;
}
/**
 * There are cases where `globalThis.crypto.subtle` is fully defined
 * but the algorithm `Ed25519` is NOT SUPPORTED.
 *
 * unfortunately, there is NO WAY to check this syncronously.
 */ function ensureNativeSupport() {
    return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    if (!__hasNativeSupport) return [
                        2 /*return*/ ,
                        false
                    ];
                    return [
                        4 /*yield*/ ,
                        _test_support()
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ ,
                        __hasNativeSupport
                    ];
            }
        });
    });
}
/**
 * getulates sha2-512 (64bytes) hash of a list of uint8 numbers.
 * Result is also a list of uint8 number.
 * @example
 * bytesToHex(sha2_512_sync([0x61, 0x62, 0x63])) => "ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"
 * @example
 * bytesToHex(sha2_512_sync([])) => "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"
 * @param {number[]} bytes - list of uint8 numbers
 * @returns {number[]} - list of uint8 numbers
 */ function sha2_512_sync(bytes) {
    if (!(bytes instanceof Uint8Array)) bytes = new Uint8Array(bytes);
    if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
    return (0, sha512_1.sha512)(bytes);
}
exports.sha2_512_sync = sha2_512_sync;
function wrapped_sha2_512_sync(bytes) {
    return Promise.resolve(sha2_512_sync(bytes));
}
exports.sha2_512 = __hasNativeSupport ? nativeSha2_512 : wrapped_sha2_512_sync;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/utils/positiveMod.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.positiveMod = void 0;
var _0n = BigInt(0);
function positiveMod(x, n) {
    n = typeof n === "bigint" ? n : BigInt(n);
    x = typeof x === "bigint" ? x : BigInt(x);
    var res = x % n;
    return res < _0n ? res + n : res;
}
exports.positiveMod = positiveMod;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/utils/bigintToBuffer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bigintToBuffer = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
function bigintToBuffer(bigint, nBytes) {
    if (nBytes === void 0) {
        nBytes = undefined;
    }
    if (bigint < BigInt(0)) throw new Error("cannot convert negative bigint to buffer");
    if (typeof nBytes !== "number") nBytes = undefined;
    if (bigint === BigInt(0)) {
        if (nBytes === undefined) nBytes = 0;
        return new Uint8Array(nBytes);
    }
    var buffHexString = bigint.toString(16);
    buffHexString = buffHexString.length % 2 === 0 ? buffHexString : '0' + buffHexString;
    if (typeof nBytes === "number") {
        nBytes = Math.round(Math.abs(nBytes));
        buffHexString = buffHexString.padStart(nBytes * 2, "00");
        if (buffHexString.length > nBytes * 2) // only keep the last nBytes
        buffHexString = buffHexString.slice(buffHexString.length - nBytes * 2);
    }
    return (0, uint8array_utils_1.fromHex)(buffHexString);
}
exports.bigintToBuffer = bigintToBuffer;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/ed25519.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifyEd25519Signature = exports.verifyEd25519Signature_sync = exports.getEd25519Signature = exports.getEd25519Signature_sync = exports.signExtendedEd25519 = exports.signExtendedEd25519_sync = exports.signEd25519 = exports.signEd25519_sync = exports.extendedToPublic = exports.deriveEd25519PublicKey = exports.deriveEd25519PublicKey_sync = exports.getExtendedEd25519PrivateKey = exports.getExtendedEd25519PrivateKey_sync = exports.getExtendEd25519PrivateKeyComponents_sync = exports.getExtendEd25519PrivateKeyComponentsAsBytes_sync = exports.scalarMultBase = exports.scalarToBytes = exports.scalarFromBytes = exports.pointFromBytes = exports.bigpointToUint8Array = exports.encodeInt = exports.scalarMul = exports.addPointsEdwards = exports.ed25519bigint = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var sha2_512_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)");
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var positiveMod_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/positiveMod.js [app-client] (ecmascript)");
var bigintToBuffer_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/bigintToBuffer.js [app-client] (ecmascript)");
var hasGlobalWebCrypto_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/hasGlobalWebCrypto.js [app-client] (ecmascript)");
// "Ed25519" does not seem to have great support yet
var __hasNativeSupport = false && hasGlobalWebCrypto_1.hasGlobalWebCrypto && typeof globalThis.crypto.subtle.importKey === "function" && typeof globalThis.crypto.subtle.sign === "function" && typeof globalThis.crypto.subtle.verify === "function";
var NATIVE_ALGO_NAME = "Ed25519";
var NATIVE_ALGO = Object.freeze({
    name: NATIVE_ALGO_NAME
});
var importKey = __hasNativeSupport ? globalThis.crypto.subtle.importKey.bind(globalThis.crypto.subtle) : function() {
    return Promise.resolve(new ArrayBuffer(0));
};
function getNativePrivateKey(bytes) {
    return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    // ensure 64 bytes
                    if (bytes.length === 32) bytes = getExtendedEd25519PrivateKey_sync(bytes);
                    return [
                        4 /*yield*/ ,
                        importKey("raw", bytes, NATIVE_ALGO, false, [
                            "sign",
                            "deriveKey"
                        ])
                    ];
                case 1:
                    return [
                        2 /*return*/ ,
                        _a.sent()
                    ];
            }
        });
    });
}
function getNativePublicKey(bytes) {
    return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
            return [
                2 /*return*/ ,
                importKey("raw", bytes, NATIVE_ALGO, false, [
                    "verify"
                ])
            ];
        });
    });
}
function nativeEd25519Sign(privateKey, data) {
    return __awaiter(this, void 0, void 0, function() {
        var _a, _b, _c, _d;
        return __generator(this, function(_e) {
            switch(_e.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        ensureNativeSupport()
                    ];
                case 1:
                    if (!_e.sent()) return [
                        2 /*return*/ ,
                        getEd25519Signature_sync(privateKey, data)
                    ];
                    _a = Uint8Array.bind;
                    _c = (_b = globalThis.crypto.subtle).sign;
                    _d = [
                        NATIVE_ALGO_NAME
                    ];
                    return [
                        4 /*yield*/ ,
                        getNativePrivateKey(privateKey)
                    ];
                case 2:
                    return [
                        4 /*yield*/ ,
                        _c.apply(_b, _d.concat([
                            _e.sent(),
                            data
                        ]))
                    ];
                case 3:
                    return [
                        2 /*return*/ ,
                        new (_a.apply(Uint8Array, [
                            void 0,
                            _e.sent()
                        ]))()
                    ];
            }
        });
    });
}
var ED25519_ORDER = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');
function ed25519bigint(n) {
    return (0, positiveMod_1.positiveMod)(n, ED25519_ORDER);
}
exports.ed25519bigint = ed25519bigint;
function toArrayBuffer(bytes) {
    if (bytes instanceof ArrayBuffer) return bytes;
    var buffer = new ArrayBuffer(bytes.length);
    var view = new Uint8Array(buffer);
    view.set(bytes);
    return buffer;
}
function nativeEd25519Verify(publicKey, signature, data) {
    return __awaiter(this, void 0, void 0, function() {
        var _a, _b, _c;
        return __generator(this, function(_d) {
            switch(_d.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        ensureNativeSupport()
                    ];
                case 1:
                    if (!_d.sent()) return [
                        2 /*return*/ ,
                        verifyEd25519Signature_sync(signature, data, publicKey)
                    ];
                    _b = (_a = globalThis.crypto.subtle).verify;
                    _c = [
                        NATIVE_ALGO_NAME
                    ];
                    return [
                        4 /*yield*/ ,
                        getNativePublicKey(publicKey)
                    ];
                case 2:
                    return [
                        2 /*return*/ ,
                        _b.apply(_a, _c.concat([
                            _d.sent(),
                            toArrayBuffer(signature),
                            toArrayBuffer(data)
                        ]))
                    ];
            }
        });
    });
}
function _test(privateKey, publicKey, data, uint8ArrayEq) {
    return __awaiter(this, void 0, void 0, function() {
        var privBytes, _a, pubBytes, _b, nativeSignResult, nativeVerifyResult, mySignResult, myVerifyResult, _c;
        return __generator(this, function(_d) {
            switch(_d.label){
                case 0:
                    _d.trys.push([
                        0,
                        5,
                        ,
                        6
                    ]);
                    _a = Uint8Array.bind;
                    return [
                        4 /*yield*/ ,
                        globalThis.crypto.subtle.exportKey("raw", privateKey)
                    ];
                case 1:
                    privBytes = new (_a.apply(Uint8Array, [
                        void 0,
                        _d.sent()
                    ]))();
                    _b = Uint8Array.bind;
                    return [
                        4 /*yield*/ ,
                        globalThis.crypto.subtle.exportKey("raw", publicKey)
                    ];
                case 2:
                    pubBytes = new (_b.apply(Uint8Array, [
                        void 0,
                        _d.sent()
                    ]))();
                    return [
                        4 /*yield*/ ,
                        nativeEd25519Sign(privBytes, data)
                    ];
                case 3:
                    nativeSignResult = _d.sent();
                    return [
                        4 /*yield*/ ,
                        nativeEd25519Verify(pubBytes, nativeSignResult, data)
                    ];
                case 4:
                    nativeVerifyResult = _d.sent();
                    mySignResult = getEd25519Signature_sync(data, privBytes);
                    myVerifyResult = verifyEd25519Signature_sync(mySignResult, data, pubBytes);
                    __hasNativeSupport = __hasNativeSupport && uint8ArrayEq(nativeSignResult, mySignResult) && nativeVerifyResult === myVerifyResult;
                    return [
                        3 /*break*/ ,
                        6
                    ];
                case 5:
                    _c = _d.sent();
                    __hasNativeSupport = false;
                    return [
                        3 /*break*/ ,
                        6
                    ];
                case 6:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}
var _support_was_tested = false;
function _test_support() {
    return __awaiter(this, void 0, void 0, function() {
        var _keyPair /* { privateKey, publicKey } */ , extendedPrivate, cryptoPrivate, repeatArr, eqU8Arr, bench, sum, _a;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    if (_support_was_tested || !__hasNativeSupport) return [
                        2 /*return*/ 
                    ];
                    _b.label = 1;
                case 1:
                    _b.trys.push([
                        1,
                        5,
                        ,
                        6
                    ]);
                    return [
                        4 /*yield*/ ,
                        globalThis.crypto.subtle.generateKey(NATIVE_ALGO, true, [
                            "sign",
                            "verify"
                        ])
                    ];
                case 2:
                    _keyPair = _b.sent();
                    extendedPrivate = new Uint8Array(64);
                    globalThis.crypto.getRandomValues(extendedPrivate);
                    return [
                        4 /*yield*/ ,
                        getNativePrivateKey(extendedPrivate)
                    ];
                case 3:
                    cryptoPrivate = _b.sent();
                    repeatArr = function(arr, n) {
                        for(var i = 0; i < n; i++)arr = arr.concat.apply(arr, __spreadArray([], __read(arr), false));
                        return arr;
                    };
                    eqU8Arr = function(a, b) {
                        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) return false;
                        if (a.length !== b.length) return false;
                        for(var i = 0; i < a.length; i++)if (a[i] !== b[i]) return false;
                        return true;
                    };
                    return [
                        4 /*yield*/ ,
                        Promise.all(// repeatArr(
                        //     [
                        //         new Uint8Array( 0 ),
                        //         new Uint8Array( 10 ),
                        //         new Uint8Array([ 0xde, 0xad, 0xbe, 0xef ]),
                        // 
                        //         new Uint8Array( repeatArr([0xaa], 20 ) ),
                        //         new Uint8Array( repeatArr([0xbb], 20 ) ),
                        //         new Uint8Array( repeatArr([0xcc], 20 ) ),
                        //         new Uint8Array( repeatArr([0xdd], 20 ) ),
                        //         new Uint8Array( repeatArr([0xee], 20 ) ),
                        //         new Uint8Array( repeatArr([0xff], 20 ) ),
                        // 
                        //         new Uint8Array( repeatArr([0xaa, 0xbb], 33 ) ),
                        //         new Uint8Array( repeatArr([0xbb, 0xcc], 33 ) ),
                        //         new Uint8Array( repeatArr([0xcc, 0xdd], 33 ) ),
                        //         new Uint8Array( repeatArr([0xdd, 0xee], 33 ) ),
                        //         new Uint8Array( repeatArr([0xee, 0xff], 33 ) ),
                        //         new Uint8Array( repeatArr([0xff, 0x00], 33 ) ),
                        // 
                        //         new Uint8Array( repeatArr([ 0xde, 0xad, 0xbe, 0xef ], 30 ) ),
                        //     ],
                        //     10
                        // )
                        // .map( data => _test( privateKey, publicKey, data, uint8ArrayEq ) )
                        [])
                    ];
                case 4:
                    bench = _b.sent();
                    if (!__hasNativeSupport) return [
                        2 /*return*/ 
                    ];
                    sum = bench.reduce(function(acc, _a) {
                        var _b = __read(_a, 2), native = _b[0], js = _b[1];
                        acc[0] += native;
                        acc[1] += js;
                        return acc;
                    }, [
                        0,
                        0
                    ]);
                    __hasNativeSupport = __hasNativeSupport && sum[0] < sum[1];
                    return [
                        3 /*break*/ ,
                        6
                    ];
                case 5:
                    _a = _b.sent();
                    __hasNativeSupport = false;
                    _support_was_tested = true;
                    return [
                        3 /*break*/ ,
                        6
                    ];
                case 6:
                    _support_was_tested = true;
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}
if (__hasNativeSupport) {
    _test_support();
} else {
    _support_was_tested = true;
}
/**
 * There are cases where `globalThis.crypto.subtle` is fully defined
 * but the algorithm `Ed25519` is NOT SUPPORTED.
 *
 * unfortunately, there is NO WAY to check this syncronously.
 */ function ensureNativeSupport() {
    return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    if (!__hasNativeSupport) return [
                        2 /*return*/ ,
                        false
                    ];
                    return [
                        4 /*yield*/ ,
                        _test_support()
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ ,
                        __hasNativeSupport
                    ];
            }
        });
    });
}
var Q = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"); // ipowi(255) - 19
var Q38 = BigInt("7237005577332262213973186563042994240829374041602535252466099000494570602494"); // (Q + 3)/8
var CURVE_ORDER = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"); // ipow2(252) + 27742317777372353535851937790883648493;
var D = -BigInt("4513249062541557337682894930092624173785641285191125241628941591882900924598840740"); // -121665 * invert(121666);
var I = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"); // expMod(BigInt( 2 ), (Q - BigInt( 1 ))/4, Q);
var BASE = Object.freeze([
    BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960") // (4*invert(5)) % Q
]);
/**
 *
 * @param {bigint} b
 * @param {bigint} e
 * @param {bigint} m
 * @returns {bigint}
 */ function expMod(b, e, m) {
    if (e == BigInt(0)) {
        return BigInt(1);
    } else {
        var t = expMod(b, e / BigInt(2), m);
        t = t * t % m;
        if (e % BigInt(2) !== BigInt(0)) {
            t = (0, positiveMod_1.positiveMod)(t * b, m);
        }
        return t;
    }
}
function invert(n) {
    var a = (0, positiveMod_1.positiveMod)(n, Q);
    var b = Q;
    var x = BigInt(0);
    var y = BigInt(1);
    var u = BigInt(1);
    var v = BigInt(0);
    while(a !== BigInt(0)){
        var q = b / a;
        var r = b % a;
        var m = x - u * q;
        var n_1 = y - v * q;
        b = a;
        a = r;
        x = u;
        y = v;
        u = m;
        v = n_1;
    }
    return (0, positiveMod_1.positiveMod)(x, Q);
}
/**
 * @param {bigint} y
 * @returns {bigint}
 */ function recoverX(y) {
    var yy = y * y;
    var xx = (yy - BigInt(1)) * invert(D * yy + BigInt(1));
    var x = expMod(xx, Q38, Q);
    if ((x * x - xx) % Q !== BigInt(0)) {
        x = x * I % Q;
    }
    if (x % BigInt(2) !== BigInt(0)) {
        x = Q - x;
    }
    return x;
}
/**
 * Curve point 'addition'
 * Note: this is probably the bottleneck of this Ed25519 implementation
 */ function addPointsEdwards(a, b) {
    var x1 = a[0];
    var y1 = a[1];
    var x2 = b[0];
    var y2 = b[1];
    var dxxyy = D * x1 * x2 * y1 * y2;
    var x3 = (x1 * y2 + x2 * y1) * invert(BigInt(1) + dxxyy);
    var y3 = (y1 * y2 + x1 * x2) * invert(BigInt(1) - dxxyy);
    return [
        (0, positiveMod_1.positiveMod)(x3, Q),
        (0, positiveMod_1.positiveMod)(y3, Q)
    ];
}
exports.addPointsEdwards = addPointsEdwards;
function scalarMul(point, n) {
    if (n === BigInt(0)) {
        return [
            BigInt(0),
            BigInt(1)
        ];
    } else {
        var sum = scalarMul(point, n / BigInt(2));
        sum = addPointsEdwards(sum, sum);
        if (n % BigInt(2) !== BigInt(0)) {
            sum = addPointsEdwards(sum, point);
        }
        return sum;
    }
}
exports.scalarMul = scalarMul;
/**
 * Curve point 'multiplication'
 */ function encodeInt(y) {
    return (0, bigintToBuffer_1.bigintToBuffer)(y, 32).reverse();
}
exports.encodeInt = encodeInt;
function decodeInt(s) {
    return BigInt("0x" + (0, types_1.byteArrToHex)(s.reverse()));
}
function bigpointToByteArray(point) {
    var _a = __read(point, 2), x = _a[0], y = _a[1];
    var bytes = encodeInt(y);
    // last bit is determined by x
    bytes[31] = bytes[31] & 255 | Number(x & BigInt(1)) * 128;
    return bytes;
}
function bigpointToUint8Array(point) {
    return new Uint8Array(bigpointToByteArray(point));
}
exports.bigpointToUint8Array = bigpointToUint8Array;
function getBit(bytes, i) {
    return bytes[Math.floor(i / 8)] >> i % 8 & 1;
}
function isOnCurve(point) {
    var x = point[0];
    var y = point[1];
    var xx = x * x;
    var yy = y * y;
    return (-xx + yy - BigInt(1) - D * xx * yy) % Q == BigInt(0);
}
function pointFromBytes(s) {
    if (!(s instanceof Uint8Array)) s = forceUint8Array(s);
    // assert(s.length === 32, "point must have length of 32; point length:" + s.length);
    var bytes = s.slice(0, 32);
    bytes[31] = bytes[31] & 127;
    var y = decodeInt(bytes);
    var x = recoverX(y);
    if (Number(x & BigInt(1)) !== getBit(s, 255)) {
        x = Q - x;
    }
    var point = [
        x,
        y
    ];
    if (!isOnCurve(point)) throw new Error("point isn't on curve");
    return point;
}
exports.pointFromBytes = pointFromBytes;
var ipow2_253 = BigInt("28948022309329048855892746252171976963317496166410141009864396001978282409984"); // ipow2(253)
function scalarFromBytes(h) {
    var bytes = h.slice(0, 32);
    bytes[0] = bytes[0] & 248;
    bytes[31] = bytes[31] & 63;
    return ipow2_253 + BigInt("0x" + (0, types_1.byteArrToHex)(bytes.reverse()));
}
exports.scalarFromBytes = scalarFromBytes;
function scalarToBytes(s) {
    s = (0, positiveMod_1.positiveMod)(s, CURVE_ORDER);
    var bytes = encodeInt(s);
    bytes.reverse();
    return bytes;
}
exports.scalarToBytes = scalarToBytes;
function ihash(m) {
    return decodeInt((0, sha2_512_1.sha2_512_sync)(m));
}
function forceUint8Array(stuff) {
    if (stuff instanceof Uint8Array) return stuff;
    if (stuff instanceof ArrayBuffer) return new Uint8Array(stuff);
    if (typeof stuff === "string") return (0, uint8array_utils_1.fromHex)(stuff);
    return new Uint8Array(stuff);
}
function scalarMultBase(scalar) {
    return scalarMul(BASE, scalar);
}
exports.scalarMultBase = scalarMultBase;
////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//------------------------------------------------------------------------------------------------------// 
//------------------------------------------- key management -------------------------------------------// 
//------------------------------------------- and derivation -------------------------------------------// 
//------------------------------------------------------------------------------------------------------// 
////////////////////////////////////////////////////////////////////////////////////////////////////////// 
function getExtendEd25519PrivateKeyComponentsAsBytes_sync(privateKey) {
    var extended = (0, sha2_512_1.sha2_512_sync)(privateKey);
    return [
        extended.slice(0, 32),
        extended.slice(32, 64)
    ];
}
exports.getExtendEd25519PrivateKeyComponentsAsBytes_sync = getExtendEd25519PrivateKeyComponentsAsBytes_sync;
function getExtendEd25519PrivateKeyComponents_sync(privateKey) {
    var _a = __read(getExtendEd25519PrivateKeyComponentsAsBytes_sync(privateKey), 2), a_bytes = _a[0], extension = _a[1];
    return [
        scalarFromBytes(a_bytes),
        extension
    ];
}
exports.getExtendEd25519PrivateKeyComponents_sync = getExtendEd25519PrivateKeyComponents_sync;
function getExtendedEd25519PrivateKey_sync(privateKey) {
    privateKey = Uint8Array.prototype.slice.call(forceUint8Array(privateKey), 0, 32);
    var extended = (0, sha2_512_1.sha2_512_sync)(privateKey);
    extended.set(privateKey, 0);
    return extended;
}
exports.getExtendedEd25519PrivateKey_sync = getExtendedEd25519PrivateKey_sync;
function getExtendedEd25519PrivateKey(privateKey) {
    return __awaiter(this, void 0, void 0, function() {
        var extended;
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    // here `__hasNativeSupport` instead of `await ensureNativeSupport()` is fine
                    // because we want to use `sha2_512`, wich implies different tests than the ones
                    // used in `ensureNativeSupport`; `__hasNativeSupport` at least tell us if there is a `crypto` global at all 
                    if (!__hasNativeSupport) return [
                        2 /*return*/ ,
                        getExtendedEd25519PrivateKey_sync(privateKey)
                    ];
                    privateKey = Uint8Array.prototype.slice.call(forceUint8Array(privateKey), 0, 32);
                    return [
                        4 /*yield*/ ,
                        (0, sha2_512_1.sha2_512)(privateKey)
                    ];
                case 1:
                    extended = _a.sent();
                    extended.set(privateKey, 0);
                    return [
                        2 /*return*/ ,
                        extended
                    ];
            }
        });
    });
}
exports.getExtendedEd25519PrivateKey = getExtendedEd25519PrivateKey;
function deriveEd25519PublicKey_sync(privateKey) {
    var extended = (0, sha2_512_1.sha2_512_sync)(privateKey);
    var a = scalarFromBytes(extended);
    var A = scalarMul(BASE, a);
    return bigpointToByteArray(A);
}
exports.deriveEd25519PublicKey_sync = deriveEd25519PublicKey_sync;
function wrapped_deriveEd25519PublicKey_sync(privateKey) {
    return Promise.resolve(deriveEd25519PublicKey_sync(privateKey));
}
function deriveEd25519PublicKey_async(privateKey) {
    return __awaiter(this, void 0, void 0, function() {
        var extended, a, A;
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    if (!__hasNativeSupport) return [
                        2 /*return*/ ,
                        deriveEd25519PublicKey_sync(privateKey)
                    ];
                    return [
                        4 /*yield*/ ,
                        (0, sha2_512_1.sha2_512)(privateKey)
                    ];
                case 1:
                    extended = _a.sent();
                    a = scalarFromBytes(extended);
                    A = scalarMul(BASE, a);
                    return [
                        2 /*return*/ ,
                        bigpointToByteArray(A)
                    ];
            }
        });
    });
}
exports.deriveEd25519PublicKey = __hasNativeSupport ? deriveEd25519PublicKey_async : wrapped_deriveEd25519PublicKey_sync;
function extendedToPublic(extended) {
    extended = forceUint8Array(extended);
    var a = scalarFromBytes(extended);
    var A = scalarMul(BASE, a);
    return new Uint8Array(bigpointToByteArray(A));
}
exports.extendedToPublic = extendedToPublic;
/** sign a message with a (32 bytes) private key */ function signEd25519_sync(message, privateKey) {
    message = forceUint8Array(message);
    privateKey = forceUint8Array(privateKey);
    var extendedKey = privateKey.length === 64 ? privateKey : (0, sha2_512_1.sha2_512_sync)(privateKey);
    return signExtendedEd25519_sync(message, extendedKey);
}
exports.signEd25519_sync = signEd25519_sync;
/** sign a message with a (32 bytes) private key */ function signEd25519(message, privateKey) {
    return __awaiter(this, void 0, void 0, function() {
        var extended, _a;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    privateKey = forceUint8Array(privateKey);
                    if (!(privateKey.length === 64)) return [
                        3 /*break*/ ,
                        1
                    ];
                    _a = privateKey;
                    return [
                        3 /*break*/ ,
                        3
                    ];
                case 1:
                    return [
                        4 /*yield*/ ,
                        (0, sha2_512_1.sha2_512)(privateKey)
                    ];
                case 2:
                    _a = _b.sent();
                    _b.label = 3;
                case 3:
                    extended = _a;
                    return [
                        4 /*yield*/ ,
                        (0, exports.signExtendedEd25519)(message, extended)
                    ];
                case 4:
                    return [
                        2 /*return*/ ,
                        _b.sent()
                    ];
            }
        });
    });
}
exports.signEd25519 = signEd25519;
/** sign a message with a (64 bytes) private key */ function signExtendedEd25519_sync(_message, _extendedKey) {
    var _a;
    var message = forceUint8Array(_message);
    var privateKeyHash = forceUint8Array(_extendedKey);
    if (privateKeyHash.length !== 64) throw new Error('signExtendedEd25519_sync:: extended key must have length 64');
    var a = scalarFromBytes(privateKeyHash);
    // for convenience getulate publicKey here:
    var publicKey = bigpointToByteArray(scalarMul(BASE, a));
    var r = ihash((0, uint8array_utils_1.concatUint8Array)(privateKeyHash.slice(32, 64), forceUint8Array(message)));
    var R = scalarMul(BASE, r);
    var S = (0, positiveMod_1.positiveMod)(r + ihash((0, uint8array_utils_1.concatUint8Array)(bigpointToByteArray(R), publicKey, forceUint8Array(message))) * a, CURVE_ORDER);
    var pubKey = publicKey;
    var signature = (0, uint8array_utils_1.concatUint8Array)(bigpointToByteArray(R), encodeInt(S));
    return _a = {
        0: pubKey,
        1: signature,
        length: 2
    }, _a[Symbol.iterator] = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        pubKey
                    ];
                case 1:
                    _a.sent();
                    return [
                        4 /*yield*/ ,
                        signature
                    ];
                case 2:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    }, _a.pubKey = pubKey, _a.signature = signature, _a;
}
exports.signExtendedEd25519_sync = signExtendedEd25519_sync;
function wrapped_signExtendedEd25519_sync(message, extendedKey) {
    return Promise.resolve(signExtendedEd25519_sync(message, extendedKey));
}
/** sign a message with a (64 bytes) private key */ function nativeExtendedSignEd25519(_message, _extendedKey) {
    return __awaiter(this, void 0, void 0, function() {
        var message, privateKeyHash, a, pubKey, signature;
        var _a;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        ensureNativeSupport()
                    ];
                case 1:
                    if (!_b.sent()) return [
                        2 /*return*/ ,
                        signExtendedEd25519_sync(_message, _extendedKey)
                    ];
                    message = forceUint8Array(_message);
                    privateKeyHash = forceUint8Array(_extendedKey);
                    if (privateKeyHash.length !== 64) throw new Error('nativeExtendedSignEd25519:: extended key must have length 64');
                    a = scalarFromBytes(privateKeyHash);
                    pubKey = bigpointToByteArray(scalarMul(BASE, a));
                    return [
                        4 /*yield*/ ,
                        nativeEd25519Sign(privateKeyHash, message)
                    ];
                case 2:
                    signature = _b.sent();
                    return [
                        2 /*return*/ ,
                        (_a = {
                            0: pubKey,
                            1: signature,
                            length: 2
                        }, _a[Symbol.iterator] = function() {
                            return __generator(this, function(_a) {
                                switch(_a.label){
                                    case 0:
                                        return [
                                            4 /*yield*/ ,
                                            pubKey
                                        ];
                                    case 1:
                                        _a.sent();
                                        return [
                                            4 /*yield*/ ,
                                            signature
                                        ];
                                    case 2:
                                        _a.sent();
                                        return [
                                            2 /*return*/ 
                                        ];
                                }
                            });
                        }, _a.pubKey = pubKey, _a.signature = signature, _a)
                    ];
            }
        });
    });
}
/** sign a message with a (64 bytes) private key */ exports.signExtendedEd25519 = __hasNativeSupport ? nativeExtendedSignEd25519 : wrapped_signExtendedEd25519_sync;
/** sign a message with a (32 bytes) private key */ function getEd25519Signature_sync(message, privateKey) {
    return signEd25519_sync(message, privateKey).signature;
}
exports.getEd25519Signature_sync = getEd25519Signature_sync;
function wrapped_getEd25519Signature_sync(message, privateKey) {
    return Promise.resolve(getEd25519Signature_sync(message, privateKey));
}
/** sign a message with a (32 bytes) private key */ exports.getEd25519Signature = __hasNativeSupport ? nativeEd25519Sign : wrapped_getEd25519Signature_sync;
///////////////////////////////////////////////////////////////////////////////////////////////////// 
//-------------------------------------------------------------------------------------------------// 
//------------------------------------------- verifying -------------------------------------------// 
//-------------------------------------------------------------------------------------------------// 
/////////////////////////////////////////////////////////////////////////////////////////////////////
function verifyEd25519Signature_sync(_signature, _message, _publicKey) {
    var signature = forceUint8Array(_signature);
    var message = forceUint8Array(_message);
    var publicKey = forceUint8Array(_publicKey);
    if (signature.length !== 64 || publicKey.length !== 32) {
        throw new Error("unexpected signature length ".concat(signature.length));
    }
    var R_bytes = forceUint8Array(signature).slice(0, 32);
    var R = pointFromBytes(R_bytes);
    var A = pointFromBytes(forceUint8Array(publicKey));
    var S = decodeInt(forceUint8Array(signature).slice(32, 64));
    var h = ihash((0, uint8array_utils_1.concatUint8Array)(R_bytes, publicKey, message));
    var left = scalarMul(BASE, S);
    var right = addPointsEdwards(R, scalarMul(A, h));
    return left[0] == right[0] && left[1] == right[1];
}
exports.verifyEd25519Signature_sync = verifyEd25519Signature_sync;
function wrapped_verifyEd25519Signature_sync(signature, message, publicKey) {
    return Promise.resolve(verifyEd25519Signature_sync(signature, message, publicKey));
}
exports.verifyEd25519Signature = __hasNativeSupport ? nativeEd25519Verify : wrapped_verifyEd25519Signature_sync;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/hmac.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hmac = exports.HMAC = void 0;
var _assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/_assert.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
// HMAC (RFC 2104)
var HMAC = function(_super) {
    __extends(HMAC, _super);
    function HMAC(hash, _key) {
        var _this = _super.call(this) || this;
        _this.finished = false;
        _this.destroyed = false;
        (0, _assert_1.hash)(hash);
        var key = (0, utils_1.toBytes)(_key);
        _this.iHash = hash.create();
        if (typeof _this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
        _this.blockLen = _this.iHash.blockLen;
        _this.outputLen = _this.iHash.outputLen;
        var blockLen = _this.blockLen;
        var pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(var i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        _this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        _this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(var i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;
        _this.oHash.update(pad);
        pad.fill(0);
        return _this;
    }
    HMAC.prototype.update = function(buf) {
        (0, _assert_1.exists)(this);
        this.iHash.update(buf);
        return this;
    };
    HMAC.prototype.digestInto = function(out) {
        (0, _assert_1.exists)(this);
        (0, _assert_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    };
    HMAC.prototype.digest = function() {
        var out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    };
    HMAC.prototype._cloneInto = function(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        var _a = this, oHash = _a.oHash, iHash = _a.iHash, finished = _a.finished, destroyed = _a.destroyed, blockLen = _a.blockLen, outputLen = _a.outputLen;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    };
    HMAC.prototype.destroy = function() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    };
    return HMAC;
}(utils_1.Hash);
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */ var hmac = function(hash, key, message) {
    return new HMAC(hash, key).update(message).digest();
};
exports.hmac = hmac;
exports.hmac.create = function(hash, key) {
    return new HMAC(hash, key);
};
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/hmacSHA512.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hmacSHA512 = void 0;
var hmac_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/hmac.js [app-client] (ecmascript)");
var sha512_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/sha512.js [app-client] (ecmascript)");
/**
 * here because we need it in `@harmoniclabs/bip32_ed25519`
 *
 * and in particular, because it is a dependency of `pbkdf2` (which could also be calculated using native webcrypto)
 */ function hmacSHA512(key, data) {
    return new Uint8Array((0, hmac_1.hmac)(sha512_1.sha512, key, data));
}
exports.hmacSHA512 = hmacSHA512;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/keccak.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.keccak_512 = exports.keccak_384 = exports.keccak_224 = exports.keccak_256 = void 0;
var noble = __importStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/keccak.js [app-client] (ecmascript)"));
function keccak_256(msg) {
    return noble.keccak_256(msg);
}
exports.keccak_256 = keccak_256;
function keccak_224(msg) {
    return noble.keccak_224(msg);
}
exports.keccak_224 = keccak_224;
function keccak_384(msg) {
    return noble.keccak_384(msg);
}
exports.keccak_384 = keccak_384;
function keccak_512(msg) {
    return noble.keccak_512(msg);
}
exports.keccak_512 = keccak_512;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/_shortw_utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createCurve = exports.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var hmac_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/hmac.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
var weierstrass_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/weierstrass.js [app-client] (ecmascript)");
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash: hash,
        hmac: function(key) {
            var msgs = [];
            for(var _i = 1; _i < arguments.length; _i++){
                msgs[_i - 1] = arguments[_i];
            }
            return (0, hmac_1.hmac)(hash, key, utils_1.concatBytes.apply(void 0, __spreadArray([], __read(msgs), false)));
        },
        randomBytes: utils_1.randomBytes
    };
}
exports.getHash = getHash;
function createCurve(curveDef, defHash) {
    var create = function(hash) {
        return (0, weierstrass_1.weierstrass)(__assign(__assign({}, curveDef), getHash(hash)));
    };
    return Object.freeze(__assign(__assign({}, create(defHash)), {
        create: create
    }));
}
exports.createCurve = createCurve;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/secp256k1.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifySecp256k1 = exports.signSecp256k1 = exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.verifySchnorr = exports.signSchnorr = exports.Secp256k1Point = exports.secp256k1PointToBytes = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var sha256_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/sha256.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
var modular_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/modular.js [app-client] (ecmascript)");
var weierstrass_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/curves/weierstrass.js [app-client] (ecmascript)");
var utils_2 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/utils.js [app-client] (ecmascript)");
var hash_to_curve_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/abstract/hash-to-curve.js [app-client] (ecmascript)");
var _shortw_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/_shortw_utils.js [app-client] (ecmascript)");
var secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
var secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
var _1n = BigInt(1);
var _2n = BigInt(2);
var divNearest = function(a, b) {
    return (a + b / _2n) / b;
};
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */ function sqrtMod(y) {
    var P = secp256k1P;
    var _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    var _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    var b2 = y * y * y % P; // x^3, 11
    var b3 = b2 * b2 * y % P; // x^7
    var b6 = (0, modular_1.pow2)(b3, _3n, P) * b3 % P;
    var b9 = (0, modular_1.pow2)(b6, _3n, P) * b3 % P;
    var b11 = (0, modular_1.pow2)(b9, _2n, P) * b2 % P;
    var b22 = (0, modular_1.pow2)(b11, _11n, P) * b11 % P;
    var b44 = (0, modular_1.pow2)(b22, _22n, P) * b22 % P;
    var b88 = (0, modular_1.pow2)(b44, _44n, P) * b44 % P;
    var b176 = (0, modular_1.pow2)(b88, _88n, P) * b88 % P;
    var b220 = (0, modular_1.pow2)(b176, _44n, P) * b44 % P;
    var b223 = (0, modular_1.pow2)(b220, _3n, P) * b3 % P;
    var t1 = (0, modular_1.pow2)(b223, _23n, P) * b22 % P;
    var t2 = (0, modular_1.pow2)(t1, _6n, P) * b2 % P;
    var root = (0, modular_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');
    return root;
}
var Fp = (0, modular_1.Field)(secp256k1P, undefined, undefined, {
    sqrt: sqrtMod
});
exports.secp256k1 = (0, _shortw_utils_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */ endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: function(k) {
            var n = secp256k1N;
            var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            var b2 = a1;
            var POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            var c1 = divNearest(b2 * k, n);
            var c2 = divNearest(-b1 * k, n);
            var k1 = (0, modular_1.mod)(k - c1 * a1 - c2 * a2, n);
            var k2 = (0, modular_1.mod)(-c1 * b1 - c2 * b2, n);
            var k1neg = k1 > POW_2_128;
            var k2neg = k2 > POW_2_128;
            if (k1neg) k1 = n - k1;
            if (k2neg) k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
                throw new Error('splitScalar: Endomorphism failed, k=' + k);
            }
            return {
                k1neg: k1neg,
                k1: k1,
                k2neg: k2neg,
                k2: k2
            };
        }
    }
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
var _0n = BigInt(0);
var fe = function(x) {
    return typeof x === 'bigint' && _0n < x && x < secp256k1P;
};
var ge = function(x) {
    return typeof x === 'bigint' && _0n < x && x < secp256k1N;
};
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag) {
    var messages = [];
    for(var _i = 1; _i < arguments.length; _i++){
        messages[_i - 1] = arguments[_i];
    }
    var tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        var tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, function(c) {
            return c.charCodeAt(0);
        }));
        tagP = (0, utils_2.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)(utils_2.concatBytes.apply(void 0, __spreadArray([
        tagP
    ], __read(messages), false)));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
var pointToBytes = function(point) {
    return point.toRawBytes(true).slice(1);
};
exports.secp256k1PointToBytes = pointToBytes;
var numTo32b = function(n) {
    return (0, utils_2.numberToBytesBE)(n, 32);
};
var modP = function(x) {
    return (0, modular_1.mod)(x, secp256k1P);
};
var modN = function(x) {
    return (0, modular_1.mod)(x, secp256k1N);
};
var Point = exports.secp256k1.ProjectivePoint;
exports.Secp256k1Point = exports.secp256k1.ProjectivePoint;
var GmulAdd = function(Q, a, b) {
    return Point.BASE.multiplyAndAddUnsafe(Q, a, b);
};
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    var d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    var p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside
    var scalar = p.hasEvenY() ? d_ : modN(-d_);
    return {
        scalar: scalar,
        bytes: pointToBytes(p)
    };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */ function lift_x(x) {
    if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x  p.
    var xx = modP(x * x);
    var c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.
    var y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and
    var p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */ function challenge() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++){
        args[_i] = arguments[_i];
    }
    return modN((0, utils_2.bytesToNumberBE)(taggedHash.apply(void 0, __spreadArray([
        'BIP0340/challenge'
    ], __read(args), false))));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */ function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */ function schnorrSign(message, privateKey, auxRand) {
    if (auxRand === void 0) {
        auxRand = (0, utils_1.randomBytes)(32);
    }
    var m = (0, utils_2.ensureBytes)('message', message);
    var _a = schnorrGetExtPubKey(privateKey), px = _a.bytes, d = _a.scalar; // checks for isWithinCurveOrder
    var a = (0, utils_2.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    var t = numTo32b(d ^ (0, utils_2.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    var rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    var k_ = modN((0, utils_2.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.
    var _b = schnorrGetExtPubKey(k_), rx = _b.bytes, k = _b.scalar; // Let R = k'G.
    var e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    var sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */ function schnorrVerify(signature, message, publicKey) {
    var sig = (0, utils_2.ensureBytes)('signature', signature, 64);
    var m = (0, utils_2.ensureBytes)('message', message);
    var pub = (0, utils_2.ensureBytes)('publicKey', publicKey, 32);
    try {
        var P = lift_x((0, utils_2.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        var r = (0, utils_2.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
        if (!fe(r)) return false;
        var s = (0, utils_2.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
        if (!ge(s)) return false;
        var e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        var R = GmulAdd(P, s, modN(-e)); // R = sG - eP
        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
    } catch (error) {
        return false;
    }
}
exports.signSchnorr = schnorrSign;
exports.verifySchnorr = schnorrVerify;
exports.schnorr = function() {
    return {
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
            randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
            lift_x: lift_x,
            pointToBytes: pointToBytes,
            numberToBytesBE: utils_2.numberToBytesBE,
            bytesToNumberBE: utils_2.bytesToNumberBE,
            taggedHash: taggedHash,
            mod: modular_1.mod
        }
    };
}();
var isoMap = /* @__PURE__ */ function() {
    return (0, hash_to_curve_1.isogenyMap)(Fp, [
        // xNum
        [
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
            '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
            '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'
        ],
        // xDen
        [
            '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
            '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
        ],
        // yNum
        [
            '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
            '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
            '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
            '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'
        ],
        // yDen
        [
            '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
            '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
            '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
        ]
    ].map(function(i) {
        return i.map(function(j) {
            return BigInt(j);
        });
    }));
}();
var mapSWU = /* @__PURE__ */ function() {
    return (0, weierstrass_1.mapToCurveSimpleSWU)(Fp, {
        A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
        B: BigInt('1771'),
        Z: Fp.create(BigInt('-11'))
    });
}();
var htf = /* @__PURE__ */ function() {
    return (0, hash_to_curve_1.createHasher)(exports.secp256k1.ProjectivePoint, function(scalars) {
        var _a = mapSWU(Fp.create(scalars[0])), x = _a.x, y = _a.y;
        return isoMap(x, y);
    }, {
        DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
        encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: sha256_1.sha256
    });
}();
exports.hashToCurve = function() {
    return htf.hashToCurve;
}();
exports.encodeToCurve = function() {
    return htf.encodeToCurve;
}();
function signSecp256k1(data, privateKey, extraEntropy) {
    return exports.secp256k1.sign(data, privateKey, {
        extraEntropy: extraEntropy
    }).toCompactRawBytes();
}
exports.signSecp256k1 = signSecp256k1;
var myDefaultVerOpts = {
    lowS: true,
    prehash: false
};
function verifySecp256k1(sig, msgHash, pubKey) {
    return exports.secp256k1.verify(sig, msgHash, pubKey, myDefaultVerOpts);
}
exports.verifySecp256k1 = verifySecp256k1;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/secp256k1.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifySchnorrSecp256k1Signature = exports.verifyEcdsaSecp256k1Signature = void 0;
var secp256k1_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/secp256k1.js [app-client] (ecmascript)");
function verifyEcdsaSecp256k1Signature(vk, messageHash, signature) {
    if (!(vk instanceof Uint8Array && messageHash instanceof Uint8Array && signature instanceof Uint8Array && vk.length === 33 && messageHash.length === 32 && signature.length === 64)) throw new TypeError("invalid arguments passed to 'verifyEcdsaSecp256k1Signature'");
    var vkHead = vk[0];
    if (!(vkHead === 0x02 || vkHead === 0x03)) throw new Error("plutus-machine only supports compressed public keys for 'verifyEcdsaSecp256k1Signature'");
    return (0, secp256k1_1.verifySecp256k1)(signature, messageHash, vk);
}
exports.verifyEcdsaSecp256k1Signature = verifyEcdsaSecp256k1Signature;
function verifySchnorrSecp256k1Signature(pubKey, messageHash, signature) {
    if (!(pubKey instanceof Uint8Array && messageHash instanceof Uint8Array && signature instanceof Uint8Array && pubKey.length === 32 && signature.length === 64)) throw new TypeError("invalid arguments passed to 'verifyEcdsaSecp256k1Signature'");
    // signature 64
    // pubKey 32
    return (0, secp256k1_1.verifySchnorr)(signature, messageHash, pubKey);
}
exports.verifySchnorrSecp256k1Signature = verifySchnorrSecp256k1Signature;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/utils/rotr32.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rotr32 = void 0;
function rotr32(x, by) {
    return x >>> by | x << 32 - by | 0;
}
exports.rotr32 = rotr32;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/sha2_256.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hasNativeSha2_256 = exports.sha2_256 = exports.sha2_256_sync = void 0;
var rotr32_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/rotr32.js [app-client] (ecmascript)");
var hasGlobalWebCrypto_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/hasGlobalWebCrypto.js [app-client] (ecmascript)");
var __hasNativeSupport = hasGlobalWebCrypto_1.hasGlobalWebCrypto && typeof globalThis.crypto.subtle.digest === "function";
var NATIVE_ALGO = "SHA-256";
var digest = __hasNativeSupport ? globalThis.crypto.subtle.digest.bind(globalThis.crypto.subtle) : function() {
    return Promise.resolve(new ArrayBuffer(0));
};
function _test_nativeSha2_256(data) {
    return __awaiter(this, void 0, void 0, function() {
        var _a;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    _a = Uint8Array.bind;
                    return [
                        4 /*yield*/ ,
                        digest(NATIVE_ALGO, data)
                    ];
                case 1:
                    // await ensureNativeSupport();
                    // if( !__hasNativeSupport ) return sha2_256_sync( data );
                    return [
                        2 /*return*/ ,
                        new (_a.apply(Uint8Array, [
                            void 0,
                            _b.sent()
                        ]))()
                    ];
            }
        });
    });
}
function nativeSha2_256(data) {
    return __awaiter(this, void 0, void 0, function() {
        var _a;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        ensureNativeSupport()
                    ];
                case 1:
                    _b.sent();
                    if (!__hasNativeSupport) return [
                        2 /*return*/ ,
                        sha2_256_sync(data)
                    ];
                    _a = Uint8Array.bind;
                    return [
                        4 /*yield*/ ,
                        digest(NATIVE_ALGO, data)
                    ];
                case 2:
                    return [
                        2 /*return*/ ,
                        new (_a.apply(Uint8Array, [
                            void 0,
                            _b.sent()
                        ]))()
                    ];
            }
        });
    });
}
function _test(data, uint8ArrayEq) {
    return __awaiter(this, void 0, void 0, function() {
        var start, end, nativeRestult, _a, nativeTime, result, jsTime, _b;
        return __generator(this, function(_c) {
            switch(_c.label){
                case 0:
                    if (!__hasNativeSupport) return [
                        2 /*return*/ ,
                        [
                            50,
                            1
                        ]
                    ];
                    start = 0;
                    end = 0;
                    _c.label = 1;
                case 1:
                    _c.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    start = performance.now();
                    _a = Uint8Array.bind;
                    return [
                        4 /*yield*/ ,
                        _test_nativeSha2_256(data)
                    ];
                case 2:
                    nativeRestult = new (_a.apply(Uint8Array, [
                        void 0,
                        _c.sent()
                    ]))();
                    end = performance.now();
                    nativeTime = end - start;
                    start = performance.now();
                    result = sha2_256_sync(data);
                    end = performance.now();
                    jsTime = end - start;
                    __hasNativeSupport = __hasNativeSupport && uint8ArrayEq(nativeRestult, result);
                    return [
                        2 /*return*/ ,
                        [
                            nativeTime,
                            jsTime
                        ]
                    ];
                case 3:
                    _b = _c.sent();
                    __hasNativeSupport = false;
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 4:
                    return [
                        2 /*return*/ ,
                        [
                            50,
                            1
                        ]
                    ];
            }
        });
    });
}
var _support_was_tested = false;
function _test_support() {
    return __awaiter(this, void 0, void 0, function() {
        var repeatArr, eqU8Arr_1, bench, sum, _a;
        return __generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    if (_support_was_tested || !__hasNativeSupport) return [
                        2 /*return*/ 
                    ];
                    _b.label = 1;
                case 1:
                    _b.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    repeatArr = function(arr, n) {
                        for(var i = 0; i < n; i++)arr = arr.concat.apply(arr, __spreadArray([], __read(arr), false));
                        return arr;
                    };
                    eqU8Arr_1 = function(a, b) {
                        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) return false;
                        if (a.length !== b.length) return false;
                        for(var i = 0; i < a.length; i++)if (a[i] !== b[i]) return false;
                        return true;
                    };
                    return [
                        4 /*yield*/ ,
                        Promise.all(repeatArr([
                            new Uint8Array(0),
                            new Uint8Array(10),
                            new Uint8Array([
                                0xde,
                                0xad,
                                0xbe,
                                0xef
                            ]),
                            new Uint8Array(repeatArr([
                                0xaa
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xbb
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xcc
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xdd
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xee
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xff
                            ], 20)),
                            new Uint8Array(repeatArr([
                                0xaa,
                                0xbb
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xbb,
                                0xcc
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xcc,
                                0xdd
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xdd,
                                0xee
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xee,
                                0xff
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xff,
                                0x00
                            ], 33)),
                            new Uint8Array(repeatArr([
                                0xde,
                                0xad,
                                0xbe,
                                0xef
                            ], 30))
                        ], 10).map(function(data) {
                            return _test(data, eqU8Arr_1);
                        }))
                    ];
                case 2:
                    bench = _b.sent();
                    if (!__hasNativeSupport) return [
                        2 /*return*/ 
                    ];
                    sum = bench.reduce(function(acc, _a) {
                        var _b = __read(_a, 2), native = _b[0], js = _b[1];
                        acc[0] += native;
                        acc[1] += js;
                        return acc;
                    }, [
                        0,
                        0
                    ]);
                    __hasNativeSupport = __hasNativeSupport && sum[0] < sum[1];
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 3:
                    _a = _b.sent();
                    __hasNativeSupport = false;
                    _support_was_tested = true;
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 4:
                    _support_was_tested = true;
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}
if (__hasNativeSupport) {
    _test_support();
} else {
    _support_was_tested = true;
}
/**
 * There are cases where `globalThis.crypto.subtle` is fully defined
 * but the algorithm `Ed25519` is NOT SUPPORTED.
 *
 * unfortunately, there is NO WAY to check this syncronously.
 */ function ensureNativeSupport() {
    return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    if (!__hasNativeSupport) return [
                        2 /*return*/ ,
                        false
                    ];
                    return [
                        4 /*yield*/ ,
                        _test_support()
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ ,
                        __hasNativeSupport
                    ];
            }
        });
    });
}
/**
 * Pad a bytearray so its size is a multiple of 64 (512 bits).
 * Internal method.
 */ function pad(src) {
    var nBits = src.length * 8;
    var finalLen = src.length;
    // dst = src.slice();
    // dst.push(0x80);
    finalLen++;
    var nZeroes = 64 - (src.length + 1) % 64 - 8;
    if (nZeroes < 0) {
        nZeroes += 64;
    }
    // for (let i = 0; i < nZeroes; i++) {
    //     dst.push(0);
    // }
    finalLen += nZeroes;
    // assume nBits fits in 32 bits
    // dst.push(0);
    // dst.push(0);
    // dst.push(0);
    // dst.push(0);
    // dst.push( ((nBits >> 24) & 0xff) as byte);
    // dst.push( ((nBits >> 16) & 0xff) as byte);
    // dst.push( ((nBits >> 8)  & 0xff) as byte);
    // dst.push( ((nBits >> 0)  & 0xff) as byte);
    finalLen += 8;
    var dst = new Uint8Array(finalLen);
    dst.set(src);
    dst[src.length] = 0x80;
    dst[finalLen - 4] = nBits >>> 24 & 0xff;
    dst[finalLen - 3] = nBits >>> 16 & 0xff;
    dst[finalLen - 2] = nBits >>> 8 & 0xff;
    dst[finalLen - 1] = nBits & 0xff;
    return dst;
}
var k = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
];
function sigma0(x) {
    return (0, rotr32_1.rotr32)(x, 7) ^ (0, rotr32_1.rotr32)(x, 18) ^ x >>> 3;
}
function sigma1(x) {
    return (0, rotr32_1.rotr32)(x, 17) ^ (0, rotr32_1.rotr32)(x, 19) ^ x >>> 10;
}
var initialHash = new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
/**
 * getulates sha2-256 (32bytes) hash of a list of uint8 numbers.
 * Result is also a list of uint8 number.
 * @example
 * bytesToHex(sha2_256([0x61, 0x62, 0x63])) => "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
 * @example
 * sha2_256(textToBytes("Hello, World!")) => [223, 253, 96, 33, 187, 43, 213, 176, 175, 103, 98, 144, 128, 158, 195, 165, 49, 145, 221, 129, 199, 247, 10, 75, 40, 104, 138, 54, 33, 130, 152, 111]
 * @param {uint5[]} bytes - list of uint8 numbers
 * @returns {number[]} - list of uint8 numbers
 */ function sha2_256_sync(_bytes) {
    if (!(_bytes instanceof Uint8Array)) _bytes = new Uint8Array(_bytes);
    if (_bytes instanceof ArrayBuffer) _bytes = new Uint8Array(_bytes);
    /**
     * Initial hash (updated during compression phase)
     */ var hash = initialHash.slice();
    var bytes = pad(_bytes);
    // break message in successive 64 byte chunks
    for(var chunkStart = 0; chunkStart < bytes.length; chunkStart += 64){
        var chunk = Uint8Array.prototype.slice.call(bytes, chunkStart, chunkStart + 64);
        // bytes.slice(chunkStart, chunkStart + 64);
        var w = new Int32Array(64); // (new Array(64)).fill(0); // array of 32 bit numbers!
        // copy chunk into first 16 positions of w
        for(var i = 0; i < 16; i++){
            w[i] = chunk[i * 4 + 0] << 24 | chunk[i * 4 + 1] << 16 | chunk[i * 4 + 2] << 8 | chunk[i * 4 + 3];
        }
        // this DOES NOT WORK
        // w.set( new Int32Array( chunk.buffer, chunk.byteOffset, 16 ) );
        // extends the first 16 positions into the remaining 48 positions
        for(var i = 16; i < 64; i++){
            w[i] = w[i - 16] + sigma0(w[i - 15]) + w[i - 7] + sigma1(w[i - 2]) | 0;
        }
        // intialize working variables to current hash value
        var a = hash[0];
        var b = hash[1];
        var c = hash[2];
        var d = hash[3];
        var e = hash[4];
        var f = hash[5];
        var g = hash[6];
        var h = hash[7];
        // compression function main loop
        for(var i = 0; i < 64; i++){
            var S1 = (0, rotr32_1.rotr32)(e, 6) ^ (0, rotr32_1.rotr32)(e, 11) ^ (0, rotr32_1.rotr32)(e, 25);
            var ch = e & f ^ ~e & g;
            var temp1 = h + S1 + ch + k[i] + w[i] | 0;
            var S0 = (0, rotr32_1.rotr32)(a, 2) ^ (0, rotr32_1.rotr32)(a, 13) ^ (0, rotr32_1.rotr32)(a, 22);
            var maj = a & b ^ a & c ^ b & c;
            var temp2 = S0 + maj | 0;
            h = g;
            g = f;
            f = e;
            e = d + temp1 | 0;
            d = c;
            c = b;
            b = a;
            a = temp1 + temp2 | 0;
        }
        // update the hash
        hash[0] = hash[0] + a | 0;
        hash[1] = hash[1] + b | 0;
        hash[2] = hash[2] + c | 0;
        hash[3] = hash[3] + d | 0;
        hash[4] = hash[4] + e | 0;
        hash[5] = hash[5] + f | 0;
        hash[6] = hash[6] + g | 0;
        hash[7] = hash[7] + h | 0;
    }
    // produce the final digest of uint8 numbers
    var result = new Uint8Array(32);
    for(var i = 0; i < 8; i++){
        var item = hash[i];
        // result.push( ((item >> 24) & 0xff) as byte );
        // result.push( ((item >> 16) & 0xff) as byte );
        // result.push( ((item >>  8) & 0xff) as byte );
        // result.push( ((item >>  0) & 0xff) as byte );
        var i4 = i * 4;
        result[i4] = item >>> 24 & 0xff;
        result[i4 + 1] = item >>> 16 & 0xff;
        result[i4 + 2] = item >>> 8 & 0xff;
        result[i4 + 3] = item & 0xff;
    }
    return result;
}
exports.sha2_256_sync = sha2_256_sync;
function wrapped_sha2_256_sync(data) {
    return Promise.resolve(sha2_256_sync(data));
}
exports.sha2_256 = __hasNativeSupport ? nativeSha2_256 : wrapped_sha2_256_sync;
exports.hasNativeSha2_256 = exports.sha2_256 === nativeSha2_256;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/sha3.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha3 = void 0;
var types_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var types_2 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)");
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var assert_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/assert.js [app-client] (ecmascript)");
/**
 * state width (1600 bits, )
 */ var WIDTH = 200;
/**
 * rate (1088 bits, 136 bytes)
 */ var RATE = 136;
/**
 * capacity
 */ var CAP = WIDTH - RATE;
/**
 * Apply 1000...1 padding until size is multiple of r.
 * If already multiple of r then add a whole block of padding.
 * @param {number[]} src - list of uint8 numbers
 * @returns {number[]} - list of uint8 numbers
 */ function pad(src) {
    var dst = src.slice();
    var nZeroes = RATE - 2 - dst.length % RATE;
    if (nZeroes < -1) {
        nZeroes += RATE - 2;
    }
    if (nZeroes == -1) {
        dst.push(0x86);
    } else {
        dst.push(0x06);
        for(var i = 0; i < nZeroes; i++){
            dst.push(0);
        }
        dst.push(0x80);
    }
    (0, assert_1.assert)(dst.length % RATE === 0, "wrong destination length");
    return dst;
}
/**
 * 24 numbers used in the sha3 permute function
 */ var OFFSETS = Object.freeze([
    6,
    12,
    18,
    24,
    3,
    9,
    10,
    16,
    22,
    1,
    7,
    13,
    19,
    20,
    4,
    5,
    11,
    17,
    23,
    2,
    8,
    14,
    15,
    21
]);
/**
 * 24 numbers used in the sha3 permute function
 */ var SHIFTS = Object.freeze([
    -12,
    -11,
    21,
    14,
    28,
    20,
    3,
    -13,
    -29,
    1,
    6,
    25,
    8,
    18,
    27,
    -4,
    10,
    15,
    -24,
    -30,
    -23,
    -7,
    -9,
    2
]);
/**
 * Round constants used in the sha3 permute function
 */ var RC = Object.freeze([
    (0, types_2.uint64)("0x0000000000000001"),
    (0, types_2.uint64)("0x0000000000008082"),
    (0, types_2.uint64)("0x800000000000808a"),
    (0, types_2.uint64)("0x8000000080008000"),
    (0, types_2.uint64)("0x000000000000808b"),
    (0, types_2.uint64)("0x0000000080000001"),
    (0, types_2.uint64)("0x8000000080008081"),
    (0, types_2.uint64)("0x8000000000008009"),
    (0, types_2.uint64)("0x000000000000008a"),
    (0, types_2.uint64)("0x0000000000000088"),
    (0, types_2.uint64)("0x0000000080008009"),
    (0, types_2.uint64)("0x000000008000000a"),
    (0, types_2.uint64)("0x000000008000808b"),
    (0, types_2.uint64)("0x800000000000008b"),
    (0, types_2.uint64)("0x8000000000008089"),
    (0, types_2.uint64)("0x8000000000008003"),
    (0, types_2.uint64)("0x8000000000008002"),
    (0, types_2.uint64)("0x8000000000000080"),
    (0, types_2.uint64)("0x000000000000800a"),
    (0, types_2.uint64)("0x800000008000000a"),
    (0, types_2.uint64)("0x8000000080008081"),
    (0, types_2.uint64)("0x8000000000008080"),
    (0, types_2.uint64)("0x0000000080000001"),
    (0, types_2.uint64)("0x8000000080008008")
]);
function permute(s) {
    var c = new Array(5);
    var b = new Array(25);
    for(var round = 0; round < 24; round++){
        for(var i = 0; i < 5; i++){
            c[i] = (0, types_2.uint64)(s[i] ^ s[i + 5] ^ s[i + 10] ^ s[i + 15] ^ s[i + 20]);
        }
        for(var i = 0; i < 5; i++){
            var tmp = (0, types_2.uint64)(c[(i + 4) % 5] ^ (0, types_2.uint64Rotr)(c[(i + 1) % 5], 63));
            for(var j = 0; j < 5; j++){
                s[i + 5 * j] = (0, types_2.uint64)(s[i + 5 * j] ^ tmp);
            }
        }
        b[0] = s[0];
        for(var i = 1; i < 25; i++){
            var offset = OFFSETS[i - 1];
            var left = Math.abs(SHIFTS[i - 1]);
            var right = 32 - left;
            if (SHIFTS[i - 1] < 0) {
                b[i] = (0, types_2.uint64Rotr)(s[offset], right);
            } else {
                b[i] = (0, types_2.uint64Rotr)(s[offset], right + 32);
            }
        }
        for(var i = 0; i < 5; i++){
            for(var j = 0; j < 5; j++){
                s[i * 5 + j] = (0, types_2.uint64)(b[i * 5 + j] ^ ~b[i * 5 + (j + 1) % 5] & b[i * 5 + (j + 2) % 5]);
            }
        }
        s[0] = s[0] ^ RC[round];
    }
}
/**
 * getulates sha3-256 (32bytes) hash of a list of uint8 numbers.
 * Result is also a list of uint8 number.
 * Sha3 only bit-wise operations, so 64-bit operations can easily be replicated using 2 32-bit operations instead
 * @example
 * bytesToHex(sha3(textToBytes("abc"))) => "3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532"
 * @example
 * bytesToHex(sha3((new Array(136)).fill(1))) => "b36dc2167c4d9dda1a58b87046c8d76a6359afe3612c4de8a38857e09117b2db"
 * @example
 * bytesToHex(sha3((new Array(135)).fill(2))) => "5bdf5d815d29a9d7161c66520efc17c2edd7898f2b99a029e8d2e4ff153407f4"
 * @example
 * bytesToHex(sha3((new Array(134)).fill(3))) => "8e6575663dfb75a88f94a32c5b363c410278b65020734560d968aadd6896a621"
 * @example
 * bytesToHex(sha3((new Array(137)).fill(4))) => "f10b39c3e455006aa42120b9751faa0f35c821211c9d086beb28bf3c4134c6c6"
 */ function sha3(bytes) {
    if ((0, uint8array_utils_1.isUint8Array)(bytes)) {
        bytes = (0, types_1.buffToByteArr)(bytes);
    }
    bytes = pad(bytes);
    // initialize the state
    var state = new Array(WIDTH / 8).fill((0, types_2.uint64)(0));
    for(var chunkStart = 0; chunkStart < bytes.length; chunkStart += RATE){
        // extend the chunk to become length WIDTH
        var chunk = bytes.slice(chunkStart, chunkStart + RATE).concat(new Array(CAP).fill(0));
        // element-wise xor with 'state'
        for(var i = 0; i < WIDTH; i += 8){
            state[i / 8] = (0, types_2.uint64)(state[i / 8] ^ (0, types_2.uint64)("0x" + (0, types_2.byteArrToHex)(chunk.slice(i, i + 8).reverse())));
        // beware: a uint32 is stored as little endian, but a pair of uint32s that form a uin64 are stored in big endian format!
        //state[i/4] ^= (chunk[i] << 0) | (chunk[i+1] << 8) | (chunk[i+2] << 16) | (chunk[i+3] << 24);
        }
        // apply block permutations
        permute(state);
    }
    var hash = [];
    for(var i = 0; i < 4; i++){
        hash.push.apply(hash, __spreadArray([], __read((0, types_2.uint64ToBytesLE)(state[i])), false));
    }
    return hash;
}
exports.sha3 = sha3;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/utils/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/base32.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/positiveMod.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/rotr32.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/curves.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.negate_scalar = exports.pack_unpacked_scalar = exports.unpacked_scalar_from_bytes_wide = exports.unpack_scalar = exports.add_scalars = exports.mul_scalars = exports.scalar_from_bytes_mod_order_wide = exports.scalar_from_u64 = exports.ProjectivePoint = exports.CompletedPoint = exports.decompressCompressedEdwardsY = exports.LookupTableProjectiveNielsPoint = exports.ProjectiveNielsPoint = exports.ED25519_BASEPOINT_POINT = exports.EdwardsPoint = exports.MontgomeryPoint = exports.FieldElem51 = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
function load8(bytes, offset) {
    var dataView = bytes instanceof DataView ? bytes : new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    return dataView.getBigUint64(offset, true);
}
var _0n = BigInt(0);
var _1n = BigInt(1);
var _51n = BigInt(51);
var _52n = BigInt(52);
var _64n = BigInt(64);
var LOW_51_BIT_MASK = (_1n << _51n) - _1n;
var LOW_52_BIT_MASK = (_1n << _52n) - _1n;
var LOW_64_BIT_MASK = (_1n << _64n) - _1n;
function innerConditionalAssign(self, other, choice) {
    // if choice = 0, mask = (-0) = 0000...0000
    // if choice = 1, mask = (-1) = 1111...1111
    // return self ^ ( choice ? ( self ^ other ) : _0n );
    // const mask = choice ? (_1n << _64n) - _1n : _0n;
    // return self ^ ( mask & ( self ^ other ) );
    return choice ? other : self;
}
var FieldElem51 = function() {
    function FieldElem51(bytes) {
        this.bytes = bytes;
    }
    FieldElem51.zero = function() {
        return new FieldElem51(new BigUint64Array([
            _0n,
            _0n,
            _0n,
            _0n,
            _0n
        ]));
    };
    FieldElem51.one = function() {
        return new FieldElem51(new BigUint64Array([
            _1n,
            _0n,
            _0n,
            _0n,
            _0n
        ]));
    };
    /*
    /// Construct -1.
    pub fn minus_one() -> FieldElem51 {
        FieldElem51([2251799813685228, 2251799813685247, 2251799813685247, 2251799813685247, 2251799813685247])
    }
    */ FieldElem51.minus_one = function() {
        return new FieldElem51(new BigUint64Array([
            BigInt("2251799813685228"),
            BigInt("2251799813685247"),
            BigInt("2251799813685247"),
            BigInt("2251799813685247"),
            BigInt("2251799813685247")
        ]));
    };
    Object.defineProperty(FieldElem51, "EDWARDS_D", {
        get: function() {
            return new FieldElem51(new BigUint64Array([
                BigInt("929955233495203"),
                BigInt("466365720129213"),
                BigInt("1662059464998953"),
                BigInt("2033849074728123"),
                BigInt("1442794654840575")
            ]));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FieldElem51, "EDWARDS_D2", {
        get: function() {
            return new FieldElem51(new BigUint64Array([
                BigInt("1859910466990425"),
                BigInt("932731440258426"),
                BigInt("1072319116312658"),
                BigInt("1815898335770999"),
                BigInt("633789495995903")
            ]));
        },
        enumerable: false,
        configurable: true
    });
    FieldElem51.fromBytes = function(bytes) {
        var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        return new FieldElem51(new BigUint64Array([
            load8(dataView, 0) & LOW_51_BIT_MASK,
            load8(dataView, 6) >> BigInt(3) & LOW_51_BIT_MASK,
            load8(dataView, 12) >> BigInt(6) & LOW_51_BIT_MASK,
            load8(dataView, 19) >> BigInt(1) & LOW_51_BIT_MASK,
            load8(dataView, 24) >> BigInt(12) & LOW_51_BIT_MASK
        ]));
    };
    /*
    #[allow(unused)]
    pub(crate) fn elligator_encode(r_0: &FieldElement) -> MontgomeryPoint {
        let one = FieldElement::one();
        let d_1 = &one + &r_0.square2(); / * 2r^2 * /
    
        let d = &MONTGOMERY_A_NEG * &(d_1.invert()); // * A/(1+2r^2) * /
    
        let d_sq = &d.square();
        let au = &MONTGOMERY_A * &d;
    
        let inner = &(d_sq + &au) + &one;
        let eps = &d * &inner; // * eps = d^3 + Ad^2 + d * /
    
        let (eps_is_sq, _eps) = FieldElement::sqrt_ratio_i(&eps, &one);
    
        let zero = FieldElement::zero();
        let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare* /
        let mut u = &d + &Atemp; /* d, or d+A if nonsquare * /
        u.conditional_negate(!eps_is_sq); /* d, or -d-A if nonsquare * /
    
        MontgomeryPoint(u.to_bytes())
    }
    */ FieldElem51.elligator_encode = function(r_0) {
        var one = FieldElem51.one();
        var d_1 = one.add(r_0.square2());
        // const d = d_1.invert().mul( FieldElem51.fromBytes( new Uint8Array( 32 ) ) );
        var d = FieldElem51.MONTGOMERY_A_NEG.mul(d_1.invert());
        var MONTGOMERY_A = FieldElem51.MONTGOMERY_A;
        var d_sq = d.square();
        var au = MONTGOMERY_A.mul(d);
        var inner = d_sq.add(au).add(one);
        var eps = d.mul(inner);
        var _a = __read(FieldElem51.sqrt_ratio_i(eps, one), 2), eps_is_sq = _a[0], _eps = _a[1];
        var zero = FieldElem51.zero();
        // let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare*/
        var Atemp = FieldElem51.conditional_select(MONTGOMERY_A, zero, eps_is_sq);
        var u = d.add(Atemp);
        u.conditional_negate(!eps_is_sq);
        return new MontgomeryPoint(u.toBytes());
    };
    FieldElem51.elligator_encode_var_time = function(r_0) {
        var one = FieldElem51.one();
        var d_1 = one.add(r_0.square2());
        // const d = d_1.invert().mul( FieldElem51.fromBytes( new Uint8Array( 32 ) ) );
        var d = FieldElem51.MONTGOMERY_A_NEG.mul(d_1.invert());
        var MONTGOMERY_A = FieldElem51.MONTGOMERY_A;
        var d_sq = d.square();
        var au = MONTGOMERY_A.mul(d);
        var inner = d_sq.add(au).add(one);
        var eps = d.mul(inner);
        var _a = __read(FieldElem51.sqrt_ratio_i(eps, one), 2), eps_is_sq = _a[0], _eps = _a[1];
        var zero = FieldElem51.zero();
        // let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare*/
        var Atemp = FieldElem51.conditional_select(MONTGOMERY_A, zero, eps_is_sq);
        var u = d.add(Atemp);
        u.conditional_negate(!eps_is_sq);
        return new MontgomeryPoint(u.toBytes());
    };
    /*
    fn conditional_select(
        a: &FieldElement51,
        b: &FieldElement51,
        choice: Choice,
    ) -> FieldElement51 {
        FieldElement51([
            u64::conditional_select(&a.0[0], &b.0[0], choice),
            u64::conditional_select(&a.0[1], &b.0[1], choice),
            u64::conditional_select(&a.0[2], &b.0[2], choice),
            u64::conditional_select(&a.0[3], &b.0[3], choice),
            u64::conditional_select(&a.0[4], &b.0[4], choice),
        ])
    }
        // u64::conditional_select(&a.0[0], &b.0[0], choice),
        #[inline]
            fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                // if choice = 0, mask = (-0) = 0000...0000
                // if choice = 1, mask = (-1) = 1111...1111
                let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                a ^ (mask & (a ^ b))
            }
    */ FieldElem51.conditional_select = function(a, b, choice) {
        var mask = choice ? LOW_64_BIT_MASK : _0n;
        var a_bytes = a.bytes;
        var b_bytes = b.bytes;
        return new FieldElem51(new BigUint64Array([
            a_bytes[0] ^ mask & (a_bytes[0] ^ b_bytes[0]),
            a_bytes[1] ^ mask & (a_bytes[1] ^ b_bytes[1]),
            a_bytes[2] ^ mask & (a_bytes[2] ^ b_bytes[2]),
            a_bytes[3] ^ mask & (a_bytes[3] ^ b_bytes[3]),
            a_bytes[4] ^ mask & (a_bytes[4] ^ b_bytes[4])
        ]));
    };
    Object.defineProperty(FieldElem51, "MONTGOMERY_A_NEG", {
        get: function() {
            return new FieldElem51(new BigUint64Array([
                BigInt("2251799813198567"),
                BigInt("2251799813685247"),
                BigInt("2251799813685247"),
                BigInt("2251799813685247"),
                BigInt("2251799813685247")
            ]));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FieldElem51, "MONTGOMERY_A", {
        get: function() {
            return new FieldElem51(new BigUint64Array([
                BigInt("486662"),
                _0n,
                _0n,
                _0n,
                _0n
            ]));
        },
        enumerable: false,
        configurable: true
    });
    FieldElem51.prototype.pow2k = function(k) {
        /*
        pub fn pow2k(&self, mut k: u32) -> FieldElem51 {

        debug_assert!( k > 0 );

        /// Multiply two 64-bit integers with 128 bits of output.
        #[inline(always)]
        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }

        let mut a: [u64; 5] = self.0;

        loop {
            // Precondition: assume input limbs a[i] are bounded as
            //
            // a[i] < 2^(51 + b)
            //
            // where b is a real parameter measuring the "bit excess" of the limbs.

            // Precomputation: 64-bit multiply by 19.
            //
            // This fits into a u64 whenever 51 + b + lg(19) < 64.
            //
            // Since 51 + b + lg(19) < 51 + 4.25 + b
            //                       = 55.25 + b,
            // this fits if b < 8.75.
            let a3_19 = 19 * a[3];
            let a4_19 = 19 * a[4];

            // Multiply to get 128-bit coefficients of output.
            //
            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,
            // which doesn't seem any better or worse than doing them as precomputations
            // on the 64-bit inputs.
            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );
            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );
            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );
            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );
            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );

            // Same bound as in multiply:
            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)
            //         < 2^(102 + lg(1 + 4*19) + 2*b)
            //         < 2^(108.27 + 2*b)
            //
            // The carry (c[i] >> 51) fits into a u64 when
            //    108.27 + 2*b - 51 < 64
            //    2*b < 6.73
            //    b < 3.365.
            //
            // So we require b < 3 to ensure this fits.
            debug_assert!(a[0] < (1 << 54));
            debug_assert!(a[1] < (1 << 54));
            debug_assert!(a[2] < (1 << 54));
            debug_assert!(a[3] < (1 << 54));
            debug_assert!(a[4] < (1 << 54));

            const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;

            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so
            // that the addition is a u128 + u64 rather than u128 + u128.
            c1 += ((c0 >> 51) as u64) as u128;
            a[0] = (c0 as u64) & LOW_51_BIT_MASK;

            c2 += ((c1 >> 51) as u64) as u128;
            a[1] = (c1 as u64) & LOW_51_BIT_MASK;

            c3 += ((c2 >> 51) as u64) as u128;
            a[2] = (c2 as u64) & LOW_51_BIT_MASK;

            c4 += ((c3 >> 51) as u64) as u128;
            a[3] = (c3 as u64) & LOW_51_BIT_MASK;

            let carry: u64 = (c4 >> 51) as u64;
            a[4] = (c4 as u64) & LOW_51_BIT_MASK;

            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.
            //
            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)
            //    < 2^(102 + 2*b + lg(5)) + 2^64.
            //
            // When b < 3 we get
            //
            // c4 < 2^110.33  so that carry < 2^59.33
            //
            // so that
            //
            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58
            //
            // and there is no overflow.
            a[0] = a[0] + carry * 19;

            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).
            a[1] += a[0] >> 51;
            a[0] &= LOW_51_BIT_MASK;

            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).

            k = k - 1;
            if k == 0 {
                break;
            }
        }

        FieldElem51(a)
    }
        */ k = Math.abs(k);
        var a = this.bytes.slice();
        while(true){
            var a3_19 = BigInt(19) * a[3];
            var a4_19 = BigInt(19) * a[4];
            var c0 = a[0] * a[0] + BigInt(2) * (a[1] * a4_19 + a[2] * a3_19);
            var c1 = a[3] * a3_19 + BigInt(2) * (a[0] * a[1] + a[2] * a4_19);
            var c2 = a[1] * a[1] + BigInt(2) * (a[0] * a[2] + a[4] * a3_19);
            var c3 = a[4] * a4_19 + BigInt(2) * (a[0] * a[3] + a[1] * a[2]);
            var c4 = a[2] * a[2] + BigInt(2) * (a[0] * a[4] + a[1] * a[3]);
            c1 += c0 >> _51n;
            a[0] = c0 & LOW_51_BIT_MASK;
            c2 += c1 >> _51n;
            a[1] = c1 & LOW_51_BIT_MASK;
            c3 += c2 >> _51n;
            a[2] = c2 & LOW_51_BIT_MASK;
            c4 += c3 >> _51n;
            a[3] = c3 & LOW_51_BIT_MASK;
            var carry = c4 >> _51n;
            a[4] = c4 & LOW_51_BIT_MASK;
            a[0] = a[0] + carry * BigInt(19);
            a[1] += a[0] >> _51n;
            a[0] &= LOW_51_BIT_MASK;
            k = k - 1;
            if (k === 0) break;
        }
        return new FieldElem51(a);
    };
    FieldElem51.prototype.square2 = function() {
        var square = this.pow2k(1);
        // for i in 0..5 {
        //     square.0[i] *= 2;
        // }
        for(var i = 0; i < 5; i++){
            square.bytes[i] *= BigInt(2);
        }
        return square;
    };
    /*
    fn add_assign(&mut self, _rhs: &'b FieldElem51) {
        for i in 0..5 {
            self.0[i] += _rhs.0[i];
        }
    }
    add(self, _rhs: &'b FieldElem51) -> FieldElem51 {
        let mut output = *self;
        output += _rhs;
        output
    }
    */ FieldElem51.prototype.add = function(_rhs) {
        var output = this.bytes.slice();
        for(var i = 0; i < 5; i++){
            output[i] += _rhs.bytes[i];
        }
        return new FieldElem51(output);
    };
    /*
    /// Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).
    #[inline(always)]
    fn reduce(mut limbs: [u64; 5]) -> FieldElem51 {
        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;

        // Since the input limbs are bounded by 2^64, the biggest
        // carry-out is bounded by 2^13.
        //
        // The biggest carry-in is c4 * 19, resulting in
        //
        // 2^51 + 19*2^13 < 2^51.0000000001
        //
        // Because we don't need to canonicalize, only to reduce the
        // limb sizes, it's OK to do a "weak reduction", where we
        // compute the carry-outs in parallel.

        let c0 = limbs[0] >> 51;
        let c1 = limbs[1] >> 51;
        let c2 = limbs[2] >> 51;
        let c3 = limbs[3] >> 51;
        let c4 = limbs[4] >> 51;

        limbs[0] &= LOW_51_BIT_MASK;
        limbs[1] &= LOW_51_BIT_MASK;
        limbs[2] &= LOW_51_BIT_MASK;
        limbs[3] &= LOW_51_BIT_MASK;
        limbs[4] &= LOW_51_BIT_MASK;

        limbs[0] += c4 * 19;
        limbs[1] += c0;
        limbs[2] += c1;
        limbs[3] += c2;
        limbs[4] += c3;

        FieldElem51(limbs)
    }
    */ FieldElem51.reduce = function(limbs) {
        var c0 = limbs[0] >> _51n;
        var c1 = limbs[1] >> _51n;
        var c2 = limbs[2] >> _51n;
        var c3 = limbs[3] >> _51n;
        var c4 = limbs[4] >> _51n;
        limbs[0] &= LOW_51_BIT_MASK;
        limbs[1] &= LOW_51_BIT_MASK;
        limbs[2] &= LOW_51_BIT_MASK;
        limbs[3] &= LOW_51_BIT_MASK;
        limbs[4] &= LOW_51_BIT_MASK;
        limbs[0] += c4 * BigInt(19);
        limbs[1] += c0;
        limbs[2] += c1;
        limbs[3] += c2;
        limbs[4] += c3;
        return new FieldElem51(limbs);
    };
    /*
    fn sub_assign(&mut self, _rhs: &'b FieldElem51) {
        let result = (self as &FieldElem51) - _rhs;
        self.0 = result.0;
    }
    type Output = FieldElem51;
    fn sub(self, _rhs: &'b FieldElem51) -> FieldElem51 {
        // To avoid underflow, first add a multiple of p.
        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.
        //
        // If we could statically track the bitlengths of the limbs
        // of every FieldElem51, we could choose a multiple of p
        // just bigger than _rhs and avoid having to do a reduction.
        //
        // Since we don't yet have type-level integers to do this, we
        // have to add an explicit reduction call here.
        FieldElem51::reduce([
            (self.0[0] + 36028797018963664u64) - _rhs.0[0],
            (self.0[1] + 36028797018963952u64) - _rhs.0[1],
            (self.0[2] + 36028797018963952u64) - _rhs.0[2],
            (self.0[3] + 36028797018963952u64) - _rhs.0[3],
            (self.0[4] + 36028797018963952u64) - _rhs.0[4],
        ])
    }
    */ FieldElem51.prototype.sub = function(_rhs) {
        return FieldElem51.reduce(new BigUint64Array([
            this.bytes[0] + BigInt("36028797018963664") - _rhs.bytes[0],
            this.bytes[1] + BigInt("36028797018963952") - _rhs.bytes[1],
            this.bytes[2] + BigInt("36028797018963952") - _rhs.bytes[2],
            this.bytes[3] + BigInt("36028797018963952") - _rhs.bytes[3],
            this.bytes[4] + BigInt("36028797018963952") - _rhs.bytes[4]
        ]));
    };
    /*
    fn mul_assign(&mut self, _rhs: &'b FieldElem51) {
        let result = (self as &FieldElem51) * _rhs;
        self.0 = result.0;
    }
    type Output = FieldElem51;
    fn mul(self, _rhs: &'b FieldElem51) -> FieldElem51 {
        /// Helper function to multiply two 64-bit integers with 128
        /// bits of output.
        #[inline(always)]
        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }

        // Alias self, _rhs for more readable formulas
        let a: &[u64; 5] = &self.0;
        let b: &[u64; 5] = &_rhs.0;

        // Precondition: assume input limbs a[i], b[i] are bounded as
        //
        // a[i], b[i] < 2^(51 + b)
        //
        // where b is a real parameter measuring the "bit excess" of the limbs.

        // 64-bit precomputations to avoid 128-bit multiplications.
        //
        // This fits into a u64 whenever 51 + b + lg(19) < 64.
        //
        // Since 51 + b + lg(19) < 51 + 4.25 + b
        //                       = 55.25 + b,
        // this fits if b < 8.75.
        let b1_19 = b[1] * 19;
        let b2_19 = b[2] * 19;
        let b3_19 = b[3] * 19;
        let b4_19 = b[4] * 19;

        // Multiply to get 128-bit coefficients of output
        let     c0: u128 = m(a[0],b[0]) + m(a[4],b1_19) + m(a[3],b2_19) + m(a[2],b3_19) + m(a[1],b4_19);
        let mut c1: u128 = m(a[1],b[0]) + m(a[0],b[1])  + m(a[4],b2_19) + m(a[3],b3_19) + m(a[2],b4_19);
        let mut c2: u128 = m(a[2],b[0]) + m(a[1],b[1])  + m(a[0],b[2])  + m(a[4],b3_19) + m(a[3],b4_19);
        let mut c3: u128 = m(a[3],b[0]) + m(a[2],b[1])  + m(a[1],b[2])  + m(a[0],b[3])  + m(a[4],b4_19);
        let mut c4: u128 = m(a[4],b[0]) + m(a[3],b[1])  + m(a[2],b[2])  + m(a[1],b[3])  + m(a[0],b[4]);

        // How big are the c[i]? We have
        //
        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)
        //         < 2^(102 + lg(1 + 4*19) + 2*b)
        //         < 2^(108.27 + 2*b)
        //
        // The carry (c[i] >> 51) fits into a u64 when
        //    108.27 + 2*b - 51 < 64
        //    2*b < 6.73
        //    b < 3.365.
        //
        // So we require b < 3 to ensure this fits.
        debug_assert!(a[0] < (1 << 54)); debug_assert!(b[0] < (1 << 54));
        debug_assert!(a[1] < (1 << 54)); debug_assert!(b[1] < (1 << 54));
        debug_assert!(a[2] < (1 << 54)); debug_assert!(b[2] < (1 << 54));
        debug_assert!(a[3] < (1 << 54)); debug_assert!(b[3] < (1 << 54));
        debug_assert!(a[4] < (1 << 54)); debug_assert!(b[4] < (1 << 54));

        // Casting to u64 and back tells the compiler that the carry is
        // bounded by 2^64, so that the addition is a u128 + u64 rather
        // than u128 + u128.

        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;
        let mut out = [0u64; 5];

        c1 += ((c0 >> 51) as u64) as u128;
        out[0] = (c0 as u64) & LOW_51_BIT_MASK;

        c2 += ((c1 >> 51) as u64) as u128;
        out[1] = (c1 as u64) & LOW_51_BIT_MASK;

        c3 += ((c2 >> 51) as u64) as u128;
        out[2] = (c2 as u64) & LOW_51_BIT_MASK;

        c4 += ((c3 >> 51) as u64) as u128;
        out[3] = (c3 as u64) & LOW_51_BIT_MASK;

        let carry: u64 = (c4 >> 51) as u64;
        out[4] = (c4 as u64) & LOW_51_BIT_MASK;

        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.
        //
        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)
        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)
        //    < 2^(102 + 2*b + lg(5)) + 2^64.
        //
        // When b < 3 we get
        //
        // c4 < 2^110.33  so that carry < 2^59.33
        //
        // so that
        //
        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58
        //
        // and there is no overflow.
        out[0] = out[0] + carry * 19;

        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).
        out[1] += out[0] >> 51;
        out[0] &= LOW_51_BIT_MASK;

        // Now out[i] < 2^(51 + epsilon) for all i.
        FieldElem51(out)
    }
    */ FieldElem51.prototype.mul = function(_rhs) {
        var a = this.bytes.slice();
        var b = _rhs.bytes.slice();
        var b1_19 = b[1] * BigInt(19);
        var b2_19 = b[2] * BigInt(19);
        var b3_19 = b[3] * BigInt(19);
        var b4_19 = b[4] * BigInt(19);
        var c0 = a[0] * b[0] + a[4] * b1_19 + a[3] * b2_19 + a[2] * b3_19 + a[1] * b4_19;
        var c1 = a[1] * b[0] + a[0] * b[1] + a[4] * b2_19 + a[3] * b3_19 + a[2] * b4_19;
        var c2 = a[2] * b[0] + a[1] * b[1] + a[0] * b[2] + a[4] * b3_19 + a[3] * b4_19;
        var c3 = a[3] * b[0] + a[2] * b[1] + a[1] * b[2] + a[0] * b[3] + a[4] * b4_19;
        var c4 = a[4] * b[0] + a[3] * b[1] + a[2] * b[2] + a[1] * b[3] + a[0] * b[4];
        var out = new BigUint64Array(5);
        c1 += c0 >> _51n;
        out[0] = c0 & LOW_51_BIT_MASK;
        c2 += c1 >> _51n;
        out[1] = c1 & LOW_51_BIT_MASK;
        c3 += c2 >> _51n;
        out[2] = c2 & LOW_51_BIT_MASK;
        c4 += c3 >> _51n;
        out[3] = c3 & LOW_51_BIT_MASK;
        var carry = c4 >> _51n;
        out[4] = c4 & LOW_51_BIT_MASK;
        out[0] = out[0] + carry * BigInt(19);
        out[1] += out[0] >> _51n;
        out[0] &= LOW_51_BIT_MASK;
        return new FieldElem51(out);
    };
    /*
    pub fn invert(&self) -> FieldElement {
        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.
        //
        //                                 nonzero bits of exponent
        let (t19, t3) = self.pow22501();   // t19: 249..0 ; t3: 3,1,0
        let t20 = t19.pow2k(5);            // 254..5
        let t21 = &t20 * &t3;              // 254..5,3,1,0

        t21
    }
    */ FieldElem51.prototype.invert = function() {
        var _a = __read(this.pow22501(), 2), t19 = _a[0], t3 = _a[1];
        var t20 = t19.pow2k(5);
        var t21 = t20.mul(t3);
        return t21;
    };
    /*
    /// Compute (self^(2^250-1), self^11), used as a helper function
    /// within invert() and pow22523().
    fn pow22501(&self) -> (FieldElement, FieldElement) {
        // Instead of managing which temporary variables are used
        // for what, we define as many as we need and leave stack
        // allocation to the compiler
        //
        // Each temporary variable t_i is of the form (self)^e_i.
        // Squaring t_i corresponds to multiplying e_i by 2,
        // so the pow2k function shifts e_i left by k places.
        // Multiplying t_i and t_j corresponds to adding e_i + e_j.
        //
        // Temporary t_i                      Nonzero bits of e_i
        //
        let t0  = self.square();           // 1         e_0 = 2^1
        let t1  = t0.square().square();    // 3         e_1 = 2^3
        let t2  = self * &t1;              // 3,0       e_2 = 2^3 + 2^0
        let t3  = &t0 * &t2;               // 3,1,0
        let t4  = t3.square();             // 4,2,1
        let t5  = &t2 * &t4;               // 4,3,2,1,0
        let t6  = t5.pow2k(5);             // 9,8,7,6,5
        let t7  = &t6 * &t5;               // 9,8,7,6,5,4,3,2,1,0
        let t8  = t7.pow2k(10);            // 19..10
        let t9  = &t8 * &t7;               // 19..0
        let t10 = t9.pow2k(20);            // 39..20
        let t11 = &t10 * &t9;              // 39..0
        let t12 = t11.pow2k(10);           // 49..10
        let t13 = &t12 * &t7;              // 49..0
        let t14 = t13.pow2k(50);           // 99..50
        let t15 = &t14 * &t13;             // 99..0
        let t16 = t15.pow2k(100);          // 199..100
        let t17 = &t16 * &t15;             // 199..0
        let t18 = t17.pow2k(50);           // 249..50
        let t19 = &t18 * &t13;             // 249..0

        (t19, t3)
    }
    */ FieldElem51.prototype.pow22501 = function() {
        var t0 = this.square();
        var t1 = t0.square().square();
        var t2 = this.mul(t1);
        var t3 = t0.mul(t2);
        var t4 = t3.square();
        var t5 = t2.mul(t4);
        var t6 = t5.pow2k(5);
        var t7 = t6.mul(t5);
        var t8 = t7.pow2k(10);
        var t9 = t8.mul(t7);
        var t10 = t9.pow2k(20);
        var t11 = t10.mul(t9);
        var t12 = t11.pow2k(10);
        var t13 = t12.mul(t7);
        var t14 = t13.pow2k(50);
        var t15 = t14.mul(t13);
        var t16 = t15.pow2k(100);
        var t17 = t16.mul(t15);
        var t18 = t17.pow2k(50);
        var t19 = t18.mul(t13);
        return [
            t19,
            t3
        ];
    };
    /*
    pub fn square(&self) -> FieldElem51 {
        self.pow2k(1)
    }
    */ FieldElem51.prototype.square = function() {
        return this.pow2k(1);
    };
    /*
    /// Given `FieldElements` `u` and `v`, compute either `sqrt(u/v)`
    /// or `sqrt(i*u/v)` in constant time.
    ///
    /// This function always returns the nonnegative square root.
    ///
    /// # Return
    ///
    /// - `(Choice(1), +sqrt(u/v))  ` if `v` is nonzero and `u/v` is square;
    /// - `(Choice(1), zero)        ` if `u` is zero;
    /// - `(Choice(0), zero)        ` if `v` is zero and `u` is nonzero;
    /// - `(Choice(0), +sqrt(i*u/v))` if `u/v` is nonsquare (so `i*u/v` is square).
    ///
    pub fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (Choice, FieldElement) {
        // Using the same trick as in ed25519 decoding, we merge the
        // inversion, the square root, and the square test as follows.
        //
        // To compute sqrt(), we can compute  = ^((p+3)/8).
        // Then ^2 = , so multiplying  by sqrt(-1) if necessary
        // gives sqrt().
        //
        // To compute 1/sqrt(), we observe that
        //    1/ = ^(p-1 - (p+3)/8) = ^((7p-11)/8)
        //                            = ^3 * (^7)^((p-5)/8).
        //
        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)
        // by first computing
        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)
        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)
        //      = (uv^3) (uv^7)^((p-5)/8).
        //
        // If v is nonzero and u/v is square, then r^2 = u/v,
        //                                     so vr^2 = u.
        // If vr^2 =  u, then sqrt(u/v) = r.
        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).
        //
        // If v is zero, r is also zero.

        let v3 = &v.square()  * v;
        let v7 = &v3.square() * v;
        let mut r = &(u * &v3) * &(u * &v7).pow_p58();
        let check = v * &r.square();

        let i = &constants::SQRT_M1;

        let correct_sign_sqrt   = check.ct_eq(        u);
        let flipped_sign_sqrt   = check.ct_eq(     &(-u));
        let flipped_sign_sqrt_i = check.ct_eq(&(&(-u)*i));

        let r_prime = &constants::SQRT_M1 * &r;
        r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);

        // Choose the nonnegative square root.
        let r_is_negative = r.is_negative();
        r.conditional_negate(r_is_negative);

        let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;

        (was_nonzero_square, r)
    }
    */ FieldElem51.sqrt_ratio_i = function(u, v) {
        var v3 = v.square().mul(v);
        var v7 = v3.square().mul(v);
        var r = u.mul(v3).mul(u.mul(v7).pow_p58());
        var check = v.mul(r.square());
        var i = FieldElem51.SQRT_M1;
        var correct_sign_sqrt = check.ct_eq(u);
        var flipped_sign_sqrt = check.ct_eq(u.neg());
        var flipped_sign_sqrt_i = check.ct_eq(u.neg().mul(i));
        var r_prime = i.mul(r);
        r.conditional_assign(r_prime, flipped_sign_sqrt || flipped_sign_sqrt_i);
        // let r_is_negative = r.is_negative();
        r.conditional_negate(r.is_negative());
        var was_nonzero_square = correct_sign_sqrt || flipped_sign_sqrt;
        // `flipped_sign_sqrt_i` WAS NOT HERE IN THE ORIGINAL CODE
        // but otherwise I get the "Montgomery conversion to Edwards point in Elligator failed" error
        // || flipped_sign_sqrt_i;
        return [
            was_nonzero_square,
            r
        ];
    };
    /*
    pub fn is_negative(&self) -> Choice {
        let bytes = self.to_bytes();
        (bytes[0] & 1).into()
    }
    */ FieldElem51.prototype.is_negative = function() {
        return (this.toBytes()[0] & 1) === 1;
    };
    /*
    fn conditional_negate(&mut self, choice: Choice) {
        // Need to cast to eliminate mutability
        let self_neg: T = -(self as &T);
        self.conditional_assign(&self_neg, choice);
    }
    */ FieldElem51.prototype.conditional_negate = function(choice) {
        var self_neg = this.neg();
        return this.conditional_assign(self_neg, choice);
    // the above should have been the proper implementation
    // however it was NOT negating for some reason
    // this implementation should be equivalent to the intended implementation
    // with the exception that it is not constant
    // const self_neg = this.neg();
    // if( choice ) (this as any).bytes = self_neg.bytes;
    };
    /*
    // `Choice` is just a `boolean` in a `u8`
    fn conditional_assign(&mut self, other: &FieldElem51, choice: Choice) {
        inner_conditional_assign( self.0[0], (&other.0[0], choice));
        inner_conditional_assign( self.0[1], (&other.0[1], choice));
        inner_conditional_assign( self.0[2], (&other.0[2], choice));
        inner_conditional_assign( self.0[3], (&other.0[3], choice));
        inner_conditional_assign( self.0[4], (&other.0[4], choice));
    }
    #[inline]
    fn inner_conditional_assign(&mut self, other: &Self, choice: Choice) {
        // if choice = 0, mask = (-0) = 0000...0000
        // if choice = 1, mask = (-1) = 1111...1111
        let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
        *self ^= mask & (*self ^ *other);
    }
    */ FieldElem51.prototype.conditional_assign = function(other, choice) {
        this.bytes[0] = innerConditionalAssign(this.bytes[0], other.bytes[0], choice);
        this.bytes[1] = innerConditionalAssign(this.bytes[1], other.bytes[1], choice);
        this.bytes[2] = innerConditionalAssign(this.bytes[2], other.bytes[2], choice);
        this.bytes[3] = innerConditionalAssign(this.bytes[3], other.bytes[3], choice);
        this.bytes[4] = innerConditionalAssign(this.bytes[4], other.bytes[4], choice);
    // the above was giving problems
    // I'm not sure this is constant time
    // but it should at least be close to it
    // if( choice ) (this as any).bytes = other.bytes.slice();
    // else (this as any).bytes = this.bytes.slice();
    // return this;
    };
    FieldElem51.prototype.clone = function() {
        return new FieldElem51(this.bytes.slice());
    };
    /*
    fn neg(self) -> FieldElem51 {
        let mut output = *self;
        output.negate();
        output
    }
    */ FieldElem51.prototype.neg = function() {
        var output = this.clone();
        return output.negate();
    };
    /*
    pub fn negate(&mut self) {
        // See commentary in the Sub impl
        let neg = FieldElem51::reduce([
            36028797018963664u64 - self.0[0],
            36028797018963952u64 - self.0[1],
            36028797018963952u64 - self.0[2],
            36028797018963952u64 - self.0[3],
            36028797018963952u64 - self.0[4],
        ]);
        self.0 = neg.0;
    }
    */ FieldElem51.prototype.negate = function() {
        return FieldElem51.reduce(new BigUint64Array([
            BigInt("36028797018963664") - this.bytes[0],
            BigInt("36028797018963952") - this.bytes[1],
            BigInt("36028797018963952") - this.bytes[2],
            BigInt("36028797018963952") - this.bytes[3],
            BigInt("36028797018963952") - this.bytes[4]
        ]));
    };
    /*
    /// Test equality between two `FieldElement`s.  Since the
    /// internal representation is not canonical, the field elements
    /// are normalized to wire format before comparison.
    fn ct_eq(&self, other: &FieldElement) -> Choice {
        self.to_bytes().ct_eq(&other.to_bytes())
    }
    */ FieldElem51.prototype.ct_eq = function(other) {
        return (0, uint8array_utils_1.uint8ArrayEq)(this.toBytes(), other.toBytes());
    };
    Object.defineProperty(FieldElem51, "SQRT_M1", {
        get: function() {
            return new FieldElem51(new BigUint64Array([
                BigInt("1718705420411056"),
                BigInt("234908883556509"),
                BigInt("2233514472574048"),
                BigInt("2117202627021982"),
                BigInt("765476049583133")
            ]));
        },
        enumerable: false,
        configurable: true
    });
    /*
    /// Raise this field element to the power (p-5)/8 = 2^252 -3.
    fn pow_p58(&self) -> FieldElement {
        // The bits of (p-5)/8 are 101111.....11.
        //
        //                                 nonzero bits of exponent
        let (t19, _) = self.pow22501();    // 249..0
        let t20 = t19.pow2k(2);            // 251..2
        let t21 = self * &t20;             // 251..2,0

        t21
    }
    */ FieldElem51.prototype.pow_p58 = function() {
        var _a = __read(this.pow22501(), 2), t19 = _a[0], _ = _a[1];
        var t20 = t19.pow2k(2);
        var t21 = this.mul(t20);
        return t21;
    };
    /*
    // Serialize this `FieldElem51` to a 32-byte array.  The
    /// encoding is canonical.
    pub fn to_bytes(&self) -> [u8; 32] {
        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.
        //
        // Write h = pq + r with 0 <= r < p.
        //
        // We want to compute r = h mod p.
        //
        // If h < 2*p = 2^256 - 38,
        // then q = 0 or 1,
        //
        // with q = 0 when h < p
        //  and q = 1 when h >= p.
        //
        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.
        // Therefore q can be computed as the carry bit of h + 19.

        // First, reduce the limbs to ensure h < 2*p.
        let mut limbs = FieldElem51::reduce(self.0).0;

        let mut q = (limbs[0] + 19) >> 51;
        q = (limbs[1] + q) >> 51;
        q = (limbs[2] + q) >> 51;
        q = (limbs[3] + q) >> 51;
        q = (limbs[4] + q) >> 51;

        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q

        limbs[0] += 19*q;

        // Now carry the result to compute r + 19q ...
        let low_51_bit_mask = (1u64 << 51) - 1;
        limbs[1] +=  limbs[0] >> 51;
        limbs[0] = limbs[0] & low_51_bit_mask;
        limbs[2] +=  limbs[1] >> 51;
        limbs[1] = limbs[1] & low_51_bit_mask;
        limbs[3] +=  limbs[2] >> 51;
        limbs[2] = limbs[2] & low_51_bit_mask;
        limbs[4] +=  limbs[3] >> 51;
        limbs[3] = limbs[3] & low_51_bit_mask;
        // ... but instead of carrying (limbs[4] >> 51) = 2^255q
        // into another limb, discard it, subtracting the value
        limbs[4] = limbs[4] & low_51_bit_mask;

        // Now arrange the bits of the limbs.
        let mut s = [0u8;32];
        s[ 0] =   limbs[0]        as u8;
        s[ 1] =  (limbs[0] >>  8) as u8;
        s[ 2] =  (limbs[0] >> 16) as u8;
        s[ 3] =  (limbs[0] >> 24) as u8;
        s[ 4] =  (limbs[0] >> 32) as u8;
        s[ 5] =  (limbs[0] >> 40) as u8;
        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;
        s[ 7] =  (limbs[1] >>  5) as u8;
        s[ 8] =  (limbs[1] >> 13) as u8;
        s[ 9] =  (limbs[1] >> 21) as u8;
        s[10] =  (limbs[1] >> 29) as u8;
        s[11] =  (limbs[1] >> 37) as u8;
        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;
        s[13] =  (limbs[2] >>  2) as u8;
        s[14] =  (limbs[2] >> 10) as u8;
        s[15] =  (limbs[2] >> 18) as u8;
        s[16] =  (limbs[2] >> 26) as u8;
        s[17] =  (limbs[2] >> 34) as u8;
        s[18] =  (limbs[2] >> 42) as u8;
        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;
        s[20] =  (limbs[3] >>  7) as u8;
        s[21] =  (limbs[3] >> 15) as u8;
        s[22] =  (limbs[3] >> 23) as u8;
        s[23] =  (limbs[3] >> 31) as u8;
        s[24] =  (limbs[3] >> 39) as u8;
        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;
        s[26] =  (limbs[4] >>  4) as u8;
        s[27] =  (limbs[4] >> 12) as u8;
        s[28] =  (limbs[4] >> 20) as u8;
        s[29] =  (limbs[4] >> 28) as u8;
        s[30] =  (limbs[4] >> 36) as u8;
        s[31] =  (limbs[4] >> 44) as u8;

        // High bit should be zero.
        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);

        s
    }
    */ FieldElem51.prototype.toBytes = function() {
        var limbs = FieldElem51.reduce(this.bytes).bytes.slice();
        var q = limbs[0] + BigInt(19) >> _51n;
        q = limbs[1] + q >> _51n;
        q = limbs[2] + q >> _51n;
        q = limbs[3] + q >> _51n;
        q = limbs[4] + q >> _51n;
        limbs[0] += BigInt(19) * q;
        limbs[1] += limbs[0] >> _51n;
        limbs[0] &= LOW_51_BIT_MASK;
        limbs[2] += limbs[1] >> _51n;
        limbs[1] &= LOW_51_BIT_MASK;
        limbs[3] += limbs[2] >> _51n;
        limbs[2] &= LOW_51_BIT_MASK;
        limbs[4] += limbs[3] >> _51n;
        limbs[3] &= LOW_51_BIT_MASK;
        limbs[4] &= LOW_51_BIT_MASK;
        var s = new Uint8Array(32);
        // DO NOT TRY TO DO SMART THINGS
        //
        // DO NOT USE `DataView` OR OTHER BULLSHIT
        // 
        // THIS IS THE CODE AND THIS WE KEEP
        // IT MIGHT SEEM IT IS JUST SHIFITNG THE BITS TO ALLIGN TO THE BYTES
        // !!! BUT IT IS NOT !!!
        // SOME ELEMENTS ARE SHIFTED BY STRANGE NUMBERS
        s[0] = Number(limbs[0] & BigInt(0xff));
        s[1] = Number(limbs[0] >> BigInt(8) & BigInt(0xff));
        s[2] = Number(limbs[0] >> BigInt(16) & BigInt(0xff));
        s[3] = Number(limbs[0] >> BigInt(24) & BigInt(0xff));
        s[4] = Number(limbs[0] >> BigInt(32) & BigInt(0xff));
        s[5] = Number(limbs[0] >> BigInt(40) & BigInt(0xff));
        s[6] = Number(limbs[0] >> BigInt(48) | limbs[1] << BigInt(3) & BigInt(0xff));
        s[7] = Number(limbs[1] >> BigInt(5) & BigInt(0xff));
        s[8] = Number(limbs[1] >> BigInt(13) & BigInt(0xff));
        s[9] = Number(limbs[1] >> BigInt(21) & BigInt(0xff));
        s[10] = Number(limbs[1] >> BigInt(29) & BigInt(0xff));
        s[11] = Number(limbs[1] >> BigInt(37) & BigInt(0xff));
        s[12] = Number(limbs[1] >> BigInt(45) | limbs[2] << BigInt(6) & BigInt(0xff));
        s[13] = Number(limbs[2] >> BigInt(2) & BigInt(0xff));
        s[14] = Number(limbs[2] >> BigInt(10) & BigInt(0xff));
        s[15] = Number(limbs[2] >> BigInt(18) & BigInt(0xff));
        s[16] = Number(limbs[2] >> BigInt(26) & BigInt(0xff));
        s[17] = Number(limbs[2] >> BigInt(34) & BigInt(0xff));
        s[18] = Number(limbs[2] >> BigInt(42) & BigInt(0xff));
        s[19] = Number(limbs[2] >> BigInt(50) | limbs[3] << _1n & BigInt(0xff));
        s[20] = Number(limbs[3] >> BigInt(7) & BigInt(0xff));
        s[21] = Number(limbs[3] >> BigInt(15) & BigInt(0xff));
        s[22] = Number(limbs[3] >> BigInt(23) & BigInt(0xff));
        s[23] = Number(limbs[3] >> BigInt(31) & BigInt(0xff));
        s[24] = Number(limbs[3] >> BigInt(39) & BigInt(0xff));
        s[25] = Number(limbs[3] >> BigInt(47) | limbs[4] << BigInt(4) & BigInt(0xff));
        s[26] = Number(limbs[4] >> BigInt(4) & BigInt(0xff));
        s[27] = Number(limbs[4] >> BigInt(12) & BigInt(0xff));
        s[28] = Number(limbs[4] >> BigInt(20) & BigInt(0xff));
        s[29] = Number(limbs[4] >> BigInt(28) & BigInt(0xff));
        s[30] = Number(limbs[4] >> BigInt(36) & BigInt(0xff));
        s[31] = Number(limbs[4] >> BigInt(44) & BigInt(0xff));
        return s;
    };
    return FieldElem51;
}();
exports.FieldElem51 = FieldElem51;
var MontgomeryPoint = function() {
    function MontgomeryPoint(bytes) {
        this.bytes = bytes;
    }
    /*
    pub fn to_edwards(&self, sign: u8) -> Option<EdwardsPoint> {
        // To decompress the Montgomery u coordinate to an
        // `EdwardsPoint`, we apply the birational map to obtain the
        // Edwards y coordinate, then do Edwards decompression.
        //
        // The birational map is y = (u-1)/(u+1).
        //
        // The exceptional points are the zeros of the denominator,
        // i.e., u = -1.
        //
        // But when u = -1, v^2 = u*(u^2+486662*u+1) = 486660.
        //
        // Since this is nonsquare mod p, u = -1 corresponds to a point
        // on the twist, not the curve, so we can reject it early.

        let u = FieldElement::from_bytes(&self.0);

        if u == FieldElement::minus_one() { return None; }

        let one = FieldElement::one();

        let y = &(&u - &one) * &(&u + &one).invert();

        let mut y_bytes = y.to_bytes();
        y_bytes[31] ^= sign << 7;

        CompressedEdwardsY(y_bytes).decompress()
    }
    */ MontgomeryPoint.prototype.to_edwards = function(sign_bit) {
        var u = FieldElem51.fromBytes(this.bytes);
        if (u.ct_eq(FieldElem51.minus_one())) return undefined;
        var one = FieldElem51.one();
        var y = u.sub(one).mul(u.add(one).invert());
        var y_bytes = y.toBytes();
        y_bytes[31] ^= sign_bit << 7;
        return decompressCompressedEdwardsY(y_bytes);
    };
    return MontgomeryPoint;
}();
exports.MontgomeryPoint = MontgomeryPoint;
/*
fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>
    where
        I: IntoIterator,
        I::Item: Borrow<Scalar>,
        J: IntoIterator<Item = Option<EdwardsPoint>>,
    {
        use backend::serial::curve_models::{CompletedPoint, ProjectiveNielsPoint, ProjectivePoint};
        use window::NafLookupTable5;
        use traits::Identity;

        let nafs: Vec<_> = scalars
            .into_iter()
            .map(|c| c.borrow().non_adjacent_form(5))
            .collect();

        let lookup_tables = points
            .into_iter()
            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))
            .collect::<Option<Vec<_>>>()?;

        let mut r = ProjectivePoint::identity();

        for i in (0..256).rev() {
            let mut t: CompletedPoint = r.double();

            for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {
                if naf[i] > 0 {
                    t = &t.to_extended() + &lookup_table.select(naf[i] as usize);
                } else if naf[i] < 0 {
                    t = &t.to_extended() - &lookup_table.select(-naf[i] as usize);
                }
            }

            r = t.to_projective();
        }

        Some(r.to_extended())
    }
*/ function straus_optional_multiscalar_mul(scalars, points) {
    var nafs = scalars.map(function(s) {
        return scalar_non_adjacent_form(s, 5);
    });
    var lookupTables = points.map(function(p) {
        return NafLookupTable.fromEdwardsPoint(p);
    });
    var r = ProjectivePoint.IDENTITY;
    for(var i = 255; i >= 0; i--){
        var t = r.double();
        for(var j = 0; j < nafs.length; j++){
            var naf = nafs[j];
            var lookupTable = lookupTables[j];
            if (naf[i] > 0) t = t.toExtended().addProjectiveNiels(lookupTable.select(naf[i]));
            else if (naf[i] < 0) t = t.toExtended().subProjectiveNiels(lookupTable.select(-naf[i]));
            r = t.toProjective();
        }
        r = t.toProjective();
    }
    return r.toExtended();
}
/*
fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>
    where
        I: IntoIterator,
        I::Item: Borrow<Scalar>,
        J: IntoIterator<Item = Option<EdwardsPoint>>,
    {
        use traits::Identity;

        let mut scalars = scalars.into_iter();
        let size = scalars.by_ref().size_hint().0;

        // Digit width in bits. As digit width grows,
        // number of point additions goes down, but amount of
        // buckets and bucket additions grows exponentially.
        let w = if size < 500 {
            6
        } else if size < 800 {
            7
        } else {
            8
        };

        let max_digit: usize = 1 << w;
        let digits_count: usize = Scalar::to_radix_2w_size_hint(w);
        let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket

        // Collect optimized scalars and points in buffers for repeated access
        // (scanning the whole set per digit position).
        let scalars = scalars
            .map(|s| s.borrow().to_radix_2w(w));

        let points = points
            .into_iter()
            .map(|p| p.map(|P| P.to_projective_niels()));

        let scalars_points = scalars
            .zip(points)
            .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))
            .collect::<Option<Vec<_>>>()?;

        // Prepare 2^w/2 buckets.
        // buckets[i] corresponds to a multiplication factor (i+1).
        let mut buckets: Vec<_> = (0..buckets_count)
            .map(|_| EdwardsPoint::identity())
            .collect();

        let mut columns = (0..digits_count).rev().map(|digit_index| {
            // Clear the buckets when processing another digit.
            for i in 0..buckets_count {
                buckets[i] = EdwardsPoint::identity();
            }

            // Iterate over pairs of (point, scalar)
            // and add/sub the point to the corresponding bucket.
            // Note: if we add support for precomputed lookup tables,
            // we'll be adding/subtracting point premultiplied by `digits[i]` to buckets[0].
            for (digits, pt) in scalars_points.iter() {
                // Widen digit so that we don't run into edge cases when w=8.
                let digit = digits[digit_index] as i16;
                if digit > 0 {
                    let b = (digit - 1) as usize;
                    buckets[b] = (&buckets[b] + pt).to_extended();
                } else if digit < 0 {
                    let b = (-digit - 1) as usize;
                    buckets[b] = (&buckets[b] - pt).to_extended();
                }
            }

            // Add the buckets applying the multiplication factor to each bucket.
            // The most efficient way to do that is to have a single sum with two running sums:
            // an intermediate sum from last bucket to the first, and a sum of intermediate sums.
            //
            // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:
            //   C
            //   C B
            //   C B A   Sum = C + (C+B) + (C+B+A)
            let mut buckets_intermediate_sum = buckets[buckets_count - 1];
            let mut buckets_sum = buckets[buckets_count - 1];
            for i in (0..(buckets_count - 1)).rev() {
                buckets_intermediate_sum += buckets[i];
                buckets_sum += buckets_intermediate_sum;
            }

            buckets_sum
        });

        // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.
        // `unwrap()` always succeeds because we know we have more than zero digits.
        let hi_column = columns.next().unwrap();

        Some(
            columns
                .fold(hi_column, |total, p| total.mul_by_pow_2(w as u32) + p),
        )
    }
}
*/ function pippenger_optional_multiscalar_mul(scalars, points) {
    var size = scalars.length;
    var w = size < 500 ? 6 : size < 800 ? 7 : 8;
    var max_digit = 1 << w;
    var digits_count = scalar_to_radix_2w_size_hint(w);
    var buckets_count = max_digit / 2 >>> 0;
    var scalras_digits = scalars.map(function(s) {
        return scalar_to_radix_2w(s, w);
    });
    var points_proj = points.map(function(p) {
        return p.toProjectiveNiels();
    });
    // zipped
    var scalars_points = scalras_digits.map(function(s, i) {
        return [
            s,
            points_proj[i]
        ];
    });
    // all elems will be replaced in `columns` loop, just a temp value
    var buckets = new Array(buckets_count).fill(EdwardsPoint.IDENTITY);
    var columns = new Array(buckets_count).fill(0).map(function() {
        return EdwardsPoint.IDENTITY;
    });
    for(var i = digits_count - 1; i >= 0; i--){
        for(var j = 0; j < buckets_count; j++)buckets[j] = EdwardsPoint.IDENTITY;
        for(var j = 0; j < scalars_points.length; j++){
            var _a = __read(scalars_points[j], 2), digits = _a[0], pt = _a[1];
            var digit = digits[i];
            if (digit > 0) {
                var b = digit - 1;
                buckets[b] = buckets[b].addProjectiveNiels(pt).toExtended();
            } else if (digit < 0) {
                var b = -digit - 1;
                buckets[b] = buckets[b].subProjectiveNiels(pt).toExtended();
            }
        }
        var buckets_intermediate_sum = buckets[buckets_count - 1];
        var buckets_sum = buckets[buckets_count - 1];
        for(var j = buckets_count - 2; j >= 0; j--){
            buckets_intermediate_sum = buckets_intermediate_sum.add(buckets[j]);
            buckets_sum = buckets_sum.add(buckets_intermediate_sum);
        }
        columns[i] = buckets_sum;
    }
    // const hi_column = columns[ columns.length - 1 ];
    return columns.reduce(function(total, p) {
        return total.mulByPow2(w).add(p);
    });
}
function scalar_to_radix_2w_size_hint(w) {
    return ((256 + w - 1) / w >>> 0) + (w >= 8 ? 1 : 0);
}
/*
pub(crate) fn to_radix_2w(&self, w: usize) -> [i8; 64] {
        debug_assert!(w >= 4);
        debug_assert!(w <= 8);

        if w == 4 {
            return self.to_radix_16();
        }

        use byteorder::{ByteOrder, LittleEndian};

        // Scalar formatted as four `u64`s with carry bit packed into the highest bit.
        let mut scalar64x4 = [0u64; 4];
        LittleEndian::read_u64_into(&self.bytes, &mut scalar64x4[0..4]);

        let radix: u64 = 1 << w;
        let window_mask: u64 = radix - 1;

        let mut carry = 0u64;
        let mut digits = [0i8; 64];
        let digits_count = (256 + w - 1)/w as usize;
        for i in 0..digits_count {
            // Construct a buffer of bits of the scalar, starting at `bit_offset`.
            let bit_offset = i*w;
            let u64_idx = bit_offset / 64;
            let bit_idx = bit_offset % 64;

            // Read the bits from the scalar
            let bit_buf: u64;
            if bit_idx < 64 - w  || u64_idx == 3 {
                // This window's bits are contained in a single u64,
                // or it's the last u64 anyway.
                bit_buf = scalar64x4[u64_idx] >> bit_idx;
            } else {
                // Combine the current u64's bits with the bits from the next u64
                bit_buf = (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1+u64_idx] << (64 - bit_idx));
            }

            // Read the actual coefficient value from the window
            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)

             // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)
            carry = (coef + (radix/2) as u64) >> w;
            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;
        }

        // When w < 8, we can fold the final carry onto the last digit d,
        // because d < 2^w/2 so d + carry*2^w = d + 1*2^w < 2^(w+1) < 2^8.
        //
        // When w = 8, we can't fit carry*2^w into an i8.  This should
        // not happen anyways, because the final carry will be 0 for
        // reduced scalars, but the Scalar invariant allows 255-bit scalars.
        // To handle this, we expand the size_hint by 1 when w=8,
        // and accumulate the final carry onto another digit.
        match w {
            8 => digits[digits_count] += carry as i8,
            _ => digits[digits_count-1] += (carry << w) as i8,
        }

        digits
    }
*/ function scalar_to_radix_2w(scalar, w) {
    if (w === 4) return scalar_to_radix_16(scalar);
    var scalar64x4 = new BigUint64Array(4);
    read_u64_into_LE(scalar, scalar64x4);
    var radix = BigInt(1 << w);
    var window_mask = radix - _1n;
    var carry = _0n;
    var digits = new Int8Array(64);
    var u8digits = new Uint8Array(digits.buffer);
    var digits_count = (256 + w - 1) / w >>> 0;
    for(var i = 0; i < digits_count; i++){
        var bit_offset = i * w;
        var u64_idx = bit_offset / 64 >>> 0;
        var bit_idx = BigInt(bit_offset % 64);
        var bit_buf = void 0;
        if (bit_idx < 64 - w || u64_idx === 3) bit_buf = scalar64x4[u64_idx] >> bit_idx;
        else bit_buf = scalar64x4[u64_idx] >> bit_idx | scalar64x4[1 + u64_idx] << _64n - bit_idx & LOW_64_BIT_MASK;
        var coef = carry + (bit_buf & window_mask) & LOW_64_BIT_MASK;
        carry = (coef + (radix >> _1n)) / radix & LOW_64_BIT_MASK;
        u8digits[i] = Number(coef - carry * radix) & 0xff;
    }
    if (w === 8) u8digits[digits_count] = u8digits[digits_count] + Number(carry) & 0xff;
    else u8digits[digits_count - 1] = u8digits[digits_count - 1] + (Number(carry) << w) & 0xff;
    return digits;
}
var EdwardsPoint = function() {
    function EdwardsPoint(X, Y, Z, T) {
        this.X = X;
        this.Y = Y;
        this.Z = Z;
        this.T = T;
    }
    /*
    /// Compute \\([2\^k] P \\) by successive doublings. Requires \\( k > 0 \\).
    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {
        debug_assert!( k > 0 );
        let mut r: CompletedPoint;
        let mut s = self.to_projective();
        for _ in 0..(k-1) {
            r = s.double(); s = r.to_projective();
        }
        // Unroll last iteration so we can go directly to_extended()
        s.double().to_extended()
    }
    */ EdwardsPoint.prototype.mulByPow2 = function(k) {
        if (k <= 0) throw new Error("k must be > 0");
        var r;
        var s = this.toProjective();
        for(var i = 0; i < k - 1; i++){
            r = s.double();
            s = r.toProjective();
        }
        return s.double().toExtended();
    };
    EdwardsPoint.prototype.equals = function(other) {
        return this.X.ct_eq(other.X) && this.Y.ct_eq(other.Y) && this.Z.ct_eq(other.Z) && this.T.ct_eq(other.T);
    };
    Object.defineProperty(EdwardsPoint, "DOUBLE_BASE_COMPRESSED", {
        get: function() {
            return new Uint8Array([
                0xc9,
                0xa3,
                0xf8,
                0x6a,
                0xae,
                0x46,
                0x5f,
                0xe,
                0x56,
                0x51,
                0x38,
                0x64,
                0x51,
                0x0f,
                0x39,
                0x97,
                0x56,
                0x1f,
                0xa2,
                0xc9,
                0xe8,
                0x5e,
                0xa2,
                0x1d,
                0xc2,
                0x29,
                0x23,
                0x09,
                0xf3,
                0xcd,
                0x60,
                0x22
            ]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EdwardsPoint, "BASEPOINT_ED25519_COMPRESSED", {
        get: function() {
            return new Uint8Array([
                0x58,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66,
                0x66
            ]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EdwardsPoint, "BASEPOINT_ED25519", {
        get: function() {
            return new EdwardsPoint(new FieldElem51(new BigUint64Array([
                BigInt("1738742601995546"),
                BigInt("1146398526822698"),
                BigInt("2070867633025821"),
                BigInt("562264141797630"),
                BigInt("587772402128613")
            ])), new FieldElem51(new BigUint64Array([
                BigInt("1801439850948184"),
                BigInt("1351079888211148"),
                BigInt("450359962737049"),
                BigInt("900719925474099"),
                BigInt("1801439850948198")
            ])), new FieldElem51(new BigUint64Array([
                BigInt("1"),
                BigInt("0"),
                BigInt("0"),
                BigInt("0"),
                BigInt("0")
            ])), new FieldElem51(new BigUint64Array([
                BigInt("1841354044333475"),
                BigInt("16398895984059"),
                BigInt("755974180946558"),
                BigInt("900171276175154"),
                BigInt("1821297809914039")
            ])));
        },
        enumerable: false,
        configurable: true
    });
    EdwardsPoint.prototype.is_valid = function() {
        var on_curve = this.toProjective().is_valid();
        var on_ceger_image = this.X.mul(this.Y).ct_eq(this.Z.mul(this.T));
        return on_curve && on_ceger_image;
    };
    /*
    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>
    where
        I: IntoIterator,
        I::Item: Borrow<Scalar>,
        J: IntoIterator<Item = Option<EdwardsPoint>>,
    {
        // Sanity-check lengths of input iterators
        let mut scalars = scalars.into_iter();
        let mut points = points.into_iter();

        // Lower and upper bounds on iterators
        let (s_lo, s_hi) = scalars.by_ref().size_hint();
        let (p_lo, p_hi) = points.by_ref().size_hint();

        // They should all be equal
        assert_eq!(s_lo, p_lo);
        assert_eq!(s_hi, Some(s_lo));
        assert_eq!(p_hi, Some(p_lo));

        // Now we know there's a single size.
        // Use this as the hint to decide which algorithm to use.
        let size = s_lo;

        if size < 190 {
            scalar_mul::straus::Straus::optional_multiscalar_mul(scalars, points)
        } else {
            scalar_mul::pippenger::Pippenger::optional_multiscalar_mul(scalars, points)
        }
    }
    */ EdwardsPoint.vartime_multiscalar_mul = function(scalars, points) {
        return straus_optional_multiscalar_mul(scalars, points);
    // pippenger impl is wrong
    // if( scalars.length < 190 )
    //     return straus_optional_multiscalar_mul( scalars, points );
    // else
    //     return pippenger_optional_multiscalar_mul( scalars, points );
    };
    EdwardsPoint.prototype.double = function() {
        return this.toProjective().double().toExtended();
    };
    /*
/// Compute \\(aA + bB\\) in variable time, where \\(B\\) is the Ed25519 basepoint.
pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {
    let a_naf = a.non_adjacent_form(5);
    let b_naf = b.non_adjacent_form(8);

    // Find starting index
    let mut i: usize = 255;
    for j in (0..256).rev() {
        i = j;
        if a_naf[i] != 0 || b_naf[i] != 0 {
            break;
        }
    }

    let table_A = NafLookupTable::<ProjectiveNielsPoint>::from(A);
    let table_B = &constants::AFFINE_ODD_MULTIPLES_OF_BASEPOINT;

    let mut r = ProjectivePoint::identity();
    loop {
        let mut t = r.double();

        if a_naf[i] > 0 {
            t = &t.to_extended() + &table_A.select(a_naf[i] as usize);
        } else if a_naf[i] < 0 {
            t = &t.to_extended() - &table_A.select(-a_naf[i] as usize);
        }

        if b_naf[i] > 0 {
            t = &t.to_extended() + &table_B.select(b_naf[i] as usize);
        } else if b_naf[i] < 0 {
            t = &t.to_extended() - &table_B.select(-b_naf[i] as usize);
        }

        r = t.to_projective();

        if i == 0 {
            break;
        }
        i -= 1;
    }

    r.to_extended()
}
    */ EdwardsPoint.vartime_double_scalar_mul_basepoint = function(neg_challenge, pk, response) {
        var a_naf = scalar_non_adjacent_form(neg_challenge, 5);
        var b_naf = scalar_non_adjacent_form(response, 8);
        var i = 255;
        for(var j = 255; j >= 0; j--){
            i = j;
            if (a_naf[i] !== 0 || b_naf[i] !== 0) {
                break;
            }
        }
        ;
        var table_A = NafLookupTable.fromEdwardsPoint(pk);
        var table_B = AFFINE_ODD_MULTIPLES_OF_BASEPOINT;
        var r = ProjectivePoint.IDENTITY;
        while(true){
            var t = r.double();
            if (a_naf[i] > 0) t = t.toExtended().addProjectiveNiels(table_A.select(a_naf[i]));
            else if (a_naf[i] < 0) t = t.toExtended().subProjectiveNiels(table_A.select(-a_naf[i]));
            if (b_naf[i] > 0) t = t.toExtended().addAffineNielsPoint(table_B.select(b_naf[i]));
            else if (b_naf[i] < 0) t = t.toExtended().subAffineNielsPoint(table_B.select(-b_naf[i]));
            r = t.toProjective();
            if (i === 0) break;
            i--;
        }
        return r.toExtended();
    };
    EdwardsPoint.prototype.ct_eq = function(other) {
        return (0, uint8array_utils_1.uint8ArrayEq)(this.compress(), other.compress());
    };
    EdwardsPoint.decompress = function(compressed) {
        return decompressCompressedEdwardsY(compressed);
    };
    EdwardsPoint.uncompress = function(compressed) {
        return decompressCompressedEdwardsY(compressed);
    };
    /*
    pub fn is_small_order(&self) -> bool {
        self.mul_by_cofactor().is_identity()
    }
    */ EdwardsPoint.prototype.is_small_order = function() {
        return this.mul_by_cofactor().is_identity();
    };
    /*
    fn is_identity(&self) -> bool {
        self.ct_eq(&T::identity()).unwrap_u8() == 1u8
    }
    */ EdwardsPoint.prototype.is_identity = function() {
        return this.ct_eq(EdwardsPoint.IDENTITY);
    };
    EdwardsPoint.prototype.clone = function() {
        return new EdwardsPoint(this.X.clone(), this.Y.clone(), this.Z.clone(), this.T.clone());
    };
    Object.defineProperty(EdwardsPoint, "IDENTITY", {
        get: function() {
            return new EdwardsPoint(FieldElem51.zero(), FieldElem51.one(), FieldElem51.one(), FieldElem51.zero());
        },
        enumerable: false,
        configurable: true
    });
    /*
    fn add(self, other: &'b EdwardsPoint) -> EdwardsPoint {
        (self + &other.to_projective_niels()).to_extended()
    }
    */ EdwardsPoint.prototype.add = function(other) {
        return this.addProjectiveNiels(other.toProjectiveNiels()).toExtended();
    };
    /*
    fn add(self, other: &'b ProjectiveNielsPoint) -> CompletedPoint {
        let Y_plus_X  = &self.Y + &self.X;
        let Y_minus_X = &self.Y - &self.X;
        let PP = &Y_plus_X  * &other.Y_plus_X;
        let MM = &Y_minus_X * &other.Y_minus_X;
        let TT2d = &self.T * &other.T2d;
        let ZZ   = &self.Z * &other.Z;
        let ZZ2  = &ZZ + &ZZ;

        CompletedPoint{
            X: &PP - &MM,
            Y: &PP + &MM,
            Z: &ZZ2 + &TT2d,
            T: &ZZ2 - &TT2d
        }
    }
    */ EdwardsPoint.prototype.addProjectiveNiels = function(other) {
        var Y_plus_X = this.Y.add(this.X);
        var Y_minus_X = this.Y.sub(this.X);
        var PP = Y_plus_X.mul(other.Y_plus_X);
        var MM = Y_minus_X.mul(other.Y_minus_X);
        var TT2d = this.T.mul(other.T2d);
        var ZZ = this.Z.mul(other.Z);
        var ZZ2 = ZZ.add(ZZ);
        return new CompletedPoint(PP.sub(MM), PP.add(MM), ZZ2.add(TT2d), ZZ2.sub(TT2d));
    };
    /*
    fn sub(self, other: &'b ProjectiveNielsPoint) -> CompletedPoint {
        let Y_plus_X  = &self.Y + &self.X;
        let Y_minus_X = &self.Y - &self.X;
        let PM = &Y_plus_X * &other.Y_minus_X;
        let MP = &Y_minus_X  * &other.Y_plus_X;
        let TT2d = &self.T * &other.T2d;
        let ZZ   = &self.Z * &other.Z;
        let ZZ2  = &ZZ + &ZZ;

        CompletedPoint{
            X: &PM - &MP,
            Y: &PM + &MP,
            Z: &ZZ2 - &TT2d,
            T: &ZZ2 + &TT2d
        }
    }
    */ EdwardsPoint.prototype.subProjectiveNiels = function(other) {
        var Y_plus_X = this.Y.add(this.X);
        var Y_minus_X = this.Y.sub(this.X);
        var PM = Y_plus_X.mul(other.Y_minus_X);
        var MP = Y_minus_X.mul(other.Y_plus_X);
        var TT2d = this.T.mul(other.T2d);
        var ZZ = this.Z.mul(other.Z);
        var ZZ2 = ZZ.add(ZZ);
        return new CompletedPoint(PM.sub(MP), PM.add(MP), ZZ2.sub(TT2d), ZZ2.add(TT2d));
    };
    /*
    fn add(self, other: &'b AffineNielsPoint) -> CompletedPoint {
        let Y_plus_X  = &self.Y + &self.X;
        let Y_minus_X = &self.Y - &self.X;
        let PP        = &Y_plus_X  * &other.y_plus_x;
        let MM        = &Y_minus_X * &other.y_minus_x;
        let Txy2d     = &self.T * &other.xy2d;
        let Z2        = &self.Z + &self.Z;

        CompletedPoint{
            X: &PP - &MM,
            Y: &PP + &MM,
            Z: &Z2 + &Txy2d,
            T: &Z2 - &Txy2d
        }
    }
    */ EdwardsPoint.prototype.addAffineNielsPoint = function(other) {
        var Y_plus_X = this.Y.add(this.X);
        var Y_minus_X = this.Y.sub(this.X);
        var PP = Y_plus_X.mul(other.y_plus_x);
        var MM = Y_minus_X.mul(other.y_minus_x);
        var Txy2d = this.T.mul(other.xy2d);
        var Z2 = this.Z.add(this.Z);
        return new CompletedPoint(PP.sub(MM), PP.add(MM), Z2.add(Txy2d), Z2.sub(Txy2d));
    };
    /*
    fn sub(self, other: &'b AffineNielsPoint) -> CompletedPoint {
        let Y_plus_X  = &self.Y + &self.X;
        let Y_minus_X = &self.Y - &self.X;
        let PM        = &Y_plus_X  * &other.y_minus_x;
        let MP        = &Y_minus_X * &other.y_plus_x;
        let Txy2d     = &self.T * &other.xy2d;
        let Z2        = &self.Z + &self.Z;

        CompletedPoint{
            X: &PM - &MP,
            Y: &PM + &MP,
            Z: &Z2 - &Txy2d,
            T: &Z2 + &Txy2d
        }
    }
    */ EdwardsPoint.prototype.subAffineNielsPoint = function(other) {
        var Y_plus_X = this.Y.add(this.X);
        var Y_minus_X = this.Y.sub(this.X);
        var PM = Y_plus_X.mul(other.y_minus_x);
        var MP = Y_minus_X.mul(other.y_plus_x);
        var Txy2d = this.T.mul(other.xy2d);
        var Z2 = this.Z.add(this.Z);
        return new CompletedPoint(PM.sub(MP), PM.add(MP), Z2.sub(Txy2d), Z2.add(Txy2d));
    };
    /*
    /// Convert to a ProjectiveNielsPoint
    pub(crate) fn to_projective_niels(&self) -> ProjectiveNielsPoint {
        ProjectiveNielsPoint{
            Y_plus_X:  &self.Y + &self.X,
            Y_minus_X: &self.Y - &self.X,
            Z:          self.Z,
            T2d:       &self.T * &constants::EDWARDS_D2,
        }
    }
    */ EdwardsPoint.prototype.toProjectiveNiels = function() {
        return new ProjectiveNielsPoint(this.Y.add(this.X), this.Y.sub(this.X), this.Z, this.T.mul(FieldElem51.EDWARDS_D2));
    };
    /*
    /// Multiply by the cofactor: return \\([8]P\\).
    pub fn mul_by_cofactor(&self) -> EdwardsPoint {
        self.mul_by_pow_2(3)
    }
    */ EdwardsPoint.prototype.mul_by_cofactor = function() {
        return this.mul_by_pow_2(3);
    };
    /*
    /// Compress this point to `CompressedEdwardsY` format.
    pub fn compress(&self) -> CompressedEdwardsY {
        let recip = self.Z.invert();
        let x = &self.X * &recip;
        let y = &self.Y * &recip;
        let mut s: [u8; 32];

        s = y.to_bytes();
        s[31] ^= x.is_negative().unwrap_u8() << 7;
        CompressedEdwardsY(s)
    }
    */ EdwardsPoint.prototype.compress = function() {
        var recip = this.Z.invert();
        var x = this.X.mul(recip);
        var y = this.Y.mul(recip);
        var s = y.toBytes();
        var bit = x.is_negative() ? 1 : 0;
        s[31] ^= bit << 7;
        return s;
    };
    EdwardsPoint.prototype.compressed_is_negative = function() {
        var recip = this.Z.invert();
        var x = this.X.mul(recip);
        return x.is_negative();
    };
    /*
    /// Compute \\([2\^k] P \\) by successive doublings. Requires \\( k > 0 \\).
    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {
        debug_assert!( k > 0 );
        let mut r: CompletedPoint;
        let mut s = self.to_projective();
        for _ in 0..(k-1) {
            r = s.double(); s = r.to_projective();
        }
        // Unroll last iteration so we can go directly to_extended()
        s.double().to_extended()
    }
    */ EdwardsPoint.prototype.mul_by_pow_2 = function(k) {
        if (k <= 0) throw new Error("mul_by_pow_2 :: k must be greater than 0");
        var r;
        var s = this.toProjective();
        for(var i = 0; i < k - 1; i++){
            r = s.double();
            s = r.toProjective();
        }
        return s.double().toExtended();
    };
    /*
    /// Convert the representation of this point from extended
    /// coordinates to projective coordinates.
    ///
    /// Free.
    pub(crate) fn to_projective(&self) -> ProjectivePoint {
        ProjectivePoint{
            X: self.X,
            Y: self.Y,
            Z: self.Z,
        }
    }
    */ EdwardsPoint.prototype.toProjective = function() {
        return new ProjectivePoint(this.X, this.Y, this.Z);
    };
    /*
    /// Perform constant-time, variable-base scalar multiplication.
    pub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {
        // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]
        let lookup_table = LookupTable::<ProjectiveNielsPoint>::from(point);
        // Setting s = scalar, compute
        //
        //    s = s_0 + s_1*16^1 + ... + s_63*16^63,
        //
        // with `-8  s_i < 8` for `0  i < 63` and `-8  s_63  8`.
        let scalar_digits = scalar.to_radix_16();
        // Compute s*P as
        //
        //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)
        //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63
        //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))
        //
        // We sum right-to-left.

        // Unwrap first loop iteration to save computing 16*identity
        let mut tmp2;
        let mut tmp3 = EdwardsPoint::identity();
        let mut tmp1 = &tmp3 + &lookup_table.select(scalar_digits[63]);
        // Now tmp1 = s_63*P in P1xP1 coords
        for i in (0..63).rev() {
            tmp2 = tmp1.to_projective(); // tmp2 =    (prev) in P2 coords
            tmp1 = tmp2.double();        // tmp1 =  2*(prev) in P1xP1 coords
            tmp2 = tmp1.to_projective(); // tmp2 =  2*(prev) in P2 coords
            tmp1 = tmp2.double();        // tmp1 =  4*(prev) in P1xP1 coords
            tmp2 = tmp1.to_projective(); // tmp2 =  4*(prev) in P2 coords
            tmp1 = tmp2.double();        // tmp1 =  8*(prev) in P1xP1 coords
            tmp2 = tmp1.to_projective(); // tmp2 =  8*(prev) in P2 coords
            tmp1 = tmp2.double();        // tmp1 = 16*(prev) in P1xP1 coords
            tmp3 = tmp1.to_extended();   // tmp3 = 16*(prev) in P3 coords
            tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);
            // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords
        }
        tmp1.to_extended()
    }
    */ /*
    */ EdwardsPoint.prototype.scalarMul = function(scalar) {
        var lookup_table = ProjectiveNielsPoint.tableFromEdwardPoint(this);
        var scalar_digits = scalar_to_radix_16(scalar);
        var tmp2 = ProjectivePoint.IDENTITY;
        var tmp3 = EdwardsPoint.IDENTITY;
        var tmp1 = tmp3.addProjectiveNiels(lookup_table.select(scalar_digits[63]));
        for(var i = 62; i >= 0; i--){
            tmp2 = tmp1.toProjective();
            tmp1 = tmp2.double();
            tmp2 = tmp1.toProjective();
            tmp1 = tmp2.double();
            tmp2 = tmp1.toProjective();
            tmp1 = tmp2.double();
            tmp2 = tmp1.toProjective();
            tmp1 = tmp2.double();
            tmp3 = tmp1.toExtended();
            tmp1 = tmp3.addProjectiveNiels(lookup_table.select(scalar_digits[i]));
        }
        return tmp1.toExtended();
    };
    return EdwardsPoint;
}();
exports.EdwardsPoint = EdwardsPoint;
var NafLookupTable = function() {
    function NafLookupTable(points) {
        this.points = points;
    }
    /*
    /// Given public, odd \\( x \\) with \\( 0 < x < 2^4 \\), return \\(xA\\).
    pub fn select(&self, x: usize) -> T {
        debug_assert_eq!(x & 1, 1);
        debug_assert!(x < 16););

        self.0[x / 2]
    }
    */ NafLookupTable.prototype.select = function(i) {
        // debug_assert_eq(x & 1, 1);
        // debug_assert(x < 16););
        return this.points[i / 2 >>> 0];
    };
    /*
    fn from(A: &'a EdwardsPoint) -> Self {
        let mut Ai: [ProjectiveNielsPoint; 8] = [A.to_projective_niels(); 8];
        let A2 = A.double();
        for i in 0..7 {
            Ai[i + 1] = (&A2 + &Ai[i]).to_extended().to_projective_niels();
        }
        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]
        NafLookupTable(Ai)
    }
    */ NafLookupTable.fromEdwardsPoint = function(point) {
        var Ai = new Array(8).fill(0).map(function(_) {
            return point.toProjectiveNiels();
        });
        var A2 = point.double();
        for(var i = 0; i < 7; i++){
            Ai[i + 1] = A2.addProjectiveNiels(Ai[i]).toExtended().toProjectiveNiels();
        }
        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]
        return new NafLookupTable(Ai);
    };
    return NafLookupTable;
}();
var AffineNielsPoint = function() {
    function AffineNielsPoint(y_plus_x, y_minus_x, xy2d) {
        this.y_plus_x = y_plus_x;
        this.y_minus_x = y_minus_x;
        this.xy2d = xy2d;
    }
    return AffineNielsPoint;
}();
exports.ED25519_BASEPOINT_POINT = new EdwardsPoint(new FieldElem51(new BigUint64Array([
    BigInt("1738742601995546"),
    BigInt("1146398526822698"),
    BigInt("2070867633025821"),
    BigInt("562264141797630"),
    BigInt("587772402128613")
])), new FieldElem51(new BigUint64Array([
    BigInt("1801439850948184"),
    BigInt("1351079888211148"),
    BigInt("450359962737049"),
    BigInt("900719925474099"),
    BigInt("1801439850948198")
])), new FieldElem51(new BigUint64Array([
    BigInt("1"),
    BigInt("0"),
    BigInt("0"),
    BigInt("0"),
    BigInt("0")
])), new FieldElem51(new BigUint64Array([
    BigInt("1841354044333475"),
    BigInt("16398895984059"),
    BigInt("755974180946558"),
    BigInt("900171276175154"),
    BigInt("1821297809914039")
])));
/*
pub struct ProjectiveNielsPoint {
    pub Y_plus_X:  FieldElement,
    pub Y_minus_X: FieldElement,
    pub Z:         FieldElement,
    pub T2d:       FieldElement,
}

*/ var ProjectiveNielsPoint = function() {
    function ProjectiveNielsPoint(Y_plus_X, Y_minus_X, Z, T2d) {
        this.Y_plus_X = Y_plus_X;
        this.Y_minus_X = Y_minus_X;
        this.Z = Z;
        this.T2d = T2d;
    }
    ProjectiveNielsPoint.prototype.clone = function() {
        return new ProjectiveNielsPoint(this.Y_plus_X.clone(), this.Y_minus_X.clone(), this.Z.clone(), this.T2d.clone());
    };
    /** not really, but useful to debug */ ProjectiveNielsPoint.prototype.compress = function() {
        return EdwardsPoint.IDENTITY.addProjectiveNiels(this).toExtended().compress();
    };
    ProjectiveNielsPoint.prototype.compressed_is_negative = function() {
        return EdwardsPoint.IDENTITY.addProjectiveNiels(this).toExtended().compressed_is_negative();
    };
    ProjectiveNielsPoint.identity = function() {
        return new ProjectiveNielsPoint(FieldElem51.one(), FieldElem51.one(), FieldElem51.one(), FieldElem51.zero());
    };
    /**
     * # WARNING
     *
     * **I FOUND NO IMPLEMENTATION** (Thanks generics)
     *
     * I am ASSUMING this is what is meant to happen
     *
     */ ProjectiveNielsPoint.prototype.conditional_negate = function(choice) {
        // this.Y_plus_X.conditional_negate( choice );
        // this.Y_minus_X.conditional_negate( choice );
        // this.Z.conditional_negate( choice );
        // this.T2d.conditional_negate( choice );
        // ??? WTF ???
        // ??? not even this works ???
        // ??? WHY ???
        // 
        // if( choice )
        // {
        //     (this as any).Y_plus_X = this.Y_plus_X.neg();
        //     (this as any).Y_minus_X = this.Y_minus_X.neg();
        //     (this as any).Z = this.Z.neg();
        //     (this as any).T2d = this.T2d.neg();
        // }
        if (choice) {
            var neg = this.neg();
            this.Y_plus_X = neg.Y_plus_X;
            this.Y_minus_X = neg.Y_minus_X;
            this.Z = neg.Z;
            this.T2d = neg.T2d;
        }
    };
    /**
     *
     * I HAD TO FUCKING REVERSE ENGENEER THIS SHIT
     *
     * WHO THE FUCK TOUGHT MACROS WERE A GOOD IDEA IN RUST?
     */ ProjectiveNielsPoint.prototype.neg = function() {
        return new ProjectiveNielsPoint(// swap places minus and plus
        this.Y_minus_X.clone(), this.Y_plus_X.clone(), // same Z
        this.Z.clone(), // negate T2d
        this.T2d.neg());
    };
    /*
    fn conditional_assign(&mut self, other: &Self, choice: Choice) {
        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);
        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);
        self.Z.conditional_assign(&other.Z, choice);
        self.T2d.conditional_assign(&other.T2d, choice);
    }
    */ ProjectiveNielsPoint.prototype.conditional_assign = function(other, choice) {
        this.Y_plus_X.conditional_assign(other.Y_plus_X, choice);
        this.Y_minus_X.conditional_assign(other.Y_minus_X, choice);
        this.Z.conditional_assign(other.Z, choice);
        this.T2d.conditional_assign(other.T2d, choice);
    };
    /*
    fn from(P: &'a EdwardsPoint) -> Self {
        let mut points = [P.to_projective_niels(); $size];
        for j in $conv_range {
            points[j + 1] = (P + &points[j]).to_extended().to_projective_niels();
        }
        $name(points)
    }
    */ ProjectiveNielsPoint.tableFromEdwardPoint = function(point) {
        var points = new Array(LookupTableProjectiveNielsPoint.SIZE).fill(0).map(function(_) {
            return point.toProjectiveNiels();
        });
        for(var j = 0; j < LookupTableProjectiveNielsPoint.CONVERSION_RANGE_MAX; j++){
            points[j + 1] = point.addProjectiveNiels(points[j]).toExtended().toProjectiveNiels();
        }
        return new LookupTableProjectiveNielsPoint(points);
    };
    return ProjectiveNielsPoint;
}();
exports.ProjectiveNielsPoint = ProjectiveNielsPoint;
/*
impl_lookup_table! {
    Name = LookupTable,
    Size = 8,
    SizeNeg = -8,
    SizeRange = 1 .. 9,
    ConversionRange = 0 .. 7
} // radix-16
*/ var LookupTableProjectiveNielsPoint = function() {
    function LookupTableProjectiveNielsPoint(points) {
        this.points = points;
    }
    /*
    /// Given \\(-8 \leq x \leq 8\\), return \\(xP\\) in constant time.
    pub fn select(&self, x: i8) -> T {
        debug_assert!(x >= $neg);
        debug_assert!(x as i16 <= $size as i16); // XXX We have to convert to i16s here for the radix-256 case.. this is wrong.

        // Compute xabs = |x|
        let xmask = x  as i16 >> 7;
        let xabs = (x as i16 + xmask) ^ xmask;

        // Set t = 0 * P = identity
        let mut t = T::identity();
        for j in $range {
            // Copy `points[j-1] == j*P` onto `t` in constant time if `|x| == j`.
            let c = (xabs as u16).ct_eq(&(j as u16));
            t.conditional_assign(&self.0[j - 1], c);
        }
        // Now t == |x| * P.

        let neg_mask = Choice::from((xmask & 1) as u8);
        t.conditional_negate(neg_mask);
        // Now t == x * P.

        t
    }
    */ LookupTableProjectiveNielsPoint.prototype.select = function(pos) {
        var view = new DataView(new ArrayBuffer(2));
        view.setUint16(0, pos & 0xffff, false);
        var posI16 = view.getInt16(0, false);
        // const posU16 = view.getUint16( 0, false );
        var xmask = posI16 >> 7;
        var xabs = posI16 + xmask ^ xmask;
        var t = ProjectiveNielsPoint.identity();
        for(var j = LookupTableProjectiveNielsPoint.SIZE_RANGE_MIN; j <= LookupTableProjectiveNielsPoint.SIZE_RANGE_MAX; j++){
            var c = xabs === j;
            t.conditional_assign(this.points[j - 1].clone(), c);
        }
        var neg_mask = xmask & 1;
        t.conditional_negate(neg_mask === 1);
        return t;
    };
    LookupTableProjectiveNielsPoint.SIZE = 8;
    LookupTableProjectiveNielsPoint.SIZE_NEG = -8;
    LookupTableProjectiveNielsPoint.SIZE_RANGE = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
    ];
    LookupTableProjectiveNielsPoint.SIZE_RANGE_MIN = 1;
    LookupTableProjectiveNielsPoint.SIZE_RANGE_MAX = 8;
    LookupTableProjectiveNielsPoint.CONVERSION_RANGE = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7
    ];
    LookupTableProjectiveNielsPoint.CONVERSION_RANGE_MAX = 7;
    return LookupTableProjectiveNielsPoint;
}();
exports.LookupTableProjectiveNielsPoint = LookupTableProjectiveNielsPoint;
/*
pub(crate) fn to_radix_16(&self) -> [i8; 64] {
    debug_assert!(self[31] <= 127);
    let mut output = [0i8; 64];

    // Step 1: change radix.
    // Convert from radix 256 (bytes) to radix 16 (nibbles)
    #[inline(always)]
    fn bot_half(x: u8) -> u8 { (x >> 0) & 15 }
    #[inline(always)]
    fn top_half(x: u8) -> u8 { (x >> 4) & 15 }

    for i in 0..32 {
        output[2*i  ] = bot_half(self[i]) as i8;
        output[2*i+1] = top_half(self[i]) as i8;
    }
    // Precondition note: since self[31] <= 127, output[63] <= 7

    // Step 2: recenter coefficients from [0,16) to [-8,8)
    for i in 0..63 {
        let carry    = (output[i] + 8) >> 4;
        output[i  ] -= carry << 4;
        output[i+1] += carry;
    }
    // Precondition note: output[63] is not recentered.  It
    // increases by carry <= 1.  Thus output[63] <= 8.

    output
}
*/ function scalar_to_radix_16(scalar) {
    var output = new Int8Array(64);
    var u8 = new Uint8Array(output.buffer);
    for(var i = 0; i < 32; i++){
        u8[2 * i] = scalar[i] >> 0 & 15;
        u8[2 * i + 1] = scalar[i] >> 4 & 15;
    }
    for(var i = 0; i < 63; i++){
        var carry = output[i] + 8 >> 4;
        u8[i] -= carry << 4 & 0xff;
        u8[i + 1] += carry & 0xff;
    }
    return output;
}
/*
/// Attempt to decompress to an `EdwardsPoint`.
///
/// Returns `None` if the input is not the \\(y\\)-coordinate of a
/// curve point.
pub fn decompress( bytes: [u8] ) -> Option<EdwardsPoint> {
    let Y = FieldElement::from_bytes( bytes );
    let Z = FieldElement::one();
    let YY = Y.square();
    let u = &YY - &Z;                            // u =  y-1
    let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy+1
    let (is_valid_y_coord, mut X) = FieldElement::sqrt_ratio_i(&u, &v);

    if is_valid_y_coord.unwrap_u8() != 1u8 { return None; }

        // FieldElement::sqrt_ratio_i always returns the nonnegative square root,
        // so we negate according to the supplied sign bit.
    let compressed_sign_bit = Choice::from(self.as_bytes()[31] >> 7);
    X.conditional_negate(compressed_sign_bit);

    Some(EdwardsPoint{ X, Y, Z, T: &X * &Y })
}
*/ function decompressCompressedEdwardsY(bytes) {
    var Y = FieldElem51.fromBytes(bytes);
    var Z = FieldElem51.one();
    var YY = Y.square();
    var u = YY.sub(Z);
    var v = YY.mul(FieldElem51.EDWARDS_D).add(Z);
    var _a = __read(FieldElem51.sqrt_ratio_i(u, v), 2), is_valid_y_coord = _a[0], X = _a[1];
    if (is_valid_y_coord !== true) return undefined;
    var compressed_sign_bit = bytes[31] >> 7 & 1;
    X.conditional_negate(compressed_sign_bit === 1);
    return new EdwardsPoint(X, Y, Z, X.mul(Y));
}
exports.decompressCompressedEdwardsY = decompressCompressedEdwardsY;
var CompletedPoint = function() {
    function CompletedPoint(X, Y, Z, T) {
        this.X = X;
        this.Y = Y;
        this.Z = Z;
        this.T = T;
    }
    CompletedPoint.prototype.clone = function() {
        return new CompletedPoint(this.X.clone(), this.Y.clone(), this.Z.clone(), this.T.clone());
    };
    /*
    pub fn to_projective(&self) -> ProjectivePoint {
        ProjectivePoint {
            X: &self.X * &self.T,
            Y: &self.Y * &self.Z,
            Z: &self.Z * &self.T,
        }
    }
    */ CompletedPoint.prototype.toProjective = function() {
        return new ProjectivePoint(this.X.mul(this.T), this.Y.mul(this.Z), this.Z.mul(this.T));
    };
    /*
    pub fn to_extended(&self) -> EdwardsPoint {
        EdwardsPoint {
            X: &self.X * &self.T,
            Y: &self.Y * &self.Z,
            Z: &self.Z * &self.T,
            T: &self.X * &self.Y,
        }
    }
    */ CompletedPoint.prototype.toExtended = function() {
        return new EdwardsPoint(this.X.mul(this.T), this.Y.mul(this.Z), this.Z.mul(this.T), this.X.mul(this.Y));
    };
    return CompletedPoint;
}();
exports.CompletedPoint = CompletedPoint;
var ProjectivePoint = function() {
    function ProjectivePoint(X, Y, Z) {
        this.X = X;
        this.Y = Y;
        this.Z = Z;
    }
    /*
    fn is_valid(&self) -> bool {
        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,
        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2
        let XX = self.X.square();
        let YY = self.Y.square();
        let ZZ = self.Z.square();
        let ZZZZ = ZZ.square();
        let lhs = &(&YY - &XX) * &ZZ;
        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));

        lhs == rhs
    }
    */ ProjectivePoint.prototype.is_valid = function() {
        var XX = this.X.square();
        var YY = this.Y.square();
        var ZZ = this.Z.square();
        var ZZZZ = ZZ.square();
        var lhs = YY.sub(XX).mul(ZZ);
        var rhs = ZZZZ.add(FieldElem51.EDWARDS_D.mul(XX.mul(YY)));
        return lhs.ct_eq(rhs);
    };
    ProjectivePoint.prototype.clone = function() {
        return new ProjectivePoint(this.X.clone(), this.Y.clone(), this.Z.clone());
    };
    /*
    pub fn to_extended(&self) -> EdwardsPoint {
        EdwardsPoint {
            X: &self.X * &self.Z,
            Y: &self.Y * &self.Z,
            Z: self.Z.square(),
            T: &self.X * &self.Y,
        }
    }
    */ ProjectivePoint.prototype.toExtended = function() {
        return new EdwardsPoint(this.X.mul(this.Z), this.Y.mul(this.Z), this.Z.square(), this.X.mul(this.Y));
    };
    Object.defineProperty(ProjectivePoint, "IDENTITY", {
        get: function() {
            return new ProjectivePoint(FieldElem51.zero(), FieldElem51.one(), FieldElem51.one());
        },
        enumerable: false,
        configurable: true
    });
    /*
    /// Double this point: return self + self
    pub fn double(&self) -> CompletedPoint { // Double()
        let XX          = self.X.square();
        let YY          = self.Y.square();
        let ZZ2         = self.Z.square2();
        let X_plus_Y    = &self.X + &self.Y;
        let X_plus_Y_sq = X_plus_Y.square();
        let YY_plus_XX  = &YY + &XX;
        let YY_minus_XX = &YY - &XX;

        CompletedPoint{
            X: &X_plus_Y_sq - &YY_plus_XX,
            Y: YY_plus_XX,
            Z: YY_minus_XX,
            T: &ZZ2 - &YY_minus_XX
        }
    }
    */ ProjectivePoint.prototype.double = function() {
        var XX = this.X.square();
        var YY = this.Y.square();
        var ZZ2 = this.Z.square2();
        var X_plus_Y = this.X.add(this.Y);
        var X_plus_Y_sq = X_plus_Y.square();
        var YY_plus_XX = YY.add(XX);
        var YY_minus_XX = YY.sub(XX);
        return new CompletedPoint(X_plus_Y_sq.sub(YY_plus_XX), YY_plus_XX, YY_minus_XX, ZZ2.sub(YY_minus_XX));
    };
    return ProjectivePoint;
}();
exports.ProjectivePoint = ProjectivePoint;
/*
#[inline]
    fn write_u64(buf: &mut [u8], n: u64) {
        buf[..8].copy_from_slice(&n.to_le_bytes());
    }
fn from(x: u64) -> Scalar {
        use byteorder::{ByteOrder, LittleEndian};
        let mut s_bytes = [0u8; 32];
        LittleEndian::write_u64(&mut s_bytes, x);
        Scalar{ bytes: s_bytes }
    }
*/ function scalar_from_u64(n) {
    n = BigInt(n);
    var s_bytes = new Uint8Array(32);
    var view = new DataView(s_bytes.buffer);
    view.setBigUint64(0, n, true);
    return s_bytes;
}
exports.scalar_from_u64 = scalar_from_u64;
function scalar_from_bytes_mod_order_wide(input) {
    // UnpackedScalar::from_bytes_wide(input).pack()
    return pack_unpacked_scalar(unpacked_scalar_from_bytes_wide(input));
}
exports.scalar_from_bytes_mod_order_wide = scalar_from_bytes_mod_order_wide;
function mul_scalars(a, b) {
    return pack_unpacked_scalar(mul_unpacked_scalars(unpacked_scalar_from_bytes(a), unpacked_scalar_from_bytes(b)));
}
exports.mul_scalars = mul_scalars;
/*
type Output = Scalar;
    #[allow(non_snake_case)]
    fn add(self, _rhs: &'b Scalar) -> Scalar {
        // The UnpackedScalar::add function produces reduced outputs
        // if the inputs are reduced.  However, these inputs may not
        // be reduced -- they might come from Scalar::from_bits.  So
        // after computing the sum, we explicitly reduce it mod l
        // before repacking.
        let sum = UnpackedScalar::add(&self.unpack(), &_rhs.unpack());
        let sum_R = UnpackedScalar::mul_internal(&sum, &constants::R);
        let sum_mod_l = UnpackedScalar::montgomery_reduce(&sum_R);
        sum_mod_l.pack()
    }
*/ function add_scalars(a, b) {
    var sum = unpacked_scalar_add(unpacked_scalar_from_bytes(a), unpacked_scalar_from_bytes(b));
    var sum_R = scalar_mul_internal(sum, SCALAR_R);
    var sum_mod_l = scalar_montgomery_reduce(sum_R);
    return pack_unpacked_scalar(sum_mod_l);
}
exports.add_scalars = add_scalars;
/*
// Compute `a + b` (mod l)
    pub fn add(a: &Scalar52, b: &Scalar52) -> Scalar52 {
        let mut sum = Scalar52::zero();
        let mask = (1u64 << 52) - 1;

        // a + b
        let mut carry: u64 = 0;
        for i in 0..5 {
            carry = a[i] + b[i] + (carry >> 52);
            sum[i] = carry & mask;
        }

        // subtract l if the sum is >= l
        Scalar52::sub(&sum, &constants::L)
    }
*/ function unpacked_scalar_add(a, b) {
    var sum = SCALAR_0.slice();
    var mask = LOW_52_BIT_MASK;
    var carry = _0n;
    for(var i = 0; i < 5; i++){
        carry = a[i] + b[i] + (carry >> _52n);
        sum[i] = carry & mask;
    }
    return scalar_sub(sum, SCALAR_L);
}
/*
/// Unpack a 32 byte / 256 bit scalar into 5 52-bit limbs.
    pub fn from_bytes(bytes: &[u8; 32]) -> Scalar52 {
        let mut words = [0u64; 4];
        for i in 0..4 {
            for j in 0..8 {
                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);
            }
        }

        let mask = (1u64 << 52) - 1;
        let top_mask = (1u64 << 48) - 1;
        let mut s = Scalar52::zero();

        s[ 0] =   words[0]                            & mask;
        s[ 1] = ((words[0] >> 52) | (words[1] << 12)) & mask;
        s[ 2] = ((words[1] >> 40) | (words[2] << 24)) & mask;
        s[ 3] = ((words[2] >> 28) | (words[3] << 36)) & mask;
        s[ 4] =  (words[3] >> 16)                     & top_mask;

        s
    }
*/ function unpacked_scalar_from_bytes(input) {
    var words = new BigUint64Array(4);
    for(var i = 0; i < 4; i++){
        for(var j = 0; j < 8; j++){
            words[i] |= BigInt(input[i * 8 + j]) << BigInt(j * 8);
        }
    }
    var mask = LOW_52_BIT_MASK;
    var top_mask = (_1n << BigInt(48)) - _1n;
    var s = SCALAR_0.slice();
    s[0] = words[0] & mask;
    s[1] = (words[0] >> _52n | words[1] << BigInt(12)) & mask;
    s[2] = (words[1] >> BigInt(40) | words[2] << BigInt(24)) & mask;
    s[3] = (words[2] >> BigInt(28) | words[3] << BigInt(36)) & mask;
    s[4] = words[3] >> BigInt(16) & top_mask;
    return s;
}
exports.unpack_scalar = unpacked_scalar_from_bytes;
/*
#[inline(never)]
    pub fn mul(a: &Scalar52, b: &Scalar52) -> Scalar52 {
        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));
        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &constants::RR))
    }
*/ function mul_unpacked_scalars(a, b) {
    var ab = scalar_montgomery_reduce(scalar_mul_internal(a, b));
    return scalar_montgomery_reduce(scalar_mul_internal(ab, SCALAR_RR));
}
/*
pub struct Scalar52(pub [u64; 5]);

    /// Reduce a 64 byte / 512 bit scalar mod l
    pub fn from_bytes_wide(bytes: &[u8; 64]) -> Scalar52 {
        let mut words = [0u64; 8];
        for i in 0..8 {
            for j in 0..8 {
                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);
            }
        }

        let mask = (1u64 << 52) - 1;
        let mut lo = Scalar52::zero();
        let mut hi = Scalar52::zero();

        lo[0] =   words[ 0]                             & mask;
        lo[1] = ((words[ 0] >> 52) | (words[ 1] << 12)) & mask;
        lo[2] = ((words[ 1] >> 40) | (words[ 2] << 24)) & mask;
        lo[3] = ((words[ 2] >> 28) | (words[ 3] << 36)) & mask;
        lo[4] = ((words[ 3] >> 16) | (words[ 4] << 48)) & mask;
        hi[0] =  (words[ 4] >>  4)                      & mask;
        hi[1] = ((words[ 4] >> 56) | (words[ 5] <<  8)) & mask;
        hi[2] = ((words[ 5] >> 44) | (words[ 6] << 20)) & mask;
        hi[3] = ((words[ 6] >> 32) | (words[ 7] << 32)) & mask;
        hi[4] =   words[ 7] >> 20                             ;

        lo = Scalar52::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo
        hi = Scalar52::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R

        Scalar52::add(&hi, &lo)
    }

*/ function unpacked_scalar_from_bytes_wide(input) {
    // UnpackedScalar::from_bytes_wide(input)
    var words = new BigUint64Array(8);
    for(var i = 0; i < 8; i++){
        for(var j = 0; j < 8; j++){
            words[i] |= BigInt(input[i * 8 + j]) << BigInt(j * 8);
        }
    }
    var mask = LOW_52_BIT_MASK;
    var lo = new BigUint64Array(5);
    var hi = new BigUint64Array(5);
    lo[0] = words[0] & mask;
    lo[1] = (words[0] >> _52n | words[1] << BigInt(12)) & mask;
    lo[2] = (words[1] >> BigInt(40) | words[2] << BigInt(24)) & mask;
    lo[3] = (words[2] >> BigInt(28) | words[3] << BigInt(36)) & mask;
    lo[4] = (words[3] >> BigInt(16) | words[4] << BigInt(48)) & mask;
    hi[0] = words[4] >> BigInt(4) & mask;
    hi[1] = (words[4] >> BigInt(56) | words[5] << BigInt(8)) & mask;
    hi[2] = (words[5] >> BigInt(44) | words[6] << BigInt(20)) & mask;
    hi[3] = (words[6] >> BigInt(32) | words[7] << BigInt(32)) & mask;
    hi[4] = words[7] >> BigInt(20);
    lo = scalar_montgomery_mul(lo, SCALAR_R);
    hi = scalar_montgomery_mul(hi, SCALAR_RR);
    return scalar_52_add(hi, lo);
}
exports.unpacked_scalar_from_bytes_wide = unpacked_scalar_from_bytes_wide;
var SCALAR_R = new BigUint64Array([
    BigInt("0x000f48bd6721e6ed"),
    BigInt("0x0003bab5ac67e45a"),
    BigInt("0x000fffffeb35e51b"),
    BigInt("0x000fffffffffffff"),
    BigInt("0x00000fffffffffff")
]);
var SCALAR_RR = new BigUint64Array([
    BigInt("0x0009d265e952d13b"),
    BigInt("0x000d63c715bea69f"),
    BigInt("0x0005be65cb687604"),
    BigInt("0x0003dceec73d217f"),
    BigInt("0x000009411b7c309a")
]);
/*
/// Compute `a + b` (mod l)
    pub fn add(a: &Scalar52, b: &Scalar52) -> Scalar52 {
        let mut sum = Scalar52::zero();
        let mask = (1u64 << 52) - 1;

        // a + b
        let mut carry: u64 = 0;
        for i in 0..5 {
            carry = a[i] + b[i] + (carry >> 52);
            sum[i] = carry & mask;
        }

        // subtract l if the sum is >= l
        Scalar52::sub(&sum, &constants::L)
    }
*/ function scalar_52_add(a, b) {
    var sum = SCALAR_0.slice();
    var mask = LOW_52_BIT_MASK;
    var carry = _0n;
    for(var i = 0; i < 5; i++){
        carry = a[i] + b[i] + (carry >> _52n);
        sum[i] = carry & mask;
    }
    return scalar_sub(sum, SCALAR_L);
}
function scalar_montgomery_mul(a, b) {
    return scalar_montgomery_reduce(scalar_mul_internal(a, b));
}
/*
// Compute `limbs/R` (mod l), where R is the Montgomery modulus 2^260
    #[inline(always)]
    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> Scalar52 {

        #[inline(always)]
        fn part1(sum: u128) -> (u128, u64) {
            let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);
            ((sum + m(p,constants::L[0])) >> 52, p)
        }

        #[inline(always)]
        fn part2(sum: u128) -> (u128, u64) {
            let w = (sum as u64) & ((1u64 << 52) - 1);
            (sum >> 52, w)
        }

        // note: l[3] is zero, so its multiples can be skipped
        let l = &constants::L;

        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R
        let (carry, n0) = part1(        limbs[0]);
        let (carry, n1) = part1(carry + limbs[1] + m(n0,l[1]));
        let (carry, n2) = part1(carry + limbs[2] + m(n0,l[2]) + m(n1,l[1]));
        let (carry, n3) = part1(carry + limbs[3]              + m(n1,l[2]) + m(n2,l[1]));
        let (carry, n4) = part1(carry + limbs[4] + m(n0,l[4])              + m(n2,l[2]) + m(n3,l[1]));

        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result
        let (carry, r0) = part2(carry + limbs[5]              + m(n1,l[4])              + m(n3,l[2]) + m(n4,l[1]));
        let (carry, r1) = part2(carry + limbs[6]                           + m(n2,l[4])              + m(n4,l[2]));
        let (carry, r2) = part2(carry + limbs[7]                                        + m(n3,l[4])             );
        let (carry, r3) = part2(carry + limbs[8]                                                     + m(n4,l[4]));
        let         r4 = carry as u64;

        // result may be >= l, so attempt to subtract l
        Scalar52::sub(&Scalar52([r0,r1,r2,r3,r4]), l)
    }

*/ function scalar_montgomery_reduce(limbs) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var l = SCALAR_L.slice();
    var carry, n0, n1, n2, n3, n4, r0, r1, r2, r3, r4;
    _a = __read(smr_part1(limbs[0]), 2), carry = _a[0], n0 = _a[1];
    _b = __read(smr_part1(carry + limbs[1] + n0 * l[1]), 2), carry = _b[0], n1 = _b[1];
    _c = __read(smr_part1(carry + limbs[2] + n0 * l[2] + n1 * l[1]), 2), carry = _c[0], n2 = _c[1];
    _d = __read(smr_part1(carry + limbs[3] + n1 * l[2] + n2 * l[1]), 2), carry = _d[0], n3 = _d[1];
    _e = __read(smr_part1(carry + limbs[4] + n0 * l[4] + n2 * l[2] + n3 * l[1]), 2), carry = _e[0], n4 = _e[1];
    _f = __read(smr_part2(carry + limbs[5] + n1 * l[4] + n3 * l[2] + n4 * l[1]), 2), carry = _f[0], r0 = _f[1];
    _g = __read(smr_part2(carry + limbs[6] + n2 * l[4] + n4 * l[2]), 2), carry = _g[0], r1 = _g[1];
    _h = __read(smr_part2(carry + limbs[7] + n3 * l[4]), 2), carry = _h[0], r2 = _h[1];
    _j = __read(smr_part2(carry + limbs[8] + n4 * l[4]), 2), carry = _j[0], r3 = _j[1];
    r4 = carry & LOW_64_BIT_MASK;
    return scalar_sub(new BigUint64Array([
        r0,
        r1,
        r2,
        r3,
        r4
    ]), l);
}
function smr_part1(sum) {
    var p = rust_u64_wrapping_mul(sum, LFACTOR) & LOW_52_BIT_MASK;
    return [
        sum + p * SCALAR_L[0] >> _52n,
        p
    ];
}
function smr_part2(sum) {
    var w = sum & LOW_52_BIT_MASK;
    return [
        sum >> _52n,
        w
    ];
}
var U64_PLUS_ONE = _1n << _64n;
function rust_u64_wrapping_mul(a, b) {
    // Convert inputs to BigInt and perform multiplication
    return a * b % U64_PLUS_ONE;
}
/*
/// Compute `a - b` (mod l)
    pub fn sub(a: &Scalar52, b: &Scalar52) -> Scalar52 {
        let mut difference = Scalar52::zero();
        let mask = (1u64 << 52) - 1;

        // a - b
        let mut borrow: u64 = 0;
        for i in 0..5 {
            borrow = a[i].wrapping_sub(b[i] + (borrow >> 63));
            difference[i] = borrow & mask;
        }

        // conditionally add l if the difference is negative
        let underflow_mask = ((borrow >> 63) ^ 1).wrapping_sub(1);
        let mut carry: u64 = 0;
        for i in 0..5 {
            carry = (carry >> 52) + difference[i] + (constants::L[i] & underflow_mask);
            difference[i] = carry & mask;
        }

        difference
    }
*/ function scalar_sub(a, b) {
    var difference = SCALAR_0.slice();
    var mask = LOW_52_BIT_MASK;
    var borrow = _0n;
    for(var i = 0; i < 5; i++){
        borrow = rust_u64_wrapping_sub(a[i], b[i] + (borrow >> BigInt(63)));
        difference[i] = borrow & mask;
    }
    // conditionally add l if the difference is negative
    var underflow_mask = rust_u64_wrapping_sub(borrow >> BigInt(63) ^ _1n, _1n);
    var carry = _0n;
    for(var i = 0; i < 5; i++){
        carry = (carry >> _52n) + difference[i] + (SCALAR_L[i] & underflow_mask);
        difference[i] = carry & mask;
    }
    return difference;
}
/**
 * ```rs
 * pub const fn wrapping_sub_signed(self, rhs: i64) -> u64
 * ```
*/ function rust_u64_wrapping_sub(self, rhs) {
    var U64_MAX = LOW_64_BIT_MASK; // 2^64 - 1, max value of u64
    // Convert inputs to BigInt
    var result = BigInt(self) - BigInt(rhs);
    // Wrap around if out of bounds
    if (result < _0n) {
        result += U64_MAX + _1n; // Wrap from negative to upper bound
    } else if (result > U64_MAX) {
        result %= U64_MAX + _1n; // Wrap around on overflow
    }
    return result;
}
var SCALAR_0 = new BigUint64Array(5).fill(_0n);
var SCALAR_L = new BigUint64Array([
    BigInt("0x0002631a5cf5d3ed"),
    BigInt("0x000dea2f79cd6581"),
    BigInt("0x000000000014def9"),
    BigInt("0x0000000000000000"),
    BigInt("0x0000100000000000")
]);
var LFACTOR = BigInt("0x51da312547e1b");
/*
#[inline(always)]
fn m(x: u64, y: u64) -> u128 {
    (x as u128) * (y as u128)
}
/// Compute `a * b`
    #[inline(always)]
    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9] {
        let mut z = [0u128; 9];

        z[0] = m(a[0],b[0]);
        z[1] = m(a[0],b[1]) + m(a[1],b[0]);
        z[2] = m(a[0],b[2]) + m(a[1],b[1]) + m(a[2],b[0]);
        z[3] = m(a[0],b[3]) + m(a[1],b[2]) + m(a[2],b[1]) + m(a[3],b[0]);
        z[4] = m(a[0],b[4]) + m(a[1],b[3]) + m(a[2],b[2]) + m(a[3],b[1]) + m(a[4],b[0]);
        z[5] =                m(a[1],b[4]) + m(a[2],b[3]) + m(a[3],b[2]) + m(a[4],b[1]);
        z[6] =                               m(a[2],b[4]) + m(a[3],b[3]) + m(a[4],b[2]);
        z[7] =                                              m(a[3],b[4]) + m(a[4],b[3]);
        z[8] =                                                             m(a[4],b[4]);

        z
    }
*/ function scalar_mul_internal(a, b) {
    var z = new Array(9);
    z[0] = a[0] * b[0];
    z[1] = a[0] * b[1] + a[1] * b[0];
    z[2] = a[0] * b[2] + a[1] * b[1] + a[2] * b[0];
    z[3] = a[0] * b[3] + a[1] * b[2] + a[2] * b[1] + a[3] * b[0];
    z[4] = a[0] * b[4] + a[1] * b[3] + a[2] * b[2] + a[3] * b[1] + a[4] * b[0];
    z[5] = a[1] * b[4] + a[2] * b[3] + a[3] * b[2] + a[4] * b[1];
    z[6] = a[2] * b[4] + a[3] * b[3] + a[4] * b[2];
    z[7] = a[3] * b[4] + a[4] * b[3];
    z[8] = a[4] * b[4];
    return z;
}
/*
 /// Pack the limbs of this `Scalar52` into 32 bytes
    pub fn to_bytes(&self) -> [u8; 32] {
        let mut s = [0u8; 32];

        s[0]  =  (self.0[ 0] >>  0)                      as u8;
        s[1]  =  (self.0[ 0] >>  8)                      as u8;
        s[2]  =  (self.0[ 0] >> 16)                      as u8;
        s[3]  =  (self.0[ 0] >> 24)                      as u8;
        s[4]  =  (self.0[ 0] >> 32)                      as u8;
        s[5]  =  (self.0[ 0] >> 40)                      as u8;
        s[6]  = ((self.0[ 0] >> 48) | (self.0[ 1] << 4)) as u8;
        s[7]  =  (self.0[ 1] >>  4)                      as u8;
        s[8]  =  (self.0[ 1] >> 12)                      as u8;
        s[9]  =  (self.0[ 1] >> 20)                      as u8;
        s[10] =  (self.0[ 1] >> 28)                      as u8;
        s[11] =  (self.0[ 1] >> 36)                      as u8;
        s[12] =  (self.0[ 1] >> 44)                      as u8;
        s[13] =  (self.0[ 2] >>  0)                      as u8;
        s[14] =  (self.0[ 2] >>  8)                      as u8;
        s[15] =  (self.0[ 2] >> 16)                      as u8;
        s[16] =  (self.0[ 2] >> 24)                      as u8;
        s[17] =  (self.0[ 2] >> 32)                      as u8;
        s[18] =  (self.0[ 2] >> 40)                      as u8;
        s[19] = ((self.0[ 2] >> 48) | (self.0[ 3] << 4)) as u8;
        s[20] =  (self.0[ 3] >>  4)                      as u8;
        s[21] =  (self.0[ 3] >> 12)                      as u8;
        s[22] =  (self.0[ 3] >> 20)                      as u8;
        s[23] =  (self.0[ 3] >> 28)                      as u8;
        s[24] =  (self.0[ 3] >> 36)                      as u8;
        s[25] =  (self.0[ 3] >> 44)                      as u8;
        s[26] =  (self.0[ 4] >>  0)                      as u8;
        s[27] =  (self.0[ 4] >>  8)                      as u8;
        s[28] =  (self.0[ 4] >> 16)                      as u8;
        s[29] =  (self.0[ 4] >> 24)                      as u8;
        s[30] =  (self.0[ 4] >> 32)                      as u8;
        s[31] =  (self.0[ 4] >> 40)                      as u8;

        s
    }
*/ function pack_unpacked_scalar(input) {
    var s = new Uint8Array(32);
    var u8mask = BigInt(0xff);
    s[0] = Number(input[0] >> _0n & u8mask);
    s[1] = Number(input[0] >> BigInt(8) & u8mask);
    s[2] = Number(input[0] >> BigInt(16) & u8mask);
    s[3] = Number(input[0] >> BigInt(24) & u8mask);
    s[4] = Number(input[0] >> BigInt(32) & u8mask);
    s[5] = Number(input[0] >> BigInt(40) & u8mask);
    s[6] = Number((input[0] >> BigInt(48) | input[1] << BigInt(4)) & u8mask);
    s[7] = Number(input[1] >> BigInt(4) & u8mask);
    s[8] = Number(input[1] >> BigInt(12) & u8mask);
    s[9] = Number(input[1] >> BigInt(20) & u8mask);
    s[10] = Number(input[1] >> BigInt(28) & u8mask);
    s[11] = Number(input[1] >> BigInt(36) & u8mask);
    s[12] = Number(input[1] >> BigInt(44) & u8mask);
    s[13] = Number(input[2] >> _0n & u8mask);
    s[14] = Number(input[2] >> BigInt(8) & u8mask);
    s[15] = Number(input[2] >> BigInt(16) & u8mask);
    s[16] = Number(input[2] >> BigInt(24) & u8mask);
    s[17] = Number(input[2] >> BigInt(32) & u8mask);
    s[18] = Number(input[2] >> BigInt(40) & u8mask);
    s[19] = Number((input[2] >> BigInt(48) | input[3] << BigInt(4)) & u8mask);
    s[20] = Number(input[3] >> BigInt(4) & u8mask);
    s[21] = Number(input[3] >> BigInt(12) & u8mask);
    s[22] = Number(input[3] >> BigInt(20) & u8mask);
    s[23] = Number(input[3] >> BigInt(28) & u8mask);
    s[24] = Number(input[3] >> BigInt(36) & u8mask);
    s[25] = Number(input[3] >> BigInt(44) & u8mask);
    s[26] = Number(input[4] >> _0n & u8mask);
    s[27] = Number(input[4] >> BigInt(8) & u8mask);
    s[28] = Number(input[4] >> BigInt(16) & u8mask);
    s[29] = Number(input[4] >> BigInt(24) & u8mask);
    s[30] = Number(input[4] >> BigInt(32) & u8mask);
    s[31] = Number(input[4] >> BigInt(40) & u8mask);
    return s;
}
exports.pack_unpacked_scalar = pack_unpacked_scalar;
/*
#[allow(non_snake_case)]
    fn neg(self) -> Scalar {
        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);
        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);
        UnpackedScalar::sub(&UnpackedScalar::zero(), &self_mod_l).pack()
    }
}
*/ function negate_scalar(scalar) {
    var self_R = scalar_mul_internal(unpacked_scalar_from_bytes(scalar), SCALAR_R);
    var self_mod_l = scalar_montgomery_reduce(self_R);
    return pack_unpacked_scalar(scalar_sub(SCALAR_0, self_mod_l));
}
exports.negate_scalar = negate_scalar;
/*
pub(crate) fn non_adjacent_form(&self, w: usize) -> [i8; 256] {
        // required by the NAF definition
        debug_assert!( w >= 2 );
        // required so that the NAF digits fit in i8
        debug_assert!( w <= 8 );

        use byteorder::{ByteOrder, LittleEndian};

        let mut naf = [0i8; 256];

        let mut x_u64 = [0u64; 5];
        LittleEndian::read_u64_into(&self.bytes, &mut x_u64[0..4]);

        let width = 1 << w;
        let window_mask = width - 1;

        let mut pos = 0;
        let mut carry = 0;
        while pos < 256 {
            // Construct a buffer of bits of the scalar, starting at bit `pos`
            let u64_idx = pos / 64;
            let bit_idx = pos % 64;
            let bit_buf: u64;
            if bit_idx < 64 - w {
                // This window's bits are contained in a single u64
                bit_buf = x_u64[u64_idx] >> bit_idx;
            } else {
                // Combine the current u64's bits with the bits from the next u64
                bit_buf = (x_u64[u64_idx] >> bit_idx) | (x_u64[1+u64_idx] << (64 - bit_idx));
            }

            // Add the carry into the current window
            let window = carry + (bit_buf & window_mask);

            if window & 1 == 0 {
                // If the window value is even, preserve the carry and continue.
                // Why is the carry preserved?
                // If carry == 0 and window & 1 == 0, then the next carry should be 0
                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1
                pos += 1;
                continue;
            }

            if window < width/2 {
                carry = 0;
                naf[pos] = window as i8;
            } else {
                carry = 1;
                naf[pos] = (window as i8).wrapping_sub(width as i8);
            }

            pos += w;
        }

        naf
    }
*/ function scalar_non_adjacent_form(scalar, w) {
    // required by the NAF definition
    if (w < 2) throw new Error("w must be >= 2");
    // required so that the NAF digits fit in i8
    if (w > 8) throw new Error("w must be <= 8");
    var naf = new Int8Array(256);
    var naf_u8 = new Uint8Array(naf.buffer);
    var x_u64 = new BigUint64Array(5);
    // LittleEndian::read_u64_into(&self.bytes, &mut x_u64[0..4]);
    read_u64_into_LE(scalar, x_u64, 4);
    var width = _1n << BigInt(w);
    var window_mask = width - _1n;
    var pos = 0;
    var carry = _0n;
    while(pos < 256){
        var u64_idx = pos / 64 >>> 0;
        var bit_idx = pos % 64;
        var bit_buf = void 0;
        if (bit_idx < 64 - w) bit_buf = x_u64[u64_idx] >> BigInt(bit_idx);
        else bit_buf = x_u64[u64_idx] >> BigInt(bit_idx) | x_u64[1 + u64_idx] << BigInt(64 - bit_idx);
        var window_1 = carry + (bit_buf & window_mask);
        if ((window_1 & _1n) === _0n) {
            // If the window value is even, preserve the carry and continue.
            // Why is the carry preserved?
            // If carry == 0 and window & 1 == 0, then the next carry should be 0
            // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1
            pos += 1;
            continue;
        }
        if (window_1 < width / BigInt(2)) {
            carry = _0n;
            naf_u8[pos] = Number(window_1) & 0xff;
        } else {
            carry = _1n;
            naf_u8[pos] = Number(window_1) - Number(width) & 0xff;
        }
        pos += w;
    }
    return naf;
}
function read_u64_into_LE(src, dst, dst_len) {
    if (dst_len === void 0) {
        dst_len = Math.min(dst.length * 8, src.length) / 8 >>> 0;
    }
    if (src.length > dst.length * 8) {
        throw new Error("Source and destination size mismatch");
    }
    var srcView = new DataView(src.buffer, src.byteOffset, src.byteLength);
    var dstView = new DataView(dst.buffer, dst.byteOffset, dst.byteLength);
    for(var i = 0; i < dst_len; i++){
        dstView.setBigUint64(i * 8, srcView.getBigUint64(i * 8, true), true);
    }
}
var AFFINE_ODD_MULTIPLES_OF_BASEPOINT = new NafLookupTable([
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3540182452943730"),
        BigInt("2497478415033846"),
        BigInt("2521227595762870"),
        BigInt("1462984067271729"),
        BigInt("2389212253076811")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("62697248952638"),
        BigInt("204681361388450"),
        BigInt("631292143396476"),
        BigInt("338455783676468"),
        BigInt("1213667448819585")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("301289933810280"),
        BigInt("1259582250014073"),
        BigInt("1422107436869536"),
        BigInt("796239922652654"),
        BigInt("1953934009299142")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1601611775252272"),
        BigInt("1720807796594148"),
        BigInt("1132070835939856"),
        BigInt("3512254832574799"),
        BigInt("2147779492816910")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("316559037616741"),
        BigInt("2177824224946892"),
        BigInt("1459442586438991"),
        BigInt("1461528397712656"),
        BigInt("751590696113597")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1850748884277385"),
        BigInt("1200145853858453"),
        BigInt("1068094770532492"),
        BigInt("672251375690438"),
        BigInt("1586055907191707")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("769950342298400"),
        BigInt("2384754244604994"),
        BigInt("3095885746880802"),
        BigInt("3225892188161580"),
        BigInt("2977876099231263")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("425251763115706"),
        BigInt("608463272472562"),
        BigInt("442562545713235"),
        BigInt("837766094556764"),
        BigInt("374555092627893")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1086255230780037"),
        BigInt("274979815921559"),
        BigInt("1960002765731872"),
        BigInt("929474102396301"),
        BigInt("1190409889297339")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2916800678241215"),
        BigInt("2065379846933858"),
        BigInt("2622030924071124"),
        BigInt("2602788184473875"),
        BigInt("1233371373142984")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2019367628972465"),
        BigInt("676711900706637"),
        BigInt("110710997811333"),
        BigInt("1108646842542025"),
        BigInt("517791959672113")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("965130719900578"),
        BigInt("247011430587952"),
        BigInt("526356006571389"),
        BigInt("91986625355052"),
        BigInt("2157223321444601")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1802695059464988"),
        BigInt("1664899123557221"),
        BigInt("2845359304426105"),
        BigInt("2160434469266658"),
        BigInt("3179370264440279")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1725674970513508"),
        BigInt("1933645953859181"),
        BigInt("1542344539275782"),
        BigInt("1767788773573747"),
        BigInt("1297447965928905")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1381809363726107"),
        BigInt("1430341051343062"),
        BigInt("2061843536018959"),
        BigInt("1551778050872521"),
        BigInt("2036394857967624")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("4222693909998302"),
        BigInt("2779866139518454"),
        BigInt("1619374932191226"),
        BigInt("2207306624415883"),
        BigInt("1169170329061080")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2070390218572616"),
        BigInt("1458919061857835"),
        BigInt("624171843017421"),
        BigInt("1055332792707765"),
        BigInt("433987520732508")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("893653801273833"),
        BigInt("1168026499324677"),
        BigInt("1242553501121234"),
        BigInt("1306366254304474"),
        BigInt("1086752658510815")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2465253816303469"),
        BigInt("3191571337672685"),
        BigInt("1159882208056013"),
        BigInt("2569188183312765"),
        BigInt("621213314200686")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1971678598905747"),
        BigInt("338026507889165"),
        BigInt("762398079972271"),
        BigInt("655096486107477"),
        BigInt("42299032696322")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("177130678690680"),
        BigInt("1754759263300204"),
        BigInt("1864311296286618"),
        BigInt("1180675631479880"),
        BigInt("1292726903152791")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1913163449625248"),
        BigInt("2712579013977241"),
        BigInt("2193883288642313"),
        BigInt("1008900146920800"),
        BigInt("1721983679009502")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1070401523076875"),
        BigInt("1272492007800961"),
        BigInt("1910153608563310"),
        BigInt("2075579521696771"),
        BigInt("1191169788841221")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("692896803108118"),
        BigInt("500174642072499"),
        BigInt("2068223309439677"),
        BigInt("1162190621851337"),
        BigInt("1426986007309901")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1819621230288238"),
        BigInt("2735700366193240"),
        BigInt("1755134670739586"),
        BigInt("3080648199451191"),
        BigInt("4172807995775876")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("992069868904071"),
        BigInt("799011518185730"),
        BigInt("1777586403832768"),
        BigInt("1134820506145684"),
        BigInt("1999461475558530")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("425204543703124"),
        BigInt("2040469794090382"),
        BigInt("1651690622153809"),
        BigInt("1500530168597569"),
        BigInt("1253908377065966")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2105824306960939"),
        BigInt("1387520302709358"),
        BigInt("3633176580451016"),
        BigInt("2211816663841753"),
        BigInt("1629085891776489")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1485201376284999"),
        BigInt("1022406647424656"),
        BigInt("504181009209019"),
        BigInt("962621520820995"),
        BigInt("590876713147230")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("265873406365287"),
        BigInt("1192742653492898"),
        BigInt("88553098803050"),
        BigInt("525037770869640"),
        BigInt("1266933811251234")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3552316659826612"),
        BigInt("1254279525791875"),
        BigInt("1609927932077699"),
        BigInt("3578654071679972"),
        BigInt("3750681296069893")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("37186803519861"),
        BigInt("1404297334376301"),
        BigInt("578519728836650"),
        BigInt("1740727951192592"),
        BigInt("2095534282477028")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("833234263154399"),
        BigInt("2023862470013762"),
        BigInt("1854137933982069"),
        BigInt("853924318090959"),
        BigInt("1589812702805850")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3679150557957763"),
        BigInt("1319179453661745"),
        BigInt("497496853611112"),
        BigInt("2665464286942351"),
        BigInt("1208137952365560")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1654513078530905"),
        BigInt("907489875842908"),
        BigInt("126098711296368"),
        BigInt("1726320004173677"),
        BigInt("28269495058173")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("114436686957443"),
        BigInt("532739313025996"),
        BigInt("115428841215897"),
        BigInt("2191499400074366"),
        BigInt("370280402676434")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1111146849833253"),
        BigInt("2016430049079759"),
        BigInt("1860522747477948"),
        BigInt("3537164738290194"),
        BigInt("4137142824844184")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("429069864577128"),
        BigInt("975327637149449"),
        BigInt("237881983565075"),
        BigInt("1654761232378630"),
        BigInt("2122527599091807")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2093793463548278"),
        BigInt("754827233241879"),
        BigInt("1420389751719629"),
        BigInt("1829952782588138"),
        BigInt("2011865756773717")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("676293365438898"),
        BigInt("2850296017886344"),
        BigInt("1205350322490195"),
        BigInt("2763699392265669"),
        BigInt("2133931188538142")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("48340340349120"),
        BigInt("1299261101494832"),
        BigInt("1137329686775218"),
        BigInt("1534848106674340"),
        BigInt("1351662218216799")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1904520614137939"),
        BigInt("1590301001714014"),
        BigInt("215781420985270"),
        BigInt("2043534301034629"),
        BigInt("1970888949300424")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2365217962409710"),
        BigInt("2061307169694064"),
        BigInt("1887478590157603"),
        BigInt("2169639621284316"),
        BigInt("2373810867477200")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1020052624656948"),
        BigInt("1260412094216707"),
        BigInt("366721640607121"),
        BigInt("585331442306596"),
        BigInt("345876457758061")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("975390299880933"),
        BigInt("1066555195234642"),
        BigInt("12651997758352"),
        BigInt("1184252205433068"),
        BigInt("1058378155074223")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1431537716602643"),
        BigInt("2024827957433813"),
        BigInt("3746434518400495"),
        BigInt("1087794891033550"),
        BigInt("2156817571680455")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("929288033346881"),
        BigInt("255179964546973"),
        BigInt("711057989588035"),
        BigInt("208899572612840"),
        BigInt("185348357387383")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("823689746424808"),
        BigInt("47266130989546"),
        BigInt("209403309368097"),
        BigInt("1100966895202707"),
        BigInt("710792075292719")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2311213117823762"),
        BigInt("3296668540922318"),
        BigInt("2004276520649823"),
        BigInt("1861500579441125"),
        BigInt("3148029033359833")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1563693677475261"),
        BigInt("1843782073741194"),
        BigInt("1950700654453170"),
        BigInt("911540858113949"),
        BigInt("2085151496302359")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1427880892005482"),
        BigInt("106216431121745"),
        BigInt("42608394782284"),
        BigInt("1217295886989793"),
        BigInt("1514235272796882")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3544335535746750"),
        BigInt("2367994491347456"),
        BigInt("2567261456502612"),
        BigInt("1854058085060971"),
        BigInt("2263545563461076")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("787426011300053"),
        BigInt("2105981035769060"),
        BigInt("1130476291127206"),
        BigInt("1748659348100075"),
        BigInt("53470983013756")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("553548273865386"),
        BigInt("5927805718390"),
        BigInt("65184587381926"),
        BigInt("633576679686953"),
        BigInt("576048559439973")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("993787326657446"),
        BigInt("3868807161609258"),
        BigInt("1615796046728943"),
        BigInt("2514644292681953"),
        BigInt("2059021068660907")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("251010270518880"),
        BigInt("1681684095763484"),
        BigInt("1521949356387564"),
        BigInt("431593457045116"),
        BigInt("1855308922422910")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("618490909691959"),
        BigInt("1257497595618257"),
        BigInt("202952467594088"),
        BigInt("35577762721238"),
        BigInt("1494883566841973")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1673474571932262"),
        BigInt("2409784519770613"),
        BigInt("2636095316260487"),
        BigInt("2761112584601925"),
        BigInt("3333713288149876")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1600640202645197"),
        BigInt("1019569075331823"),
        BigInt("1041916487915822"),
        BigInt("1680448171313267"),
        BigInt("2126903137527901")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("894964745143659"),
        BigInt("106116880092678"),
        BigInt("1009869382959477"),
        BigInt("317866368542032"),
        BigInt("1986983122763912")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1765281781276487"),
        BigInt("2863247187455184"),
        BigInt("2589075472439062"),
        BigInt("1386435905543054"),
        BigInt("2182338478845320")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1144730936996693"),
        BigInt("2213315231278180"),
        BigInt("1489676672185125"),
        BigInt("665039429138074"),
        BigInt("1131283313040268")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2004734176670602"),
        BigInt("1738311085075235"),
        BigInt("418866995976618"),
        BigInt("1050782508034394"),
        BigInt("577747313404652")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2185209688340293"),
        BigInt("1309276076461009"),
        BigInt("2514740038571278"),
        BigInt("3994889904012999"),
        BigInt("3018098826231021")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1405936970888515"),
        BigInt("1754621155316654"),
        BigInt("1211862168554999"),
        BigInt("1813045702919083"),
        BigInt("997853418197172")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("82037622045021"),
        BigInt("1646398333621944"),
        BigInt("613095452763466"),
        BigInt("1312329542583705"),
        BigInt("81014679202721")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2389287991277873"),
        BigInt("403851022333257"),
        BigInt("1597473361477193"),
        BigInt("2953351602509212"),
        BigInt("2135174663049062")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1826548187201150"),
        BigInt("302299893734126"),
        BigInt("1475477168615781"),
        BigInt("842617616347376"),
        BigInt("1438600873676130")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("663049852468609"),
        BigInt("1649295727846569"),
        BigInt("1048009692742781"),
        BigInt("628866177992421"),
        BigInt("1914360327429204")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1795645928096646"),
        BigInt("306878154408959"),
        BigInt("2924901319092394"),
        BigInt("2801261341654799"),
        BigInt("1653782432983523")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2077597317438627"),
        BigInt("212642017882064"),
        BigInt("674844477518888"),
        BigInt("875487498687554"),
        BigInt("2060550250171182")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1420448018683809"),
        BigInt("1032663994771382"),
        BigInt("1341927003385267"),
        BigInt("1340360916546159"),
        BigInt("1988547473895228")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1082660122598844"),
        BigInt("2545055705583789"),
        BigInt("3888919679589007"),
        BigInt("1670283344995811"),
        BigInt("3403239134794618")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("90430593339788"),
        BigInt("1838338032241275"),
        BigInt("571293238480915"),
        BigInt("1639938867416883"),
        BigInt("257378872001111")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1528535658865034"),
        BigInt("1516636853043960"),
        BigInt("787000569996728"),
        BigInt("1464531394704506"),
        BigInt("1684822625133795")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("811329918113934"),
        BigInt("2783463529007378"),
        BigInt("1769095754634835"),
        BigInt("2970819621866866"),
        BigInt("881037178164325")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1784566501964517"),
        BigInt("433890943689325"),
        BigInt("1186055625589419"),
        BigInt("1496077405487512"),
        BigInt("1731807117886548")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("424909811816304"),
        BigInt("1355993963741797"),
        BigInt("409606483251841"),
        BigInt("455665350637068"),
        BigInt("1617009023642808")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2478728492077816"),
        BigInt("2780289048655501"),
        BigInt("2328687177473769"),
        BigInt("4107341333582032"),
        BigInt("1316147724308250")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1617420574301156"),
        BigInt("1741273341070467"),
        BigInt("667135503486508"),
        BigInt("2100436564640123"),
        BigInt("1032223920000865")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1753947659404033"),
        BigInt("247279202390193"),
        BigInt("1819288880178945"),
        BigInt("737334285670249"),
        BigInt("1037873664856104")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1762568490530034"),
        BigInt("673742465299012"),
        BigInt("2054571050635888"),
        BigInt("2040165159255111"),
        BigInt("3040123733327257")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1627187989987422"),
        BigInt("1686331580821752"),
        BigInt("1309895873498183"),
        BigInt("719718719104086"),
        BigInt("300063199808722")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("238176707016164"),
        BigInt("1440454788877048"),
        BigInt("203336037573144"),
        BigInt("1437789888677072"),
        BigInt("101522256664211")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1895216760098480"),
        BigInt("1934324337975022"),
        BigInt("3677350688973167"),
        BigInt("2536415965456176"),
        BigInt("714678003308640")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("508185358728815"),
        BigInt("1691320535341855"),
        BigInt("2168887448239256"),
        BigInt("1035124393070661"),
        BigInt("1936603999698584")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("390562831571647"),
        BigInt("1390223890708972"),
        BigInt("1383183990676371"),
        BigInt("435998174196410"),
        BigInt("1882086414390730")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3747620842612921"),
        BigInt("2081794785291195"),
        BigInt("3284594056262745"),
        BigInt("2090090346797895"),
        BigInt("2581692978935809")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("244144781251265"),
        BigInt("1290834426417077"),
        BigInt("1888701171101942"),
        BigInt("1233922456644870"),
        BigInt("241117402207491")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1266169390045455"),
        BigInt("1148042013187970"),
        BigInt("878921907853942"),
        BigInt("1815738019658093"),
        BigInt("908920199341621")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2521768507305118"),
        BigInt("953557056811112"),
        BigInt("2015863732865770"),
        BigInt("1358382511861315"),
        BigInt("2835421647899992")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2239837206240498"),
        BigInt("330928973149665"),
        BigInt("422268062913642"),
        BigInt("1481280019493032"),
        BigInt("619879520439841")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1360166735366017"),
        BigInt("1770556573948510"),
        BigInt("1395061284191031"),
        BigInt("1814003148068126"),
        BigInt("522781147076884")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2611794802645686"),
        BigInt("707234844948070"),
        BigInt("1314059396506491"),
        BigInt("2919250341703934"),
        BigInt("2161831667832785")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("934831784182383"),
        BigInt("433734253968318"),
        BigInt("1660867106725771"),
        BigInt("1968393082772831"),
        BigInt("873946300968490")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("26306827827554"),
        BigInt("430884999378685"),
        BigInt("1504310424376419"),
        BigInt("1761358720837522"),
        BigInt("542195685418530")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1762131062631725"),
        BigInt("3123952634417535"),
        BigInt("3619918390837537"),
        BigInt("2909990877347294"),
        BigInt("1411594230004385")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("538272372224622"),
        BigInt("1425714779586199"),
        BigInt("588313661410172"),
        BigInt("1497062084392578"),
        BigInt("1602174047128512")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("907490361939255"),
        BigInt("1963620338391363"),
        BigInt("626927432296975"),
        BigInt("1250748516081414"),
        BigInt("959901171882527")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1335066153744413"),
        BigInt("2887804660779657"),
        BigInt("2653073855954038"),
        BigInt("2765226981667422"),
        BigInt("938831784476763")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("296699434737224"),
        BigInt("2047543711075683"),
        BigInt("2076451038937139"),
        BigInt("227783599906901"),
        BigInt("1602062110967627")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1574834773194203"),
        BigInt("1384279952062839"),
        BigInt("393652417255803"),
        BigInt("2166968242848859"),
        BigInt("1552890441390820")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1619646774410947"),
        BigInt("1576090644023562"),
        BigInt("3035228391320965"),
        BigInt("1735328519940543"),
        BigInt("2355324535937066")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1024074573633446"),
        BigInt("957088456885874"),
        BigInt("1690425531356997"),
        BigInt("2102187380180052"),
        BigInt("1082544623222033")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1871906170635853"),
        BigInt("1719383891167200"),
        BigInt("1584032250247862"),
        BigInt("823764804192117"),
        BigInt("2244048510084261")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("642147846489775"),
        BigInt("3334304977145699"),
        BigInt("305205716788147"),
        BigInt("2589176626729533"),
        BigInt("2224680511484174")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1734162377166545"),
        BigInt("260713621840346"),
        BigInt("157174591942595"),
        BigInt("952544272517991"),
        BigInt("222818702471733")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1213115494182947"),
        BigInt("286778704335711"),
        BigInt("2130189536016490"),
        BigInt("308349182281342"),
        BigInt("1217623948685491")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3360052266973635"),
        BigInt("1843486583624091"),
        BigInt("1561693837124349"),
        BigInt("1084041964025479"),
        BigInt("1866270922024009")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("460705465481210"),
        BigInt("1968151453817859"),
        BigInt("497005926994844"),
        BigInt("625618055866751"),
        BigInt("2176893440866887")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1655800250476757"),
        BigInt("2036588542300609"),
        BigInt("666447448675243"),
        BigInt("1615721995750683"),
        BigInt("1508669225186765")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2245948203759141"),
        BigInt("1058306669699396"),
        BigInt("1452898014240582"),
        BigInt("3961024141962768"),
        BigInt("1633235287338608")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("986647273684279"),
        BigInt("1507266907811370"),
        BigInt("1260572633649005"),
        BigInt("2071672342077446"),
        BigInt("695976026010857")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1312356620823495"),
        BigInt("1635278548098567"),
        BigInt("901946076841033"),
        BigInt("585120475533168"),
        BigInt("1240667113237384")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2313723935779695"),
        BigInt("1506054666773895"),
        BigInt("996040223525031"),
        BigInt("636592914999692"),
        BigInt("1497801917020297")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("292042016419794"),
        BigInt("1158932298133044"),
        BigInt("2062611870323738"),
        BigInt("1946058478962569"),
        BigInt("1749165808126286")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("654683942212830"),
        BigInt("1526897351349087"),
        BigInt("2006818439922838"),
        BigInt("2194919327350361"),
        BigInt("1451960776874416")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3015041017808905"),
        BigInt("2951823141773809"),
        BigInt("2584865668253675"),
        BigInt("2508192032998563"),
        BigInt("2582137700042019")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1628123495344283"),
        BigInt("2072923641214546"),
        BigInt("1647225812023982"),
        BigInt("855655925244679"),
        BigInt("1758126430071140")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1615895096489599"),
        BigInt("275295258643784"),
        BigInt("937665541219916"),
        BigInt("1313496726746346"),
        BigInt("1186468946422626")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1603070202850694"),
        BigInt("2072127623773242"),
        BigInt("1692648737212158"),
        BigInt("2493373404187852"),
        BigInt("1248948672117105")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("11167836031898"),
        BigInt("596565174397990"),
        BigInt("2196351068723859"),
        BigInt("314744641791907"),
        BigInt("1102014997250781")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1409047922401191"),
        BigInt("69960384467966"),
        BigInt("688103515547600"),
        BigInt("1309746102488044"),
        BigInt("150292892873778")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1986083055103168"),
        BigInt("691715819340300"),
        BigInt("1361811659746933"),
        BigInt("3459052030333434"),
        BigInt("1063594696046061")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1201987338414749"),
        BigInt("2198784582460616"),
        BigInt("1203335513981498"),
        BigInt("489243077045066"),
        BigInt("2205278143582433")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2034744376624534"),
        BigInt("2077387101466387"),
        BigInt("148448542974969"),
        BigInt("1502697574577258"),
        BigInt("473186584705655")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("472016956315960"),
        BigInt("720786972252993"),
        BigInt("2840633661190043"),
        BigInt("3150798753357827"),
        BigInt("2816563335499153")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("253464247569755"),
        BigInt("168314237403057"),
        BigInt("511780806170295"),
        BigInt("1058862316549135"),
        BigInt("1646858476817137")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("595092995922219"),
        BigInt("1491311840717691"),
        BigInt("291581784452778"),
        BigInt("1569186646367854"),
        BigInt("1031385061400544")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3483137021572755"),
        BigInt("1526955102024322"),
        BigInt("2778006642704458"),
        BigInt("457549634924205"),
        BigInt("1097420237736736")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1246991699537710"),
        BigInt("81367319519439"),
        BigInt("530844036072196"),
        BigInt("163656863755855"),
        BigInt("1950742455979290")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("191532664076407"),
        BigInt("539378506082089"),
        BigInt("1021612562876554"),
        BigInt("1026603384732632"),
        BigInt("1773368780410653")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("4144620731387879"),
        BigInt("590179521333342"),
        BigInt("4034023318016108"),
        BigInt("2255745030335426"),
        BigInt("2699746851701250")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2206599697359952"),
        BigInt("553895797384417"),
        BigInt("181689161933786"),
        BigInt("1153123447919104"),
        BigInt("778568064152659")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1706307000059211"),
        BigInt("1885601289314487"),
        BigInt("889758608505788"),
        BigInt("550131729999853"),
        BigInt("1006862664714268")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3210197754285058"),
        BigInt("2048500453422630"),
        BigInt("3403309827888207"),
        BigInt("927154428508963"),
        BigInt("4199813798872019")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("992058915374933"),
        BigInt("476120535358775"),
        BigInt("1973648780784340"),
        BigInt("2025282643598818"),
        BigInt("2182318983793230")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1343440812005821"),
        BigInt("1316045839091795"),
        BigInt("1884951299078063"),
        BigInt("1765919609219175"),
        BigInt("2197567554627988")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3129247779382818"),
        BigInt("4415026969054274"),
        BigInt("1900265885969643"),
        BigInt("1528796215447059"),
        BigInt("2172730393748688")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1773355092297603"),
        BigInt("64654329538271"),
        BigInt("1332124041660957"),
        BigInt("748492100858001"),
        BigInt("895500006200535")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2000840647851980"),
        BigInt("546565968824914"),
        BigInt("420633283457524"),
        BigInt("195470736374507"),
        BigInt("1958689297569520")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("743138980705446"),
        BigInt("3411117504637167"),
        BigInt("2591389959690621"),
        BigInt("2380042066577202"),
        BigInt("3022267940115114")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("165947002229363"),
        BigInt("115186103724967"),
        BigInt("1068573292121517"),
        BigInt("1842565776920938"),
        BigInt("1969395681111987")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("553322266190633"),
        BigInt("234265665613185"),
        BigInt("484544650202821"),
        BigInt("1238773526575826"),
        BigInt("2017991917953668")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2581954631514051"),
        BigInt("1245093644265357"),
        BigInt("3537016673825374"),
        BigInt("1834216551713857"),
        BigInt("923978372152807")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1855378315339552"),
        BigInt("890045579230758"),
        BigInt("1764718173975590"),
        BigInt("197904186055854"),
        BigInt("1718129022310327")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1278162928734862"),
        BigInt("1894118254109862"),
        BigInt("987503995465517"),
        BigInt("177406744098996"),
        BigInt("781538103127693")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1996603431230215"),
        BigInt("1191888797552937"),
        BigInt("1207440075928499"),
        BigInt("2765853449051137"),
        BigInt("2525314961343288")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("808903879370889"),
        BigInt("990820108751280"),
        BigInt("1084429472258867"),
        BigInt("1078562781312589"),
        BigInt("254514692695625")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("615855140068469"),
        BigInt("586046731175395"),
        BigInt("693470779212674"),
        BigInt("1964537100203868"),
        BigInt("1350330550265229")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3344544372023708"),
        BigInt("720386671449874"),
        BigInt("2480841360702110"),
        BigInt("2036034126860286"),
        BigInt("2015744690201389")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1337446193390478"),
        BigInt("1984110761311871"),
        BigInt("746489405020285"),
        BigInt("407347127604128"),
        BigInt("1740475330360596")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("140840424783613"),
        BigInt("1063284623568331"),
        BigInt("1136446106453878"),
        BigInt("372042229029799"),
        BigInt("442607248430694")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2330781679120937"),
        BigInt("376801425148230"),
        BigInt("2032603686676107"),
        BigInt("1488926293635130"),
        BigInt("1317278311532959")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1290116731380016"),
        BigInt("2166899563471713"),
        BigInt("831997001838078"),
        BigInt("870954980505220"),
        BigInt("2108537278055823")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1912719171026343"),
        BigInt("846194720551034"),
        BigInt("2043988124740726"),
        BigInt("993234269653961"),
        BigInt("421229796383281")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2651184584992902"),
        BigInt("2775702557638963"),
        BigInt("2539786009779572"),
        BigInt("2575974880015305"),
        BigInt("2122619079836732")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1154054290132562"),
        BigInt("931753998725577"),
        BigInt("1647742001778052"),
        BigInt("865765466488226"),
        BigInt("1083816107290025")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("986341121095108"),
        BigInt("1522330369638573"),
        BigInt("1990880546211047"),
        BigInt("501525962272123"),
        BigInt("198539304862139")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1496414019192687"),
        BigInt("3991034436173951"),
        BigInt("3380311659062196"),
        BigInt("2854747485359158"),
        BigInt("3346958036643152")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("805612068303425"),
        BigInt("1891790027761335"),
        BigInt("1587008567571549"),
        BigInt("722120737390201"),
        BigInt("378156757163816")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1588994517921951"),
        BigInt("977362751042302"),
        BigInt("1329302387067714"),
        BigInt("2069348224564088"),
        BigInt("1586007159625211")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2490539421551682"),
        BigInt("1985699850375015"),
        BigInt("2331762317128172"),
        BigInt("4145097393776678"),
        BigInt("2521049460190674")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("615817553313996"),
        BigInt("2245962768078178"),
        BigInt("482564324326173"),
        BigInt("2101336843140780"),
        BigInt("1240914880829407")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1438242482238189"),
        BigInt("874267817785463"),
        BigInt("1620810389770625"),
        BigInt("866155221338671"),
        BigInt("1040426546798301")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("2403083624110300"),
        BigInt("2548561409802975"),
        BigInt("2492699136535911"),
        BigInt("2358289519456539"),
        BigInt("3203964320363148")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1913986535403097"),
        BigInt("1977163223054199"),
        BigInt("1972905914623196"),
        BigInt("1650122133472502"),
        BigInt("1905849310819035")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("858174816360838"),
        BigInt("614595356564037"),
        BigInt("1099584959044836"),
        BigInt("636998087084906"),
        BigInt("1070393269058348")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3666695924830668"),
        BigInt("3585640662737501"),
        BigInt("2372994528684236"),
        BigInt("2628565977288995"),
        BigInt("3482812783469694")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1994161359147952"),
        BigInt("2198039369802658"),
        BigInt("62790022842537"),
        BigInt("1522306785848169"),
        BigInt("951223194802833")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("852296621440717"),
        BigInt("431889737774209"),
        BigInt("370755457746189"),
        BigInt("437604073958073"),
        BigInt("627857326892757")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1794955764684156"),
        BigInt("2586904290013612"),
        BigInt("1322647643615887"),
        BigInt("856117964085888"),
        BigInt("2652432778663153")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("933592377399646"),
        BigInt("78031722952813"),
        BigInt("926049890685253"),
        BigInt("1471649501316246"),
        BigInt("33789909190376")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1479319468832059"),
        BigInt("203906207621608"),
        BigInt("659828362330083"),
        BigInt("44358398435755"),
        BigInt("1273573524210803")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1592342143350813"),
        BigInt("3227219208247713"),
        BigInt("2345240352078765"),
        BigInt("2577750109932929"),
        BigInt("2933512841197243")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2184946892642995"),
        BigInt("1517382324576002"),
        BigInt("1557940277419806"),
        BigInt("2170635134813213"),
        BigInt("747314658627002")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1823193620577742"),
        BigInt("1135817878516419"),
        BigInt("1731253819308581"),
        BigInt("1031652967267804"),
        BigInt("2123506616999453")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1346190246005805"),
        BigInt("2052692552023851"),
        BigInt("1718128041785940"),
        BigInt("2491557332978474"),
        BigInt("3474370880388305")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("424776012994573"),
        BigInt("281050757243423"),
        BigInt("626466040846420"),
        BigInt("990194703866532"),
        BigInt("38571969885982")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("192408346595466"),
        BigInt("1054889725292349"),
        BigInt("584097975693004"),
        BigInt("1447909807397749"),
        BigInt("2134645004369136")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3169895788615063"),
        BigInt("3503097743181446"),
        BigInt("601598510029975"),
        BigInt("1422812237223371"),
        BigInt("2121009661378329")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1603348391996783"),
        BigInt("2066143816131699"),
        BigInt("1789627290363958"),
        BigInt("2145705961178118"),
        BigInt("1985578641438222")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("352633958653380"),
        BigInt("856927627345554"),
        BigInt("793925083122702"),
        BigInt("93551575767286"),
        BigInt("1222010153634215")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1756866499986349"),
        BigInt("911731956999969"),
        BigInt("2707505543214075"),
        BigInt("4006920335263786"),
        BigInt("822501008147910")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1094036422864347"),
        BigInt("1897208881572508"),
        BigInt("1503607738246960"),
        BigInt("1901060196071406"),
        BigInt("294068411105729")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("587776484399576"),
        BigInt("1116861711228807"),
        BigInt("343398777436088"),
        BigInt("936544065763093"),
        BigInt("1643746750211060")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("3477749685790410"),
        BigInt("267997399528836"),
        BigInt("2953780922004404"),
        BigInt("3252368924080907"),
        BigInt("3787792887348381")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("2042368155872443"),
        BigInt("41662387210459"),
        BigInt("1676313264498480"),
        BigInt("1333968523426810"),
        BigInt("1765708383352310")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1453394896690938"),
        BigInt("1585795827439909"),
        BigInt("1469309456804303"),
        BigInt("1294645324464404"),
        BigInt("2042954198665899")
    ]))),
    new AffineNielsPoint(new FieldElem51(new BigUint64Array([
        BigInt("1810069207599881"),
        BigInt("1358344669503239"),
        BigInt("1989371257548167"),
        BigInt("2316270051121225"),
        BigInt("3019675451276507")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1866114438287676"),
        BigInt("1663420339568364"),
        BigInt("1437691317033088"),
        BigInt("538298302628038"),
        BigInt("1212711449614363")
    ])), new FieldElem51(new BigUint64Array([
        BigInt("1769235035677897"),
        BigInt("1562012115317882"),
        BigInt("31277513664750"),
        BigInt("536198657928416"),
        BigInt("1976134212537183")
    ])))
]);
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/vrf03.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.scalar_from_bits_inplace = exports.vrf_ed25519_sha512_ell2_compute_challenge = exports.vrf_ed25519_sha512_ell2_nonce_generation = exports.scalar_hash_from_bytes = exports.vrf_ed25519_sha512_ell2_hash_to_curve = exports.edwards_hash_from_bytes = exports.proof_to_hash = exports.vrf_ed25519_sha512_ell2_verify_proof = exports.vrf_ed25519_sha512_ell2_generate_proof = exports.adjust_scalar_bits = exports.extend_secret_key = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var sha2_512_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)");
var curves_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/curves.js [app-client] (ecmascript)");
/**
4.4. RSA-FDH-VRF Ciphersuites

This document defines RSA-FDH-VRF-SHA256 as follows:

suite_string = 0x01.
The hash function Hash is SHA-256 as specified in [RFC6234], with hLen = 32.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA384 as follows:

suite_string = 0x02.
The hash function Hash is SHA-384 as specified in [RFC6234], with hLen = 48.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA512 as follows:

suite_string = 0x03.
The hash function Hash is SHA-512 as specified in [RFC6234], with hLen = 64.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

 */ var SUITE = 0x04;
var ONE = 0x01;
var TWO = 0x02;
/*
pub fn extend(&self) -> (Scalar, [u8; 32]) {
    let mut h: Sha512 = Sha512::new();
    let mut extended = [0u8; 64];
    let mut secret_key_bytes = [0u8; 32];
    let mut extension = [0u8; 32];

    h.update(self.as_bytes());
    extended.copy_from_slice(&h.finalize().as_slice()[..64]);

    secret_key_bytes.copy_from_slice(&extended[..32]);
    extension.copy_from_slice(&extended[32..]);

    secret_key_bytes[0] &= 248;
    secret_key_bytes[31] &= 127;
    secret_key_bytes[31] |= 64;

    (Scalar::from_bits(secret_key_bytes), extension)
}
*/ function extend_secret_key(secret_key) {
    var extended = (0, sha2_512_1.sha2_512_sync)(secret_key);
    var secret_key_bytes = extended.slice(0, 32);
    var extension = extended.slice(32, 64);
    secret_key_bytes[0] &= 248;
    secret_key_bytes[31] &= 127;
    secret_key_bytes[31] |= 64;
    adjust_scalar_bits(secret_key_bytes);
    return [
        secret_key_bytes,
        extension
    ];
}
exports.extend_secret_key = extend_secret_key;
function adjust_scalar_bits(bytes) {
    bytes[31] &= 127;
}
exports.adjust_scalar_bits = adjust_scalar_bits;
function vrf_ed25519_sha512_ell2_generate_proof(secret_key, public_key, alpha_string) {
    var _a = __read(extend_secret_key(secret_key), 2), secret_scalar = _a[0], secret_extension = _a[1];
    var h = vrf_ed25519_sha512_ell2_hash_to_curve(public_key, alpha_string);
    var compressed_h = h.compress();
    var gamma = h.scalarMul(secret_scalar);
    var compressed_gamma = gamma.compress();
    var k = vrf_ed25519_sha512_ell2_nonce_generation(secret_extension, compressed_h);
    var compressed_announcement_base = curves_1.ED25519_BASEPOINT_POINT.scalarMul(k).compress();
    var compressed_announcement_h = h.scalarMul(k).compress();
    // Self::compute_challenge(&compressed_h, &gamma, &announcement_base, &announcement_h);
    var challenge = vrf_ed25519_sha512_ell2_compute_challenge(compressed_h, compressed_gamma, compressed_announcement_base, compressed_announcement_h);
    var response = (0, curves_1.add_scalars)(k, (0, curves_1.mul_scalars)(challenge, secret_scalar));
    return {
        gamma: gamma,
        challenge: challenge,
        response: response
    };
}
exports.vrf_ed25519_sha512_ell2_generate_proof = vrf_ed25519_sha512_ell2_generate_proof;
/*
/// Verify VRF function, following the 03 specification.
    pub fn verify(
        &self,
        public_key: &PublicKey03,
        alpha_string: &[u8],
    ) -> Result<[u8; OUTPUT_SIZE], VrfError> {
        let h = Self::hash_to_curve(public_key, alpha_string);
        let compressed_h = h.compress();

        let decompressed_pk = public_key
            .0
            .decompress()
            .ok_or(VrfError::DecompressionFailed)?;

        if decompressed_pk.is_small_order() {
            return Err(VrfError::PkSmallOrder);
        }

        let U = EdwardsPoint::vartime_double_scalar_mul_basepoint(
            &self.challenge.neg(),
            &decompressed_pk,
            &self.response,
        );
        let V = EdwardsPoint::vartime_multiscalar_mul(
            iter::once(self.response).chain(iter::once(self.challenge.neg())),
            iter::once(h).chain(iter::once(self.gamma)),
        );

        // Now we compute the challenge
        let challenge = Self::compute_challenge(&compressed_h, &self.gamma, &U, &V);

        if challenge.to_bytes()[..16] == self.challenge.to_bytes()[..16] {
            Ok(self.proof_to_hash())
        } else {
            Err(VrfError::VerificationFailed)
        }
    }
*/ function vrf_ed25519_sha512_ell2_verify_proof(public_key, alpha_string, proof) {
    var h = vrf_ed25519_sha512_ell2_hash_to_curve(public_key, alpha_string);
    var compressed_h = h.compress();
    var decompressed_pk = (0, curves_1.decompressCompressedEdwardsY)(public_key); // pointFromBytes( public_key );
    if (!decompressed_pk || decompressed_pk.is_small_order()) return false;
    // Scalar
    var proof_challenge = proof.challenge;
    var U = curves_1.EdwardsPoint.vartime_double_scalar_mul_basepoint((0, curves_1.negate_scalar)(proof_challenge), decompressed_pk, proof.response);
    var gamma = proof.gamma;
    /*
    let V = EdwardsPoint::vartime_multiscalar_mul(
            iter::once(self.response).chain(iter::once(self.challenge.neg())),
            iter::once(h).chain(iter::once(self.gamma)),
        );
    */ var V = curves_1.EdwardsPoint.vartime_multiscalar_mul([
        proof.response,
        (0, curves_1.negate_scalar)(proof_challenge)
    ], [
        h,
        gamma
    ]);
    var computed_challenge = vrf_ed25519_sha512_ell2_compute_challenge(compressed_h, proof.gamma.compress(), U.compress(), V.compress());
    return (0, uint8array_utils_1.uint8ArrayEq)(computed_challenge.slice(0, 16), proof_challenge.slice(0, 16));
}
exports.vrf_ed25519_sha512_ell2_verify_proof = vrf_ed25519_sha512_ell2_verify_proof;
/*
/// `proof_to_hash` function, following the 03 specification. This computes the output of the VRF
    /// function. In particular, this function computes
    /// SHA512(SUITE || THREE || Gamma)
    pub fn proof_to_hash(&self) -> [u8; OUTPUT_SIZE] {
        let mut output = [0u8; OUTPUT_SIZE];
        let gamma_cofac = self.gamma.mul_by_cofactor();
        let mut hash = Sha512::new();
        hash.update(SUITE);
        hash.update(THREE);
        hash.update(gamma_cofac.compress().as_bytes());

        output.copy_from_slice(hash.finalize().as_slice());
        output
    }

*/ function proof_to_hash(proof) {
    var gamma_cofac = proof.gamma.mul_by_cofactor();
    var hashInput = new Uint8Array(2 + gamma_cofac.compress().length);
    hashInput[0] = SUITE;
    hashInput[1] = 0x03;
    hashInput.set(gamma_cofac.compress(), 2);
    return (0, sha2_512_1.sha2_512_sync)(hashInput);
}
exports.proof_to_hash = proof_to_hash;
/*
export function vrfProofToBytesProof( proof: IVrfProof03 )
{
    return {
        gamma: bigpointToUint8Array( proof.gamma ),
        challange: encodeInt( proof.challange ),
        response: encodeInt( proof.response ),
    }
}
//*/ function edwards_hash_from_bytes(bytes) {
    var hash = (0, sha2_512_1.sha2_512_sync)(bytes);
    var res = hash.slice(0, 32);
    /*
        //////////////////////////////////////////////////////////////////////////////////////
        //// We need to be compatible with the third version of the VRF standard, which   ////
        //// always unsets the sign bit. Given the visibility of the functions used to    ////
        //// compute the ristretto mapping, we need to fork the original repo, to unset   ////
        //// bit in this function. This fork should never be used, unless one needs to be ////
        //// compatible with the version 3 of the VRF standard.                           ////
        //// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-03#section-5.4.1.2 ////
        //// The goal is to be always a single commit ahead of version 3.2.0, and this    ////
        //// single commit only changes the following line, and a disclaimer in the       ////
        //// README.                                                                      ////
        //////////////////////////////////////////////////////////////////////////////////////
        let sign_bit = 0;

        let fe = FieldElement::from_bytes(&res);

        let M1 = crate::montgomery::elligator_encode(&fe);
        let E1_opt = M1.to_edwards(sign_bit);

        E1_opt
            .expect("Montgomery conversion to Edwards point in Elligator failed")
            .mul_by_cofactor()
    */ var sign_bit = 0;
    var fe = curves_1.FieldElem51.fromBytes(res);
    var M1 = curves_1.FieldElem51.elligator_encode(fe);
    var E1_opt = M1.to_edwards(sign_bit);
    if (!E1_opt) {
        throw new Error("Montgomery conversion to Edwards point in Elligator failed");
    }
    return E1_opt.mul_by_cofactor();
}
exports.edwards_hash_from_bytes = edwards_hash_from_bytes;
function vrf_ed25519_sha512_ell2_hash_to_curve(public_key, alpha_string) {
    var input = new Uint8Array(2 + public_key.length + alpha_string.length);
    input[0] = SUITE;
    input[1] = ONE;
    input.set(public_key, 2);
    input.set(alpha_string, 2 + public_key.length);
    return edwards_hash_from_bytes(input); // sha2_512_sync(input);
}
exports.vrf_ed25519_sha512_ell2_hash_to_curve = vrf_ed25519_sha512_ell2_hash_to_curve;
function scalar_hash_from_bytes(input) {
    return (0, curves_1.scalar_from_bytes_mod_order_wide)((0, sha2_512_1.sha2_512_sync)(input));
}
exports.scalar_hash_from_bytes = scalar_hash_from_bytes;
function vrf_ed25519_sha512_ell2_nonce_generation(secret_extension, compressed_h) {
    var input = new Uint8Array(64);
    input.set(secret_extension, 0);
    input.set(compressed_h, 32);
    //return pointFromBytes(sha2_512_sync(input))
    return scalar_hash_from_bytes(input);
}
exports.vrf_ed25519_sha512_ell2_nonce_generation = vrf_ed25519_sha512_ell2_nonce_generation;
/*
/// Hash points function, following the 03 specification.
    fn compute_challenge(
        compressed_h: &CompressedEdwardsY,
        gamma: &EdwardsPoint,
        announcement_1: &EdwardsPoint,
        announcement_2: &EdwardsPoint,
    ) -> Scalar {
        // we use a scalar of 16 bytes (instead of 32), but store it in 32 bits, as that is what
        // `Scalar::from_bits()` expects.
        let mut scalar_bytes = [0u8; 32];
        let mut challenge_hash = Sha512::new();
        challenge_hash.update(SUITE);
        challenge_hash.update(TWO);
        challenge_hash.update(compressed_h.to_bytes());
        challenge_hash.update(gamma.compress().as_bytes());
        challenge_hash.update(announcement_1.compress().as_bytes());
        challenge_hash.update(announcement_2.compress().as_bytes());

        scalar_bytes[..16].copy_from_slice(&challenge_hash.finalize().as_slice()[..16]);

        Scalar::from_bits(scalar_bytes)
    }
* /
export function vrf_ed25519_sha512_ell2_challenge_generation(
    H: Uint8Array,
    gamma: Uint8Array,
    announcement_1: Uint8Array,
    announcement_2: Uint8Array,
): Uint8Array
{
    // const input = new Uint8Array( 2 + H.length + gamma.length + announcement_1.length + announcement_2.length );
    // input[0] = SUITE;
    // input[1] = TWO;
    // input.set( H, 2 );
    // input.set( gamma, 2 + H.length );
    // input.set( announcement_1, 2 + H.length + gamma.length );
    // input.set( announcement_2, 2 + H.length + gamma.length + announcement_1.length );
    // return sha2_512_sync(input).slice(0,16);
}
//*/ function vrf_ed25519_sha512_ell2_compute_challenge(compressed_h, compressed_gamma, compressed_announcement_1, compressed_announcement_2) {
    var scalar_bytes = new Uint8Array(32);
    var hash_input = new Uint8Array(2 + compressed_h.length + compressed_gamma.length + compressed_announcement_1.length + compressed_announcement_2.length);
    hash_input[0] = SUITE;
    hash_input[1] = TWO;
    hash_input.set(compressed_h, 2);
    hash_input.set(compressed_gamma, 2 + compressed_h.length);
    hash_input.set(compressed_announcement_1, 2 + compressed_h.length + compressed_gamma.length);
    hash_input.set(compressed_announcement_2, 2 + compressed_h.length + compressed_gamma.length + compressed_announcement_1.length);
    var hash = (0, sha2_512_1.sha2_512_sync)(hash_input);
    scalar_bytes.set(hash.slice(0, 16), 0);
    scalar_from_bits_inplace(scalar_bytes);
    return scalar_bytes;
}
exports.vrf_ed25519_sha512_ell2_compute_challenge = vrf_ed25519_sha512_ell2_compute_challenge;
/*
// Construct a `Scalar` from the low 255 bits of a 256-bit integer.
    ///
    /// This function is intended for applications like X25519 which
    /// require specific bit-patterns when performing scalar
    /// multiplication.
    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {
        let mut s = Scalar{bytes};
        // Ensure that s < 2^255 by masking the high bit
        s.bytes[31] &= 0b0111_1111;

        s
    }
*/ function scalar_from_bits_inplace(bytes) {
    bytes[31] &= 127;
}
exports.scalar_from_bits_inplace = scalar_from_bits_inplace; /**
 * https://datatracker.ietf.org/doc/html/rfc9381#section-5.1
 *
 * test cases:
 * https://datatracker.ietf.org/doc/html/rfc9381#name-ecvrf-edwards25519-sha512-e
 * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-03#appendix-A.4
 *
 * /// Generate a new VRF proof following the 03 standard. It proceeds as follows:
 * /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
 * /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
 * /// - Compute `Gamma = secret_scalar *  H`
 * /// - Generate a proof of discrete logarithm equality between `PK` and `Gamma` with
 * ///   bases `generator` and `H` respectively.
 *
 * /
export function vrf_ed25519_sha512_ell2_prove(sk: Uint8Array, alpha: Uint8Array): IVrfProof03
{
    /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
    const [ scalar, extension ] = getExtendEd25519PrivateKeyComponents_sync( sk );
    // 1. Use SK to derive the VRF secret scalar x and the VRF public key Y = x*B
    /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
    const pk = new Uint8Array( deriveEd25519PublicKey_sync( sk ) );
    const H = vrf_ed25519_sha512_ell2_hash_to_curve( pk, alpha );
    
    const H_point = pointFromBytes( H );
    const gamma = scalarMul( H_point, scalar );
    const compressed_gamma = bigpointToUint8Array( gamma );
    const k = vrf_ed25519_sha512_ell2_nonce_generation( extension, H );
    const announcement_1 = bigpointToUint8Array( scalarMultBase( k ) );
    const announcement_2 = bigpointToUint8Array( scalarMul( H_point, k ) );
    const challange = scalarFromBytes(
        vrf_ed25519_sha512_ell2_challenge_generation( H, compressed_gamma, announcement_1, announcement_2 )
    );
    const response = k + challange * scalar;
    return {
        gamma,
        challange,
        response
    };
}
//*/ 
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/vrf10.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.scalar_from_bits_inplace = exports.vrf10_ed25519_sha512_ell2_compute_challenge = exports.vrf10_ed25519_sha512_ell2_nonce_generation = exports.scalar_hash_from_bytes = exports.vrf10_ed25519_sha512_ell2_hash_to_curve = exports.edwards_hash_from_bytes = exports.vrf10_proof_to_hash = exports.vrf10_ed25519_sha512_ell2_verify_proof = exports.vrf10_ed25519_sha512_ell2_generate_proof = exports.adjust_scalar_bits = exports.extend_secret_key = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var sha2_512_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)");
var curves_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/curves.js [app-client] (ecmascript)");
/**
4.4. RSA-FDH-VRF Ciphersuites

This document defines RSA-FDH-VRF-SHA256 as follows:

suite_string = 0x01.
The hash function Hash is SHA-256 as specified in [RFC6234], with hLen = 32.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA384 as follows:

suite_string = 0x02.
The hash function Hash is SHA-384 as specified in [RFC6234], with hLen = 48.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA512 as follows:

suite_string = 0x10.
The hash function Hash is SHA-512 as specified in [RFC6234], with hLen = 64.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

 */ var SUITE = 0x04;
/*
/// Temporary SUITE identifier, as TAI uses 0x03
pub const SUITE_TEMP: &[u8] = &[0x03];
*/ var SUITE_TEMP = 0x03;
var ONE = 0x01;
var TWO = 0x02;
/*
pub fn extend(&self) -> (Scalar, [u8; 32]) {
    let mut h: Sha512 = Sha512::new();
    let mut extended = [0u8; 64];
    let mut secret_key_bytes = [0u8; 32];
    let mut extension = [0u8; 32];

    h.update(self.as_bytes());
    extended.copy_from_slice(&h.finalize().as_slice()[..64]);

    secret_key_bytes.copy_from_slice(&extended[..32]);
    extension.copy_from_slice(&extended[32..]);

    secret_key_bytes[0] &= 248;
    secret_key_bytes[31] &= 127;
    secret_key_bytes[31] |= 64;

    (Scalar::from_bits(secret_key_bytes), extension)
}
*/ function extend_secret_key(secret_key) {
    var extended = (0, sha2_512_1.sha2_512_sync)(secret_key);
    var secret_key_bytes = extended.slice(0, 32);
    var extension = extended.slice(32, 64);
    secret_key_bytes[0] &= 248;
    secret_key_bytes[31] &= 127;
    secret_key_bytes[31] |= 64;
    adjust_scalar_bits(secret_key_bytes);
    return [
        secret_key_bytes,
        extension
    ];
}
exports.extend_secret_key = extend_secret_key;
function adjust_scalar_bits(bytes) {
    bytes[31] &= 127;
}
exports.adjust_scalar_bits = adjust_scalar_bits;
function vrf10_ed25519_sha512_ell2_generate_proof(secret_key, public_key, alpha_string) {
    var _a = __read(extend_secret_key(secret_key), 2), secret_scalar = _a[0], secret_extension = _a[1];
    var h = vrf10_ed25519_sha512_ell2_hash_to_curve(public_key, alpha_string);
    var compressed_h = h.compress();
    var gamma = h.scalarMul(secret_scalar);
    var compressed_gamma = gamma.compress();
    var k = vrf10_ed25519_sha512_ell2_nonce_generation(secret_extension, compressed_h);
    var compressed_announcement_base = curves_1.ED25519_BASEPOINT_POINT.scalarMul(k).compress();
    var compressed_announcement_h = h.scalarMul(k).compress();
    // Self::compute_challenge(&compressed_h, &gamma, &announcement_base, &announcement_h);
    var challenge = vrf10_ed25519_sha512_ell2_compute_challenge(compressed_h, compressed_gamma, compressed_announcement_base, compressed_announcement_h);
    var response = (0, curves_1.add_scalars)(k, (0, curves_1.mul_scalars)(challenge, secret_scalar));
    return {
        gamma: gamma,
        challenge: challenge,
        response: response
    };
}
exports.vrf10_ed25519_sha512_ell2_generate_proof = vrf10_ed25519_sha512_ell2_generate_proof;
/*
/// Verify VRF function, following the 10 specification.
    pub fn verify(
        &self,
        public_key: &PublicKey10,
        alpha_string: &[u8],
    ) -> Result<[u8; OUTPUT_SIZE], VrfError> {
        let h = Self::hash_to_curve(public_key, alpha_string);
        let compressed_h = h.compress();

        let decompressed_pk = public_key
            .0
            .decompress()
            .ok_or(VrfError::DecompressionFailed)?;

        if decompressed_pk.is_small_order() {
            return Err(VrfError::PkSmallOrder);
        }

        let U = EdwardsPoint::vartime_double_scalar_mul_basepoint(
            &self.challenge.neg(),
            &decompressed_pk,
            &self.response,
        );
        let V = EdwardsPoint::vartime_multiscalar_mul(
            iter::once(self.response).chain(iter::once(self.challenge.neg())),
            iter::once(h).chain(iter::once(self.gamma)),
        );

        // Now we compute the challenge
        let challenge = Self::compute_challenge(&compressed_h, &self.gamma, &U, &V);

        if challenge.to_bytes()[..16] == self.challenge.to_bytes()[..16] {
            Ok(self.proof_to_hash())
        } else {
            Err(VrfError::VerificationFailed)
        }
    }
*/ function vrf10_ed25519_sha512_ell2_verify_proof(public_key, alpha_string, proof) {
    var h = vrf10_ed25519_sha512_ell2_hash_to_curve(public_key, alpha_string);
    var compressed_h = h.compress();
    var decompressed_pk = (0, curves_1.decompressCompressedEdwardsY)(public_key); // pointFromBytes( public_key );
    if (!decompressed_pk || decompressed_pk.is_small_order()) return false;
    // Scalar
    var proof_challenge = proof.challenge;
    var gamma = proof.gamma;
    var U = curves_1.EdwardsPoint.vartime_double_scalar_mul_basepoint((0, curves_1.negate_scalar)(proof_challenge), decompressed_pk, proof.response);
    /*
    let V = EdwardsPoint::vartime_multiscalar_mul(
            iter::once(self.response).chain(iter::once(self.challenge.neg())),
            iter::once(h).chain(iter::once(self.gamma)),
        );
    */ var V = curves_1.EdwardsPoint.vartime_multiscalar_mul([
        proof.response,
        (0, curves_1.negate_scalar)(proof_challenge)
    ], [
        h,
        gamma
    ]);
    var computed_challenge = vrf10_ed25519_sha512_ell2_compute_challenge(compressed_h, proof.gamma.compress(), U.compress(), V.compress());
    return (0, uint8array_utils_1.uint8ArrayEq)(computed_challenge.slice(0, 16), proof_challenge.slice(0, 16));
}
exports.vrf10_ed25519_sha512_ell2_verify_proof = vrf10_ed25519_sha512_ell2_verify_proof;
/*
/// `proof_to_hash` function, following the 10 specification. This computes the output of the VRF
    /// function. In particular, this function computes
    /// SHA512(SUITE || THREE || Gamma || ZERO)
    fn proof_to_hash(&self) -> [u8; OUTPUT_SIZE] {
        let mut output = [0u8; OUTPUT_SIZE];
        let gamma_cofac = self.gamma.mul_by_cofactor();
        let mut hash = Sha512::new();
        hash.update(SUITE_TEMP);
        hash.update(THREE);
        hash.update(gamma_cofac.compress().as_bytes());
        hash.update(ZERO);

        output.copy_from_slice(hash.finalize().as_slice());
        output
    }
*/ function vrf10_proof_to_hash(proof) {
    var compressed_gamma_cofac = proof.gamma.mul_by_cofactor().compress();
    var hashInput = new Uint8Array(3 + compressed_gamma_cofac.length);
    hashInput[0] = SUITE_TEMP;
    hashInput[1] = 0x03;
    hashInput.set(compressed_gamma_cofac, 2);
    hashInput[2 + compressed_gamma_cofac.length] = 0;
    return (0, sha2_512_1.sha2_512_sync)(hashInput);
}
exports.vrf10_proof_to_hash = vrf10_proof_to_hash;
/*
export function vrfProofToBytesProof( proof: IVrfProof10 )
{
    return {
        gamma: bigpointToUint8Array( proof.gamma ),
        challange: encodeInt( proof.challange ),
        response: encodeInt( proof.response ),
    }
}
//*/ function edwards_hash_from_bytes(bytes) {
    var hash = (0, sha2_512_1.sha2_512_sync)(bytes);
    var res = hash.slice(0, 32);
    /*
        //////////////////////////////////////////////////////////////////////////////////////
        //// We need to be compatible with the third version of the VRF standard, which   ////
        //// always unsets the sign bit. Given the visibility of the functions used to    ////
        //// compute the ristretto mapping, we need to fork the original repo, to unset   ////
        //// bit in this function. This fork should never be used, unless one needs to be ////
        //// compatible with the version 3 of the VRF standard.                           ////
        //// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-10#section-5.4.1.2 ////
        //// The goal is to be always a single commit ahead of version 3.2.0, and this    ////
        //// single commit only changes the following line, and a disclaimer in the       ////
        //// README.                                                                      ////
        //////////////////////////////////////////////////////////////////////////////////////
        let sign_bit = 0;

        let fe = FieldElement::from_bytes(&res);

        let M1 = crate::montgomery::elligator_encode(&fe);
        let E1_opt = M1.to_edwards(sign_bit);

        E1_opt
            .expect("Montgomery conversion to Edwards point in Elligator failed")
            .mul_by_cofactor()
    */ var sign_bit = 0;
    var fe = curves_1.FieldElem51.fromBytes(res);
    var M1 = curves_1.FieldElem51.elligator_encode(fe);
    var E1_opt = M1.to_edwards(sign_bit);
    if (!E1_opt) {
        throw new Error("Montgomery conversion to Edwards point in Elligator failed");
    }
    return E1_opt.mul_by_cofactor();
}
exports.edwards_hash_from_bytes = edwards_hash_from_bytes;
/*
/// Computing the `hash_to_curve` using try and increment. In order to make the
    /// function always terminate, we bound  the number of tries to 64. If the try
    /// 64 fails, which happens with probability around 1/2^64, we compute the
    /// Elligator mapping. This diverges from the standard: the latter describes
    /// the function with an infinite loop. To avoid infinite loops or possibly
    /// non-terminating functions, we adopt this modification.
    /// This function is temporary, until `curve25519` provides a `hash_to_curve` as
    /// presented in the standard. Depends on
    /// [this pr](https://github.com/dalek-cryptography/curve25519-dalek/pull/377). The
    /// goal of providing this temporary function, is to ensure that the rest of the
    /// implementation is valid with respect to the standard, by using their test-vectors.
    pub(crate) fn hash_to_curve(public_key: &PublicKey10, alpha_string: &[u8]) -> EdwardsPoint {
        let mut counter = 0u8;
        let mut hash_input = Vec::with_capacity(4 + PUBLIC_KEY_SIZE + alpha_string.len());
        hash_input.extend_from_slice(SUITE_TEMP);
        hash_input.extend_from_slice(ONE);
        hash_input.extend_from_slice(public_key.as_bytes());
        hash_input.extend_from_slice(alpha_string);
        hash_input.extend_from_slice(&counter.to_be_bytes());
        hash_input.extend_from_slice(ZERO);

        while counter < 64 {
            hash_input[2 + PUBLIC_KEY_SIZE + alpha_string.len()] = counter.to_be_bytes()[0];
            if let Some(result) =
                CompressedEdwardsY::from_slice(&Sha512::digest(&hash_input)[..32]).decompress()
            {
                return result.mul_by_cofactor();
            };

            counter += 1;
        }

        EdwardsPoint::hash_from_bytes::<Sha512>(&hash_input)
    }
*/ /**
 * Computing the `hash_to_curve` using try and increment. In order to make the
 * function always terminate, we bound  the number of tries to 64. If the try
 * 64 fails, which happens with probability around 1/2^64, we compute the
 * Elligator mapping. This diverges from the standard: the latter describes
 * the function with an infinite loop. To avoid infinite loops or possibly
 * non-terminating functions, we adopt this modification.
 * This function is temporary, until `curve25519` provides a `hash_to_curve` as
 * presented in the standard. Depends on
 * [this pr](https://github.com/dalek-cryptography/curve25519-dalek/pull/377). The
 * goal of providing this temporary function, is to ensure that the rest of the
 * implementation is valid with respect to the standard, by using their test-vectors.
**/ function vrf10_ed25519_sha512_ell2_hash_to_curve(public_key, alpha_string) {
    var counter_u8 = 0;
    var input = new Uint8Array(4 + 32 + alpha_string.length);
    input[0] = SUITE_TEMP;
    input[1] = ONE;
    input.set(public_key.slice(0, 32), 2);
    input.set(alpha_string, 34);
    input[34 + alpha_string.length] = counter_u8;
    input[35 + alpha_string.length] = 0;
    while(counter_u8 < 64){
        input[34 + alpha_string.length] = counter_u8;
        var result = (0, curves_1.decompressCompressedEdwardsY)((0, sha2_512_1.sha2_512_sync)(input).slice(0, 32));
        if (result) return result.mul_by_cofactor();
        ++counter_u8;
    }
    return edwards_hash_from_bytes(input); // sha2_512_sync(input);
}
exports.vrf10_ed25519_sha512_ell2_hash_to_curve = vrf10_ed25519_sha512_ell2_hash_to_curve;
function scalar_hash_from_bytes(input) {
    return (0, curves_1.scalar_from_bytes_mod_order_wide)((0, sha2_512_1.sha2_512_sync)(input));
}
exports.scalar_hash_from_bytes = scalar_hash_from_bytes;
function vrf10_ed25519_sha512_ell2_nonce_generation(secret_extension, compressed_h) {
    var input = new Uint8Array(64);
    input.set(secret_extension.slice(0, 32), 0);
    input.set(compressed_h.slice(0, 32), 32);
    //return pointFromBytes(sha2_512_sync(input))
    return scalar_hash_from_bytes(input);
}
exports.vrf10_ed25519_sha512_ell2_nonce_generation = vrf10_ed25519_sha512_ell2_nonce_generation;
/*
/// Hash points function, following the 10 specification.
    fn compute_challenge(
        compressed_h: &CompressedEdwardsY,
        gamma: &EdwardsPoint,
        announcement_1: &EdwardsPoint,
        announcement_2: &EdwardsPoint,
    ) -> Scalar {
        // we use a scalar of 16 bytes (instead of 32), but store it in 32 bits, as that is what
        // `Scalar::from_bits()` expects.
        let mut scalar_bytes = [0u8; 32];
        let mut challenge_hash = Sha512::new();
        challenge_hash.update(SUITE);
        challenge_hash.update(TWO);
        challenge_hash.update(compressed_h.to_bytes());
        challenge_hash.update(gamma.compress().as_bytes());
        challenge_hash.update(announcement_1.compress().as_bytes());
        challenge_hash.update(announcement_2.compress().as_bytes());

        scalar_bytes[..16].copy_from_slice(&challenge_hash.finalize().as_slice()[..16]);

        Scalar::from_bits(scalar_bytes)
    }
* /
export function vrf_ed25519_sha512_ell2_challenge_generation(
    H: Uint8Array,
    gamma: Uint8Array,
    announcement_1: Uint8Array,
    announcement_2: Uint8Array,
): Uint8Array
{
    // const input = new Uint8Array( 2 + H.length + gamma.length + announcement_1.length + announcement_2.length );
    // input[0] = SUITE;
    // input[1] = TWO;
    // input.set( H, 2 );
    // input.set( gamma, 2 + H.length );
    // input.set( announcement_1, 2 + H.length + gamma.length );
    // input.set( announcement_2, 2 + H.length + gamma.length + announcement_1.length );
    // return sha2_512_sync(input).slice(0,16);
}
//*/ /*
/// Hash points function, following the 10 specification.
    pub(crate) fn compute_challenge(
        compressed_h: &CompressedEdwardsY,
        gamma: &EdwardsPoint,
        announcement_1: &EdwardsPoint,
        announcement_2: &EdwardsPoint,
    ) -> Scalar {
        // we use a scalar of 16 bytes (instead of 32), but store it in 32 bits, as that is what
        // `Scalar::from_bits()` expects.
        let mut scalar_bytes = [0u8; 32];
        let mut challenge_hash = Sha512::new();
        challenge_hash.update(SUITE_TEMP);
        challenge_hash.update(TWO);
        challenge_hash.update(compressed_h.to_bytes());
        challenge_hash.update(gamma.compress().as_bytes());
        challenge_hash.update(announcement_1.compress().as_bytes());
        challenge_hash.update(announcement_2.compress().as_bytes());
        challenge_hash.update(ZERO);

        scalar_bytes[..16].copy_from_slice(&challenge_hash.finalize().as_slice()[..16]);

        Scalar::from_bits(scalar_bytes)
    }
*/ function vrf10_ed25519_sha512_ell2_compute_challenge(compressed_h, compressed_gamma, compressed_announcement_1, compressed_announcement_2) {
    var scalar_bytes = new Uint8Array(32);
    var hash_input = new Uint8Array(3 + compressed_h.length + compressed_gamma.length + compressed_announcement_1.length + compressed_announcement_2.length);
    hash_input[0] = SUITE_TEMP;
    hash_input[1] = TWO;
    var len = 2;
    hash_input.set(compressed_h, len);
    len += compressed_h.length;
    hash_input.set(compressed_gamma, len);
    len += compressed_gamma.length;
    hash_input.set(compressed_announcement_1, len);
    len += compressed_announcement_1.length;
    hash_input.set(compressed_announcement_2, len);
    hash_input[len + compressed_announcement_2.length] = 0;
    var hash = (0, sha2_512_1.sha2_512_sync)(hash_input);
    scalar_bytes.set(hash.slice(0, 16), 0);
    scalar_from_bits_inplace(scalar_bytes);
    return scalar_bytes;
}
exports.vrf10_ed25519_sha512_ell2_compute_challenge = vrf10_ed25519_sha512_ell2_compute_challenge;
/*
// Construct a `Scalar` from the low 255 bits of a 256-bit integer.
    ///
    /// This function is intended for applications like X25519 which
    /// require specific bit-patterns when performing scalar
    /// multiplication.
    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {
        let mut s = Scalar{bytes};
        // Ensure that s < 2^255 by masking the high bit
        s.bytes[31] &= 0b0111_1111;

        s
    }
*/ function scalar_from_bits_inplace(bytes) {
    bytes[31] &= 127;
}
exports.scalar_from_bits_inplace = scalar_from_bits_inplace; /**
 * https://datatracker.ietf.org/doc/html/rfc9381#section-5.1
 *
 * test cases:
 * https://datatracker.ietf.org/doc/html/rfc9381#name-ecvrf-edwards25519-sha512-e
 * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-10#appendix-A.4
 *
 * /// Generate a new VRF proof following the 10 standard. It proceeds as follows:
 * /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
 * /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
 * /// - Compute `Gamma = secret_scalar *  H`
 * /// - Generate a proof of discrete logarithm equality between `PK` and `Gamma` with
 * ///   bases `generator` and `H` respectively.
 *
 * /
export function vrf_ed25519_sha512_ell2_prove(sk: Uint8Array, alpha: Uint8Array): IVrfProof10
{
    /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
    const [ scalar, extension ] = getExtendEd25519PrivateKeyComponents_sync( sk );
    // 1. Use SK to derive the VRF secret scalar x and the VRF public key Y = x*B
    /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
    const pk = new Uint8Array( deriveEd25519PublicKey_sync( sk ) );
    const H = vrf_ed25519_sha512_ell2_hash_to_curve( pk, alpha );
    
    const H_point = pointFromBytes( H );
    const gamma = scalarMul( H_point, scalar );
    const compressed_gamma = bigpointToUint8Array( gamma );
    const k = vrf_ed25519_sha512_ell2_nonce_generation( extension, H );
    const announcement_1 = bigpointToUint8Array( scalarMultBase( k ) );
    const announcement_2 = bigpointToUint8Array( scalarMul( H_point, k ) );
    const challange = scalarFromBytes(
        vrf_ed25519_sha512_ell2_challenge_generation( H, compressed_gamma, announcement_1, announcement_2 )
    );
    const response = k + challange * scalar;
    return {
        gamma,
        challange,
        response
    };
}
//*/ 
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/vrf10_batch.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.vrf10_batch_ed25519_sha512_ell2_verify_proof = exports.vrf10_batch_ed25519_sha512_ell2_generate_proof = exports.vrf10_batch_ed25519_sha512_ell2_proof_to_hash = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var sha2_512_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)");
var curves_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/curves.js [app-client] (ecmascript)");
var vrf10_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/vrf10.js [app-client] (ecmascript)");
/**
4.4. RSA-FDH-VRF Ciphersuites

This document defines RSA-FDH-VRF-SHA256 as follows:

suite_string = 0x01.
The hash function Hash is SHA-256 as specified in [RFC6234], with hLen = 32.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA384 as follows:

suite_string = 0x02.
The hash function Hash is SHA-384 as specified in [RFC6234], with hLen = 48.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA512 as follows:

suite_string = 0x10.
The hash function Hash is SHA-512 as specified in [RFC6234], with hLen = 64.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

 */ var SUITE = 0x04;
/*
/// Temporary SUITE identifier, as TAI uses 0x03
pub const SUITE_TEMP: &[u8] = &[0x03];
*/ var SUITE_TEMP = 0x03;
var ONE = 0x01;
var TWO = 0x02;
var THREE = 0x03;
function vrf10_batch_ed25519_sha512_ell2_proof_to_hash(proof) {
    var compressed_gamma_cofac = proof.gamma.mul_by_cofactor().compress();
    var input = new Uint8Array(3 + compressed_gamma_cofac.length);
    input[0] = SUITE_TEMP;
    input[1] = THREE;
    input.set(compressed_gamma_cofac, 2);
    input[2 + compressed_gamma_cofac.length] = 0;
    return (0, sha2_512_1.sha2_512_sync)(input);
}
exports.vrf10_batch_ed25519_sha512_ell2_proof_to_hash = vrf10_batch_ed25519_sha512_ell2_proof_to_hash;
function vrf10_batch_ed25519_sha512_ell2_generate_proof(secret_key, public_key, alpha_string) {
    var _a = __read((0, vrf10_1.extend_secret_key)(secret_key), 2), secret_scalar = _a[0], secret_extension = _a[1];
    var h = (0, vrf10_1.vrf10_ed25519_sha512_ell2_hash_to_curve)(public_key, alpha_string);
    var compressed_h = h.compress();
    var gamma = h.scalarMul(secret_scalar);
    var compressed_gamma = gamma.compress();
    var k = (0, vrf10_1.vrf10_ed25519_sha512_ell2_nonce_generation)(secret_extension, compressed_h);
    var announcement_base = curves_1.ED25519_BASEPOINT_POINT.scalarMul(k);
    var compressed_announcement_base = announcement_base.compress();
    var announcement_h = h.scalarMul(k);
    var compressed_announcement_h = announcement_h.compress();
    // Self::compute_challenge(&compressed_h, &gamma, &announcement_base, &announcement_h);
    var challenge = (0, vrf10_1.vrf10_ed25519_sha512_ell2_compute_challenge)(compressed_h, compressed_gamma, compressed_announcement_base, compressed_announcement_h);
    var response = (0, curves_1.add_scalars)(k, (0, curves_1.mul_scalars)(challenge, secret_scalar));
    return {
        gamma: gamma,
        u_point: announcement_base,
        v_point: announcement_h,
        response: response
    };
}
exports.vrf10_batch_ed25519_sha512_ell2_generate_proof = vrf10_batch_ed25519_sha512_ell2_generate_proof;
function vrf10_batch_ed25519_sha512_ell2_verify_proof(public_key, alpha_string, proof) {
    var h = (0, vrf10_1.vrf10_ed25519_sha512_ell2_hash_to_curve)(public_key, alpha_string);
    var compressed_h = h.compress();
    var decompressed_pk = (0, curves_1.decompressCompressedEdwardsY)(public_key); // pointFromBytes( public_key );
    if (!decompressed_pk || decompressed_pk.is_small_order()) return false;
    var gamma = proof.gamma;
    var compressed_gamma = gamma.compress();
    var compressed_announcement_base = proof.u_point.compress();
    var compressed_announcement_h = proof.v_point.compress();
    // Scalar
    var proof_challenge = (0, vrf10_1.vrf10_ed25519_sha512_ell2_compute_challenge)(compressed_h, compressed_gamma, compressed_announcement_base, compressed_announcement_h);
    var U = curves_1.EdwardsPoint.vartime_double_scalar_mul_basepoint((0, curves_1.negate_scalar)(proof_challenge), decompressed_pk, proof.response);
    /*
    let V = EdwardsPoint::vartime_multiscalar_mul(
            iter::once(self.response).chain(iter::once(self.challenge.neg())),
            iter::once(h).chain(iter::once(self.gamma)),
        );
    */ var V = curves_1.EdwardsPoint.vartime_multiscalar_mul([
        proof.response,
        (0, curves_1.negate_scalar)(proof_challenge)
    ], [
        h,
        gamma
    ]);
    // const computed_challenge = vrf10_ed25519_sha512_ell2_compute_challenge(
    //     compressed_h,
    //     proof.gamma.compress(),
    //     U.compress(),
    //     V.compress()
    // );
    return (0, uint8array_utils_1.uint8ArrayEq)(U.compress(), compressed_announcement_base) && (0, uint8array_utils_1.uint8ArrayEq)(V.compress(), compressed_announcement_h);
}
exports.vrf10_batch_ed25519_sha512_ell2_verify_proof = vrf10_batch_ed25519_sha512_ell2_verify_proof;
/*
/// `proof_to_hash` function, following the 10 specification. This computes the output of the VRF
    /// function. In particular, this function computes
    /// SHA512(SUITE || THREE || Gamma || ZERO)
    fn proof_to_hash(&self) -> [u8; OUTPUT_SIZE] {
        let mut output = [0u8; OUTPUT_SIZE];
        let gamma_cofac = self.gamma.mul_by_cofactor();
        let mut hash = Sha512::new();
        hash.update(SUITE_TEMP);
        hash.update(THREE);
        hash.update(gamma_cofac.compress().as_bytes());
        hash.update(ZERO);

        output.copy_from_slice(hash.finalize().as_slice());
        output
    }
*/ function vrf10_proof_to_hash(proof) {
    var compressed_gamma_cofac = proof.gamma.mul_by_cofactor().compress();
    var hashInput = new Uint8Array(3 + compressed_gamma_cofac.length);
    hashInput[0] = SUITE_TEMP;
    hashInput[1] = 0x03;
    hashInput.set(compressed_gamma_cofac, 2);
    hashInput[2 + compressed_gamma_cofac.length] = 0;
    return (0, sha2_512_1.sha2_512_sync)(hashInput);
}
/*
function vrfProofToBytesProof( proof: IVrfBatchProof10 )
{
    return {
        gamma: bigpointToUint8Array( proof.gamma ),
        challange: encodeInt( proof.challange ),
        response: encodeInt( proof.response ),
    }
}
//*/ function edwards_hash_from_bytes(bytes) {
    var hash = (0, sha2_512_1.sha2_512_sync)(bytes);
    var res = hash.slice(0, 32);
    /*
        //////////////////////////////////////////////////////////////////////////////////////
        //// We need to be compatible with the third version of the VRF standard, which   ////
        //// always unsets the sign bit. Given the visibility of the functions used to    ////
        //// compute the ristretto mapping, we need to fork the original repo, to unset   ////
        //// bit in this function. This fork should never be used, unless one needs to be ////
        //// compatible with the version 3 of the VRF standard.                           ////
        //// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-10#section-5.4.1.2 ////
        //// The goal is to be always a single commit ahead of version 3.2.0, and this    ////
        //// single commit only changes the following line, and a disclaimer in the       ////
        //// README.                                                                      ////
        //////////////////////////////////////////////////////////////////////////////////////
        let sign_bit = 0;

        let fe = FieldElement::from_bytes(&res);

        let M1 = crate::montgomery::elligator_encode(&fe);
        let E1_opt = M1.to_edwards(sign_bit);

        E1_opt
            .expect("Montgomery conversion to Edwards point in Elligator failed")
            .mul_by_cofactor()
    */ var sign_bit = 0;
    var fe = curves_1.FieldElem51.fromBytes(res);
    var M1 = curves_1.FieldElem51.elligator_encode(fe);
    var E1_opt = M1.to_edwards(sign_bit);
    if (!E1_opt) {
        throw new Error("Montgomery conversion to Edwards point in Elligator failed");
    }
    return E1_opt.mul_by_cofactor();
}
/*
// Construct a `Scalar` from the low 255 bits of a 256-bit integer.
    ///
    /// This function is intended for applications like X25519 which
    /// require specific bit-patterns when performing scalar
    /// multiplication.
    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {
        let mut s = Scalar{bytes};
        // Ensure that s < 2^255 by masking the high bit
        s.bytes[31] &= 0b0111_1111;

        s
    }
*/ function scalar_from_bits_inplace(bytes) {
    bytes[31] &= 127;
} /**
 * https://datatracker.ietf.org/doc/html/rfc9381#section-5.1
 *
 * test cases:
 * https://datatracker.ietf.org/doc/html/rfc9381#name-ecvrf-edwards25519-sha512-e
 * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-10#appendix-A.4
 *
 * /// Generate a new VRF proof following the 10 standard. It proceeds as follows:
 * /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
 * /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
 * /// - Compute `Gamma = secret_scalar *  H`
 * /// - Generate a proof of discrete logarithm equality between `PK` and `Gamma` with
 * ///   bases `generator` and `H` respectively.
 *
 * /
function vrf_ed25519_sha512_ell2_prove(sk: Uint8Array, alpha: Uint8Array): IVrfBatchProof10
{
    /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
    const [ scalar, extension ] = getExtendEd25519PrivateKeyComponents_sync( sk );
    // 1. Use SK to derive the VRF secret scalar x and the VRF public key Y = x*B
    /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
    const pk = new Uint8Array( deriveEd25519PublicKey_sync( sk ) );
    const H = vrf_ed25519_sha512_ell2_hash_to_curve( pk, alpha );
    
    const H_point = pointFromBytes( H );
    const gamma = scalarMul( H_point, scalar );
    const compressed_gamma = bigpointToUint8Array( gamma );
    const k = vrf_ed25519_sha512_ell2_nonce_generation( extension, H );
    const announcement_1 = bigpointToUint8Array( scalarMultBase( k ) );
    const announcement_2 = bigpointToUint8Array( scalarMul( H_point, k ) );
    const challange = scalarFromBytes(
        vrf_ed25519_sha512_ell2_challenge_generation( H, compressed_gamma, announcement_1, announcement_2 )
    );
    const response = k + challange * scalar;
    return {
        gamma,
        challange,
        response
    };
}
//*/ 
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/utils/getRandomValues.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRandomValues = void 0;
var hasGlobalWebCrypto_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/hasGlobalWebCrypto.js [app-client] (ecmascript)");
function _getRandomValues(buff) {
    for(var i = 0; i < buff.length; i++){
        buff[i] = Math.random() * 256 >>> 0;
    }
    return buff;
}
/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/getRandomValues) */ exports.getRandomValues = hasGlobalWebCrypto_1.hasGlobalWebCrypto ? globalThis.crypto.getRandomValues.bind(globalThis.crypto) : _getRandomValues;
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/vrf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __read = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VrfBatchVerifier = exports.VrfBatchProof10 = exports.VrfProof10 = exports.derive_vrf10_public_key = exports.VrfProof03 = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var curves_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/curves.js [app-client] (ecmascript)");
var vrf03_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/vrf03.js [app-client] (ecmascript)");
var vrf10_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/vrf10.js [app-client] (ecmascript)");
var vrf10_batch_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/rust_vrf_reimpl/vrf10_batch.js [app-client] (ecmascript)");
var getRandomValues_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/getRandomValues.js [app-client] (ecmascript)");
var VrfProof03 = function() {
    function VrfProof03(_a) {
        var gamma = _a.gamma, challenge = _a.challenge, response = _a.response;
        this.gamma = gamma;
        this.challenge = challenge;
        this.response = response;
    }
    VrfProof03.prototype.toHash = function() {
        return (0, vrf03_1.proof_to_hash)(this);
    };
    VrfProof03.generate = function(secret_key, public_key, alpha_string) {
        return new VrfProof03((0, vrf03_1.vrf_ed25519_sha512_ell2_generate_proof)(secret_key, public_key, alpha_string));
    };
    VrfProof03.verify = function(public_key, alpha_string, proof) {
        return (0, vrf03_1.vrf_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, proof);
    };
    VrfProof03.prototype.verify = function(public_key, alpha_string) {
        return (0, vrf03_1.vrf_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, this);
    };
    /*
    pub fn to_bytes(&self) -> [u8; PROOF_SIZE] {
        let mut proof = [0u8; PROOF_SIZE];
        proof[..32].copy_from_slice(self.gamma.compress().as_bytes());
        proof[32..48].copy_from_slice(&self.challenge.to_bytes()[..16]);
        proof[48..].copy_from_slice(self.response.as_bytes());

        proof
    }
    */ VrfProof03.prototype.toBytes = function() {
        var output = new Uint8Array(80);
        output.set(this.gamma.compress(), 0);
        output.set(this.challenge.slice(0, 16), 32);
        output.set(this.response, 48);
        return output;
    };
    VrfProof03.fromBytes = function(bytes) {
        var gamma = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 0, 32));
        if (!gamma) throw new Error("Invalid gamma point");
        var challenge = new Uint8Array(32);
        challenge.set(Uint8Array.prototype.slice.call(bytes, 32, 48), 0);
        var response = Uint8Array.prototype.slice.call(bytes, 48, 80);
        return new VrfProof03({
            gamma: gamma,
            challenge: challenge,
            response: response
        });
    };
    return VrfProof03;
}();
exports.VrfProof03 = VrfProof03;
function derive_vrf10_public_key(secret_key) {
    return curves_1.EdwardsPoint.BASEPOINT_ED25519.scalarMul((0, vrf10_1.extend_secret_key)(secret_key)[0]).compress();
}
exports.derive_vrf10_public_key = derive_vrf10_public_key;
var VrfProof10 = function() {
    function VrfProof10(_a) {
        var gamma = _a.gamma, challenge = _a.challenge, response = _a.response;
        this.gamma = gamma;
        this.challenge = challenge;
        this.response = response;
    }
    VrfProof10.prototype.toHash = function() {
        return (0, vrf10_1.vrf10_proof_to_hash)(this);
    };
    VrfProof10.generate = function(secret_key, public_key, alpha_string) {
        return new VrfProof10((0, vrf10_1.vrf10_ed25519_sha512_ell2_generate_proof)(secret_key, public_key, alpha_string));
    };
    VrfProof10.verify = function(public_key, alpha_string, proof) {
        return (0, vrf10_1.vrf10_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, proof);
    };
    VrfProof10.prototype.verify = function(public_key, alpha_string) {
        return (0, vrf10_1.vrf10_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, this);
    };
    /*
    pub fn to_bytes(&self) -> [u8; PROOF_SIZE] {
        let mut proof = [0u8; PROOF_SIZE];
        proof[..32].copy_from_slice(self.gamma.compress().as_bytes());
        proof[32..48].copy_from_slice(&self.challenge.to_bytes()[..16]);
        proof[48..].copy_from_slice(self.response.as_bytes());

        proof
    }
    */ VrfProof10.prototype.toBytes = function() {
        var output = new Uint8Array(80);
        output.set(this.gamma.compress(), 0);
        output.set(this.challenge.slice(0, 16), 32);
        output.set(this.response, 48);
        return output;
    };
    VrfProof10.fromBytes = function(bytes) {
        var gamma = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 0, 32));
        if (!gamma) throw new Error("Invalid gamma point");
        var challenge = new Uint8Array(32);
        challenge.set(Uint8Array.prototype.slice.call(bytes, 32, 48), 0);
        var response = Uint8Array.prototype.slice.call(bytes, 48, 80);
        return new VrfProof10({
            gamma: gamma,
            challenge: challenge,
            response: response
        });
    };
    return VrfProof10;
}();
exports.VrfProof10 = VrfProof10;
var VrfBatchProof10 = function() {
    function VrfBatchProof10(_a) {
        var gamma = _a.gamma, u_point = _a.u_point, v_point = _a.v_point, response = _a.response;
        this.gamma = gamma;
        this.u_point = u_point;
        this.v_point = v_point;
        this.response = response;
    }
    VrfBatchProof10.prototype.toHash = function() {
        return (0, vrf10_batch_1.vrf10_batch_ed25519_sha512_ell2_proof_to_hash)(this);
    };
    VrfBatchProof10.generate = function(secret_key, public_key, alpha_string) {
        return new VrfBatchProof10((0, vrf10_batch_1.vrf10_batch_ed25519_sha512_ell2_generate_proof)(secret_key, public_key, alpha_string));
    };
    VrfBatchProof10.verify = function(public_key, alpha_string, proof) {
        return (0, vrf10_batch_1.vrf10_batch_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, proof);
    };
    VrfBatchProof10.prototype.verify = function(public_key, alpha_string) {
        return (0, vrf10_batch_1.vrf10_batch_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, this);
    };
    /*
    pub fn to_bytes(&self) -> [u8; PROOF_SIZE] {
        let mut proof = [0u8; PROOF_SIZE];
        proof[..32].copy_from_slice(self.gamma.compress().as_bytes());
        proof[32..48].copy_from_slice(&self.challenge.to_bytes()[..16]);
        proof[48..].copy_from_slice(self.response.as_bytes());

        proof
    }
    */ VrfBatchProof10.prototype.toBytes = function() {
        var output = new Uint8Array(128);
        output.set(this.gamma.compress(), 0);
        output.set(this.u_point.compress(), 32);
        output.set(this.v_point.compress(), 64);
        output.set(this.response, 96);
        return output;
    };
    VrfBatchProof10.fromBytes = function(bytes) {
        var gamma = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 0, 32));
        if (!gamma) throw new Error("Invalid gamma point");
        var u_point = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 32, 64));
        if (!u_point) throw new Error("Invalid u_point point");
        var v_point = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 64, 96));
        if (!v_point) throw new Error("Invalid v_point point");
        var response = Uint8Array.prototype.slice.call(bytes, 96, 128);
        return new VrfBatchProof10({
            gamma: gamma,
            u_point: u_point,
            v_point: v_point,
            response: response
        });
    };
    return VrfBatchProof10;
}();
exports.VrfBatchProof10 = VrfBatchProof10;
function gen_u128_bytes() {
    var buff = new Uint8Array(16);
    (0, getRandomValues_1.getRandomValues)(buff);
    return buff;
}
function gen_u128() {
    return BigInt("0x" + (0, uint8array_utils_1.toHex)(gen_u128_bytes()));
}
/** for some reason, from 38 elems up it fails */ var MAX_BATCH_SIZE = 37;
var VrfBatchVerifier = function() {
    function VrfBatchVerifier(size) {
        this.size = size;
        this._currLen = 0;
        this.proof_scalars = new Array(size);
        this.pks = new Array(size);
        this.us = new Array(size);
        this.hs = new Array(size);
        this.gammas = new Array(size);
        this.vs = new Array(size);
        this._currLen = 0;
    }
    VrfBatchVerifier.prototype.insert = function(item) {
        if (this._currLen >= this.size) throw new Error("BatchVerifier is full");
        var output = item.proof.toHash();
        var decompressed_pk = curves_1.EdwardsPoint.decompress(item.public_key);
        if (!decompressed_pk || decompressed_pk.is_small_order()) throw new Error("Invalid public key");
        var h = (0, vrf10_1.vrf10_ed25519_sha512_ell2_hash_to_curve)(item.public_key, item.alpha);
        var compressed_h = h.compress();
        var gamma = item.proof.gamma;
        var compressed_gamma = gamma.compress();
        var u = item.proof.u_point;
        var compressed_u = u.compress();
        var v = item.proof.v_point;
        var compressed_v = v.compress();
        this.proof_scalars[this._currLen] = [
            (0, vrf10_1.vrf10_ed25519_sha512_ell2_compute_challenge)(compressed_h, compressed_gamma, compressed_u, compressed_v),
            item.proof.response
        ];
        this.pks[this._currLen] = decompressed_pk;
        this.us[this._currLen] = u;
        this.hs[this._currLen] = h;
        this.gammas[this._currLen] = gamma;
        this.vs[this._currLen] = v;
        this._currLen++;
    };
    VrfBatchVerifier.prototype.verify = function() {
        var size = this._currLen;
        var b_coeff = scalar_zero();
        /** array of scalars */ var lchalls = new Array(size);
        /** array of scalars */ var rchalls = new Array(size);
        /** array of scalars */ var ls = new Array(size);
        /** array of scalars */ var rs = new Array(size);
        /** array of scalars */ var rresponses = new Array(size);
        for(var i = 0; i < size; i++){
            var _a = __read(this.proof_scalars[i], 2), challenge = _a[0], response = _a[1];
            var li = new Uint8Array(32);
            li.set(gen_u128_bytes(), 0);
            var ri = new Uint8Array(32);
            ri.set(gen_u128_bytes(), 0);
            b_coeff = (0, curves_1.add_scalars)(b_coeff, (0, curves_1.mul_scalars)(li, response));
            lchalls[i] = (0, curves_1.mul_scalars)(li, challenge);
            ls[i] = li;
            rresponses[i] = (0, curves_1.mul_scalars)(ri, (0, curves_1.negate_scalar)(response));
            rchalls[i] = (0, curves_1.mul_scalars)(ri, challenge);
            rs[i] = ri;
        }
        var result = curves_1.EdwardsPoint.vartime_multiscalar_mul([
            (0, curves_1.negate_scalar)(b_coeff)
        ].concat(lchalls).concat(ls).concat(rresponses).concat(rchalls).concat(rs), [
            curves_1.EdwardsPoint.BASEPOINT_ED25519
        ].concat(this.pks).concat(this.us).concat(this.hs).concat(this.gammas).concat(this.vs));
        return result.is_identity();
    };
    return VrfBatchVerifier;
}();
exports.VrfBatchVerifier = VrfBatchVerifier;
function scalar_zero() {
    return new Uint8Array(32);
}
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/noble/ripemd_160.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var e_1, _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RIPEMD160 = void 0;
/**
 * RIPEMD-160 legacy hash function.
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 * @module
 */ var _md_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/_md.js [app-client] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/utils.js [app-client] (ecmascript)");
var Rho = /* @__PURE__ */ new Uint8Array([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]);
var Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map(function(_, i) {
    return i;
}));
var Pi = /* @__PURE__ */ Id.map(function(i) {
    return (9 * i + 5) % 16;
});
var idxL = [
    Id
];
var idxR = [
    Pi
];
for(var i = 0; i < 4; i++)try {
    for(var _b = (e_1 = void 0, __values([
        idxL,
        idxR
    ])), _c = _b.next(); !_c.done; _c = _b.next()){
        var j = _c.value;
        j.push(j[i].map(function(k) {
            return Rho[k];
        }));
    }
} catch (e_1_1) {
    e_1 = {
        error: e_1_1
    };
} finally{
    try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally{
        if (e_1) throw e_1.error;
    }
}
var shifts = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map(function(i) {
    return new Uint8Array(i);
});
var shiftsL = /* @__PURE__ */ idxL.map(function(idx, i) {
    return idx.map(function(j) {
        return shifts[i][j];
    });
});
var shiftsR = /* @__PURE__ */ idxR.map(function(idx, i) {
    return idx.map(function(j) {
        return shifts[i][j];
    });
});
var Kl = /* @__PURE__ */ new Uint32Array([
    0x00000000,
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc,
    0xa953fd4e
]);
var Kr = /* @__PURE__ */ new Uint32Array([
    0x50a28be6,
    0x5c4dd124,
    0x6d703ef3,
    0x7a6d76e9,
    0x00000000
]);
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0) return x ^ y ^ z;
    else if (group === 1) return x & y | ~x & z;
    else if (group === 2) return (x | ~y) ^ z;
    else if (group === 3) return x & z | y & ~z;
    else return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
var R_BUF = /* @__PURE__ */ new Uint32Array(16);
var RIPEMD160 = function(_super) {
    __extends(RIPEMD160, _super);
    function RIPEMD160() {
        var _this = _super.call(this, 64, 20, 8, true) || this;
        _this.h0 = 0x67452301 | 0;
        _this.h1 = 0xefcdab89 | 0;
        _this.h2 = 0x98badcfe | 0;
        _this.h3 = 0x10325476 | 0;
        _this.h4 = 0xc3d2e1f0 | 0;
        return _this;
    }
    RIPEMD160.prototype.get = function() {
        var _a = this, h0 = _a.h0, h1 = _a.h1, h2 = _a.h2, h3 = _a.h3, h4 = _a.h4;
        return [
            h0,
            h1,
            h2,
            h3,
            h4
        ];
    };
    RIPEMD160.prototype.set = function(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    };
    RIPEMD160.prototype.process = function(view, offset) {
        for(var i = 0; i < 16; i++, offset += 4)R_BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        var al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for(var group = 0; group < 5; group++){
            var rGroup = 4 - group;
            var hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            var rl = idxL[group], rr = idxR[group]; // prettier-ignore
            var sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for(var i = 0; i < 16; i++){
                var tl = (0, utils_1.rotl)(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el | 0;
                al = el, el = dl, dl = (0, utils_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for(var i = 0; i < 16; i++){
                var tr = (0, utils_1.rotl)(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er | 0;
                ar = er, er = dr, dr = (0, utils_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    };
    RIPEMD160.prototype.roundClean = function() {
        R_BUF.fill(0);
    };
    RIPEMD160.prototype.destroy = function() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    };
    return RIPEMD160;
}(_md_1.HashMD);
exports.RIPEMD160 = RIPEMD160;
/** RIPEMD-160 - a legacy hash function from 1990s. */ var _ripemd160 = /* @__PURE__ */ (0, utils_1.wrapConstructor)(function() {
    return new RIPEMD160();
});
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/ripemd_160.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ripemd160 = void 0;
var uint8array_utils_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/uint8array-utils/dist/index.js [app-client] (ecmascript)");
var ripemd_160_1 = __turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/noble/ripemd_160.js [app-client] (ecmascript)");
function ripemd160(input) {
    if (typeof input === "string") {
        if (input.startsWith("0x")) input = (0, uint8array_utils_1.fromHex)(input.toLowerCase().slice(2));
        else if (isHex(input)) input = (0, uint8array_utils_1.fromHex)(input.toLowerCase());
        else input = (0, uint8array_utils_1.fromUtf8)(input);
    }
    if (!(input instanceof Uint8Array)) input = new Uint8Array(input);
    // throw new Error("ripemd160: input must be Uint8Array or string");
    return new ripemd_160_1.RIPEMD160().update(input).digest();
}
exports.ripemd160 = ripemd160;
function isHex(str) {
    return /^[0-9A-Fa-f]*$/.test(str);
}
}),
"[project]/node_modules/@harmoniclabs/crypto/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/bech32.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/blake2b.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/bls12_318.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/ed25519.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/hmacSHA512.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/keccak.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/secp256k1.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/sha2_256.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/sha2_512.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/sha3.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/types.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/utils/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/vrf.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@harmoniclabs/crypto/dist/ripemd_160.js [app-client] (ecmascript)"), exports);
}),
]);

//# sourceMappingURL=node_modules_%40harmoniclabs_6ee52aa2._.js.map