{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/internal/util.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/internal/util.ts"],"sourcesContent":["import * as array_ from \"effect/Array\"\nimport * as Predicate from \"effect/Predicate\"\nimport type * as AST from \"../AST.js\"\nimport type * as ParseResult from \"../ParseResult.js\"\n\n/** @internal */\nexport const getKeysForIndexSignature = (\n  input: { readonly [x: PropertyKey]: unknown },\n  parameter: AST.Parameter\n): ReadonlyArray<string> | ReadonlyArray<symbol> => {\n  switch (parameter._tag) {\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n      return Object.keys(input)\n    case \"SymbolKeyword\":\n      return Object.getOwnPropertySymbols(input)\n    case \"Refinement\":\n      return getKeysForIndexSignature(input, parameter.from)\n  }\n}\n\n/** @internal */\nexport const ownKeys = (o: object): Array<PropertyKey> =>\n  (Object.keys(o) as Array<PropertyKey>).concat(Object.getOwnPropertySymbols(o))\n\n/** @internal */\nexport const memoizeThunk = <A>(f: () => A): () => A => {\n  let done = false\n  let a: A\n  return () => {\n    if (done) {\n      return a\n    }\n    a = f()\n    done = true\n    return a\n  }\n}\n\n/** @internal */\nexport const formatUnknown = (u: unknown): string => {\n  if (Predicate.isString(u)) {\n    return JSON.stringify(u)\n  } else if (\n    Predicate.isNumber(u)\n    || u == null\n    || Predicate.isBoolean(u)\n    || Predicate.isSymbol(u)\n    || Predicate.isDate(u)\n  ) {\n    return String(u)\n  } else if (Predicate.isBigInt(u)) {\n    return String(u) + \"n\"\n  } else if (\n    !array_.isArray(u)\n    && Predicate.hasProperty(u, \"toString\")\n    && Predicate.isFunction(u[\"toString\"])\n    && u[\"toString\"] !== Object.prototype.toString\n  ) {\n    return u[\"toString\"]()\n  }\n  try {\n    JSON.stringify(u)\n    if (array_.isArray(u)) {\n      return `[${u.map(formatUnknown).join(\",\")}]`\n    } else {\n      return `{${\n        ownKeys(u).map((k) =>\n          `${Predicate.isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown((u as any)[k])}`\n        ).join(\",\")\n      }}`\n    }\n  } catch (e) {\n    return String(u)\n  }\n}\n\n/** @internal */\nexport const formatPropertyKey = (name: PropertyKey): string =>\n  typeof name === \"string\" ? JSON.stringify(name) : String(name)\n\n/** @internal */\nexport type SingleOrArray<A> = A | ReadonlyArray<A>\n\n/** @internal */\nexport const isNonEmpty = <A>(x: ParseResult.SingleOrNonEmpty<A>): x is array_.NonEmptyReadonlyArray<A> =>\n  Array.isArray(x)\n\n/** @internal */\nexport const isSingle = <A>(x: A | ReadonlyArray<A>): x is A => !Array.isArray(x)\n\n/** @internal */\nexport const formatPathKey = (key: PropertyKey): string => `[${formatPropertyKey(key)}]`\n\n/** @internal */\nexport const formatPath = (path: ParseResult.Path): string =>\n  isNonEmpty(path) ? path.map(formatPathKey).join(\"\") : formatPathKey(path)\n"],"names":["array_","Predicate","getKeysForIndexSignature","input","parameter","_tag","Object","keys","getOwnPropertySymbols","from","ownKeys","o","concat","memoizeThunk","f","done","a","formatUnknown","u","isString","JSON","stringify","isNumber","isBoolean","isSymbol","isDate","String","isBigInt","isArray","hasProperty","isFunction","prototype","toString","map","join","k","e","formatPropertyKey","name","isNonEmpty","x","Array","isSingle","formatPathKey","key","formatPath","path"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/internal/errors.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/internal/errors.ts"],"sourcesContent":["import * as array_ from \"effect/Array\"\nimport type * as AST from \"../AST.js\"\nimport * as util_ from \"./util.js\"\n\nconst getErrorMessage = (\n  reason: string,\n  details?: string,\n  path?: ReadonlyArray<PropertyKey>,\n  ast?: AST.AST\n): string => {\n  let out = reason\n\n  if (path && array_.isNonEmptyReadonlyArray(path)) {\n    out += `\\nat path: ${util_.formatPath(path)}`\n  }\n\n  if (details !== undefined) {\n    out += `\\ndetails: ${details}`\n  }\n\n  if (ast) {\n    out += `\\nschema (${ast._tag}): ${ast}`\n  }\n\n  return out\n}\n\n// ---------------------------------------------\n// generic\n// ---------------------------------------------\n\n/** @internal */\nexport const getInvalidArgumentErrorMessage = (details: string) => getErrorMessage(\"Invalid Argument\", details)\n\nconst getUnsupportedSchemaErrorMessage = (details?: string, path?: ReadonlyArray<PropertyKey>, ast?: AST.AST): string =>\n  getErrorMessage(\"Unsupported schema\", details, path, ast)\n\nconst getMissingAnnotationErrorMessage = (details?: string, path?: ReadonlyArray<PropertyKey>, ast?: AST.AST): string =>\n  getErrorMessage(\"Missing annotation\", details, path, ast)\n\n// ---------------------------------------------\n// Arbitrary\n// ---------------------------------------------\n\n/** @internal */\nexport const getArbitraryUnsupportedErrorMessage = (path: ReadonlyArray<PropertyKey>, ast: AST.AST) =>\n  getUnsupportedSchemaErrorMessage(\"Cannot build an Arbitrary for this schema\", path, ast)\n\n/** @internal */\nexport const getArbitraryMissingAnnotationErrorMessage = (\n  path: ReadonlyArray<PropertyKey>,\n  ast: AST.AST\n) =>\n  getMissingAnnotationErrorMessage(\n    `Generating an Arbitrary for this schema requires an \"arbitrary\" annotation`,\n    path,\n    ast\n  )\n\n/** @internal */\nexport const getArbitraryEmptyEnumErrorMessage = (path: ReadonlyArray<PropertyKey>) =>\n  getErrorMessage(\"Empty Enums schema\", \"Generating an Arbitrary for this schema requires at least one enum\", path)\n\n// ---------------------------------------------\n// Equivalence\n// ---------------------------------------------\n\n/** @internal */\nexport const getEquivalenceUnsupportedErrorMessage = (ast: AST.AST, path: ReadonlyArray<PropertyKey>) =>\n  getUnsupportedSchemaErrorMessage(\"Cannot build an Equivalence\", path, ast)\n\n// ---------------------------------------------\n// JSON Schema\n// ---------------------------------------------\n\n/** @internal */\nexport const getJSONSchemaMissingAnnotationErrorMessage = (\n  path: ReadonlyArray<PropertyKey>,\n  ast: AST.AST\n) =>\n  getMissingAnnotationErrorMessage(\n    `Generating a JSON Schema for this schema requires a \"jsonSchema\" annotation`,\n    path,\n    ast\n  )\n\n/** @internal */\nexport const getJSONSchemaMissingIdentifierAnnotationErrorMessage = (\n  path: ReadonlyArray<PropertyKey>,\n  ast: AST.AST\n) =>\n  getMissingAnnotationErrorMessage(\n    `Generating a JSON Schema for this schema requires an \"identifier\" annotation`,\n    path,\n    ast\n  )\n\n/** @internal */\nexport const getJSONSchemaUnsupportedParameterErrorMessage = (\n  path: ReadonlyArray<PropertyKey>,\n  parameter: AST.AST\n): string => getErrorMessage(\"Unsupported index signature parameter\", undefined, path, parameter)\n\n/** @internal */\nexport const getJSONSchemaUnsupportedPostRestElementsErrorMessage = (path: ReadonlyArray<PropertyKey>): string =>\n  getErrorMessage(\n    \"Generating a JSON Schema for post-rest elements is not currently supported. You're welcome to contribute by submitting a Pull Request\",\n    undefined,\n    path\n  )\n\n/** @internal */\nexport const getJSONSchemaUnsupportedKeyErrorMessage = (key: PropertyKey, path: ReadonlyArray<PropertyKey>): string =>\n  getErrorMessage(\"Unsupported key\", `Cannot encode ${util_.formatPropertyKey(key)} key to JSON Schema`, path)\n\n// ---------------------------------------------\n// Pretty\n// ---------------------------------------------\n\n/** @internal */\nexport const getPrettyMissingAnnotationErrorMessage = (\n  path: ReadonlyArray<PropertyKey>,\n  ast: AST.AST\n) => getMissingAnnotationErrorMessage(`Generating a Pretty for this schema requires a \"pretty\" annotation`, path, ast)\n\n/** @internal */\nexport const getPrettyNeverErrorMessage = \"Cannot pretty print a `never` value\"\n\n/** @internal */\nexport const getPrettyNoMatchingSchemaErrorMessage = (\n  actual: unknown,\n  path: ReadonlyArray<PropertyKey>,\n  ast: AST.AST\n) => getErrorMessage(\"Unexpected Error\", `Cannot find a matching schema for ${util_.formatUnknown(actual)}`, path, ast)\n\n// ---------------------------------------------\n// Schema\n// ---------------------------------------------\n\n/** @internal */\nexport const getSchemaExtendErrorMessage = (x: AST.AST, y: AST.AST, path: ReadonlyArray<PropertyKey>) =>\n  getErrorMessage(\"Unsupported schema or overlapping types\", `cannot extend ${x} with ${y}`, path)\n\n/** @internal */\nexport const getSchemaUnsupportedLiteralSpanErrorMessage = (ast: AST.AST) =>\n  getErrorMessage(\"Unsupported template literal span\", undefined, undefined, ast)\n\n// ---------------------------------------------\n// AST\n// ---------------------------------------------\n\n/** @internal */\nexport const getASTUnsupportedSchema = (ast: AST.AST) => getUnsupportedSchemaErrorMessage(undefined, undefined, ast)\n\n/** @internal */\nexport const getASTUnsupportedKeySchema = (ast: AST.AST) =>\n  getErrorMessage(\"Unsupported key schema\", undefined, undefined, ast)\n\n/** @internal */\nexport const getASTUnsupportedLiteral = (literal: AST.LiteralValue) =>\n  getErrorMessage(\"Unsupported literal\", `literal value: ${util_.formatUnknown(literal)}`)\n\n/** @internal */\nexport const getASTDuplicateIndexSignatureErrorMessage = (type: \"string\" | \"symbol\"): string =>\n  getErrorMessage(\"Duplicate index signature\", `${type} index signature`)\n\n/** @internal */\nexport const getASTIndexSignatureParameterErrorMessage = getErrorMessage(\n  \"Unsupported index signature parameter\",\n  \"An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types\"\n)\n\n/** @internal */\nexport const getASTRequiredElementFollowinAnOptionalElementErrorMessage = getErrorMessage(\n  \"Invalid element\",\n  \"A required element cannot follow an optional element. ts(1257)\"\n)\n\n/** @internal */\nexport const getASTDuplicatePropertySignatureTransformationErrorMessage = (key: PropertyKey): string =>\n  getErrorMessage(\"Duplicate property signature transformation\", `Duplicate key ${util_.formatUnknown(key)}`)\n\n/** @internal */\nexport const getASTUnsupportedRenameSchema = (ast: AST.AST): string =>\n  getUnsupportedSchemaErrorMessage(undefined, undefined, ast)\n\n/** @internal */\nexport const getASTDuplicatePropertySignatureErrorMessage = (key: PropertyKey): string =>\n  getErrorMessage(\"Duplicate property signature\", `Duplicate key ${util_.formatUnknown(key)}`)\n"],"names":["array_","util_","getErrorMessage","reason","details","path","ast","out","isNonEmptyReadonlyArray","formatPath","undefined","_tag","getInvalidArgumentErrorMessage","getUnsupportedSchemaErrorMessage","getMissingAnnotationErrorMessage","getArbitraryUnsupportedErrorMessage","getArbitraryMissingAnnotationErrorMessage","getArbitraryEmptyEnumErrorMessage","getEquivalenceUnsupportedErrorMessage","getJSONSchemaMissingAnnotationErrorMessage","getJSONSchemaMissingIdentifierAnnotationErrorMessage","getJSONSchemaUnsupportedParameterErrorMessage","parameter","getJSONSchemaUnsupportedPostRestElementsErrorMessage","getJSONSchemaUnsupportedKeyErrorMessage","key","formatPropertyKey","getPrettyMissingAnnotationErrorMessage","getPrettyNeverErrorMessage","getPrettyNoMatchingSchemaErrorMessage","actual","formatUnknown","getSchemaExtendErrorMessage","x","y","getSchemaUnsupportedLiteralSpanErrorMessage","getASTUnsupportedSchema","getASTUnsupportedKeySchema","getASTUnsupportedLiteral","literal","getASTDuplicateIndexSignatureErrorMessage","type","getASTIndexSignatureParameterErrorMessage","getASTRequiredElementFollowinAnOptionalElementErrorMessage","getASTDuplicatePropertySignatureTransformationErrorMessage","getASTUnsupportedRenameSchema","getASTDuplicatePropertySignatureErrorMessage"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/AST.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/AST.ts"],"sourcesContent":["/**\n * @since 0.67.0\n */\n\nimport * as Arr from \"effect/Array\"\nimport type { Effect } from \"effect/Effect\"\nimport { dual, identity } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Number from \"effect/Number\"\nimport * as Option from \"effect/Option\"\nimport * as Order from \"effect/Order\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as regexp from \"effect/RegExp\"\nimport type { Concurrency } from \"effect/Types\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as util_ from \"./internal/util.js\"\nimport type { ParseIssue } from \"./ParseResult.js\"\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport type AST =\n  | Declaration\n  | Literal\n  | UniqueSymbol\n  | UndefinedKeyword\n  | VoidKeyword\n  | NeverKeyword\n  | UnknownKeyword\n  | AnyKeyword\n  | StringKeyword\n  | NumberKeyword\n  | BooleanKeyword\n  | BigIntKeyword\n  | SymbolKeyword\n  | ObjectKeyword\n  | Enums\n  | TemplateLiteral\n  // possible transformations\n  | Refinement\n  | TupleType\n  | TypeLiteral\n  | Union\n  | Suspend\n  // transformations\n  | Transformation\n\n// -------------------------------------------------------------------------------------\n// annotations\n// -------------------------------------------------------------------------------------\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type BrandAnnotation = Arr.NonEmptyReadonlyArray<string | symbol>\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const BrandAnnotationId = Symbol.for(\"@effect/schema/annotation/Brand\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type TypeAnnotation = symbol\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const TypeAnnotationId = Symbol.for(\"@effect/schema/annotation/Type\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type MessageAnnotation = (issue: ParseIssue) => string | Effect<string> | {\n  readonly message: string | Effect<string>\n  readonly override: boolean\n}\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const MessageAnnotationId = Symbol.for(\"@effect/schema/annotation/Message\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type MissingMessageAnnotation = () => string | Effect<string>\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const MissingMessageAnnotationId = Symbol.for(\"@effect/schema/annotation/MissingMessage\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type IdentifierAnnotation = string\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const IdentifierAnnotationId = Symbol.for(\"@effect/schema/annotation/Identifier\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type TitleAnnotation = string\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const TitleAnnotationId = Symbol.for(\"@effect/schema/annotation/Title\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type DescriptionAnnotation = string\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const DescriptionAnnotationId = Symbol.for(\"@effect/schema/annotation/Description\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type ExamplesAnnotation<A> = Arr.NonEmptyReadonlyArray<A>\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const ExamplesAnnotationId = Symbol.for(\"@effect/schema/annotation/Examples\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type DefaultAnnotation<A> = A\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const DefaultAnnotationId = Symbol.for(\"@effect/schema/annotation/Default\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type JSONSchemaAnnotation = object\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const JSONSchemaAnnotationId = Symbol.for(\"@effect/schema/annotation/JSONSchema\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type DocumentationAnnotation = string\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const DocumentationAnnotationId = Symbol.for(\"@effect/schema/annotation/Documentation\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type ConcurrencyAnnotation = Concurrency | undefined\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const ConcurrencyAnnotationId = Symbol.for(\"@effect/schema/annotation/Concurrency\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type BatchingAnnotation = boolean | \"inherit\" | undefined\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const BatchingAnnotationId = Symbol.for(\"@effect/schema/annotation/Batching\")\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport type ParseIssueTitleAnnotation = (issue: ParseIssue) => string | undefined\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const ParseIssueTitleAnnotationId = Symbol.for(\"@effect/schema/annotation/ParseIssueTitle\")\n\n/**\n * @category annotations\n * @since 0.68.3\n */\nexport const ParseOptionsAnnotationId = Symbol.for(\"@effect/schema/annotation/ParseOptions\")\n\n/** @internal */\nexport const SurrogateAnnotationId = Symbol.for(\"@effect/schema/annotation/Surrogate\")\n\n/**\n * Used by:\n *\n * - AST.keyof\n * - AST.getPropertyKeyIndexedAccess\n * - AST.getPropertyKeys\n * - AST.getPropertySignatures\n * - AST.getWeight\n * - Parser.getLiterals\n *\n * @internal\n */\nexport type SurrogateAnnotation = AST\n\n/** @internal */\nexport const StableFilterAnnotationId = Symbol.for(\"@effect/schema/annotation/StableFilter\")\n\n/** @internal */\nexport type StableFilterAnnotation = boolean\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport interface Annotations {\n  readonly [_: symbol]: unknown\n}\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport interface Annotated {\n  readonly annotations: Annotations\n}\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getAnnotation: {\n  <A>(key: symbol): (annotated: Annotated) => Option.Option<A>\n  <A>(annotated: Annotated, key: symbol): Option.Option<A>\n} = dual(\n  2,\n  <A>(annotated: Annotated, key: symbol): Option.Option<A> =>\n    Object.prototype.hasOwnProperty.call(annotated.annotations, key) ?\n      Option.some(annotated.annotations[key] as any) :\n      Option.none()\n)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getBrandAnnotation = getAnnotation<BrandAnnotation>(BrandAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getMessageAnnotation = getAnnotation<MessageAnnotation>(MessageAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getMissingMessageAnnotation = getAnnotation<MissingMessageAnnotation>(MissingMessageAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getTitleAnnotation = getAnnotation<TitleAnnotation>(TitleAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getIdentifierAnnotation = getAnnotation<IdentifierAnnotation>(IdentifierAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getDescriptionAnnotation = getAnnotation<DescriptionAnnotation>(DescriptionAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getExamplesAnnotation = getAnnotation<ExamplesAnnotation<unknown>>(ExamplesAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getDefaultAnnotation = getAnnotation<DefaultAnnotation<unknown>>(DefaultAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getJSONSchemaAnnotation = getAnnotation<JSONSchemaAnnotation>(JSONSchemaAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getDocumentationAnnotation = getAnnotation<DocumentationAnnotation>(DocumentationAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getConcurrencyAnnotation = getAnnotation<ConcurrencyAnnotation>(ConcurrencyAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getBatchingAnnotation = getAnnotation<BatchingAnnotation>(BatchingAnnotationId)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const getParseIssueTitleAnnotation = getAnnotation<ParseIssueTitleAnnotation>(ParseIssueTitleAnnotationId)\n\n/**\n * @category annotations\n * @since 0.68.3\n */\nexport const getParseOptionsAnnotation = getAnnotation<ParseOptions>(ParseOptionsAnnotationId)\n\n/** @internal */\nexport const getSurrogateAnnotation = getAnnotation<SurrogateAnnotation>(SurrogateAnnotationId)\n\nconst getStableFilterAnnotation = getAnnotation<StableFilterAnnotation>(StableFilterAnnotationId)\n\nconst JSONIdentifierAnnotationId = Symbol.for(\"@effect/schema/annotation/JSONIdentifier\")\n\n/** @internal */\nexport const getJSONIdentifierAnnotation = getAnnotation<IdentifierAnnotation>(JSONIdentifierAnnotationId)\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class Declaration implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Declaration\"\n  constructor(\n    readonly typeParameters: ReadonlyArray<AST>,\n    readonly decodeUnknown: (\n      ...typeParameters: ReadonlyArray<AST>\n    ) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>,\n    readonly encodeUnknown: (\n      ...typeParameters: ReadonlyArray<AST>\n    ) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(getExpected(this), () => \"<declaration schema>\")\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\nconst createASTGuard = <T extends AST[\"_tag\"]>(tag: T) => (ast: AST): ast is Extract<AST, { _tag: T }> =>\n  ast._tag === tag\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isDeclaration: (ast: AST) => ast is Declaration = createASTGuard(\"Declaration\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport type LiteralValue = string | number | boolean | null | bigint\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class Literal implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Literal\"\n  constructor(readonly literal: LiteralValue, readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(getExpected(this), () => util_.formatUnknown(this.literal))\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      literal: Predicate.isBigInt(this.literal) ? String(this.literal) : this.literal,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isLiteral: (ast: AST) => ast is Literal = createASTGuard(\"Literal\")\n\nconst $null = new Literal(null, {\n  [IdentifierAnnotationId]: \"null\"\n})\n\nexport {\n  /**\n   * @category constructors\n   * @since 0.67.0\n   */\n  $null as null\n}\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class UniqueSymbol implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"UniqueSymbol\"\n  constructor(readonly symbol: symbol, readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(getExpected(this), () => util_.formatUnknown(this.symbol))\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      symbol: String(this.symbol),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isUniqueSymbol: (ast: AST) => ast is UniqueSymbol = createASTGuard(\"UniqueSymbol\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class UndefinedKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"UndefinedKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const undefinedKeyword: UndefinedKeyword = new UndefinedKeyword({\n  [TitleAnnotationId]: \"undefined\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isUndefinedKeyword: (ast: AST) => ast is UndefinedKeyword = createASTGuard(\"UndefinedKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class VoidKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"VoidKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const voidKeyword: VoidKeyword = new VoidKeyword({\n  [TitleAnnotationId]: \"void\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isVoidKeyword: (ast: AST) => ast is VoidKeyword = createASTGuard(\"VoidKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class NeverKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"NeverKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const neverKeyword: NeverKeyword = new NeverKeyword({\n  [TitleAnnotationId]: \"never\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isNeverKeyword: (ast: AST) => ast is NeverKeyword = createASTGuard(\"NeverKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class UnknownKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"UnknownKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const unknownKeyword: UnknownKeyword = new UnknownKeyword({\n  [TitleAnnotationId]: \"unknown\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isUnknownKeyword: (ast: AST) => ast is UnknownKeyword = createASTGuard(\"UnknownKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class AnyKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"AnyKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const anyKeyword: AnyKeyword = new AnyKeyword({\n  [TitleAnnotationId]: \"any\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isAnyKeyword: (ast: AST) => ast is AnyKeyword = createASTGuard(\"AnyKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class StringKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"StringKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const stringKeyword: StringKeyword = new StringKeyword({\n  [TitleAnnotationId]: \"string\",\n  [DescriptionAnnotationId]: \"a string\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isStringKeyword: (ast: AST) => ast is StringKeyword = createASTGuard(\"StringKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class NumberKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"NumberKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const numberKeyword: NumberKeyword = new NumberKeyword({\n  [TitleAnnotationId]: \"number\",\n  [DescriptionAnnotationId]: \"a number\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isNumberKeyword: (ast: AST) => ast is NumberKeyword = createASTGuard(\"NumberKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class BooleanKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"BooleanKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const booleanKeyword: BooleanKeyword = new BooleanKeyword({\n  [TitleAnnotationId]: \"boolean\",\n  [DescriptionAnnotationId]: \"a boolean\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isBooleanKeyword: (ast: AST) => ast is BooleanKeyword = createASTGuard(\"BooleanKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class BigIntKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"BigIntKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const bigIntKeyword: BigIntKeyword = new BigIntKeyword({\n  [TitleAnnotationId]: \"bigint\",\n  [DescriptionAnnotationId]: \"a bigint\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isBigIntKeyword: (ast: AST) => ast is BigIntKeyword = createASTGuard(\"BigIntKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class SymbolKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"SymbolKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const symbolKeyword: SymbolKeyword = new SymbolKeyword({\n  [TitleAnnotationId]: \"symbol\",\n  [DescriptionAnnotationId]: \"a symbol\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isSymbolKeyword: (ast: AST) => ast is SymbolKeyword = createASTGuard(\"SymbolKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class ObjectKeyword implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"ObjectKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return formatKeyword(this)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const objectKeyword: ObjectKeyword = new ObjectKeyword({\n  [IdentifierAnnotationId]: \"object\",\n  [TitleAnnotationId]: \"object\",\n  [DescriptionAnnotationId]: \"an object in the TypeScript meaning, i.e. the `object` type\"\n})\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isObjectKeyword: (ast: AST) => ast is ObjectKeyword = createASTGuard(\"ObjectKeyword\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class Enums implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Enums\"\n  constructor(\n    readonly enums: ReadonlyArray<readonly [string, string | number]>,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(\n      getExpected(this),\n      () => `<enum ${this.enums.length} value(s): ${this.enums.map((_, value) => JSON.stringify(value)).join(\" | \")}>`\n    )\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      enums: this.enums,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isEnums: (ast: AST) => ast is Enums = createASTGuard(\"Enums\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class TemplateLiteralSpan {\n  constructor(readonly type: StringKeyword | NumberKeyword, readonly literal: string) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    switch (this.type._tag) {\n      case \"StringKeyword\":\n        return \"${string}\"\n      case \"NumberKeyword\":\n        return \"${number}\"\n    }\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      type: this.type.toJSON(),\n      literal: this.literal\n    }\n  }\n}\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class TemplateLiteral implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"TemplateLiteral\"\n  constructor(\n    readonly head: string,\n    readonly spans: Arr.NonEmptyReadonlyArray<TemplateLiteralSpan>,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(getExpected(this), () => formatTemplateLiteral(this))\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      head: this.head,\n      spans: this.spans.map((span) => span.toJSON()),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\nconst formatTemplateLiteral = (ast: TemplateLiteral): string =>\n  \"`\" + ast.head + ast.spans.map((span) => String(span) + span.literal).join(\"\") +\n  \"`\"\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isTemplateLiteral: (ast: AST) => ast is TemplateLiteral = createASTGuard(\"TemplateLiteral\")\n\n/**\n * @category model\n * @since 0.68.0\n */\nexport class Type implements Annotated {\n  constructor(\n    readonly type: AST,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 0.68.0\n   */\n  toJSON(): object {\n    return {\n      type: this.type.toJSON(),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n  /**\n   * @since 0.68.0\n   */\n  toString() {\n    return String(this.type)\n  }\n}\n\n/**\n * @category model\n * @since 0.68.0\n */\nexport class OptionalType extends Type {\n  constructor(\n    type: AST,\n    readonly isOptional: boolean,\n    annotations: Annotations = {}\n  ) {\n    super(type, annotations)\n  }\n  /**\n   * @since 0.68.0\n   */\n  toJSON(): object {\n    return {\n      type: this.type.toJSON(),\n      isOptional: this.isOptional,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n  /**\n   * @since 0.68.0\n   */\n  toString() {\n    return String(this.type) + (this.isOptional ? \"?\" : \"\")\n  }\n}\n\nconst getRestASTs = (rest: ReadonlyArray<Type>): ReadonlyArray<AST> => rest.map((annotatedAST) => annotatedAST.type)\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class TupleType implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"TupleType\"\n  constructor(\n    readonly elements: ReadonlyArray<OptionalType>,\n    readonly rest: ReadonlyArray<Type>,\n    readonly isReadonly: boolean,\n    readonly annotations: Annotations = {}\n  ) {\n    let hasOptionalElement = false\n    let hasIllegalRequiredElement = false\n    for (const e of elements) {\n      if (e.isOptional) {\n        hasOptionalElement = true\n      } else if (hasOptionalElement) {\n        hasIllegalRequiredElement = true\n        break\n      }\n    }\n    if (hasIllegalRequiredElement || (hasOptionalElement && rest.length > 1)) {\n      throw new Error(errors_.getASTRequiredElementFollowinAnOptionalElementErrorMessage)\n    }\n  }\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(getExpected(this), () => formatTuple(this))\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      elements: this.elements.map((e) => e.toJSON()),\n      rest: this.rest.map((ast) => ast.toJSON()),\n      isReadonly: this.isReadonly,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\nconst formatTuple = (ast: TupleType): string => {\n  const formattedElements = ast.elements.map(String)\n    .join(\", \")\n  return Arr.matchLeft(ast.rest, {\n    onEmpty: () => `readonly [${formattedElements}]`,\n    onNonEmpty: (head, tail) => {\n      const formattedHead = String(head)\n      const wrappedHead = formattedHead.includes(\" | \") ? `(${formattedHead})` : formattedHead\n\n      if (tail.length > 0) {\n        const formattedTail = tail.map(String).join(\", \")\n        if (ast.elements.length > 0) {\n          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`\n        } else {\n          return `readonly [...${wrappedHead}[], ${formattedTail}]`\n        }\n      } else {\n        if (ast.elements.length > 0) {\n          return `readonly [${formattedElements}, ...${wrappedHead}[]]`\n        } else {\n          return `ReadonlyArray<${formattedHead}>`\n        }\n      }\n    }\n  })\n}\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isTupleType: (ast: AST) => ast is TupleType = createASTGuard(\"TupleType\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class PropertySignature extends OptionalType {\n  constructor(\n    readonly name: PropertyKey,\n    type: AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations?: Annotations\n  ) {\n    super(type, isOptional, annotations)\n  }\n  /**\n   * @since 0.68.18\n   */\n  toString(): string {\n    return (this.isReadonly ? \"readonly \" : \"\") + String(this.name) + (this.isOptional ? \"?\" : \"\") + \": \" +\n      this.type\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      name: String(this.name),\n      type: this.type.toJSON(),\n      isOptional: this.isOptional,\n      isReadonly: this.isReadonly,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @since 0.67.0\n */\nexport type Parameter = StringKeyword | SymbolKeyword | TemplateLiteral | Refinement<Parameter>\n\n/**\n * @since 0.67.0\n */\nexport const isParameter = (ast: AST): ast is Parameter => {\n  switch (ast._tag) {\n    case \"StringKeyword\":\n    case \"SymbolKeyword\":\n    case \"TemplateLiteral\":\n      return true\n    case \"Refinement\":\n      return isParameter(ast.from)\n  }\n  return false\n}\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class IndexSignature {\n  /**\n   * @since 0.67.0\n   */\n  readonly parameter: Parameter\n  constructor(\n    parameter: AST,\n    readonly type: AST,\n    readonly isReadonly: boolean\n  ) {\n    if (isParameter(parameter)) {\n      this.parameter = parameter\n    } else {\n      throw new Error(errors_.getASTIndexSignatureParameterErrorMessage)\n    }\n  }\n  /**\n   * @since 0.68.18\n   */\n  toString(): string {\n    return (this.isReadonly ? \"readonly \" : \"\") + `[x: ${this.parameter}]: ${this.type}`\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      parameter: this.parameter.toJSON(),\n      type: this.type.toJSON(),\n      isReadonly: this.isReadonly\n    }\n  }\n}\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class TypeLiteral implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"TypeLiteral\"\n  /**\n   * @since 0.67.0\n   */\n  readonly propertySignatures: ReadonlyArray<PropertySignature>\n  /**\n   * @since 0.67.0\n   */\n  readonly indexSignatures: ReadonlyArray<IndexSignature>\n  constructor(\n    propertySignatures: ReadonlyArray<PropertySignature>,\n    indexSignatures: ReadonlyArray<IndexSignature>,\n    readonly annotations: Annotations = {}\n  ) {\n    // check for duplicate property signatures\n    const keys: Record<PropertyKey, null> = {}\n    for (let i = 0; i < propertySignatures.length; i++) {\n      const name = propertySignatures[i].name\n      if (Object.prototype.hasOwnProperty.call(keys, name)) {\n        throw new Error(errors_.getASTDuplicatePropertySignatureErrorMessage(name))\n      }\n      keys[name] = null\n    }\n    // check for duplicate index signatures\n    const parameters = {\n      string: false,\n      symbol: false\n    }\n    for (let i = 0; i < indexSignatures.length; i++) {\n      const parameter = getParameterBase(indexSignatures[i].parameter)\n      if (isStringKeyword(parameter)) {\n        if (parameters.string) {\n          throw new Error(errors_.getASTDuplicateIndexSignatureErrorMessage(\"string\"))\n        }\n        parameters.string = true\n      } else if (isSymbolKeyword(parameter)) {\n        if (parameters.symbol) {\n          throw new Error(errors_.getASTDuplicateIndexSignatureErrorMessage(\"symbol\"))\n        }\n        parameters.symbol = true\n      }\n    }\n\n    this.propertySignatures = sortPropertySignatures(propertySignatures)\n    this.indexSignatures = sortIndexSignatures(indexSignatures)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(getExpected(this), () => formatTypeLiteral(this))\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),\n      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\nconst formatIndexSignatures = (iss: ReadonlyArray<IndexSignature>): string => iss.map(String).join(\"; \")\n\nconst formatTypeLiteral = (ast: TypeLiteral): string => {\n  if (ast.propertySignatures.length > 0) {\n    const pss = ast.propertySignatures.map(String).join(\"; \")\n    if (ast.indexSignatures.length > 0) {\n      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`\n    } else {\n      return `{ ${pss} }`\n    }\n  } else {\n    if (ast.indexSignatures.length > 0) {\n      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`\n    } else {\n      return \"{}\"\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isTypeLiteral: (ast: AST) => ast is TypeLiteral = createASTGuard(\"TypeLiteral\")\n\n/**\n * @since 0.67.0\n */\nexport type Members<A> = readonly [A, A, ...Array<A>]\n\nconst removeNevers = (candidates: ReadonlyArray<AST>): Array<AST> => candidates.filter((ast) => !(ast === neverKeyword))\n\nconst sortCandidates = Arr.sort(\n  Order.mapInput(Number.Order, (ast: AST) => {\n    switch (ast._tag) {\n      case \"AnyKeyword\":\n        return 0\n      case \"UnknownKeyword\":\n        return 1\n      case \"ObjectKeyword\":\n        return 2\n      case \"StringKeyword\":\n      case \"NumberKeyword\":\n      case \"BooleanKeyword\":\n      case \"BigIntKeyword\":\n      case \"SymbolKeyword\":\n        return 3\n    }\n    return 4\n  })\n)\n\nconst literalMap = {\n  string: \"StringKeyword\",\n  number: \"NumberKeyword\",\n  boolean: \"BooleanKeyword\",\n  bigint: \"BigIntKeyword\"\n} as const\n\n/** @internal */\nexport const flatten = (candidates: ReadonlyArray<AST>): Array<AST> =>\n  Arr.flatMap(candidates, (ast) => isUnion(ast) ? flatten(ast.types) : [ast])\n\n/** @internal */\nexport const unify = (candidates: ReadonlyArray<AST>): Array<AST> => {\n  const cs = sortCandidates(candidates)\n  const out: Array<AST> = []\n  const uniques: { [K in AST[\"_tag\"] | \"{}\"]?: AST } = {}\n  const literals: Array<LiteralValue | symbol> = []\n  for (const ast of cs) {\n    switch (ast._tag) {\n      case \"NeverKeyword\":\n        break\n      case \"AnyKeyword\":\n        return [anyKeyword]\n      case \"UnknownKeyword\":\n        return [unknownKeyword]\n      // uniques\n      case \"ObjectKeyword\":\n      case \"UndefinedKeyword\":\n      case \"VoidKeyword\":\n      case \"StringKeyword\":\n      case \"NumberKeyword\":\n      case \"BooleanKeyword\":\n      case \"BigIntKeyword\":\n      case \"SymbolKeyword\": {\n        if (!uniques[ast._tag]) {\n          uniques[ast._tag] = ast\n          out.push(ast)\n        }\n        break\n      }\n      case \"Literal\": {\n        const type = typeof ast.literal\n        switch (type) {\n          case \"string\":\n          case \"number\":\n          case \"bigint\":\n          case \"boolean\": {\n            const _tag = literalMap[type]\n            if (!uniques[_tag] && !literals.includes(ast.literal)) {\n              literals.push(ast.literal)\n              out.push(ast)\n            }\n            break\n          }\n          // null\n          case \"object\": {\n            if (!literals.includes(ast.literal)) {\n              literals.push(ast.literal)\n              out.push(ast)\n            }\n            break\n          }\n        }\n        break\n      }\n      case \"UniqueSymbol\": {\n        if (!uniques[\"SymbolKeyword\"] && !literals.includes(ast.symbol)) {\n          literals.push(ast.symbol)\n          out.push(ast)\n        }\n        break\n      }\n      case \"TupleType\": {\n        if (!uniques[\"ObjectKeyword\"]) {\n          out.push(ast)\n        }\n        break\n      }\n      case \"TypeLiteral\": {\n        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n          if (!uniques[\"{}\"]) {\n            uniques[\"{}\"] = ast\n            out.push(ast)\n          }\n        } else if (!uniques[\"ObjectKeyword\"]) {\n          out.push(ast)\n        }\n        break\n      }\n      default:\n        out.push(ast)\n    }\n  }\n  return out\n}\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class Union implements Annotated {\n  static make = (candidates: ReadonlyArray<AST>, annotations?: Annotations): AST => {\n    const types = []\n    const memo = new Set<AST>()\n    for (let i = 0; i < candidates.length; i++) {\n      const ast = candidates[i]\n      if (ast === neverKeyword || memo.has(ast)) {\n        continue\n      }\n      memo.add(ast)\n      types.push(ast)\n    }\n    return Union.union(types, annotations)\n  }\n  /** @internal */\n  static members = (candidates: ReadonlyArray<AST>, annotations?: Annotations): AST => {\n    return Union.union(removeNevers(candidates), annotations)\n  }\n  /** @internal */\n  static unify = (candidates: ReadonlyArray<AST>, annotations?: Annotations): AST => {\n    return Union.union(unify(flatten(candidates)), annotations)\n  }\n  /** @internal */\n  static union = (types: ReadonlyArray<AST>, annotations?: Annotations): AST => {\n    return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword\n  }\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Union\"\n  private constructor(readonly types: Members<AST>, readonly annotations: Annotations = {}) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(\n      getExpected(this),\n      () => this.types.map(String).join(\" | \")\n    )\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      types: this.types.map((ast) => ast.toJSON()),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/** @internal */\nexport const mapMembers = <A, B>(members: Members<A>, f: (a: A) => B): Members<B> => members.map(f) as any\n\n/** @internal */\nexport const isMembers = <A>(as: ReadonlyArray<A>): as is Members<A> => as.length > 1\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isUnion: (ast: AST) => ast is Union = createASTGuard(\"Union\")\n\nconst toJSONMemoMap = globalValue(\n  Symbol.for(\"@effect/schema/AST/toJSONMemoMap\"),\n  () => new WeakMap<AST, object>()\n)\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class Suspend implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Suspend\"\n  constructor(readonly f: () => AST, readonly annotations: Annotations = {}) {\n    this.f = util_.memoizeThunk(f)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return getExpected(this).pipe(\n      Option.orElse(() =>\n        Option.flatMap(\n          Option.liftThrowable(this.f)(),\n          (ast) => getExpected(ast)\n        )\n      ),\n      Option.getOrElse(() => \"<suspended schema>\")\n    )\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    const ast = this.f()\n    let out = toJSONMemoMap.get(ast)\n    if (out) {\n      return out\n    }\n    toJSONMemoMap.set(ast, { _tag: this._tag })\n    out = {\n      _tag: this._tag,\n      ast: ast.toJSON(),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n    toJSONMemoMap.set(ast, out)\n    return out\n  }\n}\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isSuspend: (ast: AST) => ast is Suspend = createASTGuard(\"Suspend\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class Refinement<From extends AST = AST> implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Refinement\"\n  constructor(\n    readonly from: From,\n    readonly filter: (\n      input: any,\n      options: ParseOptions,\n      self: Refinement\n    ) => Option.Option<ParseIssue>,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(getExpected(this), () => `{ ${this.from} | filter }`)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      from: this.from.toJSON(),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isRefinement: (ast: AST) => ast is Refinement<AST> = createASTGuard(\"Refinement\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport interface ParseOptions {\n  /**\n   * The `errors` option allows you to receive all parsing errors when\n   * attempting to parse a value using a schema. By default only the first error\n   * is returned, but by setting the `errors` option to `\"all\"`, you can receive\n   * all errors that occurred during the parsing process. This can be useful for\n   * debugging or for providing more comprehensive error messages to the user.\n   *\n   * default: \"first\"\n   *\n   * @since 0.67.0\n   */\n  readonly errors?: \"first\" | \"all\" | undefined\n  /**\n   * When using a `Schema` to parse a value, by default any properties that are\n   * not specified in the `Schema` will be stripped out from the output. This is\n   * because the `Schema` is expecting a specific shape for the parsed value,\n   * and any excess properties do not conform to that shape.\n   *\n   * However, you can use the `onExcessProperty` option (default value:\n   * `\"ignore\"`) to trigger a parsing error. This can be particularly useful in\n   * cases where you need to detect and handle potential errors or unexpected\n   * values.\n   *\n   * If you want to allow excess properties to remain, you can use\n   * `onExcessProperty` set to `\"preserve\"`.\n   *\n   * default: \"ignore\"\n   *\n   * @since 0.67.0\n   */\n  readonly onExcessProperty?: \"ignore\" | \"error\" | \"preserve\" | undefined\n  /**\n   * The `propertyOrder` option provides control over the order of object fields\n   * in the output. This feature is particularly useful when the sequence of\n   * keys is important for the consuming processes or when maintaining the input\n   * order enhances readability and usability.\n   *\n   * By default, the `propertyOrder` option is set to `\"none\"`. This means that\n   * the internal system decides the order of keys to optimize parsing speed.\n   * The order of keys in this mode should not be considered stable, and it's\n   * recommended not to rely on key ordering as it may change in future updates\n   * without notice.\n   *\n   * Setting `propertyOrder` to `\"original\"` ensures that the keys are ordered\n   * as they appear in the input during the decoding/encoding process.\n   *\n   * default: \"none\"\n   *\n   * @since 0.67.20\n   */\n  readonly propertyOrder?: \"none\" | \"original\" | undefined\n  /**\n   * Handles missing properties in data structures. By default, missing\n   * properties are treated as if present with an `undefined` value. To treat\n   * missing properties as errors, set the `exact` option to `true`. This\n   * setting is already enabled by default for `is` and `asserts` functions,\n   * treating absent properties strictly unless overridden.\n   *\n   * default: false\n   *\n   * @since 0.67.24\n   */\n  readonly exact?: boolean | undefined\n}\n\n/**\n * @since 0.67.0\n */\nexport const defaultParseOption: ParseOptions = {}\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class Transformation implements Annotated {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Transformation\"\n  constructor(\n    readonly from: AST,\n    readonly to: AST,\n    readonly transformation: TransformationKind,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return Option.getOrElse(\n      getExpected(this),\n      () => `(${String(this.from)} <-> ${String(this.to)})`\n    )\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      from: this.from.toJSON(),\n      to: this.to.toJSON(),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isTransformation: (ast: AST) => ast is Transformation = createASTGuard(\"Transformation\")\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport type TransformationKind =\n  | FinalTransformation\n  | ComposeTransformation\n  | TypeLiteralTransformation\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class FinalTransformation {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"FinalTransformation\"\n  constructor(\n    readonly decode: (input: any, options: ParseOptions, self: Transformation) => Effect<any, ParseIssue, any>,\n    readonly encode: (input: any, options: ParseOptions, self: Transformation) => Effect<any, ParseIssue, any>\n  ) {}\n}\n\nconst createTransformationGuard =\n  <T extends TransformationKind[\"_tag\"]>(tag: T) =>\n  (ast: TransformationKind): ast is Extract<TransformationKind, { _tag: T }> => ast._tag === tag\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isFinalTransformation: (ast: TransformationKind) => ast is FinalTransformation = createTransformationGuard(\n  \"FinalTransformation\"\n)\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class ComposeTransformation {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"ComposeTransformation\"\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const composeTransformation: ComposeTransformation = new ComposeTransformation()\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isComposeTransformation: (ast: TransformationKind) => ast is ComposeTransformation =\n  createTransformationGuard(\n    \"ComposeTransformation\"\n  )\n\n/**\n * Represents a `PropertySignature -> PropertySignature` transformation\n *\n * The semantic of `decode` is:\n * - `none()` represents the absence of the key/value pair\n * - `some(value)` represents the presence of the key/value pair\n *\n * The semantic of `encode` is:\n * - `none()` you don't want to output the key/value pair\n * - `some(value)` you want to output the key/value pair\n *\n * @category model\n * @since 0.67.0\n */\nexport class PropertySignatureTransformation {\n  constructor(\n    readonly from: PropertyKey,\n    readonly to: PropertyKey,\n    readonly decode: (o: Option.Option<any>) => Option.Option<any>,\n    readonly encode: (o: Option.Option<any>) => Option.Option<any>\n  ) {}\n}\n\nconst isRenamingPropertySignatureTransformation = (t: PropertySignatureTransformation) =>\n  t.decode === identity && t.encode === identity\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport class TypeLiteralTransformation {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"TypeLiteralTransformation\"\n  constructor(\n    readonly propertySignatureTransformations: ReadonlyArray<\n      PropertySignatureTransformation\n    >\n  ) {\n    // check for duplicate property signature transformations\n    const fromKeys: Record<PropertyKey, true> = {}\n    const toKeys: Record<PropertyKey, true> = {}\n    for (const pst of propertySignatureTransformations) {\n      const from = pst.from\n      if (fromKeys[from]) {\n        throw new Error(errors_.getASTDuplicatePropertySignatureTransformationErrorMessage(from))\n      }\n      fromKeys[from] = true\n      const to = pst.to\n      if (toKeys[to]) {\n        throw new Error(errors_.getASTDuplicatePropertySignatureTransformationErrorMessage(to))\n      }\n      toKeys[to] = true\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 0.67.0\n */\nexport const isTypeLiteralTransformation: (ast: TransformationKind) => ast is TypeLiteralTransformation =\n  createTransformationGuard(\"TypeLiteralTransformation\")\n\n// -------------------------------------------------------------------------------------\n// API\n// -------------------------------------------------------------------------------------\n\n/**\n * Adds a group of annotations, potentially overwriting existing annotations.\n *\n * @since 0.67.0\n */\nexport const annotations = (ast: AST, annotations: Annotations): AST => {\n  const d = Object.getOwnPropertyDescriptors(ast)\n  d.annotations.value = { ...ast.annotations, ...annotations }\n  return Object.create(Object.getPrototypeOf(ast), d)\n}\n\n/**\n * Equivalent at runtime to the TypeScript type-level `keyof` operator.\n *\n * @since 0.67.0\n */\nexport const keyof = (ast: AST): AST => Union.unify(_keyof(ast))\n\nconst STRING_KEYWORD_PATTERN = \".*\"\nconst NUMBER_KEYWORD_PATTERN = \"[+-]?\\\\d*\\\\.?\\\\d+(?:[Ee][+-]?\\\\d+)?\"\n\n/**\n * @since 0.67.0\n */\nexport const getTemplateLiteralRegExp = (ast: TemplateLiteral): RegExp => {\n  let pattern = `^${regexp.escape(ast.head)}`\n\n  for (const span of ast.spans) {\n    if (isStringKeyword(span.type)) {\n      pattern += STRING_KEYWORD_PATTERN\n    } else if (isNumberKeyword(span.type)) {\n      pattern += NUMBER_KEYWORD_PATTERN\n    }\n    pattern += regexp.escape(span.literal)\n  }\n\n  pattern += \"$\"\n  return new RegExp(pattern)\n}\n\n/**\n * @since 0.67.0\n */\nexport const getPropertySignatures = (ast: AST): Array<PropertySignature> => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return getPropertySignatures(annotation.value)\n      }\n      break\n    }\n    case \"TypeLiteral\":\n      return ast.propertySignatures.slice()\n    case \"Suspend\":\n      return getPropertySignatures(ast.f())\n  }\n  return getPropertyKeys(ast).map((name) => getPropertyKeyIndexedAccess(ast, name))\n}\n\n/** @internal */\nexport const getNumberIndexedAccess = (ast: AST): AST => {\n  switch (ast._tag) {\n    case \"TupleType\": {\n      let hasOptional = false\n      let out: Array<AST> = []\n      for (const e of ast.elements) {\n        if (e.isOptional) {\n          hasOptional = true\n        }\n        out.push(e.type)\n      }\n      if (hasOptional) {\n        out.push(undefinedKeyword)\n      }\n      out = out.concat(getRestASTs(ast.rest))\n      return Union.make(out)\n    }\n    case \"Refinement\":\n      return getNumberIndexedAccess(ast.from)\n    case \"Union\":\n      return Union.make(ast.types.map(getNumberIndexedAccess))\n    case \"Suspend\":\n      return getNumberIndexedAccess(ast.f())\n  }\n  throw new Error(errors_.getASTUnsupportedSchema(ast))\n}\n\n/** @internal */\nexport const getPropertyKeyIndexedAccess = (ast: AST, name: PropertyKey): PropertySignature => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return getPropertyKeyIndexedAccess(annotation.value, name)\n      }\n      break\n    }\n    case \"TypeLiteral\": {\n      const ops = Arr.findFirst(ast.propertySignatures, (ps) => ps.name === name)\n      if (Option.isSome(ops)) {\n        return ops.value\n      } else {\n        if (Predicate.isString(name)) {\n          for (const is of ast.indexSignatures) {\n            const parameterBase = getParameterBase(is.parameter)\n            switch (parameterBase._tag) {\n              case \"TemplateLiteral\": {\n                const regex = getTemplateLiteralRegExp(parameterBase)\n                if (regex.test(name)) {\n                  return new PropertySignature(name, is.type, false, true)\n                }\n                break\n              }\n              case \"StringKeyword\":\n                return new PropertySignature(name, is.type, false, true)\n            }\n          }\n        } else if (Predicate.isSymbol(name)) {\n          for (const is of ast.indexSignatures) {\n            const parameterBase = getParameterBase(is.parameter)\n            if (isSymbolKeyword(parameterBase)) {\n              return new PropertySignature(name, is.type, false, true)\n            }\n          }\n        }\n      }\n      break\n    }\n    case \"Union\":\n      return new PropertySignature(\n        name,\n        Union.make(ast.types.map((ast) => getPropertyKeyIndexedAccess(ast, name).type)),\n        false,\n        true\n      )\n    case \"Suspend\":\n      return getPropertyKeyIndexedAccess(ast.f(), name)\n  }\n  return new PropertySignature(name, neverKeyword, false, true)\n}\n\nconst getPropertyKeys = (ast: AST): Array<PropertyKey> => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return getPropertyKeys(annotation.value)\n      }\n      break\n    }\n    case \"TypeLiteral\":\n      return ast.propertySignatures.map((ps) => ps.name)\n    case \"Suspend\":\n      return getPropertyKeys(ast.f())\n    case \"Union\":\n      return ast.types.slice(1).reduce(\n        (out: Array<PropertyKey>, ast) => Arr.intersection(out, getPropertyKeys(ast)),\n        getPropertyKeys(ast.types[0])\n      )\n    case \"Transformation\":\n      return getPropertyKeys(ast.to)\n  }\n  return []\n}\n\n/** @internal */\nexport const record = (key: AST, value: AST): {\n  propertySignatures: Array<PropertySignature>\n  indexSignatures: Array<IndexSignature>\n} => {\n  const propertySignatures: Array<PropertySignature> = []\n  const indexSignatures: Array<IndexSignature> = []\n  const go = (key: AST): void => {\n    switch (key._tag) {\n      case \"NeverKeyword\":\n        break\n      case \"StringKeyword\":\n      case \"SymbolKeyword\":\n      case \"TemplateLiteral\":\n      case \"Refinement\":\n        indexSignatures.push(new IndexSignature(key, value, true))\n        break\n      case \"Literal\":\n        if (Predicate.isString(key.literal) || Predicate.isNumber(key.literal)) {\n          propertySignatures.push(new PropertySignature(key.literal, value, false, true))\n        } else {\n          throw new Error(errors_.getASTUnsupportedLiteral(key.literal))\n        }\n        break\n      case \"Enums\": {\n        for (const [_, name] of key.enums) {\n          propertySignatures.push(new PropertySignature(name, value, false, true))\n        }\n        break\n      }\n      case \"UniqueSymbol\":\n        propertySignatures.push(new PropertySignature(key.symbol, value, false, true))\n        break\n      case \"Union\":\n        key.types.forEach(go)\n        break\n      default:\n        throw new Error(errors_.getASTUnsupportedKeySchema(key))\n    }\n  }\n  go(key)\n  return { propertySignatures, indexSignatures }\n}\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Pick`.\n *\n * @since 0.67.0\n */\nexport const pick = (ast: AST, keys: ReadonlyArray<PropertyKey>): TypeLiteral | Transformation => {\n  if (isTransformation(ast)) {\n    switch (ast.transformation._tag) {\n      case \"ComposeTransformation\":\n        return new Transformation(\n          pick(ast.from, keys),\n          pick(ast.to, keys),\n          composeTransformation\n        )\n      case \"TypeLiteralTransformation\": {\n        const ts: Array<PropertySignatureTransformation> = []\n        const fromKeys: Array<PropertyKey> = []\n        for (const k of keys) {\n          const t = ast.transformation.propertySignatureTransformations.find((t) => t.to === k)\n          if (t) {\n            ts.push(t)\n            fromKeys.push(t.from)\n          } else {\n            fromKeys.push(k)\n          }\n        }\n        return Arr.isNonEmptyReadonlyArray(ts) ?\n          new Transformation(\n            pick(ast.from, fromKeys),\n            pick(ast.to, keys),\n            new TypeLiteralTransformation(ts)\n          ) :\n          pick(ast.from, fromKeys)\n      }\n      case \"FinalTransformation\": {\n        const annotation = getSurrogateAnnotation(ast)\n        if (Option.isSome(annotation)) {\n          return pick(annotation.value, keys)\n        }\n        throw new Error(errors_.getASTUnsupportedSchema(ast))\n      }\n    }\n  }\n  return new TypeLiteral(keys.map((key) => getPropertyKeyIndexedAccess(ast, key)), [])\n}\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Omit`.\n *\n * @since 0.67.0\n */\nexport const omit = (ast: AST, keys: ReadonlyArray<PropertyKey>): TypeLiteral | Transformation =>\n  pick(ast, getPropertyKeys(ast).filter((name) => !keys.includes(name)))\n\n/** @internal */\nexport const orUndefined = (ast: AST): AST => Union.make([ast, undefinedKeyword])\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Partial`.\n *\n * @since 0.67.0\n */\nexport const partial = (ast: AST, options?: { readonly exact: true }): AST => {\n  const exact = options?.exact === true\n  switch (ast._tag) {\n    case \"TupleType\":\n      return new TupleType(\n        ast.elements.map((e) => new OptionalType(exact ? e.type : orUndefined(e.type), true)),\n        Arr.match(ast.rest, {\n          onEmpty: () => ast.rest,\n          onNonEmpty: (rest) => [new Type(Union.make([...getRestASTs(rest), undefinedKeyword]))]\n        }),\n        ast.isReadonly\n      )\n    case \"TypeLiteral\":\n      return new TypeLiteral(\n        ast.propertySignatures.map((ps) =>\n          new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)\n        ),\n        ast.indexSignatures.map((is) => new IndexSignature(is.parameter, orUndefined(is.type), is.isReadonly))\n      )\n    case \"Union\":\n      return Union.make(ast.types.map((member) => partial(member, options)))\n    case \"Suspend\":\n      return new Suspend(() => partial(ast.f(), options))\n    case \"Declaration\":\n      throw new Error(errors_.getASTUnsupportedSchema(ast))\n    case \"Refinement\":\n      throw new Error(errors_.getASTUnsupportedSchema(ast))\n    case \"Transformation\": {\n      if (\n        isTypeLiteralTransformation(ast.transformation) &&\n        ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)\n      ) {\n        return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation)\n      }\n      throw new Error(errors_.getASTUnsupportedSchema(ast))\n    }\n  }\n  return ast\n}\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Required`.\n *\n * @since 0.67.0\n */\nexport const required = (ast: AST): AST => {\n  switch (ast._tag) {\n    case \"TupleType\":\n      return new TupleType(\n        ast.elements.map((e) => new OptionalType(e.type, false)),\n        ast.rest,\n        ast.isReadonly\n      )\n    case \"TypeLiteral\":\n      return new TypeLiteral(\n        ast.propertySignatures.map((f) => new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)),\n        ast.indexSignatures\n      )\n    case \"Union\":\n      return Union.make(ast.types.map((member) => required(member)))\n    case \"Suspend\":\n      return new Suspend(() => required(ast.f()))\n    case \"Declaration\":\n      throw new Error(errors_.getASTUnsupportedSchema(ast))\n    case \"Refinement\":\n      throw new Error(errors_.getASTUnsupportedSchema(ast))\n    case \"Transformation\": {\n      if (\n        isTypeLiteralTransformation(ast.transformation) &&\n        ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)\n      ) {\n        return new Transformation(required(ast.from), required(ast.to), ast.transformation)\n      }\n      throw new Error(errors_.getASTUnsupportedSchema(ast))\n    }\n  }\n  return ast\n}\n\n/**\n * Creates a new AST with shallow mutability applied to its properties.\n *\n * @param ast - The original AST to make properties mutable (shallowly).\n *\n * @since 0.67.0\n */\nexport const mutable = (ast: AST): AST => {\n  switch (ast._tag) {\n    case \"TupleType\":\n      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations)\n    case \"TypeLiteral\": {\n      const propertySignatures = changeMap(\n        ast.propertySignatures,\n        (ps) =>\n          ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations)\n      )\n      const indexSignatures = changeMap(\n        ast.indexSignatures,\n        (is) => is.isReadonly === false ? is : new IndexSignature(is.parameter, is.type, false)\n      )\n      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ?\n        ast :\n        new TypeLiteral(propertySignatures, indexSignatures, ast.annotations)\n    }\n    case \"Union\": {\n      const types = changeMap(ast.types, mutable)\n      return types === ast.types ? ast : Union.make(types, ast.annotations)\n    }\n    case \"Suspend\":\n      return new Suspend(() => mutable(ast.f()), ast.annotations)\n    case \"Refinement\": {\n      const from = mutable(ast.from)\n      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations)\n    }\n    case \"Transformation\": {\n      const from = mutable(ast.from)\n      const to = mutable(ast.to)\n      return from === ast.from && to === ast.to ?\n        ast :\n        new Transformation(from, to, ast.transformation, ast.annotations)\n    }\n  }\n  return ast\n}\n\n// -------------------------------------------------------------------------------------\n// compiler harness\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 0.67.0\n */\nexport type Compiler<A> = (ast: AST, path: ReadonlyArray<PropertyKey>) => A\n\n/**\n * @since 0.67.0\n */\nexport type Match<A> = {\n  [K in AST[\"_tag\"]]: (ast: Extract<AST, { _tag: K }>, compile: Compiler<A>, path: ReadonlyArray<PropertyKey>) => A\n}\n\n/**\n * @since 0.67.0\n */\nexport const getCompiler = <A>(match: Match<A>): Compiler<A> => {\n  const compile = (ast: AST, path: ReadonlyArray<PropertyKey>): A => match[ast._tag](ast as any, compile, path)\n  return compile\n}\n\n/**\n * @since 0.67.0\n */\nexport const typeAST = (ast: AST): AST => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const typeParameters = changeMap(ast.typeParameters, typeAST)\n      return typeParameters === ast.typeParameters ?\n        ast :\n        new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations)\n    }\n    case \"TupleType\": {\n      const elements = changeMap(ast.elements, (e) => {\n        const type = typeAST(e.type)\n        return type === e.type ? e : new OptionalType(type, e.isOptional)\n      })\n      const restASTs = getRestASTs(ast.rest)\n      const rest = changeMap(restASTs, typeAST)\n      return elements === ast.elements && rest === restASTs ?\n        ast :\n        new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations)\n    }\n    case \"TypeLiteral\": {\n      const propertySignatures = changeMap(ast.propertySignatures, (p) => {\n        const type = typeAST(p.type)\n        return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly)\n      })\n      const indexSignatures = changeMap(ast.indexSignatures, (is) => {\n        const type = typeAST(is.type)\n        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly)\n      })\n      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ?\n        ast :\n        new TypeLiteral(propertySignatures, indexSignatures, ast.annotations)\n    }\n    case \"Union\": {\n      const types = changeMap(ast.types, typeAST)\n      return types === ast.types ? ast : Union.make(types, ast.annotations)\n    }\n    case \"Suspend\":\n      return new Suspend(() => typeAST(ast.f()), ast.annotations)\n    case \"Refinement\": {\n      const from = typeAST(ast.from)\n      return from === ast.from ?\n        ast :\n        new Refinement(from, ast.filter, ast.annotations)\n    }\n    case \"Transformation\":\n      return typeAST(ast.to)\n  }\n  return ast\n}\n\n/** @internal */\nexport const preserveAnnotations =\n  (annotationIds: ReadonlyArray<symbol>) => (annotated: Annotated): Annotations | undefined => {\n    let out: { [_: symbol]: unknown } | undefined = undefined\n    for (const id of annotationIds) {\n      if (Object.prototype.hasOwnProperty.call(annotated.annotations, id)) {\n        if (out === undefined) {\n          out = {}\n        }\n        out[id] = annotated.annotations[id]\n      }\n    }\n    return out\n  }\n\n/** @internal */\nexport const getJSONIdentifier = (annotated: Annotated) =>\n  Option.orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated))\n\n// To generate a JSON Schema from a recursive schema, an `identifier` annotation\n// is required. So, when we calculate the encodedAST, we need to preserve the\n// annotation in the form of an internal custom annotation that acts as a\n// surrogate for the identifier, which the JSON Schema compiler can then read.\nconst createJSONIdentifierAnnotation = (annotated: Annotated): Annotations | undefined =>\n  Option.match(getJSONIdentifier(annotated), {\n    onNone: () => undefined,\n    onSome: (identifier) => ({ [JSONIdentifierAnnotationId]: identifier })\n  })\n\nfunction changeMap<A>(\n  as: Arr.NonEmptyReadonlyArray<A>,\n  f: (a: A) => A\n): Arr.NonEmptyReadonlyArray<A>\nfunction changeMap<A>(as: ReadonlyArray<A>, f: (a: A) => A): ReadonlyArray<A>\nfunction changeMap<A>(as: ReadonlyArray<A>, f: (a: A) => A): ReadonlyArray<A> {\n  let changed = false\n  const out = Arr.allocate(as.length) as Array<A>\n  for (let i = 0; i < as.length; i++) {\n    const a = as[i]\n    const fa = f(a)\n    if (fa !== a) {\n      changed = true\n    }\n    out[i] = fa\n  }\n  return changed ? out : as\n}\n\nconst encodedAST_ = (ast: AST, isBound: boolean): AST => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const typeParameters = changeMap(ast.typeParameters, (ast) => encodedAST_(ast, isBound))\n      return typeParameters === ast.typeParameters ?\n        ast :\n        new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations)\n    }\n    case \"TupleType\": {\n      const elements = changeMap(ast.elements, (e) => {\n        const type = encodedAST_(e.type, isBound)\n        return type === e.type ? e : new OptionalType(type, e.isOptional)\n      })\n      const restASTs = getRestASTs(ast.rest)\n      const rest = changeMap(restASTs, (ast) => encodedAST_(ast, isBound))\n      return elements === ast.elements && rest === restASTs ?\n        ast :\n        new TupleType(\n          elements,\n          rest.map((ast) => new Type(ast)),\n          ast.isReadonly,\n          createJSONIdentifierAnnotation(ast)\n        )\n    }\n    case \"TypeLiteral\": {\n      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {\n        const type = encodedAST_(ps.type, isBound)\n        return type === ps.type\n          ? ps\n          : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly)\n      })\n      const indexSignatures = changeMap(ast.indexSignatures, (is) => {\n        const type = encodedAST_(is.type, isBound)\n        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly)\n      })\n      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ?\n        ast :\n        new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast))\n    }\n    case \"Union\": {\n      const types = changeMap(ast.types, (ast) => encodedAST_(ast, isBound))\n      return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast))\n    }\n    case \"Suspend\":\n      return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast))\n    case \"Refinement\": {\n      const from = encodedAST_(ast.from, isBound)\n      if (isBound) {\n        if (from === ast.from) {\n          return ast\n        }\n        if (!isTransformation(ast.from)) {\n          const annotations = getStableFilterAnnotation(ast)\n          if (Option.isSome(annotations) && annotations.value === true) {\n            return new Refinement(from, ast.filter)\n          }\n        }\n      }\n      return from\n    }\n    case \"Transformation\":\n      return encodedAST_(ast.from, isBound)\n  }\n  return ast\n}\n\n/**\n * @since 0.67.0\n */\nexport const encodedAST = (ast: AST): AST => encodedAST_(ast, false)\n\n/**\n * @since 0.67.0\n */\nexport const encodedBoundAST = (ast: AST): AST => encodedAST_(ast, true)\n\nconst toJSONAnnotations = (annotations: Annotations): object => {\n  const out: Record<string, unknown> = {}\n  for (const k of Object.getOwnPropertySymbols(annotations)) {\n    out[String(k)] = annotations[k]\n  }\n  return out\n}\n\n/** @internal */\nexport const getCardinality = (ast: AST): number => {\n  switch (ast._tag) {\n    case \"NeverKeyword\":\n      return 0\n    case \"Literal\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"UniqueSymbol\":\n      return 1\n    case \"BooleanKeyword\":\n      return 2\n    case \"StringKeyword\":\n    case \"NumberKeyword\":\n    case \"BigIntKeyword\":\n    case \"SymbolKeyword\":\n      return 3\n    case \"ObjectKeyword\":\n      return 5\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return 6\n    default:\n      return 4\n  }\n}\n\nconst sortPropertySignatures = Arr.sort(\n  Order.mapInput(Number.Order, (ps: PropertySignature) => getCardinality(ps.type))\n)\n\nconst sortIndexSignatures = Arr.sort(\n  Order.mapInput(Number.Order, (is: IndexSignature) => {\n    switch (getParameterBase(is.parameter)._tag) {\n      case \"StringKeyword\":\n        return 2\n      case \"SymbolKeyword\":\n        return 3\n      case \"TemplateLiteral\":\n        return 1\n    }\n  })\n)\n\ntype Weight = readonly [number, number, number]\n\nconst WeightOrder: Order.Order<Weight> = Order.tuple<\n  readonly [Order.Order<number>, Order.Order<number>, Order.Order<number>]\n>(Number.Order, Number.Order, Number.Order)\n\nconst maxWeight = Order.max<Weight>(WeightOrder)\n\nconst emptyWeight: Weight = [0, 0, 0]\n\nconst maxWeightAll = (weights: ReadonlyArray<Weight>): Weight => weights.reduce(maxWeight, emptyWeight)\n\n/** @internal */\nexport const getWeight = (ast: AST): Weight => {\n  switch (ast._tag) {\n    case \"TupleType\": {\n      return [2, ast.elements.length, ast.rest.length]\n    }\n    case \"TypeLiteral\": {\n      const y = ast.propertySignatures.length\n      const z = ast.indexSignatures.length\n      return y + z === 0 ?\n        [-4, 0, 0] :\n        [4, y, z]\n    }\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        const [_, y, z] = getWeight(annotation.value)\n        return [6, y, z]\n      }\n      return [6, 0, 0]\n    }\n    case \"Suspend\":\n      return [8, 0, 0]\n    case \"Union\":\n      return maxWeightAll(ast.types.map(getWeight))\n    case \"Refinement\": {\n      const [x, y, z] = getWeight(ast.from)\n      return [x + 1, y, z]\n    }\n    case \"Transformation\":\n      return getWeight(ast.from)\n    case \"ObjectKeyword\":\n      return [-2, 0, 0]\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return [-4, 0, 0]\n    default:\n      return emptyWeight\n  }\n}\n\n/** @internal */\nexport const getParameterBase = (\n  ast: Parameter\n): StringKeyword | SymbolKeyword | TemplateLiteral => {\n  switch (ast._tag) {\n    case \"StringKeyword\":\n    case \"SymbolKeyword\":\n    case \"TemplateLiteral\":\n      return ast\n    case \"Refinement\":\n      return getParameterBase(ast.from)\n  }\n}\n\nconst equalsTemplateLiteralSpan = Arr.getEquivalence<TemplateLiteralSpan>((self, that) =>\n  self.type._tag === that.type._tag && self.literal === that.literal\n)\n\nconst equalsEnums = Arr.getEquivalence<readonly [string, string | number]>((self, that) =>\n  that[0] === self[0] && that[1] === self[1]\n)\n\nconst equals = (self: AST, that: AST) => {\n  switch (self._tag) {\n    case \"Literal\":\n      return isLiteral(that) && that.literal === self.literal\n    case \"UniqueSymbol\":\n      return isUniqueSymbol(that) && that.symbol === self.symbol\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"NeverKeyword\":\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n    case \"StringKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"SymbolKeyword\":\n    case \"ObjectKeyword\":\n      return that._tag === self._tag\n    case \"TemplateLiteral\":\n      return isTemplateLiteral(that) && that.head === self.head && equalsTemplateLiteralSpan(that.spans, self.spans)\n    case \"Enums\":\n      return isEnums(that) && equalsEnums(that.enums, self.enums)\n    case \"Refinement\":\n    case \"TupleType\":\n    case \"TypeLiteral\":\n    case \"Union\":\n    case \"Suspend\":\n    case \"Transformation\":\n    case \"Declaration\":\n      return self === that\n  }\n}\n\nconst intersection = Arr.intersectionWith(equals)\n\nconst _keyof = (ast: AST): Array<AST> => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return _keyof(annotation.value)\n      }\n      break\n    }\n    case \"TypeLiteral\":\n      return ast.propertySignatures.map((p): AST =>\n        Predicate.isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)\n      ).concat(ast.indexSignatures.map((is) => getParameterBase(is.parameter)))\n    case \"Suspend\":\n      return _keyof(ast.f())\n    case \"Union\":\n      return ast.types.slice(1).reduce(\n        (out: Array<AST>, ast) => intersection(out, _keyof(ast)),\n        _keyof(ast.types[0])\n      )\n    case \"Transformation\":\n      return _keyof(ast.to)\n  }\n  throw new Error(errors_.getASTUnsupportedSchema(ast))\n}\n\n/** @internal */\nexport const compose = (ab: AST, cd: AST): AST => new Transformation(ab, cd, composeTransformation)\n\n/** @internal */\nexport const rename = (ast: AST, mapping: { readonly [K in PropertyKey]?: PropertyKey }): AST => {\n  switch (ast._tag) {\n    case \"TypeLiteral\": {\n      const propertySignatureTransformations: Array<PropertySignatureTransformation> = []\n      for (const key of util_.ownKeys(mapping)) {\n        const name = mapping[key]\n        if (name !== undefined) {\n          propertySignatureTransformations.push(\n            new PropertySignatureTransformation(\n              key,\n              name,\n              identity,\n              identity\n            )\n          )\n        }\n      }\n      if (propertySignatureTransformations.length === 0) {\n        return ast\n      }\n      return new Transformation(\n        ast,\n        new TypeLiteral(\n          ast.propertySignatures.map((ps) => {\n            const name = mapping[ps.name]\n            return new PropertySignature(\n              name === undefined ? ps.name : name,\n              typeAST(ps.type),\n              ps.isOptional,\n              ps.isReadonly,\n              ps.annotations\n            )\n          }),\n          ast.indexSignatures\n        ),\n        new TypeLiteralTransformation(propertySignatureTransformations)\n      )\n    }\n    case \"Union\":\n      return Union.make(ast.types.map((ast) => rename(ast, mapping)))\n    case \"Suspend\":\n      return new Suspend(() => rename(ast.f(), mapping))\n    case \"Transformation\":\n      return compose(ast, rename(typeAST(ast), mapping))\n  }\n  throw new Error(errors_.getASTUnsupportedRenameSchema(ast))\n}\n\nconst formatKeyword = (ast: AST): string => Option.getOrElse(getExpected(ast), () => ast._tag)\n\nconst getExpected = (ast: Annotated): Option.Option<string> => {\n  return getIdentifierAnnotation(ast).pipe(\n    Option.orElse(() => getTitleAnnotation(ast)),\n    Option.orElse(() => getDescriptionAnnotation(ast))\n  )\n}\n"],"names":["Arr","dual","identity","globalValue","Number","Option","Order","Predicate","regexp","errors_","util_","BrandAnnotationId","Symbol","for","TypeAnnotationId","MessageAnnotationId","MissingMessageAnnotationId","IdentifierAnnotationId","TitleAnnotationId","DescriptionAnnotationId","ExamplesAnnotationId","DefaultAnnotationId","JSONSchemaAnnotationId","DocumentationAnnotationId","ConcurrencyAnnotationId","BatchingAnnotationId","ParseIssueTitleAnnotationId","ParseOptionsAnnotationId","SurrogateAnnotationId","StableFilterAnnotationId","getAnnotation","annotated","key","Object","prototype","hasOwnProperty","call","annotations","some","none","getBrandAnnotation","getMessageAnnotation","getMissingMessageAnnotation","getTitleAnnotation","getIdentifierAnnotation","getDescriptionAnnotation","getExamplesAnnotation","getDefaultAnnotation","getJSONSchemaAnnotation","getDocumentationAnnotation","getConcurrencyAnnotation","getBatchingAnnotation","getParseIssueTitleAnnotation","getParseOptionsAnnotation","getSurrogateAnnotation","getStableFilterAnnotation","JSONIdentifierAnnotationId","getJSONIdentifierAnnotation","Declaration","typeParameters","decodeUnknown","encodeUnknown","_tag","constructor","toString","getOrElse","getExpected","toJSON","map","ast","toJSONAnnotations","createASTGuard","tag","isDeclaration","Literal","literal","formatUnknown","isBigInt","String","isLiteral","$null","null","UniqueSymbol","symbol","isUniqueSymbol","UndefinedKeyword","formatKeyword","undefinedKeyword","isUndefinedKeyword","VoidKeyword","voidKeyword","isVoidKeyword","NeverKeyword","neverKeyword","isNeverKeyword","UnknownKeyword","unknownKeyword","isUnknownKeyword","AnyKeyword","anyKeyword","isAnyKeyword","StringKeyword","stringKeyword","isStringKeyword","NumberKeyword","numberKeyword","isNumberKeyword","BooleanKeyword","booleanKeyword","isBooleanKeyword","BigIntKeyword","bigIntKeyword","isBigIntKeyword","SymbolKeyword","symbolKeyword","isSymbolKeyword","ObjectKeyword","objectKeyword","isObjectKeyword","Enums","enums","length","_","value","JSON","stringify","join","isEnums","TemplateLiteralSpan","type","TemplateLiteral","head","spans","formatTemplateLiteral","span","isTemplateLiteral","Type","OptionalType","isOptional","getRestASTs","rest","annotatedAST","TupleType","elements","isReadonly","hasOptionalElement","hasIllegalRequiredElement","e","Error","getASTRequiredElementFollowinAnOptionalElementErrorMessage","formatTuple","formattedElements","matchLeft","onEmpty","onNonEmpty","tail","formattedHead","wrappedHead","includes","formattedTail","isTupleType","PropertySignature","name","isParameter","from","IndexSignature","parameter","getASTIndexSignatureParameterErrorMessage","TypeLiteral","propertySignatures","indexSignatures","keys","i","getASTDuplicatePropertySignatureErrorMessage","parameters","string","getParameterBase","getASTDuplicateIndexSignatureErrorMessage","sortPropertySignatures","sortIndexSignatures","formatTypeLiteral","ps","formatIndexSignatures","iss","pss","isTypeLiteral","removeNevers","candidates","filter","sortCandidates","sort","mapInput","literalMap","number","boolean","bigint","flatten","flatMap","isUnion","types","unify","cs","out","uniques","literals","push","Union","make","memo","Set","has","add","union","members","isMembers","mapMembers","f","as","toJSONMemoMap","WeakMap","Suspend","memoizeThunk","pipe","orElse","liftThrowable","get","set","isSuspend","Refinement","isRefinement","defaultParseOption","Transformation","to","transformation","isTransformation","FinalTransformation","decode","encode","createTransformationGuard","isFinalTransformation","ComposeTransformation","composeTransformation","isComposeTransformation","PropertySignatureTransformation","isRenamingPropertySignatureTransformation","t","TypeLiteralTransformation","propertySignatureTransformations","fromKeys","toKeys","pst","getASTDuplicatePropertySignatureTransformationErrorMessage","isTypeLiteralTransformation","d","getOwnPropertyDescriptors","create","getPrototypeOf","keyof","_keyof","STRING_KEYWORD_PATTERN","NUMBER_KEYWORD_PATTERN","getTemplateLiteralRegExp","pattern","escape","RegExp","getPropertySignatures","annotation","isSome","slice","getPropertyKeys","getPropertyKeyIndexedAccess","getNumberIndexedAccess","hasOptional","concat","getASTUnsupportedSchema","ops","findFirst","isString","is","parameterBase","regex","test","isSymbol","reduce","intersection","record","go","isNumber","getASTUnsupportedLiteral","forEach","getASTUnsupportedKeySchema","pick","ts","k","find","isNonEmptyReadonlyArray","omit","orUndefined","partial","options","exact","match","member","every","required","mutable","changeMap","getCompiler","compile","path","typeAST","restASTs","p","preserveAnnotations","annotationIds","undefined","id","getJSONIdentifier","createJSONIdentifierAnnotation","onNone","onSome","identifier","changed","allocate","a","fa","encodedAST_","isBound","encodedAST","encodedBoundAST","getOwnPropertySymbols","getCardinality","WeightOrder","tuple","maxWeight","max","emptyWeight","maxWeightAll","weights","getWeight","y","z","x","equalsTemplateLiteralSpan","getEquivalence","self","that","equalsEnums","equals","intersectionWith","compose","ab","cd","rename","mapping","ownKeys","getASTUnsupportedRenameSchema"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,OAAO,KAAKA,GAAG,MAAM,cAAc;AAEnC,SAASC,IAAI,EAAEC,QAAQ,QAAQ,iBAAiB;AAChD,SAASC,WAAW,QAAQ,oBAAoB;AAChD,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,MAAM,MAAM,eAAe;AACvC,OAAO,KAAKC,KAAK,MAAM,cAAc;AACrC,OAAO,KAAKC,SAAS,MAAM,kBAAkB;AAC7C,OAAO,KAAKC,MAAM,MAAM,eAAe;AAEvC,OAAO,KAAKC,OAAO,MAAM,sBAAsB;AAC/C,OAAO,KAAKC,KAAK,MAAM,oBAAoB;;;;;;;;;;;AA+CpC,MAAMC,iBAAiB,GAAA,WAAA,GAAGC,MAAM,CAACC,GAAG,CAAC,iCAAiC,CAAC;AAYvE,MAAMC,gBAAgB,GAAA,WAAA,GAAGF,MAAM,CAACC,GAAG,CAAC,gCAAgC,CAAC;AAerE,MAAME,mBAAmB,GAAA,WAAA,GAAGH,MAAM,CAACC,GAAG,CAAC,mCAAmC,CAAC;AAY3E,MAAMG,0BAA0B,GAAA,WAAA,GAAGJ,MAAM,CAACC,GAAG,CAAC,0CAA0C,CAAC;AAYzF,MAAMI,sBAAsB,GAAA,WAAA,GAAGL,MAAM,CAACC,GAAG,CAAC,sCAAsC,CAAC;AAYjF,MAAMK,iBAAiB,GAAA,WAAA,GAAGN,MAAM,CAACC,GAAG,CAAC,iCAAiC,CAAC;AAYvE,MAAMM,uBAAuB,GAAA,WAAA,GAAGP,MAAM,CAACC,GAAG,CAAC,uCAAuC,CAAC;AAYnF,MAAMO,oBAAoB,GAAA,WAAA,GAAGR,MAAM,CAACC,GAAG,CAAC,oCAAoC,CAAC;AAY7E,MAAMQ,mBAAmB,GAAA,WAAA,GAAGT,MAAM,CAACC,GAAG,CAAC,mCAAmC,CAAC;AAY3E,MAAMS,sBAAsB,GAAA,WAAA,GAAGV,MAAM,CAACC,GAAG,CAAC,sCAAsC,CAAC;AAYjF,MAAMU,yBAAyB,GAAA,WAAA,GAAGX,MAAM,CAACC,GAAG,CAAC,yCAAyC,CAAC;AAYvF,MAAMW,uBAAuB,GAAA,WAAA,GAAGZ,MAAM,CAACC,GAAG,CAAC,uCAAuC,CAAC;AAYnF,MAAMY,oBAAoB,GAAA,WAAA,GAAGb,MAAM,CAACC,GAAG,CAAC,oCAAoC,CAAC;AAY7E,MAAMa,2BAA2B,GAAA,WAAA,GAAGd,MAAM,CAACC,GAAG,CAAC,2CAA2C,CAAC;AAM3F,MAAMc,wBAAwB,GAAA,WAAA,GAAGf,MAAM,CAACC,GAAG,CAAC,wCAAwC,CAAC;AAGrF,MAAMe,qBAAqB,GAAA,WAAA,GAAGhB,MAAM,CAACC,GAAG,CAAC,qCAAqC,CAAC;AAiB/E,MAAMgB,wBAAwB,GAAA,WAAA,GAAGjB,MAAM,CAACC,GAAG,CAAC,wCAAwC,CAAC;AAyBrF,MAAMiB,aAAa,GAAA,WAAA,OAGtB7B,4JAAI,EACN,CAAC,EACD,CAAI8B,SAAoB,EAAEC,GAAW,GACnCC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACL,SAAS,CAACM,WAAW,EAAEL,GAAG,CAAC,GAC9D3B,MAAM,CAACiC,mJAAI,CAACP,SAAS,CAACM,WAAW,CAACL,GAAG,CAAQ,CAAC,GAC9C3B,MAAM,CAACkC,mJAAI,EAAE,CAClB;AAMM,MAAMC,kBAAkB,GAAA,WAAA,GAAGV,aAAa,CAAkBnB,iBAAiB,CAAC;AAM5E,MAAM8B,oBAAoB,GAAA,WAAA,GAAGX,aAAa,CAAoBf,mBAAmB,CAAC;AAMlF,MAAM2B,2BAA2B,GAAA,WAAA,GAAGZ,aAAa,CAA2Bd,0BAA0B,CAAC;AAMvG,MAAM2B,kBAAkB,GAAA,WAAA,GAAGb,aAAa,CAAkBZ,iBAAiB,CAAC;AAM5E,MAAM0B,uBAAuB,GAAA,WAAA,GAAGd,aAAa,CAAuBb,sBAAsB,CAAC;AAM3F,MAAM4B,wBAAwB,GAAA,WAAA,GAAGf,aAAa,CAAwBX,uBAAuB,CAAC;AAM9F,MAAM2B,qBAAqB,GAAA,WAAA,GAAGhB,aAAa,CAA8BV,oBAAoB,CAAC;AAM9F,MAAM2B,oBAAoB,GAAA,WAAA,GAAGjB,aAAa,CAA6BT,mBAAmB,CAAC;AAM3F,MAAM2B,uBAAuB,GAAA,WAAA,GAAGlB,aAAa,CAAuBR,sBAAsB,CAAC;AAM3F,MAAM2B,0BAA0B,GAAA,WAAA,GAAGnB,aAAa,CAA0BP,yBAAyB,CAAC;AAMpG,MAAM2B,wBAAwB,GAAA,WAAA,GAAGpB,aAAa,CAAwBN,uBAAuB,CAAC;AAM9F,MAAM2B,qBAAqB,GAAA,WAAA,GAAGrB,aAAa,CAAqBL,oBAAoB,CAAC;AAMrF,MAAM2B,4BAA4B,GAAA,WAAA,GAAGtB,aAAa,CAA4BJ,2BAA2B,CAAC;AAM1G,MAAM2B,yBAAyB,GAAA,WAAA,GAAGvB,aAAa,CAAeH,wBAAwB,CAAC;AAGvF,MAAM2B,sBAAsB,GAAA,WAAA,GAAGxB,aAAa,CAAsBF,qBAAqB,CAAC;AAE/F,MAAM2B,yBAAyB,GAAA,WAAA,GAAGzB,aAAa,CAAyBD,wBAAwB,CAAC;AAEjG,MAAM2B,0BAA0B,GAAA,WAAA,GAAG5C,MAAM,CAACC,GAAG,CAAC,0CAA0C,CAAC;AAGlF,MAAM4C,2BAA2B,GAAA,WAAA,GAAG3B,aAAa,CAAuB0B,0BAA0B,CAAC;AAMpG,MAAOE,WAAW;IAMXC,cAAA,CAAA;IACAC,aAAA,CAAA;IAGAC,aAAA,CAAA;IAGAxB,WAAA,CAAA;IAZX;;MAGSyB,IAAI,GAAG,aAAa,CAAA;IAC7BC,YACWJ,cAAkC,EAClCC,aAEsF,EACtFC,aAEsF,EACtFxB,WAAA,GAA2B,CAAA,CAAE,CAAA;QAP7B,IAAA,CAAAsB,cAAc,GAAdA,cAAc;QACd,IAAA,CAAAC,aAAa,GAAbA,aAAa;QAGb,IAAA,CAAAC,aAAa,GAAbA,aAAa;QAGb,IAAA,CAAAxB,WAAW,GAAXA,WAAW;IACnB;IACH;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CAACC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAM,sBAAsB,CAAC;IAC1E;IACA;;MAGAC,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfH,cAAc,EAAE,IAAI,CAACA,cAAc,CAACS,GAAG,EAAEC,GAAG,GAAKA,GAAG,CAACF,MAAM,EAAE,CAAC;YAC9D9B,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAGF,MAAMkC,cAAc,IAA2BC,GAAM,IAAMH,GAAQ,GACjEA,GAAG,CAACP,IAAI,KAAKU,GAAG;AAMX,MAAMC,aAAa,GAAA,WAAA,GAAqCF,cAAc,CAAC,aAAa,CAAC;AAYtF,MAAOG,OAAO;IAKGC,OAAA,CAAA;IAAgCtC,WAAA,CAAA;IAJrD;;MAGSyB,IAAI,GAAG,SAAS,CAAA;IACzBC,YAAqBY,OAAqB,EAAWtC,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7D,IAAA,CAAAsC,OAAO,GAAPA,OAAO;QAAyB,IAAA,CAAAtC,WAAW,GAAXA,WAAW;IAAqB;IACrF;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CAACC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAMxD,KAAK,CAACkE,oOAAa,CAAC,IAAI,CAACD,OAAO,CAAC,CAAC;IACrF;IACA;;MAGAR,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfa,OAAO,EAAEpE,SAAS,CAACsE,uJAAQ,CAAC,IAAI,CAACF,OAAO,CAAC,GAAGG,MAAM,CAAC,IAAI,CAACH,OAAO,CAAC,GAAG,IAAI,CAACA,OAAO;YAC/EtC,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAM0C,SAAS,GAAA,WAAA,GAAiCR,cAAc,CAAC,SAAS,CAAC;AAEhF,MAAMS,KAAK,GAAA,WAAA,GAAG,IAAIN,OAAO,CAAC,IAAI,EAAE;IAC9B,CAACzD,sBAAsB,CAAA,EAAG;CAC3B,CAAC;;AAcI,MAAOiE,YAAY;IAKFC,MAAA,CAAA;IAAyB9C,WAAA,CAAA;IAJ9C;;MAGSyB,IAAI,GAAG,cAAc,CAAA;IAC9BC,YAAqBoB,MAAc,EAAW9C,WAAA,GAA2B,CAAA,CAAE,CAAA;QAAtD,IAAA,CAAA8C,MAAM,GAANA,MAAM;QAAmB,IAAA,CAAA9C,WAAW,GAAXA,WAAW;IAAqB;IAC9E;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CAACC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAMxD,KAAK,CAACkE,oOAAa,CAAC,IAAI,CAACO,MAAM,CAAC,CAAC;IACpF;IACA;;MAGAhB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfqB,MAAM,EAAEL,MAAM,CAAC,IAAI,CAACK,MAAM,CAAC;YAC3B9C,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAM+C,cAAc,GAAA,WAAA,GAAsCb,cAAc,CAAC,cAAc,CAAC;AAMzF,MAAOc,gBAAgB;IAKNhD,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,kBAAkB,CAAA;IAClCC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAMkD,gBAAgB,GAAA,WAAA,GAAqB,IAAIF,gBAAgB,CAAC;IACrE,CAACnE,iBAAiB,CAAA,EAAG;CACtB,CAAC;AAMK,MAAMsE,kBAAkB,GAAA,WAAA,GAA0CjB,cAAc,CAAC,kBAAkB,CAAC;AAMrG,MAAOkB,WAAW;IAKDpD,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,aAAa,CAAA;IAC7BC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAMqD,WAAW,GAAA,WAAA,GAAgB,IAAID,WAAW,CAAC;IACtD,CAACvE,iBAAiB,CAAA,EAAG;CACtB,CAAC;AAMK,MAAMyE,aAAa,GAAA,WAAA,GAAqCpB,cAAc,CAAC,aAAa,CAAC;AAMtF,MAAOqB,YAAY;IAKFvD,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,cAAc,CAAA;IAC9BC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAMwD,YAAY,GAAA,WAAA,GAAiB,IAAID,YAAY,CAAC;IACzD,CAAC1E,iBAAiB,CAAA,EAAG;CACtB,CAAC;AAMK,MAAM4E,cAAc,GAAA,WAAA,GAAsCvB,cAAc,CAAC,cAAc,CAAC;AAMzF,MAAOwB,cAAc;IAKJ1D,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,gBAAgB,CAAA;IAChCC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAM2D,cAAc,GAAA,WAAA,GAAmB,IAAID,cAAc,CAAC;IAC/D,CAAC7E,iBAAiB,CAAA,EAAG;CACtB,CAAC;AAMK,MAAM+E,gBAAgB,GAAA,WAAA,GAAwC1B,cAAc,CAAC,gBAAgB,CAAC;AAM/F,MAAO2B,UAAU;IAKA7D,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,YAAY,CAAA;IAC5BC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAM8D,UAAU,GAAA,WAAA,GAAe,IAAID,UAAU,CAAC;IACnD,CAAChF,iBAAiB,CAAA,EAAG;CACtB,CAAC;AAMK,MAAMkF,YAAY,GAAA,WAAA,GAAoC7B,cAAc,CAAC,YAAY,CAAC;AAMnF,MAAO8B,aAAa;IAKHhE,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,eAAe,CAAA;IAC/BC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAMiE,aAAa,GAAA,WAAA,GAAkB,IAAID,aAAa,CAAC;IAC5D,CAACnF,iBAAiB,CAAA,EAAG,QAAQ;IAC7B,CAACC,uBAAuB,CAAA,EAAG;CAC5B,CAAC;AAMK,MAAMoF,eAAe,GAAA,WAAA,GAAuChC,cAAc,CAAC,eAAe,CAAC;AAM5F,MAAOiC,aAAa;IAKHnE,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,eAAe,CAAA;IAC/BC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAMoE,aAAa,GAAA,WAAA,GAAkB,IAAID,aAAa,CAAC;IAC5D,CAACtF,iBAAiB,CAAA,EAAG,QAAQ;IAC7B,CAACC,uBAAuB,CAAA,EAAG;CAC5B,CAAC;AAMK,MAAMuF,eAAe,GAAA,WAAA,GAAuCnC,cAAc,CAAC,eAAe,CAAC;AAM5F,MAAOoC,cAAc;IAKJtE,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,gBAAgB,CAAA;IAChCC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAMuE,cAAc,GAAA,WAAA,GAAmB,IAAID,cAAc,CAAC;IAC/D,CAACzF,iBAAiB,CAAA,EAAG,SAAS;IAC9B,CAACC,uBAAuB,CAAA,EAAG;CAC5B,CAAC;AAMK,MAAM0F,gBAAgB,GAAA,WAAA,GAAwCtC,cAAc,CAAC,gBAAgB,CAAC;AAM/F,MAAOuC,aAAa;IAKHzE,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,eAAe,CAAA;IAC/BC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAM0E,aAAa,GAAA,WAAA,GAAkB,IAAID,aAAa,CAAC;IAC5D,CAAC5F,iBAAiB,CAAA,EAAG,QAAQ;IAC7B,CAACC,uBAAuB,CAAA,EAAG;CAC5B,CAAC;AAMK,MAAM6F,eAAe,GAAA,WAAA,GAAuCzC,cAAc,CAAC,eAAe,CAAC;AAM5F,MAAO0C,aAAa;IAKH5E,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,eAAe,CAAA;IAC/BC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAM6E,aAAa,GAAA,WAAA,GAAkB,IAAID,aAAa,CAAC;IAC5D,CAAC/F,iBAAiB,CAAA,EAAG,QAAQ;IAC7B,CAACC,uBAAuB,CAAA,EAAG;CAC5B,CAAC;AAMK,MAAMgG,eAAe,GAAA,WAAA,GAAuC5C,cAAc,CAAC,eAAe,CAAC;AAM5F,MAAO6C,aAAa;IAKH/E,WAAA,CAAA;IAJrB;;MAGSyB,IAAI,GAAG,eAAe,CAAA;IAC/BC,YAAqB1B,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;IAAqB;IACrD;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOsB,aAAa,CAAC,IAAI,CAAC;IAC5B;IACA;;MAGAnB,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfzB,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAMgF,aAAa,GAAA,WAAA,GAAkB,IAAID,aAAa,CAAC;IAC5D,CAACnG,sBAAsB,CAAA,EAAG,QAAQ;IAClC,CAACC,iBAAiB,CAAA,EAAG,QAAQ;IAC7B,CAACC,uBAAuB,CAAA,EAAG;CAC5B,CAAC;AAMK,MAAMmG,eAAe,GAAA,WAAA,GAAuC/C,cAAc,CAAC,eAAe,CAAC;AAM5F,MAAOgD,KAAK;IAMLC,KAAA,CAAA;IACAnF,WAAA,CAAA;IANX;;MAGSyB,IAAI,GAAG,OAAO,CAAA;IACvBC,YACWyD,KAAwD,EACxDnF,WAAA,GAA2B,CAAA,CAAE,CAAA;QAD7B,IAAA,CAAAmF,KAAK,GAALA,KAAK;QACL,IAAA,CAAAnF,WAAW,GAAXA,WAAW;IACnB;IACH;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CACrBC,WAAW,CAAC,IAAI,CAAC,EACjB,IAAM,CAAA,MAAA,EAAS,IAAI,CAACsD,KAAK,CAACC,MAAM,CAAA,WAAA,EAAc,IAAI,CAACD,KAAK,CAACpD,GAAG,CAAC,CAACsD,CAAC,EAAEC,KAAK,GAAKC,IAAI,CAACC,SAAS,CAACF,KAAK,CAAC,CAAC,CAACG,IAAI,CAAC,KAAK,CAAC,CAAA,CAAA,CAAG,CACjH;IACH;IACA;;MAGA3D,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACf0D,KAAK,EAAE,IAAI,CAACA,KAAK;YACjBnF,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAM0F,OAAO,GAAA,WAAA,GAA+BxD,cAAc,CAAC,OAAO,CAAC;AAMpE,MAAOyD,mBAAmB;IACTC,IAAA,CAAA;IAA8CtD,OAAA,CAAA;IAAnEZ,YAAqBkE,IAAmC,EAAWtD,OAAe,CAAA;QAA7D,IAAA,CAAAsD,IAAI,GAAJA,IAAI;QAA0C,IAAA,CAAAtD,OAAO,GAAPA,OAAO;IAAW;IACrF;;MAGAX,QAAQA,CAAA,EAAA;QACN,OAAQ,IAAI,CAACiE,IAAI,CAACnE,IAAI;YACpB,KAAK,eAAe;gBAClB,OAAO,WAAW;YACpB,KAAK,eAAe;gBAClB,OAAO,WAAW;QACtB;IACF;IACA;;MAGAK,MAAMA,CAAA,EAAA;QACJ,OAAO;YACL8D,IAAI,EAAE,IAAI,CAACA,IAAI,CAAC9D,MAAM,EAAE;YACxBQ,OAAO,EAAE,IAAI,CAACA,OAAAA;SACf;IACH;;AAOI,MAAOuD,eAAe;IAMfC,IAAA,CAAA;IACAC,KAAA,CAAA;IACA/F,WAAA,CAAA;IAPX;;MAGSyB,IAAI,GAAG,iBAAiB,CAAA;IACjCC,YACWoE,IAAY,EACZC,KAAqD,EACrD/F,WAAA,GAA2B,CAAA,CAAE,CAAA;QAF7B,IAAA,CAAA8F,IAAI,GAAJA,IAAI;QACJ,IAAA,CAAAC,KAAK,GAALA,KAAK;QACL,IAAA,CAAA/F,WAAW,GAAXA,WAAW;IACnB;IACH;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CAACC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAMmE,qBAAqB,CAAC,IAAI,CAAC,CAAC;IAC/E;IACA;;MAGAlE,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfqE,IAAI,EAAE,IAAI,CAACA,IAAI;YACfC,KAAK,EAAE,IAAI,CAACA,KAAK,CAAChE,GAAG,EAAEkE,IAAI,GAAKA,IAAI,CAACnE,MAAM,EAAE,CAAC;YAC9C9B,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAGF,MAAMgG,qBAAqB,IAAIhE,GAAoB,GACjD,GAAG,GAAGA,GAAG,CAAC8D,IAAI,GAAG9D,GAAG,CAAC+D,KAAK,CAAChE,GAAG,EAAEkE,IAAI,GAAKxD,MAAM,CAACwD,IAAI,CAAC,GAAGA,IAAI,CAAC3D,OAAO,CAAC,CAACmD,IAAI,CAAC,EAAE,CAAC,GAC9E,GAAG;AAME,MAAMS,iBAAiB,GAAA,WAAA,GAAyChE,cAAc,CAAC,iBAAiB,CAAC;AAMlG,MAAOiE,IAAI;IAEJP,IAAA,CAAA;IACA5F,WAAA,CAAA;IAFX0B,YACWkE,IAAS,EACT5F,WAAA,GAA2B,CAAA,CAAE,CAAA;QAD7B,IAAA,CAAA4F,IAAI,GAAJA,IAAI;QACJ,IAAA,CAAA5F,WAAW,GAAXA,WAAW;IACnB;IACH;;MAGA8B,MAAMA,CAAA,EAAA;QACJ,OAAO;YACL8D,IAAI,EAAE,IAAI,CAACA,IAAI,CAAC9D,MAAM,EAAE;YACxB9B,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;IACA;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOc,MAAM,CAAC,IAAI,CAACmD,IAAI,CAAC;IAC1B;;AAOI,MAAOQ,YAAa,SAAQD,IAAI;IAGzBE,UAAA,CAAA;IAFX3E,YACEkE,IAAS,EACAS,UAAmB,EAC5BrG,WAAA,GAA2B,CAAA,CAAE,CAAA;QAE7B,KAAK,CAAC4F,IAAI,EAAE5F,WAAW,CAAC;QAHf,IAAA,CAAAqG,UAAU,GAAVA,UAAU;IAIrB;IACA;;MAGAvE,MAAMA,CAAA,EAAA;QACJ,OAAO;YACL8D,IAAI,EAAE,IAAI,CAACA,IAAI,CAAC9D,MAAM,EAAE;YACxBuE,UAAU,EAAE,IAAI,CAACA,UAAU;YAC3BrG,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;IACA;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAOc,MAAM,CAAC,IAAI,CAACmD,IAAI,CAAC,GAAA,CAAI,IAAI,CAACS,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC;IACzD;;AAGF,MAAMC,WAAW,IAAIC,IAAyB,GAAyBA,IAAI,CAACxE,GAAG,EAAEyE,YAAY,GAAKA,YAAY,CAACZ,IAAI,CAAC;AAM9G,MAAOa,SAAS;IAMTC,QAAA,CAAA;IACAH,IAAA,CAAA;IACAI,UAAA,CAAA;IACA3G,WAAA,CAAA;IARX;;MAGSyB,IAAI,GAAG,WAAW,CAAA;IAC3BC,YACWgF,QAAqC,EACrCH,IAAyB,EACzBI,UAAmB,EACnB3G,WAAA,GAA2B,CAAA,CAAE,CAAA;QAH7B,IAAA,CAAA0G,QAAQ,GAARA,QAAQ;QACR,IAAA,CAAAH,IAAI,GAAJA,IAAI;QACJ,IAAA,CAAAI,UAAU,GAAVA,UAAU;QACV,IAAA,CAAA3G,WAAW,GAAXA,WAAW;QAEpB,IAAI4G,kBAAkB,GAAG,KAAK;QAC9B,IAAIC,yBAAyB,GAAG,KAAK;QACrC,KAAK,MAAMC,CAAC,IAAIJ,QAAQ,CAAE;YACxB,IAAII,CAAC,CAACT,UAAU,EAAE;gBAChBO,kBAAkB,GAAG,IAAI;YAC3B,CAAC,MAAM,IAAIA,kBAAkB,EAAE;gBAC7BC,yBAAyB,GAAG,IAAI;gBAChC;YACF;QACF;QACA,IAAIA,yBAAyB,IAAKD,kBAAkB,IAAIL,IAAI,CAACnB,MAAM,GAAG,CAAE,EAAE;YACxE,MAAM,IAAI2B,KAAK,CAAC3I,OAAO,CAAC4I,iRAA0D,CAAC;QACrF;IACF;IACA;;MAGArF,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CAACC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAMoF,WAAW,CAAC,IAAI,CAAC,CAAC;IACrE;IACA;;MAGAnF,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfiF,QAAQ,EAAE,IAAI,CAACA,QAAQ,CAAC3E,GAAG,EAAE+E,CAAC,GAAKA,CAAC,CAAChF,MAAM,EAAE,CAAC;YAC9CyE,IAAI,EAAE,IAAI,CAACA,IAAI,CAACxE,GAAG,EAAEC,GAAG,GAAKA,GAAG,CAACF,MAAM,EAAE,CAAC;YAC1C6E,UAAU,EAAE,IAAI,CAACA,UAAU;YAC3B3G,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAGF,MAAMiH,WAAW,IAAIjF,GAAc,IAAY;IAC7C,MAAMkF,iBAAiB,GAAGlF,GAAG,CAAC0E,QAAQ,CAAC3E,GAAG,CAACU,MAAM,CAAC,CAC/CgD,IAAI,CAAC,IAAI,CAAC;IACb,OAAO9H,GAAG,CAACwJ,0JAAS,CAACnF,GAAG,CAACuE,IAAI,EAAE;QAC7Ba,OAAO,EAAEA,CAAA,GAAM,CAAA,UAAA,EAAaF,iBAAiB,CAAA,CAAA,CAAG;QAChDG,UAAU,EAAEA,CAACvB,IAAI,EAAEwB,IAAI,KAAI;YACzB,MAAMC,aAAa,GAAG9E,MAAM,CAACqD,IAAI,CAAC;YAClC,MAAM0B,WAAW,GAAGD,aAAa,CAACE,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAA,CAAA,EAAIF,aAAa,CAAA,CAAA,CAAG,GAAGA,aAAa;YAExF,IAAID,IAAI,CAAClC,MAAM,GAAG,CAAC,EAAE;gBACnB,MAAMsC,aAAa,GAAGJ,IAAI,CAACvF,GAAG,CAACU,MAAM,CAAC,CAACgD,IAAI,CAAC,IAAI,CAAC;gBACjD,IAAIzD,GAAG,CAAC0E,QAAQ,CAACtB,MAAM,GAAG,CAAC,EAAE;oBAC3B,OAAO,CAAA,UAAA,EAAa8B,iBAAiB,CAAA,KAAA,EAAQM,WAAW,CAAA,IAAA,EAAOE,aAAa,CAAA,CAAA,CAAG;gBACjF,CAAC,MAAM;oBACL,OAAO,CAAA,aAAA,EAAgBF,WAAW,CAAA,IAAA,EAAOE,aAAa,CAAA,CAAA,CAAG;gBAC3D;YACF,CAAC,MAAM;gBACL,IAAI1F,GAAG,CAAC0E,QAAQ,CAACtB,MAAM,GAAG,CAAC,EAAE;oBAC3B,OAAO,CAAA,UAAA,EAAa8B,iBAAiB,CAAA,KAAA,EAAQM,WAAW,CAAA,GAAA,CAAK;gBAC/D,CAAC,MAAM;oBACL,OAAO,CAAA,cAAA,EAAiBD,aAAa,CAAA,CAAA,CAAG;gBAC1C;YACF;QACF;KACD,CAAC;AACJ,CAAC;AAMM,MAAMI,WAAW,GAAA,WAAA,GAAmCzF,cAAc,CAAC,WAAW,CAAC;AAMhF,MAAO0F,iBAAkB,SAAQxB,YAAY;IAEtCyB,IAAA,CAAA;IAGAlB,UAAA,CAAA;IAJXjF,YACWmG,IAAiB,EAC1BjC,IAAS,EACTS,UAAmB,EACVM,UAAmB,EAC5B3G,WAAyB,CAAA;QAEzB,KAAK,CAAC4F,IAAI,EAAES,UAAU,EAAErG,WAAW,CAAC;QAN3B,IAAA,CAAA6H,IAAI,GAAJA,IAAI;QAGJ,IAAA,CAAAlB,UAAU,GAAVA,UAAU;IAIrB;IACA;;MAGAhF,QAAQA,CAAA,EAAA;QACN,OAAO,CAAC,IAAI,CAACgF,UAAU,GAAG,WAAW,GAAG,EAAE,IAAIlE,MAAM,CAAC,IAAI,CAACoF,IAAI,CAAC,GAAA,CAAI,IAAI,CAACxB,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI,GACnG,IAAI,CAACT,IAAI;IACb;IACA;;MAGA9D,MAAMA,CAAA,EAAA;QACJ,OAAO;YACL+F,IAAI,EAAEpF,MAAM,CAAC,IAAI,CAACoF,IAAI,CAAC;YACvBjC,IAAI,EAAE,IAAI,CAACA,IAAI,CAAC9D,MAAM,EAAE;YACxBuE,UAAU,EAAE,IAAI,CAACA,UAAU;YAC3BM,UAAU,EAAE,IAAI,CAACA,UAAU;YAC3B3G,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAWK,MAAM8H,WAAW,IAAI9F,GAAQ,IAAsB;IACxD,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,eAAe;QACpB,KAAK,eAAe;QACpB,KAAK,iBAAiB;YACpB,OAAO,IAAI;QACb,KAAK,YAAY;YACf,OAAOqG,WAAW,CAAC9F,GAAG,CAAC+F,IAAI,CAAC;IAChC;IACA,OAAO,KAAK;AACd,CAAC;AAMK,MAAOC,cAAc;IAOdpC,IAAA,CAAA;IACAe,UAAA,CAAA;IAPX;;MAGSsB,SAAS,CAAA;IAClBvG,YACEuG,SAAc,EACLrC,IAAS,EACTe,UAAmB,CAAA;QADnB,IAAA,CAAAf,IAAI,GAAJA,IAAI;QACJ,IAAA,CAAAe,UAAU,GAAVA,UAAU;QAEnB,IAAImB,WAAW,CAACG,SAAS,CAAC,EAAE;YAC1B,IAAI,CAACA,SAAS,GAAGA,SAAS;QAC5B,CAAC,MAAM;YACL,MAAM,IAAIlB,KAAK,CAAC3I,OAAO,CAAC8J,gQAAyC,CAAC;QACpE;IACF;IACA;;MAGAvG,QAAQA,CAAA,EAAA;QACN,OAAO,CAAC,IAAI,CAACgF,UAAU,GAAG,WAAW,GAAG,EAAE,IAAI,CAAA,IAAA,EAAO,IAAI,CAACsB,SAAS,CAAA,GAAA,EAAM,IAAI,CAACrC,IAAI,EAAE;IACtF;IACA;;MAGA9D,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLmG,SAAS,EAAE,IAAI,CAACA,SAAS,CAACnG,MAAM,EAAE;YAClC8D,IAAI,EAAE,IAAI,CAACA,IAAI,CAAC9D,MAAM,EAAE;YACxB6E,UAAU,EAAE,IAAI,CAACA,UAAAA;SAClB;IACH;;AAOI,MAAOwB,WAAW;IAgBXnI,WAAA,CAAA;IAfX;;MAGSyB,IAAI,GAAG,aAAa,CAAA;IAC7B;;MAGS2G,kBAAkB,CAAA;IAC3B;;MAGSC,eAAe,CAAA;IACxB3G,YACE0G,kBAAoD,EACpDC,eAA8C,EACrCrI,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA7B,IAAA,CAAAA,WAAW,GAAXA,WAAW;QAEpB,0CAAA;QACA,MAAMsI,IAAI,GAA8B,CAAA,CAAE;QAC1C,IAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,kBAAkB,CAAChD,MAAM,EAAEmD,CAAC,EAAE,CAAE;YAClD,MAAMV,IAAI,GAAGO,kBAAkB,CAACG,CAAC,CAAC,CAACV,IAAI;YACvC,IAAIjI,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACuI,IAAI,EAAET,IAAI,CAAC,EAAE;gBACpD,MAAM,IAAId,KAAK,CAAC3I,OAAO,CAACoK,mQAA4C,CAACX,IAAI,CAAC,CAAC;YAC7E;YACAS,IAAI,CAACT,IAAI,CAAC,GAAG,IAAI;QACnB;QACA,uCAAA;QACA,MAAMY,UAAU,GAAG;YACjBC,MAAM,EAAE,KAAK;YACb5F,MAAM,EAAE;SACT;QACD,IAAK,IAAIyF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,eAAe,CAACjD,MAAM,EAAEmD,CAAC,EAAE,CAAE;YAC/C,MAAMN,SAAS,GAAGU,gBAAgB,CAACN,eAAe,CAACE,CAAC,CAAC,CAACN,SAAS,CAAC;YAChE,IAAI/D,eAAe,CAAC+D,SAAS,CAAC,EAAE;gBAC9B,IAAIQ,UAAU,CAACC,MAAM,EAAE;oBACrB,MAAM,IAAI3B,KAAK,CAAC3I,OAAO,CAACwK,gQAAyC,CAAC,QAAQ,CAAC,CAAC;gBAC9E;gBACAH,UAAU,CAACC,MAAM,GAAG,IAAI;YAC1B,CAAC,MAAM,IAAI5D,eAAe,CAACmD,SAAS,CAAC,EAAE;gBACrC,IAAIQ,UAAU,CAAC3F,MAAM,EAAE;oBACrB,MAAM,IAAIiE,KAAK,CAAC3I,OAAO,CAACwK,gQAAyC,CAAC,QAAQ,CAAC,CAAC;gBAC9E;gBACAH,UAAU,CAAC3F,MAAM,GAAG,IAAI;YAC1B;QACF;QAEA,IAAI,CAACsF,kBAAkB,GAAGS,sBAAsB,CAACT,kBAAkB,CAAC;QACpE,IAAI,CAACC,eAAe,GAAGS,mBAAmB,CAACT,eAAe,CAAC;IAC7D;IACA;;MAGA1G,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CAACC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAMkH,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC3E;IACA;;MAGAjH,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACf2G,kBAAkB,EAAE,IAAI,CAACA,kBAAkB,CAACrG,GAAG,EAAEiH,EAAE,GAAKA,EAAE,CAAClH,MAAM,EAAE,CAAC;YACpEuG,eAAe,EAAE,IAAI,CAACA,eAAe,CAACtG,GAAG,EAAEiH,EAAE,GAAKA,EAAE,CAAClH,MAAM,EAAE,CAAC;YAC9D9B,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAGF,MAAMiJ,qBAAqB,IAAIC,GAAkC,GAAaA,GAAG,CAACnH,GAAG,CAACU,MAAM,CAAC,CAACgD,IAAI,CAAC,IAAI,CAAC;AAExG,MAAMsD,iBAAiB,IAAI/G,GAAgB,IAAY;IACrD,IAAIA,GAAG,CAACoG,kBAAkB,CAAChD,MAAM,GAAG,CAAC,EAAE;QACrC,MAAM+D,GAAG,GAAGnH,GAAG,CAACoG,kBAAkB,CAACrG,GAAG,CAACU,MAAM,CAAC,CAACgD,IAAI,CAAC,IAAI,CAAC;QACzD,IAAIzD,GAAG,CAACqG,eAAe,CAACjD,MAAM,GAAG,CAAC,EAAE;YAClC,OAAO,CAAA,EAAA,EAAK+D,GAAG,CAAA,EAAA,EAAKF,qBAAqB,CAACjH,GAAG,CAACqG,eAAe,CAAC,CAAA,EAAA,CAAI;QACpE,CAAC,MAAM;YACL,OAAO,CAAA,EAAA,EAAKc,GAAG,CAAA,EAAA,CAAI;QACrB;IACF,CAAC,MAAM;QACL,IAAInH,GAAG,CAACqG,eAAe,CAACjD,MAAM,GAAG,CAAC,EAAE;YAClC,OAAO,CAAA,EAAA,EAAK6D,qBAAqB,CAACjH,GAAG,CAACqG,eAAe,CAAC,CAAA,EAAA,CAAI;QAC5D,CAAC,MAAM;YACL,OAAO,IAAI;QACb;IACF;AACF,CAAC;AAMM,MAAMe,aAAa,GAAA,WAAA,GAAqClH,cAAc,CAAC,aAAa,CAAC;AAO5F,MAAMmH,YAAY,IAAIC,UAA8B,GAAiBA,UAAU,CAACC,MAAM,EAAEvH,GAAG,GAAK,CAAA,CAAEA,GAAG,KAAKwB,YAAY,CAAC,CAAC;AAExH,MAAMgG,cAAc,GAAA,WAAA,GAAG7L,GAAG,CAAC8L,qJAAI,CAAA,WAAA,GAC7BxL,KAAK,CAACyL,uJAAQ,CAAC3L,MAAM,CAACE,oJAAK,GAAG+D,GAAQ,IAAI;IACxC,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,YAAY;YACf,OAAO,CAAC;QACV,KAAK,gBAAgB;YACnB,OAAO,CAAC;QACV,KAAK,eAAe;YAClB,OAAO,CAAC;QACV,KAAK,eAAe;QACpB,KAAK,eAAe;QACpB,KAAK,gBAAgB;QACrB,KAAK,eAAe;QACpB,KAAK,eAAe;YAClB,OAAO,CAAC;IACZ;IACA,OAAO,CAAC;AACV,CAAC,CAAC,CACH;AAED,MAAMkI,UAAU,GAAG;IACjBjB,MAAM,EAAE,eAAe;IACvBkB,MAAM,EAAE,eAAe;IACvBC,OAAO,EAAE,gBAAgB;IACzBC,MAAM,EAAE;CACA;AAGH,MAAMC,OAAO,IAAIT,UAA8B,GACpD3L,GAAG,CAACqM,wJAAO,CAACV,UAAU,GAAGtH,GAAG,GAAKiI,OAAO,CAACjI,GAAG,CAAC,GAAG+H,OAAO,CAAC/H,GAAG,CAACkI,KAAK,CAAC,GAAG;YAAClI,GAAG;SAAC,CAAC;AAGtE,MAAMmI,KAAK,IAAIb,UAA8B,IAAgB;IAClE,MAAMc,EAAE,GAAGZ,cAAc,CAACF,UAAU,CAAC;IACrC,MAAMe,GAAG,GAAe,EAAE;IAC1B,MAAMC,OAAO,GAAwC,CAAA,CAAE;IACvD,MAAMC,QAAQ,GAAiC,EAAE;IACjD,KAAK,MAAMvI,GAAG,IAAIoI,EAAE,CAAE;QACpB,OAAQpI,GAAG,CAACP,IAAI;YACd,KAAK,cAAc;gBACjB;YACF,KAAK,YAAY;gBACf,OAAO;oBAACqC,UAAU;iBAAC;YACrB,KAAK,gBAAgB;gBACnB,OAAO;oBAACH,cAAc;iBAAC;YACzB,UAAA;YACA,KAAK,eAAe;YACpB,KAAK,kBAAkB;YACvB,KAAK,aAAa;YAClB,KAAK,eAAe;YACpB,KAAK,eAAe;YACpB,KAAK,gBAAgB;YACrB,KAAK,eAAe;YACpB,KAAK,eAAe;gBAAE;oBACpB,IAAI,CAAC2G,OAAO,CAACtI,GAAG,CAACP,IAAI,CAAC,EAAE;wBACtB6I,OAAO,CAACtI,GAAG,CAACP,IAAI,CAAC,GAAGO,GAAG;wBACvBqI,GAAG,CAACG,IAAI,CAACxI,GAAG,CAAC;oBACf;oBACA;gBACF;YACA,KAAK,SAAS;gBAAE;oBACd,MAAM4D,IAAI,GAAG,OAAO5D,GAAG,CAACM,OAAO;oBAC/B,OAAQsD,IAAI;wBACV,KAAK,QAAQ;wBACb,KAAK,QAAQ;wBACb,KAAK,QAAQ;wBACb,KAAK,SAAS;4BAAE;gCACd,MAAMnE,IAAI,GAAGkI,UAAU,CAAC/D,IAAI,CAAC;gCAC7B,IAAI,CAAC0E,OAAO,CAAC7I,IAAI,CAAC,IAAI,CAAC8I,QAAQ,CAAC9C,QAAQ,CAACzF,GAAG,CAACM,OAAO,CAAC,EAAE;oCACrDiI,QAAQ,CAACC,IAAI,CAACxI,GAAG,CAACM,OAAO,CAAC;oCAC1B+H,GAAG,CAACG,IAAI,CAACxI,GAAG,CAAC;gCACf;gCACA;4BACF;wBACA,OAAA;wBACA,KAAK,QAAQ;4BAAE;gCACb,IAAI,CAACuI,QAAQ,CAAC9C,QAAQ,CAACzF,GAAG,CAACM,OAAO,CAAC,EAAE;oCACnCiI,QAAQ,CAACC,IAAI,CAACxI,GAAG,CAACM,OAAO,CAAC;oCAC1B+H,GAAG,CAACG,IAAI,CAACxI,GAAG,CAAC;gCACf;gCACA;4BACF;oBACF;oBACA;gBACF;YACA,KAAK,cAAc;gBAAE;oBACnB,IAAI,CAACsI,OAAO,CAAC,eAAe,CAAC,IAAI,CAACC,QAAQ,CAAC9C,QAAQ,CAACzF,GAAG,CAACc,MAAM,CAAC,EAAE;wBAC/DyH,QAAQ,CAACC,IAAI,CAACxI,GAAG,CAACc,MAAM,CAAC;wBACzBuH,GAAG,CAACG,IAAI,CAACxI,GAAG,CAAC;oBACf;oBACA;gBACF;YACA,KAAK,WAAW;gBAAE;oBAChB,IAAI,CAACsI,OAAO,CAAC,eAAe,CAAC,EAAE;wBAC7BD,GAAG,CAACG,IAAI,CAACxI,GAAG,CAAC;oBACf;oBACA;gBACF;YACA,KAAK,aAAa;gBAAE;oBAClB,IAAIA,GAAG,CAACoG,kBAAkB,CAAChD,MAAM,KAAK,CAAC,IAAIpD,GAAG,CAACqG,eAAe,CAACjD,MAAM,KAAK,CAAC,EAAE;wBAC3E,IAAI,CAACkF,OAAO,CAAC,IAAI,CAAC,EAAE;4BAClBA,OAAO,CAAC,IAAI,CAAC,GAAGtI,GAAG;4BACnBqI,GAAG,CAACG,IAAI,CAACxI,GAAG,CAAC;wBACf;oBACF,CAAC,MAAM,IAAI,CAACsI,OAAO,CAAC,eAAe,CAAC,EAAE;wBACpCD,GAAG,CAACG,IAAI,CAACxI,GAAG,CAAC;oBACf;oBACA;gBACF;YACA;gBACEqI,GAAG,CAACG,IAAI,CAACxI,GAAG,CAAC;QACjB;IACF;IACA,OAAOqI,GAAG;AACZ,CAAC;AAMK,MAAOI,KAAK;IA8BaP,KAAA,CAAA;IAA8BlK,WAAA,CAAA;IA7B3D,OAAO0K,IAAI,GAAGA,CAACpB,UAA8B,EAAEtJ,WAAyB,KAAS;QAC/E,MAAMkK,KAAK,GAAG,EAAE;QAChB,MAAMS,IAAI,GAAG,IAAIC,GAAG,EAAO;QAC3B,IAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,UAAU,CAAClE,MAAM,EAAEmD,CAAC,EAAE,CAAE;YAC1C,MAAMvG,GAAG,GAAGsH,UAAU,CAACf,CAAC,CAAC;YACzB,IAAIvG,GAAG,KAAKwB,YAAY,IAAImH,IAAI,CAACE,GAAG,CAAC7I,GAAG,CAAC,EAAE;gBACzC;YACF;YACA2I,IAAI,CAACG,GAAG,CAAC9I,GAAG,CAAC;YACbkI,KAAK,CAACM,IAAI,CAACxI,GAAG,CAAC;QACjB;QACA,OAAOyI,KAAK,CAACM,KAAK,CAACb,KAAK,EAAElK,WAAW,CAAC;IACxC,CAAC,CAAA;IACD,cAAA,GACA,OAAOgL,OAAO,GAAGA,CAAC1B,UAA8B,EAAEtJ,WAAyB,KAAS;QAClF,OAAOyK,KAAK,CAACM,KAAK,CAAC1B,YAAY,CAACC,UAAU,CAAC,EAAEtJ,WAAW,CAAC;IAC3D,CAAC,CAAA;IACD,cAAA,GACA,OAAOmK,KAAK,GAAGA,CAACb,UAA8B,EAAEtJ,WAAyB,KAAS;QAChF,OAAOyK,KAAK,CAACM,KAAK,CAACZ,KAAK,CAACJ,OAAO,CAACT,UAAU,CAAC,CAAC,EAAEtJ,WAAW,CAAC;IAC7D,CAAC,CAAA;IACD,cAAA,GACA,OAAO+K,KAAK,GAAGA,CAACb,KAAyB,EAAElK,WAAyB,KAAS;QAC3E,OAAOiL,SAAS,CAACf,KAAK,CAAC,GAAG,IAAIO,KAAK,CAACP,KAAK,EAAElK,WAAW,CAAC,GAAGkK,KAAK,CAAC9E,MAAM,KAAK,CAAC,GAAG8E,KAAK,CAAC,CAAC,CAAC,GAAG1G,YAAY;IACxG,CAAC,CAAA;IACD;;MAGS/B,IAAI,GAAG,OAAO,CAAA;IACvBC,YAA6BwI,KAAmB,EAAWlK,WAAA,GAA2B,CAAA,CAAE,CAAA;QAA3D,IAAA,CAAAkK,KAAK,GAALA,KAAK;QAAyB,IAAA,CAAAlK,WAAW,GAAXA,WAAW;IAAqB;IAC3F;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CACrBC,WAAW,CAAC,IAAI,CAAC,EACjB,IAAM,IAAI,CAACqI,KAAK,CAACnI,GAAG,CAACU,MAAM,CAAC,CAACgD,IAAI,CAAC,KAAK,CAAC,CACzC;IACH;IACA;;MAGA3D,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfyI,KAAK,EAAE,IAAI,CAACA,KAAK,CAACnI,GAAG,EAAEC,GAAG,GAAKA,GAAG,CAACF,MAAM,EAAE,CAAC;YAC5C9B,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAIK,MAAMkL,UAAU,GAAGA,CAAOF,OAAmB,EAAEG,CAAc,GAAiBH,OAAO,CAACjJ,GAAG,CAACoJ,CAAC,CAAQ;AAGnG,MAAMF,SAAS,IAAOG,EAAoB,GAAuBA,EAAE,CAAChG,MAAM,GAAG,CAAC;AAM9E,MAAM6E,OAAO,GAAA,WAAA,GAA+B/H,cAAc,CAAC,OAAO,CAAC;AAE1E,MAAMmJ,aAAa,GAAA,WAAA,OAAGvN,sKAAW,EAAA,WAAA,GAC/BS,MAAM,CAACC,GAAG,CAAC,kCAAkC,CAAC,EAC9C,IAAM,IAAI8M,OAAO,EAAe,CACjC;AAMK,MAAOC,OAAO;IAKGJ,CAAA,CAAA;IAAuBnL,WAAA,CAAA;IAJ5C;;MAGSyB,IAAI,GAAG,SAAS,CAAA;IACzBC,YAAqByJ,CAAY,EAAWnL,WAAA,GAA2B,CAAA,CAAE,CAAA;QAApD,IAAA,CAAAmL,CAAC,GAADA,CAAC;QAAsB,IAAA,CAAAnL,WAAW,GAAXA,WAAW;QACrD,IAAI,CAACmL,CAAC,GAAG9M,KAAK,CAACmN,mOAAY,CAACL,CAAC,CAAC;IAChC;IACA;;MAGAxJ,QAAQA,CAAA,EAAA;QACN,OAAOE,WAAW,CAAC,IAAI,CAAC,CAAC4J,IAAI,CAC3BzN,MAAM,CAAC0N,qJAAM,CAAC,IACZ1N,MAAM,CAACgM,sJAAO,CACZhM,MAAM,CAAC2N,4JAAa,CAAC,IAAI,CAACR,CAAC,CAAC,EAAE,GAC7BnJ,GAAG,GAAKH,WAAW,CAACG,GAAG,CAAC,CAC1B,CACF,EACDhE,MAAM,CAAC4D,wJAAS,CAAC,IAAM,oBAAoB,CAAC,CAC7C;IACH;IACA;;MAGAE,MAAMA,CAAA,EAAA;QACJ,MAAME,GAAG,GAAG,IAAI,CAACmJ,CAAC,EAAE;QACpB,IAAId,GAAG,GAAGgB,aAAa,CAACO,GAAG,CAAC5J,GAAG,CAAC;QAChC,IAAIqI,GAAG,EAAE;YACP,OAAOA,GAAG;QACZ;QACAgB,aAAa,CAACQ,GAAG,CAAC7J,GAAG,EAAE;YAAEP,IAAI,EAAE,IAAI,CAACA,IAAAA;QAAI,CAAE,CAAC;QAC3C4I,GAAG,GAAG;YACJ5I,IAAI,EAAE,IAAI,CAACA,IAAI;YACfO,GAAG,EAAEA,GAAG,CAACF,MAAM,EAAE;YACjB9B,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;QACDqL,aAAa,CAACQ,GAAG,CAAC7J,GAAG,EAAEqI,GAAG,CAAC;QAC3B,OAAOA,GAAG;IACZ;;AAOK,MAAMyB,SAAS,GAAA,WAAA,GAAiC5J,cAAc,CAAC,SAAS,CAAC;AAM1E,MAAO6J,UAAU;IAMVhE,IAAA,CAAA;IACAwB,MAAA,CAAA;IAKAvJ,WAAA,CAAA;IAXX;;MAGSyB,IAAI,GAAG,YAAY,CAAA;IAC5BC,YACWqG,IAAU,EACVwB,MAIqB,EACrBvJ,WAAA,GAA2B,CAAA,CAAE,CAAA;QAN7B,IAAA,CAAA+H,IAAI,GAAJA,IAAI;QACJ,IAAA,CAAAwB,MAAM,GAANA,MAAM;QAKN,IAAA,CAAAvJ,WAAW,GAAXA,WAAW;IACnB;IACH;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CAACC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAM,CAAA,EAAA,EAAK,IAAI,CAACkG,IAAI,CAAA,WAAA,CAAa,CAAC;IAC/E;IACA;;MAGAjG,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfsG,IAAI,EAAE,IAAI,CAACA,IAAI,CAACjG,MAAM,EAAE;YACxB9B,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAMgM,YAAY,GAAA,WAAA,GAAyC9J,cAAc,CAAC,YAAY,CAAC;AA2EvF,MAAM+J,kBAAkB,GAAiB,CAAA,CAAE;AAM5C,MAAOC,cAAc;IAMdnE,IAAA,CAAA;IACAoE,EAAA,CAAA;IACAC,cAAA,CAAA;IACApM,WAAA,CAAA;IARX;;MAGSyB,IAAI,GAAG,gBAAgB,CAAA;IAChCC,YACWqG,IAAS,EACToE,EAAO,EACPC,cAAkC,EAClCpM,WAAA,GAA2B,CAAA,CAAE,CAAA;QAH7B,IAAA,CAAA+H,IAAI,GAAJA,IAAI;QACJ,IAAA,CAAAoE,EAAE,GAAFA,EAAE;QACF,IAAA,CAAAC,cAAc,GAAdA,cAAc;QACd,IAAA,CAAApM,WAAW,GAAXA,WAAW;IACnB;IACH;;MAGA2B,QAAQA,CAAA,EAAA;QACN,OAAO3D,MAAM,CAAC4D,wJAAS,CACrBC,WAAW,CAAC,IAAI,CAAC,EACjB,IAAM,CAAA,CAAA,EAAIY,MAAM,CAAC,IAAI,CAACsF,IAAI,CAAC,CAAA,KAAA,EAAQtF,MAAM,CAAC,IAAI,CAAC0J,EAAE,CAAC,CAAA,CAAA,CAAG,CACtD;IACH;IACA;;MAGArK,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLL,IAAI,EAAE,IAAI,CAACA,IAAI;YACfsG,IAAI,EAAE,IAAI,CAACA,IAAI,CAACjG,MAAM,EAAE;YACxBqK,EAAE,EAAE,IAAI,CAACA,EAAE,CAACrK,MAAM,EAAE;YACpB9B,WAAW,EAAEiC,iBAAiB,CAAC,IAAI,CAACjC,WAAW;SAChD;IACH;;AAOK,MAAMqM,gBAAgB,GAAA,WAAA,GAAwCnK,cAAc,CAAC,gBAAgB,CAAC;AAe/F,MAAOoK,mBAAmB;IAMnBC,MAAA,CAAA;IACAC,MAAA,CAAA;IANX;;MAGS/K,IAAI,GAAG,qBAAqB,CAAA;IACrCC,YACW6K,MAAiG,EACjGC,MAAiG,CAAA;QADjG,IAAA,CAAAD,MAAM,GAANA,MAAM;QACN,IAAA,CAAAC,MAAM,GAANA,MAAM;IACd;;AAGL,MAAMC,yBAAyB,IACUtK,GAAM,IAC5CH,GAAuB,GAAsDA,GAAG,CAACP,IAAI,KAAKU,GAAG;AAMzF,MAAMuK,qBAAqB,GAAA,WAAA,GAA4DD,yBAAyB,CACrH,qBAAqB,CACtB;AAMK,MAAOE,qBAAqB;IAChC;;MAGSlL,IAAI,GAAG,uBAAuB,CAAA;;AAOlC,MAAMmL,qBAAqB,GAAA,WAAA,GAA0B,IAAID,qBAAqB,EAAE;AAMhF,MAAME,uBAAuB,GAAA,WAAA,GAClCJ,yBAAyB,CACvB,uBAAuB,CACxB;AAgBG,MAAOK,+BAA+B;IAE/B/E,IAAA,CAAA;IACAoE,EAAA,CAAA;IACAI,MAAA,CAAA;IACAC,MAAA,CAAA;IAJX9K,YACWqG,IAAiB,EACjBoE,EAAe,EACfI,MAAqD,EACrDC,MAAqD,CAAA;QAHrD,IAAA,CAAAzE,IAAI,GAAJA,IAAI;QACJ,IAAA,CAAAoE,EAAE,GAAFA,EAAE;QACF,IAAA,CAAAI,MAAM,GAANA,MAAM;QACN,IAAA,CAAAC,MAAM,GAANA,MAAM;IACd;;AAGL,MAAMO,yCAAyC,IAAIC,CAAkC,GACnFA,CAAC,CAACT,MAAM,KAAK1O,gKAAQ,IAAImP,CAAC,CAACR,MAAM,KAAK3O,gKAAQ;AAM1C,MAAOoP,yBAAyB;IAMzBC,gCAAA,CAAA;IALX;;MAGSzL,IAAI,GAAG,2BAA2B,CAAA;IAC3CC,YACWwL,gCAER,CAAA;QAFQ,IAAA,CAAAA,gCAAgC,GAAhCA,gCAAgC;QAIzC,yDAAA;QACA,MAAMC,QAAQ,GAA8B,CAAA,CAAE;QAC9C,MAAMC,MAAM,GAA8B,CAAA,CAAE;QAC5C,KAAK,MAAMC,GAAG,IAAIH,gCAAgC,CAAE;YAClD,MAAMnF,IAAI,GAAGsF,GAAG,CAACtF,IAAI;YACrB,IAAIoF,QAAQ,CAACpF,IAAI,CAAC,EAAE;gBAClB,MAAM,IAAIhB,KAAK,CAAC3I,OAAO,CAACkP,iRAA0D,CAACvF,IAAI,CAAC,CAAC;YAC3F;YACAoF,QAAQ,CAACpF,IAAI,CAAC,GAAG,IAAI;YACrB,MAAMoE,EAAE,GAAGkB,GAAG,CAAClB,EAAE;YACjB,IAAIiB,MAAM,CAACjB,EAAE,CAAC,EAAE;gBACd,MAAM,IAAIpF,KAAK,CAAC3I,OAAO,CAACkP,iRAA0D,CAACnB,EAAE,CAAC,CAAC;YACzF;YACAiB,MAAM,CAACjB,EAAE,CAAC,GAAG,IAAI;QACnB;IACF;;AAOK,MAAMoB,2BAA2B,GAAA,WAAA,GACtCd,yBAAyB,CAAC,2BAA2B,CAAC;AAWjD,MAAMzM,WAAW,GAAGA,CAACgC,GAAQ,EAAEhC,WAAwB,KAAS;IACrE,MAAMwN,CAAC,GAAG5N,MAAM,CAAC6N,yBAAyB,CAACzL,GAAG,CAAC;IAC/CwL,CAAC,CAACxN,WAAW,CAACsF,KAAK,GAAG;QAAE,GAAGtD,GAAG,CAAChC,WAAW;QAAE,GAAGA,WAAAA;IAAW,CAAE;IAC5D,OAAOJ,MAAM,CAAC8N,MAAM,CAAC9N,MAAM,CAAC+N,cAAc,CAAC3L,GAAG,CAAC,EAAEwL,CAAC,CAAC;AACrD,CAAC;AAOM,MAAMI,KAAK,IAAI5L,GAAQ,GAAUyI,KAAK,CAACN,KAAK,CAAC0D,MAAM,CAAC7L,GAAG,CAAC,CAAC;AAEhE,MAAM8L,sBAAsB,GAAG,IAAI;AACnC,MAAMC,sBAAsB,GAAG,qCAAqC;AAK7D,MAAMC,wBAAwB,IAAIhM,GAAoB,IAAY;IACvE,IAAIiM,OAAO,GAAG,CAAA,CAAA,EAAI9P,MAAM,CAAC+P,qJAAM,CAAClM,GAAG,CAAC8D,IAAI,CAAC,EAAE;IAE3C,KAAK,MAAMG,IAAI,IAAIjE,GAAG,CAAC+D,KAAK,CAAE;QAC5B,IAAI7B,eAAe,CAAC+B,IAAI,CAACL,IAAI,CAAC,EAAE;YAC9BqI,OAAO,IAAIH,sBAAsB;QACnC,CAAC,MAAM,IAAIzJ,eAAe,CAAC4B,IAAI,CAACL,IAAI,CAAC,EAAE;YACrCqI,OAAO,IAAIF,sBAAsB;QACnC;QACAE,OAAO,IAAI9P,MAAM,CAAC+P,qJAAM,CAACjI,IAAI,CAAC3D,OAAO,CAAC;IACxC;IAEA2L,OAAO,IAAI,GAAG;IACd,OAAO,IAAIE,MAAM,CAACF,OAAO,CAAC;AAC5B,CAAC;AAKM,MAAMG,qBAAqB,IAAIpM,GAAQ,IAA8B;IAC1E,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,aAAa;YAAE;gBAClB,MAAM4M,UAAU,GAAGpN,sBAAsB,CAACe,GAAG,CAAC;gBAC9C,IAAIhE,MAAM,CAACsQ,qJAAM,CAACD,UAAU,CAAC,EAAE;oBAC7B,OAAOD,qBAAqB,CAACC,UAAU,CAAC/I,KAAK,CAAC;gBAChD;gBACA;YACF;QACA,KAAK,aAAa;YAChB,OAAOtD,GAAG,CAACoG,kBAAkB,CAACmG,KAAK,EAAE;QACvC,KAAK,SAAS;YACZ,OAAOH,qBAAqB,CAACpM,GAAG,CAACmJ,CAAC,EAAE,CAAC;IACzC;IACA,OAAOqD,eAAe,CAACxM,GAAG,CAAC,CAACD,GAAG,EAAE8F,IAAI,GAAK4G,2BAA2B,CAACzM,GAAG,EAAE6F,IAAI,CAAC,CAAC;AACnF,CAAC;AAGM,MAAM6G,sBAAsB,IAAI1M,GAAQ,IAAS;IACtD,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,WAAW;YAAE;gBAChB,IAAIkN,WAAW,GAAG,KAAK;gBACvB,IAAItE,GAAG,GAAe,EAAE;gBACxB,KAAK,MAAMvD,CAAC,IAAI9E,GAAG,CAAC0E,QAAQ,CAAE;oBAC5B,IAAII,CAAC,CAACT,UAAU,EAAE;wBAChBsI,WAAW,GAAG,IAAI;oBACpB;oBACAtE,GAAG,CAACG,IAAI,CAAC1D,CAAC,CAAClB,IAAI,CAAC;gBAClB;gBACA,IAAI+I,WAAW,EAAE;oBACftE,GAAG,CAACG,IAAI,CAACtH,gBAAgB,CAAC;gBAC5B;gBACAmH,GAAG,GAAGA,GAAG,CAACuE,MAAM,CAACtI,WAAW,CAACtE,GAAG,CAACuE,IAAI,CAAC,CAAC;gBACvC,OAAOkE,KAAK,CAACC,IAAI,CAACL,GAAG,CAAC;YACxB;QACA,KAAK,YAAY;YACf,OAAOqE,sBAAsB,CAAC1M,GAAG,CAAC+F,IAAI,CAAC;QACzC,KAAK,OAAO;YACV,OAAO0C,KAAK,CAACC,IAAI,CAAC1I,GAAG,CAACkI,KAAK,CAACnI,GAAG,CAAC2M,sBAAsB,CAAC,CAAC;QAC1D,KAAK,SAAS;YACZ,OAAOA,sBAAsB,CAAC1M,GAAG,CAACmJ,CAAC,EAAE,CAAC;IAC1C;IACA,MAAM,IAAIpE,KAAK,CAAC3I,OAAO,CAACyQ,8OAAuB,CAAC7M,GAAG,CAAC,CAAC;AACvD,CAAC;AAGM,MAAMyM,2BAA2B,GAAGA,CAACzM,GAAQ,EAAE6F,IAAiB,KAAuB;IAC5F,OAAQ7F,GAAG,CAACP,IAAI;QACd,KAAK,aAAa;YAAE;gBAClB,MAAM4M,UAAU,GAAGpN,sBAAsB,CAACe,GAAG,CAAC;gBAC9C,IAAIhE,MAAM,CAACsQ,qJAAM,CAACD,UAAU,CAAC,EAAE;oBAC7B,OAAOI,2BAA2B,CAACJ,UAAU,CAAC/I,KAAK,EAAEuC,IAAI,CAAC;gBAC5D;gBACA;YACF;QACA,KAAK,aAAa;YAAE;gBAClB,MAAMiH,GAAG,GAAGnR,GAAG,CAACoR,0JAAS,CAAC/M,GAAG,CAACoG,kBAAkB,GAAGY,EAAE,GAAKA,EAAE,CAACnB,IAAI,KAAKA,IAAI,CAAC;gBAC3E,IAAI7J,MAAM,CAACsQ,qJAAM,CAACQ,GAAG,CAAC,EAAE;oBACtB,OAAOA,GAAG,CAACxJ,KAAK;gBAClB,CAAC,MAAM;oBACL,IAAIpH,SAAS,CAAC8Q,uJAAQ,CAACnH,IAAI,CAAC,EAAE;wBAC5B,KAAK,MAAMoH,EAAE,IAAIjN,GAAG,CAACqG,eAAe,CAAE;4BACpC,MAAM6G,aAAa,GAAGvG,gBAAgB,CAACsG,EAAE,CAAChH,SAAS,CAAC;4BACpD,OAAQiH,aAAa,CAACzN,IAAI;gCACxB,KAAK,iBAAiB;oCAAE;wCACtB,MAAM0N,KAAK,GAAGnB,wBAAwB,CAACkB,aAAa,CAAC;wCACrD,IAAIC,KAAK,CAACC,IAAI,CAACvH,IAAI,CAAC,EAAE;4CACpB,OAAO,IAAID,iBAAiB,CAACC,IAAI,EAAEoH,EAAE,CAACrJ,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;wCAC1D;wCACA;oCACF;gCACA,KAAK,eAAe;oCAClB,OAAO,IAAIgC,iBAAiB,CAACC,IAAI,EAAEoH,EAAE,CAACrJ,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;4BAC5D;wBACF;oBACF,CAAC,MAAM,IAAI1H,SAAS,CAACmR,uJAAQ,CAACxH,IAAI,CAAC,EAAE;wBACnC,KAAK,MAAMoH,EAAE,IAAIjN,GAAG,CAACqG,eAAe,CAAE;4BACpC,MAAM6G,aAAa,GAAGvG,gBAAgB,CAACsG,EAAE,CAAChH,SAAS,CAAC;4BACpD,IAAInD,eAAe,CAACoK,aAAa,CAAC,EAAE;gCAClC,OAAO,IAAItH,iBAAiB,CAACC,IAAI,EAAEoH,EAAE,CAACrJ,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;4BAC1D;wBACF;oBACF;gBACF;gBACA;YACF;QACA,KAAK,OAAO;YACV,OAAO,IAAIgC,iBAAiB,CAC1BC,IAAI,EACJ4C,KAAK,CAACC,IAAI,CAAC1I,GAAG,CAACkI,KAAK,CAACnI,GAAG,EAAEC,GAAG,GAAKyM,2BAA2B,CAACzM,GAAG,EAAE6F,IAAI,CAAC,CAACjC,IAAI,CAAC,CAAC,EAC/E,KAAK,EACL,IAAI,CACL;QACH,KAAK,SAAS;YACZ,OAAO6I,2BAA2B,CAACzM,GAAG,CAACmJ,CAAC,EAAE,EAAEtD,IAAI,CAAC;IACrD;IACA,OAAO,IAAID,iBAAiB,CAACC,IAAI,EAAErE,YAAY,EAAE,KAAK,EAAE,IAAI,CAAC;AAC/D,CAAC;AAED,MAAMgL,eAAe,IAAIxM,GAAQ,IAAwB;IACvD,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,aAAa;YAAE;gBAClB,MAAM4M,UAAU,GAAGpN,sBAAsB,CAACe,GAAG,CAAC;gBAC9C,IAAIhE,MAAM,CAACsQ,qJAAM,CAACD,UAAU,CAAC,EAAE;oBAC7B,OAAOG,eAAe,CAACH,UAAU,CAAC/I,KAAK,CAAC;gBAC1C;gBACA;YACF;QACA,KAAK,aAAa;YAChB,OAAOtD,GAAG,CAACoG,kBAAkB,CAACrG,GAAG,EAAEiH,EAAE,GAAKA,EAAE,CAACnB,IAAI,CAAC;QACpD,KAAK,SAAS;YACZ,OAAO2G,eAAe,CAACxM,GAAG,CAACmJ,CAAC,EAAE,CAAC;QACjC,KAAK,OAAO;YACV,OAAOnJ,GAAG,CAACkI,KAAK,CAACqE,KAAK,CAAC,CAAC,CAAC,CAACe,MAAM,CAC9B,CAACjF,GAAuB,EAAErI,GAAG,GAAKrE,GAAG,CAAC4R,6JAAY,CAAClF,GAAG,EAAEmE,eAAe,CAACxM,GAAG,CAAC,CAAC,EAC7EwM,eAAe,CAACxM,GAAG,CAACkI,KAAK,CAAC,CAAC,CAAC,CAAC,CAC9B;QACH,KAAK,gBAAgB;YACnB,OAAOsE,eAAe,CAACxM,GAAG,CAACmK,EAAE,CAAC;IAClC;IACA,OAAO,EAAE;AACX,CAAC;AAGM,MAAMqD,MAAM,GAAGA,CAAC7P,GAAQ,EAAE2F,KAAU,KAGvC;IACF,MAAM8C,kBAAkB,GAA6B,EAAE;IACvD,MAAMC,eAAe,GAA0B,EAAE;IACjD,MAAMoH,EAAE,IAAI9P,GAAQ,IAAU;QAC5B,OAAQA,GAAG,CAAC8B,IAAI;YACd,KAAK,cAAc;gBACjB;YACF,KAAK,eAAe;YACpB,KAAK,eAAe;YACpB,KAAK,iBAAiB;YACtB,KAAK,YAAY;gBACf4G,eAAe,CAACmC,IAAI,CAAC,IAAIxC,cAAc,CAACrI,GAAG,EAAE2F,KAAK,EAAE,IAAI,CAAC,CAAC;gBAC1D;YACF,KAAK,SAAS;gBACZ,IAAIpH,SAAS,CAAC8Q,uJAAQ,CAACrP,GAAG,CAAC2C,OAAO,CAAC,IAAIpE,SAAS,CAACwR,uJAAQ,CAAC/P,GAAG,CAAC2C,OAAO,CAAC,EAAE;oBACtE8F,kBAAkB,CAACoC,IAAI,CAAC,IAAI5C,iBAAiB,CAACjI,GAAG,CAAC2C,OAAO,EAAEgD,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;gBACjF,CAAC,MAAM;oBACL,MAAM,IAAIyB,KAAK,CAAC3I,OAAO,CAACuR,+OAAwB,CAAChQ,GAAG,CAAC2C,OAAO,CAAC,CAAC;gBAChE;gBACA;YACF,KAAK,OAAO;gBAAE;oBACZ,KAAK,MAAM,CAAC+C,CAAC,EAAEwC,IAAI,CAAC,IAAIlI,GAAG,CAACwF,KAAK,CAAE;wBACjCiD,kBAAkB,CAACoC,IAAI,CAAC,IAAI5C,iBAAiB,CAACC,IAAI,EAAEvC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;oBAC1E;oBACA;gBACF;YACA,KAAK,cAAc;gBACjB8C,kBAAkB,CAACoC,IAAI,CAAC,IAAI5C,iBAAiB,CAACjI,GAAG,CAACmD,MAAM,EAAEwC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;gBAC9E;YACF,KAAK,OAAO;gBACV3F,GAAG,CAACuK,KAAK,CAAC0F,OAAO,CAACH,EAAE,CAAC;gBACrB;YACF;gBACE,MAAM,IAAI1I,KAAK,CAAC3I,OAAO,CAACyR,iPAA0B,CAAClQ,GAAG,CAAC,CAAC;QAC5D;IACF,CAAC;IACD8P,EAAE,CAAC9P,GAAG,CAAC;IACP,OAAO;QAAEyI,kBAAkB;QAAEC;IAAe,CAAE;AAChD,CAAC;AAOM,MAAMyH,IAAI,GAAGA,CAAC9N,GAAQ,EAAEsG,IAAgC,KAAkC;IAC/F,IAAI+D,gBAAgB,CAACrK,GAAG,CAAC,EAAE;QACzB,OAAQA,GAAG,CAACoK,cAAc,CAAC3K,IAAI;YAC7B,KAAK,uBAAuB;gBAC1B,OAAO,IAAIyK,cAAc,CACvB4D,IAAI,CAAC9N,GAAG,CAAC+F,IAAI,EAAEO,IAAI,CAAC,EACpBwH,IAAI,CAAC9N,GAAG,CAACmK,EAAE,EAAE7D,IAAI,CAAC,EAClBsE,qBAAqB,CACtB;YACH,KAAK,2BAA2B;gBAAE;oBAChC,MAAMmD,EAAE,GAA2C,EAAE;oBACrD,MAAM5C,QAAQ,GAAuB,EAAE;oBACvC,KAAK,MAAM6C,CAAC,IAAI1H,IAAI,CAAE;wBACpB,MAAM0E,CAAC,GAAGhL,GAAG,CAACoK,cAAc,CAACc,gCAAgC,CAAC+C,IAAI,EAAEjD,CAAC,GAAKA,CAAC,CAACb,EAAE,KAAK6D,CAAC,CAAC;wBACrF,IAAIhD,CAAC,EAAE;4BACL+C,EAAE,CAACvF,IAAI,CAACwC,CAAC,CAAC;4BACVG,QAAQ,CAAC3C,IAAI,CAACwC,CAAC,CAACjF,IAAI,CAAC;wBACvB,CAAC,MAAM;4BACLoF,QAAQ,CAAC3C,IAAI,CAACwF,CAAC,CAAC;wBAClB;oBACF;oBACA,OAAOrS,GAAG,CAACuS,wKAAuB,CAACH,EAAE,CAAC,GACpC,IAAI7D,cAAc,CAChB4D,IAAI,CAAC9N,GAAG,CAAC+F,IAAI,EAAEoF,QAAQ,CAAC,EACxB2C,IAAI,CAAC9N,GAAG,CAACmK,EAAE,EAAE7D,IAAI,CAAC,EAClB,IAAI2E,yBAAyB,CAAC8C,EAAE,CAAC,CAClC,GACDD,IAAI,CAAC9N,GAAG,CAAC+F,IAAI,EAAEoF,QAAQ,CAAC;gBAC5B;YACA,KAAK,qBAAqB;gBAAE;oBAC1B,MAAMkB,UAAU,GAAGpN,sBAAsB,CAACe,GAAG,CAAC;oBAC9C,IAAIhE,MAAM,CAACsQ,qJAAM,CAACD,UAAU,CAAC,EAAE;wBAC7B,OAAOyB,IAAI,CAACzB,UAAU,CAAC/I,KAAK,EAAEgD,IAAI,CAAC;oBACrC;oBACA,MAAM,IAAIvB,KAAK,CAAC3I,OAAO,CAACyQ,8OAAuB,CAAC7M,GAAG,CAAC,CAAC;gBACvD;QACF;IACF;IACA,OAAO,IAAImG,WAAW,CAACG,IAAI,CAACvG,GAAG,EAAEpC,GAAG,GAAK8O,2BAA2B,CAACzM,GAAG,EAAErC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;AACtF,CAAC;AAOM,MAAMwQ,IAAI,GAAGA,CAACnO,GAAQ,EAAEsG,IAAgC,GAC7DwH,IAAI,CAAC9N,GAAG,EAAEwM,eAAe,CAACxM,GAAG,CAAC,CAACuH,MAAM,EAAE1B,IAAI,GAAK,CAACS,IAAI,CAACb,QAAQ,CAACI,IAAI,CAAC,CAAC,CAAC;AAGjE,MAAMuI,WAAW,IAAIpO,GAAQ,GAAUyI,KAAK,CAACC,IAAI,CAAC;QAAC1I,GAAG;QAAEkB,gBAAgB;KAAC,CAAC;AAO1E,MAAMmN,OAAO,GAAGA,CAACrO,GAAQ,EAAEsO,OAAkC,KAAS;IAC3E,MAAMC,KAAK,GAAGD,OAAO,EAAEC,KAAK,KAAK,IAAI;IACrC,OAAQvO,GAAG,CAACP,IAAI;QACd,KAAK,WAAW;YACd,OAAO,IAAIgF,SAAS,CAClBzE,GAAG,CAAC0E,QAAQ,CAAC3E,GAAG,EAAE+E,CAAC,GAAK,IAAIV,YAAY,CAACmK,KAAK,GAAGzJ,CAAC,CAAClB,IAAI,GAAGwK,WAAW,CAACtJ,CAAC,CAAClB,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC,EACrFjI,GAAG,CAAC6S,sJAAK,CAACxO,GAAG,CAACuE,IAAI,EAAE;gBAClBa,OAAO,EAAEA,CAAA,GAAMpF,GAAG,CAACuE,IAAI;gBACvBc,UAAU,GAAGd,IAAI,GAAK;wBAAC,IAAIJ,IAAI,CAACsE,KAAK,CAACC,IAAI,CAAC,CAAC;+BAAGpE,WAAW,CAACC,IAAI,CAAC;4BAAErD,gBAAgB;yBAAC,CAAC,CAAC;qBAAA;aACtF,CAAC,EACFlB,GAAG,CAAC2E,UAAU,CACf;QACH,KAAK,aAAa;YAChB,OAAO,IAAIwB,WAAW,CACpBnG,GAAG,CAACoG,kBAAkB,CAACrG,GAAG,EAAEiH,EAAE,GAC5B,IAAIpB,iBAAiB,CAACoB,EAAE,CAACnB,IAAI,EAAE0I,KAAK,GAAGvH,EAAE,CAACpD,IAAI,GAAGwK,WAAW,CAACpH,EAAE,CAACpD,IAAI,CAAC,EAAE,IAAI,EAAEoD,EAAE,CAACrC,UAAU,EAAEqC,EAAE,CAAChJ,WAAW,CAAC,CAC5G,EACDgC,GAAG,CAACqG,eAAe,CAACtG,GAAG,EAAEkN,EAAE,GAAK,IAAIjH,cAAc,CAACiH,EAAE,CAAChH,SAAS,EAAEmI,WAAW,CAACnB,EAAE,CAACrJ,IAAI,CAAC,EAAEqJ,EAAE,CAACtI,UAAU,CAAC,CAAC,CACvG;QACH,KAAK,OAAO;YACV,OAAO8D,KAAK,CAACC,IAAI,CAAC1I,GAAG,CAACkI,KAAK,CAACnI,GAAG,EAAE0O,MAAM,GAAKJ,OAAO,CAACI,MAAM,EAAEH,OAAO,CAAC,CAAC,CAAC;QACxE,KAAK,SAAS;YACZ,OAAO,IAAI/E,OAAO,CAAC,IAAM8E,OAAO,CAACrO,GAAG,CAACmJ,CAAC,EAAE,EAAEmF,OAAO,CAAC,CAAC;QACrD,KAAK,aAAa;YAChB,MAAM,IAAIvJ,KAAK,CAAC3I,OAAO,CAACyQ,8OAAuB,CAAC7M,GAAG,CAAC,CAAC;QACvD,KAAK,YAAY;YACf,MAAM,IAAI+E,KAAK,CAAC3I,OAAO,CAACyQ,8OAAuB,CAAC7M,GAAG,CAAC,CAAC;QACvD,KAAK,gBAAgB;YAAE;gBACrB,IACEuL,2BAA2B,CAACvL,GAAG,CAACoK,cAAc,CAAC,IAC/CpK,GAAG,CAACoK,cAAc,CAACc,gCAAgC,CAACwD,KAAK,CAAC3D,yCAAyC,CAAC,EACpG;oBACA,OAAO,IAAIb,cAAc,CAACmE,OAAO,CAACrO,GAAG,CAAC+F,IAAI,EAAEuI,OAAO,CAAC,EAAED,OAAO,CAACrO,GAAG,CAACmK,EAAE,EAAEmE,OAAO,CAAC,EAAEtO,GAAG,CAACoK,cAAc,CAAC;gBACrG;gBACA,MAAM,IAAIrF,KAAK,CAAC3I,OAAO,CAACyQ,8OAAuB,CAAC7M,GAAG,CAAC,CAAC;YACvD;IACF;IACA,OAAOA,GAAG;AACZ,CAAC;AAOM,MAAM2O,QAAQ,IAAI3O,GAAQ,IAAS;IACxC,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,WAAW;YACd,OAAO,IAAIgF,SAAS,CAClBzE,GAAG,CAAC0E,QAAQ,CAAC3E,GAAG,EAAE+E,CAAC,GAAK,IAAIV,YAAY,CAACU,CAAC,CAAClB,IAAI,EAAE,KAAK,CAAC,CAAC,EACxD5D,GAAG,CAACuE,IAAI,EACRvE,GAAG,CAAC2E,UAAU,CACf;QACH,KAAK,aAAa;YAChB,OAAO,IAAIwB,WAAW,CACpBnG,GAAG,CAACoG,kBAAkB,CAACrG,GAAG,EAAEoJ,CAAC,GAAK,IAAIvD,iBAAiB,CAACuD,CAAC,CAACtD,IAAI,EAAEsD,CAAC,CAACvF,IAAI,EAAE,KAAK,EAAEuF,CAAC,CAACxE,UAAU,EAAEwE,CAAC,CAACnL,WAAW,CAAC,CAAC,EAC5GgC,GAAG,CAACqG,eAAe,CACpB;QACH,KAAK,OAAO;YACV,OAAOoC,KAAK,CAACC,IAAI,CAAC1I,GAAG,CAACkI,KAAK,CAACnI,GAAG,EAAE0O,MAAM,GAAKE,QAAQ,CAACF,MAAM,CAAC,CAAC,CAAC;QAChE,KAAK,SAAS;YACZ,OAAO,IAAIlF,OAAO,CAAC,IAAMoF,QAAQ,CAAC3O,GAAG,CAACmJ,CAAC,EAAE,CAAC,CAAC;QAC7C,KAAK,aAAa;YAChB,MAAM,IAAIpE,KAAK,CAAC3I,OAAO,CAACyQ,8OAAuB,CAAC7M,GAAG,CAAC,CAAC;QACvD,KAAK,YAAY;YACf,MAAM,IAAI+E,KAAK,CAAC3I,OAAO,CAACyQ,8OAAuB,CAAC7M,GAAG,CAAC,CAAC;QACvD,KAAK,gBAAgB;YAAE;gBACrB,IACEuL,2BAA2B,CAACvL,GAAG,CAACoK,cAAc,CAAC,IAC/CpK,GAAG,CAACoK,cAAc,CAACc,gCAAgC,CAACwD,KAAK,CAAC3D,yCAAyC,CAAC,EACpG;oBACA,OAAO,IAAIb,cAAc,CAACyE,QAAQ,CAAC3O,GAAG,CAAC+F,IAAI,CAAC,EAAE4I,QAAQ,CAAC3O,GAAG,CAACmK,EAAE,CAAC,EAAEnK,GAAG,CAACoK,cAAc,CAAC;gBACrF;gBACA,MAAM,IAAIrF,KAAK,CAAC3I,OAAO,CAACyQ,8OAAuB,CAAC7M,GAAG,CAAC,CAAC;YACvD;IACF;IACA,OAAOA,GAAG;AACZ,CAAC;AASM,MAAM4O,OAAO,IAAI5O,GAAQ,IAAS;IACvC,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,WAAW;YACd,OAAOO,GAAG,CAAC2E,UAAU,KAAK,KAAK,GAAG3E,GAAG,GAAG,IAAIyE,SAAS,CAACzE,GAAG,CAAC0E,QAAQ,EAAE1E,GAAG,CAACuE,IAAI,EAAE,KAAK,EAAEvE,GAAG,CAAChC,WAAW,CAAC;QACvG,KAAK,aAAa;YAAE;gBAClB,MAAMoI,kBAAkB,GAAGyI,SAAS,CAClC7O,GAAG,CAACoG,kBAAkB,GACrBY,EAAE,GACDA,EAAE,CAACrC,UAAU,KAAK,KAAK,GAAGqC,EAAE,GAAG,IAAIpB,iBAAiB,CAACoB,EAAE,CAACnB,IAAI,EAAEmB,EAAE,CAACpD,IAAI,EAAEoD,EAAE,CAAC3C,UAAU,EAAE,KAAK,EAAE2C,EAAE,CAAChJ,WAAW,CAAC,CAC/G;gBACD,MAAMqI,eAAe,GAAGwI,SAAS,CAC/B7O,GAAG,CAACqG,eAAe,GAClB4G,EAAE,GAAKA,EAAE,CAACtI,UAAU,KAAK,KAAK,GAAGsI,EAAE,GAAG,IAAIjH,cAAc,CAACiH,EAAE,CAAChH,SAAS,EAAEgH,EAAE,CAACrJ,IAAI,EAAE,KAAK,CAAC,CACxF;gBACD,OAAOwC,kBAAkB,KAAKpG,GAAG,CAACoG,kBAAkB,IAAIC,eAAe,KAAKrG,GAAG,CAACqG,eAAe,GAC7FrG,GAAG,GACH,IAAImG,WAAW,CAACC,kBAAkB,EAAEC,eAAe,EAAErG,GAAG,CAAChC,WAAW,CAAC;YACzE;QACA,KAAK,OAAO;YAAE;gBACZ,MAAMkK,KAAK,GAAG2G,SAAS,CAAC7O,GAAG,CAACkI,KAAK,EAAE0G,OAAO,CAAC;gBAC3C,OAAO1G,KAAK,KAAKlI,GAAG,CAACkI,KAAK,GAAGlI,GAAG,GAAGyI,KAAK,CAACC,IAAI,CAACR,KAAK,EAAElI,GAAG,CAAChC,WAAW,CAAC;YACvE;QACA,KAAK,SAAS;YACZ,OAAO,IAAIuL,OAAO,CAAC,IAAMqF,OAAO,CAAC5O,GAAG,CAACmJ,CAAC,EAAE,CAAC,EAAEnJ,GAAG,CAAChC,WAAW,CAAC;QAC7D,KAAK,YAAY;YAAE;gBACjB,MAAM+H,IAAI,GAAG6I,OAAO,CAAC5O,GAAG,CAAC+F,IAAI,CAAC;gBAC9B,OAAOA,IAAI,KAAK/F,GAAG,CAAC+F,IAAI,GAAG/F,GAAG,GAAG,IAAI+J,UAAU,CAAChE,IAAI,EAAE/F,GAAG,CAACuH,MAAM,EAAEvH,GAAG,CAAChC,WAAW,CAAC;YACpF;QACA,KAAK,gBAAgB;YAAE;gBACrB,MAAM+H,IAAI,GAAG6I,OAAO,CAAC5O,GAAG,CAAC+F,IAAI,CAAC;gBAC9B,MAAMoE,EAAE,GAAGyE,OAAO,CAAC5O,GAAG,CAACmK,EAAE,CAAC;gBAC1B,OAAOpE,IAAI,KAAK/F,GAAG,CAAC+F,IAAI,IAAIoE,EAAE,KAAKnK,GAAG,CAACmK,EAAE,GACvCnK,GAAG,GACH,IAAIkK,cAAc,CAACnE,IAAI,EAAEoE,EAAE,EAAEnK,GAAG,CAACoK,cAAc,EAAEpK,GAAG,CAAChC,WAAW,CAAC;YACrE;IACF;IACA,OAAOgC,GAAG;AACZ,CAAC;AAqBM,MAAM8O,WAAW,IAAON,KAAe,IAAiB;IAC7D,MAAMO,OAAO,GAAGA,CAAC/O,GAAQ,EAAEgP,IAAgC,GAAQR,KAAK,CAACxO,GAAG,CAACP,IAAI,CAAC,CAACO,GAAU,EAAE+O,OAAO,EAAEC,IAAI,CAAC;IAC7G,OAAOD,OAAO;AAChB,CAAC;AAKM,MAAME,OAAO,IAAIjP,GAAQ,IAAS;IACvC,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,aAAa;YAAE;gBAClB,MAAMH,cAAc,GAAGuP,SAAS,CAAC7O,GAAG,CAACV,cAAc,EAAE2P,OAAO,CAAC;gBAC7D,OAAO3P,cAAc,KAAKU,GAAG,CAACV,cAAc,GAC1CU,GAAG,GACH,IAAIX,WAAW,CAACC,cAAc,EAAEU,GAAG,CAACT,aAAa,EAAES,GAAG,CAACR,aAAa,EAAEQ,GAAG,CAAChC,WAAW,CAAC;YAC1F;QACA,KAAK,WAAW;YAAE;gBAChB,MAAM0G,QAAQ,GAAGmK,SAAS,CAAC7O,GAAG,CAAC0E,QAAQ,GAAGI,CAAC,IAAI;oBAC7C,MAAMlB,IAAI,GAAGqL,OAAO,CAACnK,CAAC,CAAClB,IAAI,CAAC;oBAC5B,OAAOA,IAAI,KAAKkB,CAAC,CAAClB,IAAI,GAAGkB,CAAC,GAAG,IAAIV,YAAY,CAACR,IAAI,EAAEkB,CAAC,CAACT,UAAU,CAAC;gBACnE,CAAC,CAAC;gBACF,MAAM6K,QAAQ,GAAG5K,WAAW,CAACtE,GAAG,CAACuE,IAAI,CAAC;gBACtC,MAAMA,IAAI,GAAGsK,SAAS,CAACK,QAAQ,EAAED,OAAO,CAAC;gBACzC,OAAOvK,QAAQ,KAAK1E,GAAG,CAAC0E,QAAQ,IAAIH,IAAI,KAAK2K,QAAQ,GACnDlP,GAAG,GACH,IAAIyE,SAAS,CAACC,QAAQ,EAAEH,IAAI,CAACxE,GAAG,EAAE6D,IAAI,GAAK,IAAIO,IAAI,CAACP,IAAI,CAAC,CAAC,EAAE5D,GAAG,CAAC2E,UAAU,EAAE3E,GAAG,CAAChC,WAAW,CAAC;YAChG;QACA,KAAK,aAAa;YAAE;gBAClB,MAAMoI,kBAAkB,GAAGyI,SAAS,CAAC7O,GAAG,CAACoG,kBAAkB,GAAG+I,CAAC,IAAI;oBACjE,MAAMvL,IAAI,GAAGqL,OAAO,CAACE,CAAC,CAACvL,IAAI,CAAC;oBAC5B,OAAOA,IAAI,KAAKuL,CAAC,CAACvL,IAAI,GAAGuL,CAAC,GAAG,IAAIvJ,iBAAiB,CAACuJ,CAAC,CAACtJ,IAAI,EAAEjC,IAAI,EAAEuL,CAAC,CAAC9K,UAAU,EAAE8K,CAAC,CAACxK,UAAU,CAAC;gBAC9F,CAAC,CAAC;gBACF,MAAM0B,eAAe,GAAGwI,SAAS,CAAC7O,GAAG,CAACqG,eAAe,GAAG4G,EAAE,IAAI;oBAC5D,MAAMrJ,IAAI,GAAGqL,OAAO,CAAChC,EAAE,CAACrJ,IAAI,CAAC;oBAC7B,OAAOA,IAAI,KAAKqJ,EAAE,CAACrJ,IAAI,GAAGqJ,EAAE,GAAG,IAAIjH,cAAc,CAACiH,EAAE,CAAChH,SAAS,EAAErC,IAAI,EAAEqJ,EAAE,CAACtI,UAAU,CAAC;gBACtF,CAAC,CAAC;gBACF,OAAOyB,kBAAkB,KAAKpG,GAAG,CAACoG,kBAAkB,IAAIC,eAAe,KAAKrG,GAAG,CAACqG,eAAe,GAC7FrG,GAAG,GACH,IAAImG,WAAW,CAACC,kBAAkB,EAAEC,eAAe,EAAErG,GAAG,CAAChC,WAAW,CAAC;YACzE;QACA,KAAK,OAAO;YAAE;gBACZ,MAAMkK,KAAK,GAAG2G,SAAS,CAAC7O,GAAG,CAACkI,KAAK,EAAE+G,OAAO,CAAC;gBAC3C,OAAO/G,KAAK,KAAKlI,GAAG,CAACkI,KAAK,GAAGlI,GAAG,GAAGyI,KAAK,CAACC,IAAI,CAACR,KAAK,EAAElI,GAAG,CAAChC,WAAW,CAAC;YACvE;QACA,KAAK,SAAS;YACZ,OAAO,IAAIuL,OAAO,CAAC,IAAM0F,OAAO,CAACjP,GAAG,CAACmJ,CAAC,EAAE,CAAC,EAAEnJ,GAAG,CAAChC,WAAW,CAAC;QAC7D,KAAK,YAAY;YAAE;gBACjB,MAAM+H,IAAI,GAAGkJ,OAAO,CAACjP,GAAG,CAAC+F,IAAI,CAAC;gBAC9B,OAAOA,IAAI,KAAK/F,GAAG,CAAC+F,IAAI,GACtB/F,GAAG,GACH,IAAI+J,UAAU,CAAChE,IAAI,EAAE/F,GAAG,CAACuH,MAAM,EAAEvH,GAAG,CAAChC,WAAW,CAAC;YACrD;QACA,KAAK,gBAAgB;YACnB,OAAOiR,OAAO,CAACjP,GAAG,CAACmK,EAAE,CAAC;IAC1B;IACA,OAAOnK,GAAG;AACZ,CAAC;AAGM,MAAMoP,mBAAmB,IAC7BC,aAAoC,IAAM3R,SAAoB,IAA6B;QAC1F,IAAI2K,GAAG,GAAyCiH,SAAS;QACzD,KAAK,MAAMC,EAAE,IAAIF,aAAa,CAAE;YAC9B,IAAIzR,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACL,SAAS,CAACM,WAAW,EAAEuR,EAAE,CAAC,EAAE;gBACnE,IAAIlH,GAAG,KAAKiH,SAAS,EAAE;oBACrBjH,GAAG,GAAG,CAAA,CAAE;gBACV;gBACAA,GAAG,CAACkH,EAAE,CAAC,GAAG7R,SAAS,CAACM,WAAW,CAACuR,EAAE,CAAC;YACrC;QACF;QACA,OAAOlH,GAAG;IACZ,CAAC;AAGI,MAAMmH,iBAAiB,IAAI9R,SAAoB,GACpD1B,MAAM,CAAC0N,qJAAM,CAACtK,2BAA2B,CAAC1B,SAAS,CAAC,EAAE,IAAMa,uBAAuB,CAACb,SAAS,CAAC,CAAC;AAEjG,gFAAA;AACA,6EAAA;AACA,yEAAA;AACA,8EAAA;AACA,MAAM+R,8BAA8B,IAAI/R,SAAoB,GAC1D1B,MAAM,CAACwS,oJAAK,CAACgB,iBAAiB,CAAC9R,SAAS,CAAC,EAAE;QACzCgS,MAAM,EAAEA,CAAA,GAAMJ,SAAS;QACvBK,MAAM,GAAGC,UAAU,GAAA,CAAM;gBAAE,CAACzQ,0BAA0B,CAAA,EAAGyQ;YAAU,CAAE;KACtE,CAAC;AAOJ,SAASf,SAASA,CAAIzF,EAAoB,EAAED,CAAc;IACxD,IAAI0G,OAAO,GAAG,KAAK;IACnB,MAAMxH,GAAG,GAAG1M,GAAG,CAACmU,yJAAQ,CAAC1G,EAAE,CAAChG,MAAM,CAAa;IAC/C,IAAK,IAAImD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6C,EAAE,CAAChG,MAAM,EAAEmD,CAAC,EAAE,CAAE;QAClC,MAAMwJ,CAAC,GAAG3G,EAAE,CAAC7C,CAAC,CAAC;QACf,MAAMyJ,EAAE,GAAG7G,CAAC,CAAC4G,CAAC,CAAC;QACf,IAAIC,EAAE,KAAKD,CAAC,EAAE;YACZF,OAAO,GAAG,IAAI;QAChB;QACAxH,GAAG,CAAC9B,CAAC,CAAC,GAAGyJ,EAAE;IACb;IACA,OAAOH,OAAO,GAAGxH,GAAG,GAAGe,EAAE;AAC3B;AAEA,MAAM6G,WAAW,GAAGA,CAACjQ,GAAQ,EAAEkQ,OAAgB,KAAS;IACtD,OAAQlQ,GAAG,CAACP,IAAI;QACd,KAAK,aAAa;YAAE;gBAClB,MAAMH,cAAc,GAAGuP,SAAS,CAAC7O,GAAG,CAACV,cAAc,GAAGU,GAAG,GAAKiQ,WAAW,CAACjQ,GAAG,EAAEkQ,OAAO,CAAC,CAAC;gBACxF,OAAO5Q,cAAc,KAAKU,GAAG,CAACV,cAAc,GAC1CU,GAAG,GACH,IAAIX,WAAW,CAACC,cAAc,EAAEU,GAAG,CAACT,aAAa,EAAES,GAAG,CAACR,aAAa,EAAEQ,GAAG,CAAChC,WAAW,CAAC;YAC1F;QACA,KAAK,WAAW;YAAE;gBAChB,MAAM0G,QAAQ,GAAGmK,SAAS,CAAC7O,GAAG,CAAC0E,QAAQ,GAAGI,CAAC,IAAI;oBAC7C,MAAMlB,IAAI,GAAGqM,WAAW,CAACnL,CAAC,CAAClB,IAAI,EAAEsM,OAAO,CAAC;oBACzC,OAAOtM,IAAI,KAAKkB,CAAC,CAAClB,IAAI,GAAGkB,CAAC,GAAG,IAAIV,YAAY,CAACR,IAAI,EAAEkB,CAAC,CAACT,UAAU,CAAC;gBACnE,CAAC,CAAC;gBACF,MAAM6K,QAAQ,GAAG5K,WAAW,CAACtE,GAAG,CAACuE,IAAI,CAAC;gBACtC,MAAMA,IAAI,GAAGsK,SAAS,CAACK,QAAQ,GAAGlP,GAAG,GAAKiQ,WAAW,CAACjQ,GAAG,EAAEkQ,OAAO,CAAC,CAAC;gBACpE,OAAOxL,QAAQ,KAAK1E,GAAG,CAAC0E,QAAQ,IAAIH,IAAI,KAAK2K,QAAQ,GACnDlP,GAAG,GACH,IAAIyE,SAAS,CACXC,QAAQ,EACRH,IAAI,CAACxE,GAAG,EAAEC,GAAG,GAAK,IAAImE,IAAI,CAACnE,GAAG,CAAC,CAAC,EAChCA,GAAG,CAAC2E,UAAU,EACd8K,8BAA8B,CAACzP,GAAG,CAAC,CACpC;YACL;QACA,KAAK,aAAa;YAAE;gBAClB,MAAMoG,kBAAkB,GAAGyI,SAAS,CAAC7O,GAAG,CAACoG,kBAAkB,GAAGY,EAAE,IAAI;oBAClE,MAAMpD,IAAI,GAAGqM,WAAW,CAACjJ,EAAE,CAACpD,IAAI,EAAEsM,OAAO,CAAC;oBAC1C,OAAOtM,IAAI,KAAKoD,EAAE,CAACpD,IAAI,GACnBoD,EAAE,GACF,IAAIpB,iBAAiB,CAACoB,EAAE,CAACnB,IAAI,EAAEjC,IAAI,EAAEoD,EAAE,CAAC3C,UAAU,EAAE2C,EAAE,CAACrC,UAAU,CAAC;gBACxE,CAAC,CAAC;gBACF,MAAM0B,eAAe,GAAGwI,SAAS,CAAC7O,GAAG,CAACqG,eAAe,GAAG4G,EAAE,IAAI;oBAC5D,MAAMrJ,IAAI,GAAGqM,WAAW,CAAChD,EAAE,CAACrJ,IAAI,EAAEsM,OAAO,CAAC;oBAC1C,OAAOtM,IAAI,KAAKqJ,EAAE,CAACrJ,IAAI,GAAGqJ,EAAE,GAAG,IAAIjH,cAAc,CAACiH,EAAE,CAAChH,SAAS,EAAErC,IAAI,EAAEqJ,EAAE,CAACtI,UAAU,CAAC;gBACtF,CAAC,CAAC;gBACF,OAAOyB,kBAAkB,KAAKpG,GAAG,CAACoG,kBAAkB,IAAIC,eAAe,KAAKrG,GAAG,CAACqG,eAAe,GAC7FrG,GAAG,GACH,IAAImG,WAAW,CAACC,kBAAkB,EAAEC,eAAe,EAAEoJ,8BAA8B,CAACzP,GAAG,CAAC,CAAC;YAC7F;QACA,KAAK,OAAO;YAAE;gBACZ,MAAMkI,KAAK,GAAG2G,SAAS,CAAC7O,GAAG,CAACkI,KAAK,GAAGlI,GAAG,GAAKiQ,WAAW,CAACjQ,GAAG,EAAEkQ,OAAO,CAAC,CAAC;gBACtE,OAAOhI,KAAK,KAAKlI,GAAG,CAACkI,KAAK,GAAGlI,GAAG,GAAGyI,KAAK,CAACC,IAAI,CAACR,KAAK,EAAEuH,8BAA8B,CAACzP,GAAG,CAAC,CAAC;YAC3F;QACA,KAAK,SAAS;YACZ,OAAO,IAAIuJ,OAAO,CAAC,IAAM0G,WAAW,CAACjQ,GAAG,CAACmJ,CAAC,EAAE,EAAE+G,OAAO,CAAC,EAAET,8BAA8B,CAACzP,GAAG,CAAC,CAAC;QAC9F,KAAK,YAAY;YAAE;gBACjB,MAAM+F,IAAI,GAAGkK,WAAW,CAACjQ,GAAG,CAAC+F,IAAI,EAAEmK,OAAO,CAAC;gBAC3C,IAAIA,OAAO,EAAE;oBACX,IAAInK,IAAI,KAAK/F,GAAG,CAAC+F,IAAI,EAAE;wBACrB,OAAO/F,GAAG;oBACZ;oBACA,IAAI,CAACqK,gBAAgB,CAACrK,GAAG,CAAC+F,IAAI,CAAC,EAAE;wBAC/B,MAAM/H,WAAW,GAAGkB,yBAAyB,CAACc,GAAG,CAAC;wBAClD,IAAIhE,MAAM,CAACsQ,qJAAM,CAACtO,WAAW,CAAC,IAAIA,WAAW,CAACsF,KAAK,KAAK,IAAI,EAAE;4BAC5D,OAAO,IAAIyG,UAAU,CAAChE,IAAI,EAAE/F,GAAG,CAACuH,MAAM,CAAC;wBACzC;oBACF;gBACF;gBACA,OAAOxB,IAAI;YACb;QACA,KAAK,gBAAgB;YACnB,OAAOkK,WAAW,CAACjQ,GAAG,CAAC+F,IAAI,EAAEmK,OAAO,CAAC;IACzC;IACA,OAAOlQ,GAAG;AACZ,CAAC;AAKM,MAAMmQ,UAAU,IAAInQ,GAAQ,GAAUiQ,WAAW,CAACjQ,GAAG,EAAE,KAAK,CAAC;AAK7D,MAAMoQ,eAAe,IAAIpQ,GAAQ,GAAUiQ,WAAW,CAACjQ,GAAG,EAAE,IAAI,CAAC;AAExE,MAAMC,iBAAiB,IAAIjC,WAAwB,IAAY;IAC7D,MAAMqK,GAAG,GAA4B,CAAA,CAAE;IACvC,KAAK,MAAM2F,CAAC,IAAIpQ,MAAM,CAACyS,qBAAqB,CAACrS,WAAW,CAAC,CAAE;QACzDqK,GAAG,CAAC5H,MAAM,CAACuN,CAAC,CAAC,CAAC,GAAGhQ,WAAW,CAACgQ,CAAC,CAAC;IACjC;IACA,OAAO3F,GAAG;AACZ,CAAC;AAGM,MAAMiI,cAAc,IAAItQ,GAAQ,IAAY;IACjD,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,cAAc;YACjB,OAAO,CAAC;QACV,KAAK,SAAS;QACd,KAAK,kBAAkB;QACvB,KAAK,aAAa;QAClB,KAAK,cAAc;YACjB,OAAO,CAAC;QACV,KAAK,gBAAgB;YACnB,OAAO,CAAC;QACV,KAAK,eAAe;QACpB,KAAK,eAAe;QACpB,KAAK,eAAe;QACpB,KAAK,eAAe;YAClB,OAAO,CAAC;QACV,KAAK,eAAe;YAClB,OAAO,CAAC;QACV,KAAK,gBAAgB;QACrB,KAAK,YAAY;YACf,OAAO,CAAC;QACV;YACE,OAAO,CAAC;IACZ;AACF,CAAC;AAED,MAAMoH,sBAAsB,GAAA,WAAA,GAAGlL,GAAG,CAAC8L,qJAAI,CAAA,WAAA,GACrCxL,KAAK,CAACyL,uJAAQ,CAAC3L,MAAM,CAACE,oJAAK,GAAG+K,EAAqB,GAAKsJ,cAAc,CAACtJ,EAAE,CAACpD,IAAI,CAAC,CAAC,CACjF;AAED,MAAMkD,mBAAmB,GAAA,WAAA,GAAGnL,GAAG,CAAC8L,qJAAI,CAAA,WAAA,GAClCxL,KAAK,CAACyL,uJAAQ,CAAC3L,MAAM,CAACE,oJAAK,GAAGgR,EAAkB,IAAI;IAClD,OAAQtG,gBAAgB,CAACsG,EAAE,CAAChH,SAAS,CAAC,CAACxG,IAAI;QACzC,KAAK,eAAe;YAClB,OAAO,CAAC;QACV,KAAK,eAAe;YAClB,OAAO,CAAC;QACV,KAAK,iBAAiB;YACpB,OAAO,CAAC;IACZ;AACF,CAAC,CAAC,CACH;AAID,MAAM8Q,WAAW,GAAA,WAAA,GAAwBtU,KAAK,CAACuU,oJAAK,CAElDzU,MAAM,CAACE,oJAAK,EAAEF,MAAM,CAACE,oJAAK,EAAEF,MAAM,CAACE,oJAAK,CAAC;AAE3C,MAAMwU,SAAS,GAAA,WAAA,GAAGxU,KAAK,CAACyU,kJAAG,CAASH,WAAW,CAAC;AAEhD,MAAMI,WAAW,GAAW;IAAC,CAAC;IAAE,CAAC;IAAE,CAAC;CAAC;AAErC,MAAMC,YAAY,IAAIC,OAA8B,GAAaA,OAAO,CAACvD,MAAM,CAACmD,SAAS,EAAEE,WAAW,CAAC;AAGhG,MAAMG,SAAS,IAAI9Q,GAAQ,IAAY;IAC5C,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,WAAW;YAAE;gBAChB,OAAO;oBAAC,CAAC;oBAAEO,GAAG,CAAC0E,QAAQ,CAACtB,MAAM;oBAAEpD,GAAG,CAACuE,IAAI,CAACnB,MAAM;iBAAC;YAClD;QACA,KAAK,aAAa;YAAE;gBAClB,MAAM2N,CAAC,GAAG/Q,GAAG,CAACoG,kBAAkB,CAAChD,MAAM;gBACvC,MAAM4N,CAAC,GAAGhR,GAAG,CAACqG,eAAe,CAACjD,MAAM;gBACpC,OAAO2N,CAAC,GAAGC,CAAC,KAAK,CAAC,GAChB;oBAAC,CAAC,CAAC;oBAAE,CAAC;oBAAE,CAAC;iBAAC,GACV;oBAAC,CAAC;oBAAED,CAAC;oBAAEC,CAAC;iBAAC;YACb;QACA,KAAK,aAAa;YAAE;gBAClB,MAAM3E,UAAU,GAAGpN,sBAAsB,CAACe,GAAG,CAAC;gBAC9C,IAAIhE,MAAM,CAACsQ,qJAAM,CAACD,UAAU,CAAC,EAAE;oBAC7B,MAAM,CAAChJ,CAAC,EAAE0N,CAAC,EAAEC,CAAC,CAAC,GAAGF,SAAS,CAACzE,UAAU,CAAC/I,KAAK,CAAC;oBAC7C,OAAO;wBAAC,CAAC;wBAAEyN,CAAC;wBAAEC,CAAC;qBAAC;gBAClB;gBACA,OAAO;oBAAC,CAAC;oBAAE,CAAC;oBAAE,CAAC;iBAAC;YAClB;QACA,KAAK,SAAS;YACZ,OAAO;gBAAC,CAAC;gBAAE,CAAC;gBAAE,CAAC;aAAC;QAClB,KAAK,OAAO;YACV,OAAOJ,YAAY,CAAC5Q,GAAG,CAACkI,KAAK,CAACnI,GAAG,CAAC+Q,SAAS,CAAC,CAAC;QAC/C,KAAK,YAAY;YAAE;gBACjB,MAAM,CAACG,CAAC,EAAEF,CAAC,EAAEC,CAAC,CAAC,GAAGF,SAAS,CAAC9Q,GAAG,CAAC+F,IAAI,CAAC;gBACrC,OAAO;oBAACkL,CAAC,GAAG,CAAC;oBAAEF,CAAC;oBAAEC,CAAC;iBAAC;YACtB;QACA,KAAK,gBAAgB;YACnB,OAAOF,SAAS,CAAC9Q,GAAG,CAAC+F,IAAI,CAAC;QAC5B,KAAK,eAAe;YAClB,OAAO;gBAAC,CAAC,CAAC;gBAAE,CAAC;gBAAE,CAAC;aAAC;QACnB,KAAK,gBAAgB;QACrB,KAAK,YAAY;YACf,OAAO;gBAAC,CAAC,CAAC;gBAAE,CAAC;gBAAE,CAAC;aAAC;QACnB;YACE,OAAO4K,WAAW;IACtB;AACF,CAAC;AAGM,MAAMhK,gBAAgB,IAC3B3G,GAAc,IACqC;IACnD,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,eAAe;QACpB,KAAK,eAAe;QACpB,KAAK,iBAAiB;YACpB,OAAOO,GAAG;QACZ,KAAK,YAAY;YACf,OAAO2G,gBAAgB,CAAC3G,GAAG,CAAC+F,IAAI,CAAC;IACrC;AACF,CAAC;AAED,MAAMmL,yBAAyB,GAAA,WAAA,GAAGvV,GAAG,CAACwV,+JAAc,CAAsB,CAACC,IAAI,EAAEC,IAAI,GACnFD,IAAI,CAACxN,IAAI,CAACnE,IAAI,KAAK4R,IAAI,CAACzN,IAAI,CAACnE,IAAI,IAAI2R,IAAI,CAAC9Q,OAAO,KAAK+Q,IAAI,CAAC/Q,OAAO,CACnE;AAED,MAAMgR,WAAW,GAAA,WAAA,GAAG3V,GAAG,CAACwV,+JAAc,CAAqC,CAACC,IAAI,EAAEC,IAAI,GACpFA,IAAI,CAAC,CAAC,CAAC,KAAKD,IAAI,CAAC,CAAC,CAAC,IAAIC,IAAI,CAAC,CAAC,CAAC,KAAKD,IAAI,CAAC,CAAC,CAAC,CAC3C;AAED,MAAMG,MAAM,GAAGA,CAACH,IAAS,EAAEC,IAAS,KAAI;IACtC,OAAQD,IAAI,CAAC3R,IAAI;QACf,KAAK,SAAS;YACZ,OAAOiB,SAAS,CAAC2Q,IAAI,CAAC,IAAIA,IAAI,CAAC/Q,OAAO,KAAK8Q,IAAI,CAAC9Q,OAAO;QACzD,KAAK,cAAc;YACjB,OAAOS,cAAc,CAACsQ,IAAI,CAAC,IAAIA,IAAI,CAACvQ,MAAM,KAAKsQ,IAAI,CAACtQ,MAAM;QAC5D,KAAK,kBAAkB;QACvB,KAAK,aAAa;QAClB,KAAK,cAAc;QACnB,KAAK,gBAAgB;QACrB,KAAK,YAAY;QACjB,KAAK,eAAe;QACpB,KAAK,eAAe;QACpB,KAAK,gBAAgB;QACrB,KAAK,eAAe;QACpB,KAAK,eAAe;QACpB,KAAK,eAAe;YAClB,OAAOuQ,IAAI,CAAC5R,IAAI,KAAK2R,IAAI,CAAC3R,IAAI;QAChC,KAAK,iBAAiB;YACpB,OAAOyE,iBAAiB,CAACmN,IAAI,CAAC,IAAIA,IAAI,CAACvN,IAAI,KAAKsN,IAAI,CAACtN,IAAI,IAAIoN,yBAAyB,CAACG,IAAI,CAACtN,KAAK,EAAEqN,IAAI,CAACrN,KAAK,CAAC;QAChH,KAAK,OAAO;YACV,OAAOL,OAAO,CAAC2N,IAAI,CAAC,IAAIC,WAAW,CAACD,IAAI,CAAClO,KAAK,EAAEiO,IAAI,CAACjO,KAAK,CAAC;QAC7D,KAAK,YAAY;QACjB,KAAK,WAAW;QAChB,KAAK,aAAa;QAClB,KAAK,OAAO;QACZ,KAAK,SAAS;QACd,KAAK,gBAAgB;QACrB,KAAK,aAAa;YAChB,OAAOiO,IAAI,KAAKC,IAAI;IACxB;AACF,CAAC;AAED,MAAM9D,YAAY,GAAA,WAAA,GAAG5R,GAAG,CAAC6V,iKAAgB,CAACD,MAAM,CAAC;AAEjD,MAAM1F,MAAM,IAAI7L,GAAQ,IAAgB;IACtC,OAAQA,GAAG,CAACP,IAAI;QACd,KAAK,aAAa;YAAE;gBAClB,MAAM4M,UAAU,GAAGpN,sBAAsB,CAACe,GAAG,CAAC;gBAC9C,IAAIhE,MAAM,CAACsQ,qJAAM,CAACD,UAAU,CAAC,EAAE;oBAC7B,OAAOR,MAAM,CAACQ,UAAU,CAAC/I,KAAK,CAAC;gBACjC;gBACA;YACF;QACA,KAAK,aAAa;YAChB,OAAOtD,GAAG,CAACoG,kBAAkB,CAACrG,GAAG,EAAEoP,CAAC,GAClCjT,SAAS,CAACmR,uJAAQ,CAAC8B,CAAC,CAACtJ,IAAI,CAAC,GAAG,IAAIhF,YAAY,CAACsO,CAAC,CAACtJ,IAAI,CAAC,GAAG,IAAIxF,OAAO,CAAC8O,CAAC,CAACtJ,IAAI,CAAC,CAC5E,CAAC+G,MAAM,CAAC5M,GAAG,CAACqG,eAAe,CAACtG,GAAG,EAAEkN,EAAE,GAAKtG,gBAAgB,CAACsG,EAAE,CAAChH,SAAS,CAAC,CAAC,CAAC;QAC3E,KAAK,SAAS;YACZ,OAAO4F,MAAM,CAAC7L,GAAG,CAACmJ,CAAC,EAAE,CAAC;QACxB,KAAK,OAAO;YACV,OAAOnJ,GAAG,CAACkI,KAAK,CAACqE,KAAK,CAAC,CAAC,CAAC,CAACe,MAAM,CAC9B,CAACjF,GAAe,EAAErI,GAAG,GAAKuN,YAAY,CAAClF,GAAG,EAAEwD,MAAM,CAAC7L,GAAG,CAAC,CAAC,EACxD6L,MAAM,CAAC7L,GAAG,CAACkI,KAAK,CAAC,CAAC,CAAC,CAAC,CACrB;QACH,KAAK,gBAAgB;YACnB,OAAO2D,MAAM,CAAC7L,GAAG,CAACmK,EAAE,CAAC;IACzB;IACA,MAAM,IAAIpF,KAAK,CAAC3I,OAAO,CAACyQ,8OAAuB,CAAC7M,GAAG,CAAC,CAAC;AACvD,CAAC;AAGM,MAAMyR,OAAO,GAAGA,CAACC,EAAO,EAAEC,EAAO,GAAU,IAAIzH,cAAc,CAACwH,EAAE,EAAEC,EAAE,EAAE/G,qBAAqB,CAAC;AAG5F,MAAMgH,MAAM,GAAGA,CAAC5R,GAAQ,EAAE6R,OAAsD,KAAS;IAC9F,OAAQ7R,GAAG,CAACP,IAAI;QACd,KAAK,aAAa;YAAE;gBAClB,MAAMyL,gCAAgC,GAA2C,EAAE;gBACnF,KAAK,MAAMvN,GAAG,IAAItB,KAAK,CAACyV,8NAAO,CAACD,OAAO,CAAC,CAAE;oBACxC,MAAMhM,IAAI,GAAGgM,OAAO,CAAClU,GAAG,CAAC;oBACzB,IAAIkI,IAAI,KAAKyJ,SAAS,EAAE;wBACtBpE,gCAAgC,CAAC1C,IAAI,CACnC,IAAIsC,+BAA+B,CACjCnN,GAAG,EACHkI,IAAI,EACJhK,gKAAQ,EACRA,gKAAQ,CACT,CACF;oBACH;gBACF;gBACA,IAAIqP,gCAAgC,CAAC9H,MAAM,KAAK,CAAC,EAAE;oBACjD,OAAOpD,GAAG;gBACZ;gBACA,OAAO,IAAIkK,cAAc,CACvBlK,GAAG,EACH,IAAImG,WAAW,CACbnG,GAAG,CAACoG,kBAAkB,CAACrG,GAAG,EAAEiH,EAAE,IAAI;oBAChC,MAAMnB,IAAI,GAAGgM,OAAO,CAAC7K,EAAE,CAACnB,IAAI,CAAC;oBAC7B,OAAO,IAAID,iBAAiB,CAC1BC,IAAI,KAAKyJ,SAAS,GAAGtI,EAAE,CAACnB,IAAI,GAAGA,IAAI,EACnCoJ,OAAO,CAACjI,EAAE,CAACpD,IAAI,CAAC,EAChBoD,EAAE,CAAC3C,UAAU,EACb2C,EAAE,CAACrC,UAAU,EACbqC,EAAE,CAAChJ,WAAW,CACf;gBACH,CAAC,CAAC,EACFgC,GAAG,CAACqG,eAAe,CACpB,EACD,IAAI4E,yBAAyB,CAACC,gCAAgC,CAAC,CAChE;YACH;QACA,KAAK,OAAO;YACV,OAAOzC,KAAK,CAACC,IAAI,CAAC1I,GAAG,CAACkI,KAAK,CAACnI,GAAG,EAAEC,GAAG,GAAK4R,MAAM,CAAC5R,GAAG,EAAE6R,OAAO,CAAC,CAAC,CAAC;QACjE,KAAK,SAAS;YACZ,OAAO,IAAItI,OAAO,CAAC,IAAMqI,MAAM,CAAC5R,GAAG,CAACmJ,CAAC,EAAE,EAAE0I,OAAO,CAAC,CAAC;QACpD,KAAK,gBAAgB;YACnB,OAAOJ,OAAO,CAACzR,GAAG,EAAE4R,MAAM,CAAC3C,OAAO,CAACjP,GAAG,CAAC,EAAE6R,OAAO,CAAC,CAAC;IACtD;IACA,MAAM,IAAI9M,KAAK,CAAC3I,OAAO,CAAC2V,oPAA6B,CAAC/R,GAAG,CAAC,CAAC;AAC7D,CAAC;AAED,MAAMiB,aAAa,IAAIjB,GAAQ,GAAahE,MAAM,CAAC4D,wJAAS,CAACC,WAAW,CAACG,GAAG,CAAC,EAAE,IAAMA,GAAG,CAACP,IAAI,CAAC;AAE9F,MAAMI,WAAW,IAAIG,GAAc,IAA2B;IAC5D,OAAOzB,uBAAuB,CAACyB,GAAG,CAAC,CAACyJ,IAAI,CACtCzN,MAAM,CAAC0N,qJAAM,CAAC,IAAMpL,kBAAkB,CAAC0B,GAAG,CAAC,CAAC,EAC5ChE,MAAM,CAAC0N,qJAAM,CAAC,IAAMlL,wBAAwB,CAACwB,GAAG,CAAC,CAAC,CACnD;AACH,CAAC","ignoreList":[]}},
    {"offset": {"line": 2233, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/FastCheck.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/FastCheck.ts"],"sourcesContent":["/**\n * @since 0.67.0\n */\n\n/**\n * @category re-exports\n * @since 0.67.0\n */\nexport * from \"fast-check\"\n"],"names":[],"mappings":"AAAA;;IAIA;;;;AAIA,cAAc,YAAY","ignoreList":[]}},
    {"offset": {"line": 2509, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/internal/filters.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/internal/filters.ts"],"sourcesContent":["import type * as Schema from \"../Schema.js\"\n\n/** @internal */\nexport const GreaterThanTypeId: Schema.GreaterThanTypeId = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThan\"\n) as Schema.GreaterThanTypeId\n\n/** @internal */\nexport const GreaterThanOrEqualToTypeId: Schema.GreaterThanOrEqualToTypeId = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanOrEqualTo\"\n) as Schema.GreaterThanOrEqualToTypeId\n\n/** @internal */\nexport const LessThanTypeId: Schema.LessThanTypeId = Symbol.for(\n  \"@effect/schema/TypeId/LessThan\"\n) as Schema.LessThanTypeId\n\n/** @internal */\nexport const LessThanOrEqualToTypeId: Schema.LessThanOrEqualToTypeId = Symbol.for(\n  \"@effect/schema/TypeId/LessThanOrEqualTo\"\n) as Schema.LessThanOrEqualToTypeId\n\n/** @internal */\nexport const IntTypeId: Schema.IntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/Int\"\n) as Schema.IntTypeId\n\n/** @internal */\nexport const BetweenTypeId: Schema.BetweenTypeId = Symbol.for(\n  \"@effect/schema/TypeId/Between\"\n) as Schema.BetweenTypeId\n\n/** @internal */\nexport const GreaterThanBigintTypeId: Schema.GreaterThanBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanBigint\"\n) as Schema.GreaterThanBigIntTypeId\n\n/** @internal */\nexport const GreaterThanOrEqualToBigIntTypeId: Schema.GreaterThanOrEqualToBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanOrEqualToBigint\"\n) as Schema.GreaterThanOrEqualToBigIntTypeId\n\n/** @internal */\nexport const LessThanBigIntTypeId: Schema.LessThanBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/LessThanBigint\"\n) as Schema.LessThanBigIntTypeId\n\n/** @internal */\nexport const LessThanOrEqualToBigIntTypeId: Schema.LessThanOrEqualToBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/LessThanOrEqualToBigint\"\n) as Schema.LessThanOrEqualToBigIntTypeId\n\n/** @internal */\nexport const BetweenBigintTypeId: Schema.BetweenBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/BetweenBigint\"\n) as Schema.BetweenBigIntTypeId\n\n/** @internal */\nexport const MinLengthTypeId: Schema.MinLengthTypeId = Symbol.for(\n  \"@effect/schema/TypeId/MinLength\"\n) as Schema.MinLengthTypeId\n\n/** @internal */\nexport const MaxLengthTypeId: Schema.MaxLengthTypeId = Symbol.for(\n  \"@effect/schema/TypeId/MaxLength\"\n) as Schema.MaxLengthTypeId\n\n/** @internal */\nexport const LengthTypeId: Schema.LengthTypeId = Symbol.for(\n  \"@effect/schema/TypeId/Length\"\n) as Schema.LengthTypeId\n\n/** @internal */\nexport const MinItemsTypeId: Schema.MinItemsTypeId = Symbol.for(\n  \"@effect/schema/TypeId/MinItems\"\n) as Schema.MinItemsTypeId\n\n/** @internal */\nexport const MaxItemsTypeId: Schema.MaxItemsTypeId = Symbol.for(\n  \"@effect/schema/TypeId/MaxItems\"\n) as Schema.MaxItemsTypeId\n\n/** @internal */\nexport const ItemsCountTypeId: Schema.ItemsCountTypeId = Symbol.for(\n  \"@effect/schema/TypeId/ItemsCount\"\n) as Schema.ItemsCountTypeId\n\n/** @internal */\nexport const ParseJsonTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/ParseJson\")\n"],"names":["GreaterThanTypeId","Symbol","for","GreaterThanOrEqualToTypeId","LessThanTypeId","LessThanOrEqualToTypeId","IntTypeId","BetweenTypeId","GreaterThanBigintTypeId","GreaterThanOrEqualToBigIntTypeId","LessThanBigIntTypeId","LessThanOrEqualToBigIntTypeId","BetweenBigintTypeId","MinLengthTypeId","MaxLengthTypeId","LengthTypeId","MinItemsTypeId","MaxItemsTypeId","ItemsCountTypeId","ParseJsonTypeId"],"mappings":"AAEA,cAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACO,MAAMA,iBAAiB,GAAA,WAAA,GAA6BC,MAAM,CAACC,GAAG,CACnE,mCAAmC,CACR;AAGtB,MAAMC,0BAA0B,GAAA,WAAA,GAAsCF,MAAM,CAACC,GAAG,CACrF,4CAA4C,CACR;AAG/B,MAAME,cAAc,GAAA,WAAA,GAA0BH,MAAM,CAACC,GAAG,CAC7D,gCAAgC,CACR;AAGnB,MAAMG,uBAAuB,GAAA,WAAA,GAAmCJ,MAAM,CAACC,GAAG,CAC/E,yCAAyC,CACR;AAG5B,MAAMI,SAAS,GAAA,WAAA,GAAqBL,MAAM,CAACC,GAAG,CACnD,2BAA2B,CACR;AAGd,MAAMK,aAAa,GAAA,WAAA,GAAyBN,MAAM,CAACC,GAAG,CAC3D,+BAA+B,CACR;AAGlB,MAAMM,uBAAuB,GAAA,WAAA,GAAmCP,MAAM,CAACC,GAAG,CAC/E,yCAAyC,CACR;AAG5B,MAAMO,gCAAgC,GAAA,WAAA,GAA4CR,MAAM,CAACC,GAAG,CACjG,kDAAkD,CACR;AAGrC,MAAMQ,oBAAoB,GAAA,WAAA,GAAgCT,MAAM,CAACC,GAAG,CACzE,sCAAsC,CACR;AAGzB,MAAMS,6BAA6B,GAAA,WAAA,GAAyCV,MAAM,CAACC,GAAG,CAC3F,+CAA+C,CACR;AAGlC,MAAMU,mBAAmB,GAAA,WAAA,GAA+BX,MAAM,CAACC,GAAG,CACvE,qCAAqC,CACR;AAGxB,MAAMW,eAAe,GAAA,WAAA,GAA2BZ,MAAM,CAACC,GAAG,CAC/D,iCAAiC,CACR;AAGpB,MAAMY,eAAe,GAAA,WAAA,GAA2Bb,MAAM,CAACC,GAAG,CAC/D,iCAAiC,CACR;AAGpB,MAAMa,YAAY,GAAA,WAAA,GAAwBd,MAAM,CAACC,GAAG,CACzD,8BAA8B,CACR;AAGjB,MAAMc,cAAc,GAAA,WAAA,GAA0Bf,MAAM,CAACC,GAAG,CAC7D,gCAAgC,CACR;AAGnB,MAAMe,cAAc,GAAA,WAAA,GAA0BhB,MAAM,CAACC,GAAG,CAC7D,gCAAgC,CACR;AAGnB,MAAMgB,gBAAgB,GAAA,WAAA,GAA4BjB,MAAM,CAACC,GAAG,CACjE,kCAAkC,CACR;AAGrB,MAAMiB,eAAe,GAAA,WAAA,GAAkBlB,MAAM,CAACC,GAAG,CAAC,iCAAiC,CAAC","ignoreList":[]}},
    {"offset": {"line": 2569, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/Arbitrary.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/Arbitrary.ts"],"sourcesContent":["/**\n * @since 0.67.0\n */\n\nimport * as Arr from \"effect/Array\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as AST from \"./AST.js\"\nimport * as FastCheck from \"./FastCheck.js\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as filters_ from \"./internal/filters.js\"\nimport * as util_ from \"./internal/util.js\"\nimport type * as Schema from \"./Schema.js\"\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport interface LazyArbitrary<A> {\n  (fc: typeof FastCheck): FastCheck.Arbitrary<A>\n}\n\n/**\n * @category hooks\n * @since 0.67.0\n */\nexport const ArbitraryHookId: unique symbol = Symbol.for(\"@effect/schema/ArbitraryHookId\")\n\n/**\n * @category hooks\n * @since 0.67.0\n */\nexport type ArbitraryHookId = typeof ArbitraryHookId\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const arbitrary =\n  <A>(handler: (...args: ReadonlyArray<LazyArbitrary<any>>) => LazyArbitrary<A>) =>\n  <I, R>(self: Schema.Schema<A, I, R>): Schema.Schema<A, I, R> => self.annotations({ [ArbitraryHookId]: handler })\n\n/**\n * Returns a LazyArbitrary for the `A` type of the provided schema.\n *\n * @category arbitrary\n * @since 0.67.0\n */\nexport const makeLazy = <A, I, R>(schema: Schema.Schema<A, I, R>): LazyArbitrary<A> => go(schema.ast, {}, [])\n\n/**\n * Returns a fast-check Arbitrary for the `A` type of the provided schema.\n *\n * @category arbitrary\n * @since 0.67.0\n */\nexport const make = <A, I, R>(schema: Schema.Schema<A, I, R>): FastCheck.Arbitrary<A> => makeLazy(schema)(FastCheck)\n\nconst depthSize = 1\n\nconst record = <K extends PropertyKey, V>(\n  fc: typeof FastCheck,\n  key: FastCheck.Arbitrary<K>,\n  value: FastCheck.Arbitrary<V>,\n  options: Options\n): FastCheck.Arbitrary<{ readonly [k in K]: V }> => {\n  return (options.isSuspend ?\n    fc.oneof(\n      { depthSize },\n      fc.constant([]),\n      fc.array(fc.tuple(key, value), { minLength: 1, maxLength: 2 })\n    ) :\n    fc.array(fc.tuple(key, value))).map((tuples) => {\n      const out: { [k in K]: V } = {} as any\n      for (const [k, v] of tuples) {\n        out[k] = v\n      }\n      return out\n    })\n}\n\nconst getHook = AST.getAnnotation<\n  (...args: ReadonlyArray<LazyArbitrary<any>>) => LazyArbitrary<any>\n>(ArbitraryHookId)\n\ntype Options = {\n  readonly constraints?: Constraints\n  readonly isSuspend?: boolean\n}\n\nconst getRefinementFromArbitrary = (ast: AST.Refinement, options: Options, path: ReadonlyArray<PropertyKey>) => {\n  const constraints = combineConstraints(options.constraints, getConstraints(ast))\n  return go(ast.from, constraints ? { ...options, constraints } : options, path)\n}\n\nconst go = (ast: AST.AST, options: Options, path: ReadonlyArray<PropertyKey>): LazyArbitrary<any> => {\n  const hook = getHook(ast)\n  if (Option.isSome(hook)) {\n    switch (ast._tag) {\n      case \"Declaration\":\n        return hook.value(...ast.typeParameters.map((p) => go(p, options, path)))\n      case \"Refinement\":\n        return hook.value(getRefinementFromArbitrary(ast, options, path))\n      default:\n        return hook.value()\n    }\n  }\n  switch (ast._tag) {\n    case \"Declaration\": {\n      throw new Error(errors_.getArbitraryMissingAnnotationErrorMessage(path, ast))\n    }\n    case \"Literal\":\n      return (fc) => fc.constant(ast.literal)\n    case \"UniqueSymbol\":\n      return (fc) => fc.constant(ast.symbol)\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n      return (fc) => fc.constant(undefined)\n    case \"NeverKeyword\":\n      return () => {\n        throw new Error(errors_.getArbitraryUnsupportedErrorMessage(path, ast))\n      }\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return (fc) => fc.anything()\n    case \"StringKeyword\":\n      return (fc) => {\n        if (options.constraints) {\n          switch (options.constraints._tag) {\n            case \"StringConstraints\":\n              return fc.string(options.constraints.constraints)\n          }\n        }\n        return fc.string()\n      }\n    case \"NumberKeyword\":\n      return (fc) => {\n        if (options.constraints) {\n          switch (options.constraints._tag) {\n            case \"NumberConstraints\":\n              return fc.float(options.constraints.constraints)\n            case \"IntegerConstraints\":\n              return fc.integer(options.constraints.constraints)\n          }\n        }\n        return fc.float()\n      }\n    case \"BooleanKeyword\":\n      return (fc) => fc.boolean()\n    case \"BigIntKeyword\":\n      return (fc) => {\n        if (options.constraints) {\n          switch (options.constraints._tag) {\n            case \"BigIntConstraints\":\n              return fc.bigInt(options.constraints.constraints)\n          }\n        }\n        return fc.bigInt()\n      }\n    case \"SymbolKeyword\":\n      return (fc) => fc.string().map((s) => Symbol.for(s))\n    case \"ObjectKeyword\":\n      return (fc) => fc.oneof(fc.object(), fc.array(fc.anything()))\n    case \"TemplateLiteral\": {\n      return (fc) => {\n        const string = fc.string({ maxLength: 5 })\n        const number = fc.float({ noDefaultInfinity: true }).filter((n) => !Number.isNaN(n))\n        const components: Array<FastCheck.Arbitrary<string | number>> = [fc.constant(ast.head)]\n        for (const span of ast.spans) {\n          if (AST.isStringKeyword(span.type)) {\n            components.push(string)\n          } else {\n            components.push(number)\n          }\n          components.push(fc.constant(span.literal))\n        }\n        return fc.tuple(...components).map((spans) => spans.join(\"\"))\n      }\n    }\n    case \"TupleType\": {\n      const elements: Array<LazyArbitrary<any>> = []\n      let hasOptionals = false\n      let i = 0\n      for (const element of ast.elements) {\n        elements.push(go(element.type, options, path.concat(i++)))\n        if (element.isOptional) {\n          hasOptionals = true\n        }\n      }\n      const rest = ast.rest.map((annotatedAST) => go(annotatedAST.type, options, path))\n      return (fc) => {\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        let output = fc.tuple(...elements.map((arb) => arb(fc)))\n        if (hasOptionals) {\n          const indexes = fc.tuple(\n            ...ast.elements.map((element) => element.isOptional ? fc.boolean() : fc.constant(true))\n          )\n          output = output.chain((tuple) =>\n            indexes.map((booleans) => {\n              for (const [i, b] of booleans.reverse().entries()) {\n                if (!b) {\n                  tuple.splice(booleans.length - i, 1)\n                }\n              }\n              return tuple\n            })\n          )\n        }\n\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (Arr.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          const arb = head(fc)\n          const constraints = options.constraints\n          output = output.chain((as) => {\n            let out = fc.array(arb)\n            if (options.isSuspend) {\n              out = fc.oneof(\n                { depthSize },\n                fc.constant([]),\n                fc.array(arb, { minLength: 1, maxLength: 2 })\n              )\n            } else if (constraints && constraints._tag === \"ArrayConstraints\") {\n              out = fc.array(arb, constraints.constraints)\n            }\n            return out.map((rest) => [...as, ...rest])\n          })\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            output = output.chain((as) => tail[j](fc).map((a) => [...as, a]))\n          }\n        }\n\n        return output\n      }\n    }\n    case \"TypeLiteral\": {\n      const propertySignaturesTypes = ast.propertySignatures.map((ps) => go(ps.type, options, path.concat(ps.name)))\n      const indexSignatures = ast.indexSignatures.map((is) =>\n        [go(is.parameter, options, path), go(is.type, options, path)] as const\n      )\n      return (fc) => {\n        const arbs: any = {}\n        const requiredKeys: Array<PropertyKey> = []\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < propertySignaturesTypes.length; i++) {\n          const ps = ast.propertySignatures[i]\n          const name = ps.name\n          if (!ps.isOptional) {\n            requiredKeys.push(name)\n          }\n          arbs[name] = propertySignaturesTypes[i](fc)\n        }\n        let output = fc.record<any, any>(arbs, { requiredKeys })\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const parameter = indexSignatures[i][0](fc)\n          const type = indexSignatures[i][1](fc)\n          output = output.chain((o) => {\n            return record(fc, parameter, type, options).map((d) => ({ ...d, ...o }))\n          })\n        }\n\n        return output\n      }\n    }\n    case \"Union\": {\n      const types = ast.types.map((t) => go(t, options, path))\n      return (fc) => fc.oneof({ depthSize }, ...types.map((arb) => arb(fc)))\n    }\n    case \"Enums\": {\n      if (ast.enums.length === 0) {\n        throw new Error(errors_.getArbitraryEmptyEnumErrorMessage(path))\n      }\n      return (fc) => fc.oneof(...ast.enums.map(([_, value]) => fc.constant(value)))\n    }\n    case \"Refinement\": {\n      const from = getRefinementFromArbitrary(ast, options, path)\n      return (fc) => from(fc).filter((a) => Option.isNone(ast.filter(a, AST.defaultParseOption, ast)))\n    }\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => go(ast.f(), { ...options, isSuspend: true }, path))\n      return (fc) => fc.constant(null).chain(() => get()(fc))\n    }\n    case \"Transformation\":\n      return go(ast.to, options, path)\n  }\n}\n\n/** @internal */\nexport class NumberConstraints {\n  readonly _tag = \"NumberConstraints\"\n  readonly constraints: FastCheck.FloatConstraints\n  constructor(options: {\n    readonly min?: number | undefined\n    readonly max?: number | undefined\n    readonly noNaN?: boolean | undefined\n    readonly noDefaultInfinity?: boolean | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isNumber(options.min)) {\n      this.constraints.min = Math.fround(options.min)\n    }\n    if (Predicate.isNumber(options.max)) {\n      this.constraints.max = Math.fround(options.max)\n    }\n    if (Predicate.isBoolean(options.noNaN)) {\n      this.constraints.noNaN = options.noNaN\n    }\n    if (Predicate.isBoolean(options.noDefaultInfinity)) {\n      this.constraints.noDefaultInfinity = options.noDefaultInfinity\n    }\n  }\n}\n\n/** @internal */\nexport class StringConstraints {\n  readonly _tag = \"StringConstraints\"\n  readonly constraints: FastCheck.StringSharedConstraints\n  constructor(options: {\n    readonly minLength?: number | undefined\n    readonly maxLength?: number | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isNumber(options.minLength)) {\n      this.constraints.minLength = options.minLength\n    }\n    if (Predicate.isNumber(options.maxLength)) {\n      this.constraints.maxLength = options.maxLength\n    }\n  }\n}\n\n/** @internal */\nexport class IntegerConstraints {\n  readonly _tag = \"IntegerConstraints\"\n  readonly constraints: FastCheck.IntegerConstraints\n  constructor(options: {\n    readonly min?: number | undefined\n    readonly max?: number | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isNumber(options.min)) {\n      this.constraints.min = options.min\n    }\n    if (Predicate.isNumber(options.max)) {\n      this.constraints.max = options.max\n    }\n  }\n}\n\n/** @internal */\nexport class ArrayConstraints {\n  readonly _tag = \"ArrayConstraints\"\n  readonly constraints: FastCheck.ArrayConstraints\n  constructor(options: {\n    readonly minLength?: number | undefined\n    readonly maxLength?: number | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isNumber(options.minLength)) {\n      this.constraints.minLength = options.minLength\n    }\n    if (Predicate.isNumber(options.maxLength)) {\n      this.constraints.maxLength = options.maxLength\n    }\n  }\n}\n\n/** @internal */\nexport class BigIntConstraints {\n  readonly _tag = \"BigIntConstraints\"\n  readonly constraints: FastCheck.BigIntConstraints\n  constructor(options: {\n    readonly min?: bigint | undefined\n    readonly max?: bigint | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isBigInt(options.min)) {\n      this.constraints.min = options.min\n    }\n    if (Predicate.isBigInt(options.max)) {\n      this.constraints.max = options.max\n    }\n  }\n}\n\n/** @internal */\nexport type Constraints =\n  | NumberConstraints\n  | StringConstraints\n  | IntegerConstraints\n  | ArrayConstraints\n  | BigIntConstraints\n\n/** @internal */\nexport const getConstraints = (ast: AST.Refinement): Constraints | undefined => {\n  const TypeAnnotationId = ast.annotations[AST.TypeAnnotationId]\n  const jsonSchema: any = ast.annotations[AST.JSONSchemaAnnotationId]\n  switch (TypeAnnotationId) {\n    // int\n    case filters_.IntTypeId:\n      return new IntegerConstraints({})\n    // number\n    case filters_.GreaterThanTypeId:\n    case filters_.GreaterThanOrEqualToTypeId:\n    case filters_.LessThanTypeId:\n    case filters_.LessThanOrEqualToTypeId:\n    case filters_.BetweenTypeId:\n      return new NumberConstraints({\n        min: jsonSchema.exclusiveMinimum ?? jsonSchema.minimum,\n        max: jsonSchema.exclusiveMaximum ?? jsonSchema.maximum\n      })\n    // bigint\n    case filters_.GreaterThanBigintTypeId:\n    case filters_.GreaterThanOrEqualToBigIntTypeId:\n    case filters_.LessThanBigIntTypeId:\n    case filters_.LessThanOrEqualToBigIntTypeId:\n    case filters_.BetweenBigintTypeId: {\n      const constraints: any = ast.annotations[TypeAnnotationId]\n      return new BigIntConstraints(constraints)\n    }\n    // string\n    case filters_.MinLengthTypeId:\n    case filters_.MaxLengthTypeId:\n    case filters_.LengthTypeId:\n      return new StringConstraints(jsonSchema)\n    // array\n    case filters_.MinItemsTypeId:\n    case filters_.MaxItemsTypeId:\n    case filters_.ItemsCountTypeId:\n      return new ArrayConstraints({\n        minLength: jsonSchema.minItems,\n        maxLength: jsonSchema.maxItems\n      })\n  }\n}\n\n/** @internal */\nexport const combineConstraints = (\n  c1: Constraints | undefined,\n  c2: Constraints | undefined\n): Constraints | undefined => {\n  if (c1 === undefined) {\n    return c2\n  }\n  if (c2 === undefined) {\n    return c1\n  }\n  switch (c1._tag) {\n    case \"ArrayConstraints\": {\n      switch (c2._tag) {\n        case \"ArrayConstraints\":\n          return new ArrayConstraints({\n            minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),\n            maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength)\n          })\n      }\n      break\n    }\n    case \"NumberConstraints\": {\n      switch (c2._tag) {\n        case \"NumberConstraints\":\n          return new NumberConstraints({\n            min: getMax(c1.constraints.min, c2.constraints.min),\n            max: getMin(c1.constraints.max, c2.constraints.max),\n            noNaN: getOr(c1.constraints.noNaN, c2.constraints.noNaN),\n            noDefaultInfinity: getOr(c1.constraints.noDefaultInfinity, c2.constraints.noDefaultInfinity)\n          })\n        case \"IntegerConstraints\":\n          return new IntegerConstraints({\n            min: getMax(c1.constraints.min, c2.constraints.min),\n            max: getMin(c1.constraints.max, c2.constraints.max)\n          })\n      }\n      break\n    }\n    case \"BigIntConstraints\": {\n      switch (c2._tag) {\n        case \"BigIntConstraints\":\n          return new BigIntConstraints({\n            min: getMax(c1.constraints.min, c2.constraints.min),\n            max: getMin(c1.constraints.max, c2.constraints.max)\n          })\n      }\n      break\n    }\n    case \"StringConstraints\": {\n      switch (c2._tag) {\n        case \"StringConstraints\":\n          return new StringConstraints({\n            minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),\n            maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength)\n          })\n      }\n      break\n    }\n    case \"IntegerConstraints\": {\n      switch (c2._tag) {\n        case \"NumberConstraints\":\n        case \"IntegerConstraints\": {\n          return new IntegerConstraints({\n            min: getMax(c1.constraints.min, c2.constraints.min),\n            max: getMin(c1.constraints.max, c2.constraints.max)\n          })\n        }\n      }\n      break\n    }\n  }\n}\n\nconst getOr = (a: boolean | undefined, b: boolean | undefined): boolean | undefined => {\n  return a === undefined ? b : b === undefined ? a : a || b\n}\n\nfunction getMax(n1: bigint | undefined, n2: bigint | undefined): bigint | undefined\nfunction getMax(n1: number | undefined, n2: number | undefined): number | undefined\nfunction getMax(\n  n1: bigint | number | undefined,\n  n2: bigint | number | undefined\n): bigint | number | undefined {\n  return n1 === undefined ? n2 : n2 === undefined ? n1 : n1 <= n2 ? n2 : n1\n}\n\nfunction getMin(n1: bigint | undefined, n2: bigint | undefined): bigint | undefined\nfunction getMin(n1: number | undefined, n2: number | undefined): number | undefined\nfunction getMin(\n  n1: bigint | number | undefined,\n  n2: bigint | number | undefined\n): bigint | number | undefined {\n  return n1 === undefined ? n2 : n2 === undefined ? n1 : n1 <= n2 ? n1 : n2\n}\n"],"names":["Arr","Option","Predicate","AST","FastCheck","errors_","filters_","util_","ArbitraryHookId","Symbol","for","arbitrary","handler","self","annotations","makeLazy","schema","go","ast","make","depthSize","record","fc","key","value","options","isSuspend","oneof","constant","array","tuple","minLength","maxLength","map","tuples","out","k","v","getHook","getAnnotation","getRefinementFromArbitrary","path","constraints","combineConstraints","getConstraints","from","hook","isSome","_tag","typeParameters","p","Error","getArbitraryMissingAnnotationErrorMessage","literal","symbol","undefined","getArbitraryUnsupportedErrorMessage","anything","string","float","integer","boolean","bigInt","s","object","number","noDefaultInfinity","filter","n","Number","isNaN","components","head","span","spans","isStringKeyword","type","push","join","elements","hasOptionals","i","element","concat","isOptional","rest","annotatedAST","output","arb","indexes","chain","booleans","b","reverse","entries","splice","length","isNonEmptyReadonlyArray","tail","as","j","a","propertySignaturesTypes","propertySignatures","ps","name","indexSignatures","is","parameter","arbs","requiredKeys","o","d","types","t","enums","getArbitraryEmptyEnumErrorMessage","_","isNone","defaultParseOption","get","memoizeThunk","f","to","NumberConstraints","constructor","isNumber","min","Math","fround","max","isBoolean","noNaN","StringConstraints","IntegerConstraints","ArrayConstraints","BigIntConstraints","isBigInt","TypeAnnotationId","jsonSchema","JSONSchemaAnnotationId","IntTypeId","GreaterThanTypeId","GreaterThanOrEqualToTypeId","LessThanTypeId","LessThanOrEqualToTypeId","BetweenTypeId","exclusiveMinimum","minimum","exclusiveMaximum","maximum","GreaterThanBigintTypeId","GreaterThanOrEqualToBigIntTypeId","LessThanBigIntTypeId","LessThanOrEqualToBigIntTypeId","BetweenBigintTypeId","MinLengthTypeId","MaxLengthTypeId","LengthTypeId","MinItemsTypeId","MaxItemsTypeId","ItemsCountTypeId","minItems","maxItems","c1","c2","getMax","getMin","getOr","n1","n2"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 3069, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/TreeFormatter.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/TreeFormatter.ts"],"sourcesContent":["/**\n * @since 0.67.0\n */\n\nimport type * as Cause from \"effect/Cause\"\nimport * as Effect from \"effect/Effect\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as AST from \"./AST.js\"\nimport * as util_ from \"./internal/util.js\"\nimport type * as ParseResult from \"./ParseResult.js\"\n\ninterface Forest<A> extends ReadonlyArray<Tree<A>> {}\n\ninterface Tree<A> {\n  readonly value: A\n  readonly forest: Forest<A>\n}\n\nconst make = <A>(value: A, forest: Forest<A> = []): Tree<A> => ({\n  value,\n  forest\n})\n\n/**\n * @category formatting\n * @since 0.67.0\n */\nexport const formatIssue = (issue: ParseResult.ParseIssue): Effect.Effect<string> =>\n  Effect.map(go(issue), (tree) => drawTree(tree))\n\n/**\n * @category formatting\n * @since 0.67.0\n */\nexport const formatIssueSync = (issue: ParseResult.ParseIssue): string => Effect.runSync(formatIssue(issue))\n\n/**\n * @category formatting\n * @since 0.67.0\n */\nexport const formatError = (error: ParseResult.ParseError): Effect.Effect<string> => formatIssue(error.issue)\n\n/**\n * @category formatting\n * @since 0.67.0\n */\nexport const formatErrorSync = (error: ParseResult.ParseError): string => formatIssueSync(error.issue)\n\nconst drawTree = (tree: Tree<string>): string => tree.value + draw(\"\\n\", tree.forest)\n\nconst draw = (indentation: string, forest: Forest<string>): string => {\n  let r = \"\"\n  const len = forest.length\n  let tree: Tree<string>\n  for (let i = 0; i < len; i++) {\n    tree = forest[i]\n    const isLast = i === len - 1\n    r += indentation + (isLast ? \"\" : \"\") + \" \" + tree.value\n    r += draw(indentation + (len > 1 && !isLast ? \"  \" : \"   \"), tree.forest)\n  }\n  return r\n}\n\nconst formatTransformationKind = (kind: ParseResult.Transformation[\"kind\"]): string => {\n  switch (kind) {\n    case \"Encoded\":\n      return \"Encoded side transformation failure\"\n    case \"Transformation\":\n      return \"Transformation process failure\"\n    case \"Type\":\n      return \"Type side transformation failure\"\n  }\n}\n\nconst formatRefinementKind = (kind: ParseResult.Refinement[\"kind\"]): string => {\n  switch (kind) {\n    case \"From\":\n      return \"From side refinement failure\"\n    case \"Predicate\":\n      return \"Predicate refinement failure\"\n  }\n}\n\nconst getAnnotated = (issue: ParseResult.ParseIssue): Option.Option<AST.Annotated> =>\n  \"ast\" in issue ? Option.some(issue.ast) : Option.none()\n\ninterface CurrentMessage {\n  readonly message: string\n  readonly override: boolean\n}\n\nconst getCurrentMessage = (\n  issue: ParseResult.ParseIssue\n): Effect.Effect<CurrentMessage, Cause.NoSuchElementException> =>\n  getAnnotated(issue).pipe(\n    Option.flatMap(AST.getMessageAnnotation),\n    Effect.flatMap((annotation) => {\n      const out = annotation(issue)\n      return Predicate.isString(out)\n        ? Effect.succeed({ message: out, override: false })\n        : Effect.isEffect(out)\n        ? Effect.map(out, (message) => ({ message, override: false }))\n        : Predicate.isString(out.message)\n        ? Effect.succeed({ message: out.message, override: out.override })\n        : Effect.map(out.message, (message) => ({ message, override: out.override }))\n    })\n  )\n\nconst createParseIssueGuard =\n  <T extends ParseResult.ParseIssue[\"_tag\"]>(tag: T) =>\n  (issue: ParseResult.ParseIssue): issue is Extract<ParseResult.ParseIssue, { _tag: T }> => issue._tag === tag\n\nconst isComposite = createParseIssueGuard(\"Composite\")\nconst isRefinement = createParseIssueGuard(\"Refinement\")\nconst isTransformation = createParseIssueGuard(\"Transformation\")\n\n/** @internal */\nexport const getMessage: (\n  issue: ParseResult.ParseIssue\n) => Effect.Effect<string, Cause.NoSuchElementException> = (issue: ParseResult.ParseIssue) =>\n  getCurrentMessage(issue).pipe(\n    Effect.flatMap((currentMessage) => {\n      const useInnerMessage = !currentMessage.override && (\n        isComposite(issue) ||\n        (isRefinement(issue) && issue.kind === \"From\") ||\n        (isTransformation(issue) && issue.kind !== \"Transformation\")\n      )\n      return useInnerMessage\n        ? isTransformation(issue) || isRefinement(issue) ? getMessage(issue.issue) : Option.none()\n        : Effect.succeed(currentMessage.message)\n    })\n  )\n\nconst getParseIssueTitleAnnotation = (issue: ParseResult.ParseIssue): Option.Option<string> =>\n  getAnnotated(issue).pipe(\n    Option.flatMap(AST.getParseIssueTitleAnnotation),\n    Option.filterMap(\n      (annotation) => Option.fromNullable(annotation(issue))\n    )\n  )\n\n/** @internal */\nexport const formatTypeMessage = (e: ParseResult.Type): Effect.Effect<string> =>\n  getMessage(e).pipe(\n    Effect.orElse(() => getParseIssueTitleAnnotation(e)),\n    Effect.catchAll(() =>\n      Effect.succeed(e.message ?? `Expected ${String(e.ast)}, actual ${util_.formatUnknown(e.actual)}`)\n    )\n  )\n\nconst getParseIssueTitle = (\n  issue: ParseResult.Forbidden | ParseResult.Transformation | ParseResult.Refinement | ParseResult.Composite\n): string => Option.getOrElse(getParseIssueTitleAnnotation(issue), () => String(issue.ast))\n\n/** @internal */\nexport const formatForbiddenMessage = (e: ParseResult.Forbidden): string => e.message ?? \"is forbidden\"\n\n/** @internal */\nexport const formatUnexpectedMessage = (e: ParseResult.Unexpected): string => e.message ?? \"is unexpected\"\n\n/** @internal */\nexport const formatMissingMessage = (e: ParseResult.Missing): Effect.Effect<string> =>\n  AST.getMissingMessageAnnotation(e.ast).pipe(\n    Effect.flatMap((annotation) => {\n      const out = annotation()\n      return Predicate.isString(out) ? Effect.succeed(out) : out\n    }),\n    Effect.catchAll(() => Effect.succeed(e.message ?? \"is missing\"))\n  )\n\nconst getTree = (issue: ParseResult.ParseIssue, onFailure: () => Effect.Effect<Tree<string>>) =>\n  Effect.matchEffect(getMessage(issue), {\n    onFailure,\n    onSuccess: (message) => Effect.succeed(make(message))\n  })\n\nconst go = (\n  e: ParseResult.ParseIssue | ParseResult.Pointer\n): Effect.Effect<Tree<string>> => {\n  switch (e._tag) {\n    case \"Type\":\n      return Effect.map(formatTypeMessage(e), make)\n    case \"Forbidden\":\n      return Effect.succeed(make(getParseIssueTitle(e), [make(formatForbiddenMessage(e))]))\n    case \"Unexpected\":\n      return Effect.succeed(make(formatUnexpectedMessage(e)))\n    case \"Missing\":\n      return Effect.map(formatMissingMessage(e), make)\n    case \"Transformation\":\n      return getTree(e, () =>\n        Effect.map(\n          go(e.issue),\n          (tree) => make(getParseIssueTitle(e), [make(formatTransformationKind(e.kind), [tree])])\n        ))\n    case \"Refinement\":\n      return getTree(\n        e,\n        () =>\n          Effect.map(go(e.issue), (tree) => make(getParseIssueTitle(e), [make(formatRefinementKind(e.kind), [tree])]))\n      )\n    case \"Pointer\":\n      return Effect.map(go(e.issue), (tree) => make(util_.formatPath(e.path), [tree]))\n    case \"Composite\": {\n      const parseIssueTitle = getParseIssueTitle(e)\n      return getTree(\n        e,\n        () =>\n          util_.isNonEmpty(e.issues)\n            ? Effect.map(Effect.forEach(e.issues, go), (forest) => make(parseIssueTitle, forest))\n            : Effect.map(go(e.issues), (tree) => make(parseIssueTitle, [tree]))\n      )\n    }\n  }\n}\n"],"names":["Effect","Option","Predicate","AST","util_","make","value","forest","formatIssue","issue","map","go","tree","drawTree","formatIssueSync","runSync","formatError","error","formatErrorSync","draw","indentation","r","len","length","i","isLast","formatTransformationKind","kind","formatRefinementKind","getAnnotated","some","ast","none","getCurrentMessage","pipe","flatMap","getMessageAnnotation","annotation","out","isString","succeed","message","override","isEffect","createParseIssueGuard","tag","_tag","isComposite","isRefinement","isTransformation","getMessage","currentMessage","useInnerMessage","getParseIssueTitleAnnotation","filterMap","fromNullable","formatTypeMessage","e","orElse","catchAll","String","formatUnknown","actual","getParseIssueTitle","getOrElse","formatForbiddenMessage","formatUnexpectedMessage","formatMissingMessage","getMissingMessageAnnotation","getTree","onFailure","matchEffect","onSuccess","formatPath","path","parseIssueTitle","isNonEmpty","issues","forEach"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 3219, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/ParseResult.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/ParseResult.ts"],"sourcesContent":["/**\n * @since 0.67.0\n */\n\nimport * as array_ from \"effect/Array\"\nimport { TaggedError } from \"effect/Data\"\nimport * as Effect from \"effect/Effect\"\nimport * as Either from \"effect/Either\"\nimport type { LazyArg } from \"effect/Function\"\nimport { dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport type { Concurrency } from \"effect/Types\"\nimport * as AST from \"./AST.js\"\nimport * as util_ from \"./internal/util.js\"\nimport type * as Schema from \"./Schema.js\"\nimport * as TreeFormatter from \"./TreeFormatter.js\"\n\n/**\n * `ParseIssue` is a type that represents the different types of errors that can occur when decoding/encoding a value.\n *\n * @category model\n * @since 0.67.0\n */\nexport type ParseIssue =\n  // leaf\n  | Type\n  | Missing\n  | Unexpected\n  | Forbidden\n  // composite\n  | Pointer\n  | Refinement\n  | Transformation\n  | Composite\n\n/**\n * @category model\n * @since 0.68.0\n */\nexport type SingleOrNonEmpty<A> = A | array_.NonEmptyReadonlyArray<A>\n\n/**\n * @category model\n * @since 0.68.0\n */\nexport type Path = SingleOrNonEmpty<PropertyKey>\n\n/**\n * @category model\n * @since 0.68.0\n */\nexport class Pointer {\n  /**\n   * @since 0.68.0\n   */\n  readonly _tag = \"Pointer\"\n  constructor(\n    readonly path: Path,\n    readonly actual: unknown,\n    readonly issue: ParseIssue\n  ) {}\n}\n\n/**\n * Error that occurs when an unexpected key or index is present.\n *\n * @category model\n * @since 0.67.0\n */\nexport class Unexpected {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Unexpected\"\n  constructor(\n    readonly actual: unknown,\n    /**\n     * @since 0.68.0\n     */\n    readonly message?: string\n  ) {}\n}\n\n/**\n * Error that occurs when a required key or index is missing.\n *\n * @category model\n * @since 0.67.0\n */\nexport class Missing {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Missing\"\n  /**\n   * @since 0.68.0\n   */\n  readonly actual = undefined\n  constructor(\n    /**\n     * @since 0.68.0\n     */\n    readonly ast: AST.Annotated,\n    /**\n     * @since 0.68.0\n     */\n    readonly message?: string\n  ) {}\n}\n\n/**\n * Error that contains multiple issues.\n *\n * @category model\n * @since 0.68.0\n */\nexport class Composite {\n  /**\n   * @since 0.68.0\n   */\n  readonly _tag = \"Composite\"\n  constructor(\n    readonly ast: AST.Annotated,\n    readonly actual: unknown,\n    readonly issues: SingleOrNonEmpty<ParseIssue>,\n    readonly output?: unknown\n  ) {}\n}\n\n/**\n * Returns `true` if the value is a `Composite`.\n *\n * @category guards\n * @since 0.68.0\n */\nexport const isComposite = (u: unknown): u is Composite => Predicate.hasProperty(u, \"_tag\")\n\n/**\n * Error that occurs when a refinement has an error.\n *\n * @category model\n * @since 0.67.0\n */\nexport class Refinement {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Refinement\"\n  constructor(\n    readonly ast: AST.Refinement,\n    readonly actual: unknown,\n    readonly kind: \"From\" | \"Predicate\",\n    readonly issue: ParseIssue\n  ) {}\n}\n\n/**\n * Error that occurs when a transformation has an error.\n *\n * @category model\n * @since 0.67.0\n */\nexport class Transformation {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Transformation\"\n  constructor(\n    readonly ast: AST.Transformation,\n    readonly actual: unknown,\n    readonly kind: \"Encoded\" | \"Transformation\" | \"Type\",\n    readonly issue: ParseIssue\n  ) {}\n}\n\n/**\n * The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.\n * The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.\n *\n * @category model\n * @since 0.67.0\n */\nexport class Type {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Type\"\n  constructor(\n    readonly ast: AST.Annotated,\n    readonly actual: unknown,\n    readonly message?: string\n  ) {}\n}\n\n/**\n * The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).\n *\n * @category model\n * @since 0.67.0\n */\nexport class Forbidden {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"Forbidden\"\n  constructor(\n    readonly ast: AST.Annotated,\n    readonly actual: unknown,\n    readonly message?: string\n  ) {}\n}\n\n/**\n * @category type id\n * @since 0.68.0\n */\nexport const ParseErrorTypeId: unique symbol = Symbol.for(\"@effect/schema/ParseErrorTypeId\")\n\n/**\n * @category type id\n * @since 0.68.0\n */\nexport type ParseErrorTypeId = typeof ParseErrorTypeId\n\n/**\n * @since 0.68.0\n */\nexport const isParseError = (u: unknown): u is ParseError => Predicate.hasProperty(u, ParseErrorTypeId)\n\n/**\n * @since 0.67.0\n */\nexport class ParseError extends TaggedError(\"ParseError\")<{ readonly issue: ParseIssue }> {\n  /**\n   * @since 0.68.0\n   */\n  readonly [ParseErrorTypeId] = ParseErrorTypeId\n\n  get message() {\n    return this.toString()\n  }\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return TreeFormatter.formatIssueSync(this.issue)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toJSON() {\n    return {\n      _id: \"ParseError\",\n      message: this.toString()\n    }\n  }\n  /**\n   * @since 0.67.0\n   */\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const parseError = (issue: ParseIssue): ParseError => new ParseError({ issue })\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const succeed: <A>(a: A) => Either.Either<A, ParseIssue> = Either.right\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const fail: (issue: ParseIssue) => Either.Either<never, ParseIssue> = Either.left\n\nconst _try: <A>(options: {\n  try: LazyArg<A>\n  catch: (e: unknown) => ParseIssue\n}) => Either.Either<A, ParseIssue> = Either.try\n\nexport {\n  /**\n   * @category constructors\n   * @since 0.67.0\n   */\n  _try as try\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const fromOption: {\n  (onNone: () => ParseIssue): <A>(self: Option.Option<A>) => Either.Either<A, ParseIssue>\n  <A>(self: Option.Option<A>, onNone: () => ParseIssue): Either.Either<A, ParseIssue>\n} = Either.fromOption\n\n/**\n * @category optimisation\n * @since 0.67.0\n */\nexport const flatMap: {\n  <A, B, E1, R1>(\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>\n  <A, E, R, B, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ): Effect.Effect<B, E | E1, R | R1>\n} = dual(2, <A, E, R, B, E1, R1>(\n  self: Effect.Effect<A, E, R>,\n  f: (a: A) => Effect.Effect<B, E1, R1>\n): Effect.Effect<B, E | E1, R | R1> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return s\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return f(s.right)\n  }\n  return Effect.flatMap(self, f)\n})\n\n/**\n * @category optimisation\n * @since 0.67.0\n */\nexport const map: {\n  <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>\n} = dual(2, <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return s\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return Either.right(f(s.right))\n  }\n  return Effect.map(self, f)\n})\n\n/**\n * @category optimisation\n * @since 0.67.0\n */\nexport const mapError: {\n  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>\n} = dual(2, <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return Either.left(f(s.left))\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return s\n  }\n  return Effect.mapError(self, f)\n})\n\n/**\n * @category optimisation\n * @since 0.67.0\n */\nexport const eitherOrUndefined = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Either.Either<A, E> | undefined => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\" || s[\"_tag\"] === \"Right\") {\n    return s\n  }\n}\n\n/**\n * @category optimisation\n * @since 0.67.0\n */\nexport const mapBoth: {\n  <E, E2, A, A2>(\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>\n  <A, E, R, E2, A2>(\n    self: Effect.Effect<A, E, R>,\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): Effect.Effect<A2, E2, R>\n} = dual(2, <A, E, R, E2, A2>(\n  self: Effect.Effect<A, E, R>,\n  options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n): Effect.Effect<A2, E2, R> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return Either.left(options.onFailure(s.left))\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return Either.right(options.onSuccess(s.right))\n  }\n  return Effect.mapBoth(self, options)\n})\n\n/**\n * @category optimisation\n * @since 0.67.0\n */\nexport const orElse: {\n  <E, A2, E2, R2>(\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (e: E) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A2 | A, E2, R2 | R> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return f(s.left)\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return s\n  }\n  return Effect.catchAll(self, f)\n})\n\n/**\n * @since 0.67.0\n */\nexport type DecodeUnknown<Out, R> = (u: unknown, options?: AST.ParseOptions) => Effect.Effect<Out, ParseIssue, R>\n\n/**\n * @since 0.67.0\n */\nexport type DeclarationDecodeUnknown<Out, R> = (\n  u: unknown,\n  options: AST.ParseOptions,\n  ast: AST.Declaration\n) => Effect.Effect<Out, ParseIssue, R>\n\n/** @internal */\nexport const mergeInternalOptions = (\n  options: InternalOptions | undefined,\n  overrideOptions: InternalOptions | number | undefined\n): InternalOptions | undefined => {\n  if (overrideOptions === undefined || Predicate.isNumber(overrideOptions)) {\n    return options\n  }\n  if (options === undefined) {\n    return overrideOptions\n  }\n  return { ...options, ...overrideOptions }\n}\n\nconst getEither = (ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {\n  const parser = goMemo(ast, isDecoding)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): Either.Either<any, ParseIssue> =>\n    parser(u, mergeInternalOptions(options, overrideOptions)) as any\n}\n\nconst getSync = (ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {\n  const parser = getEither(ast, isDecoding, options)\n  return (input: unknown, overrideOptions?: AST.ParseOptions) =>\n    Either.getOrThrowWith(parser(input, overrideOptions), parseError)\n}\n\nconst getOption = (ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {\n  const parser = getEither(ast, isDecoding, options)\n  return (input: unknown, overrideOptions?: AST.ParseOptions): Option.Option<any> =>\n    Option.getRight(parser(input, overrideOptions))\n}\n\nconst getEffect = <R>(ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {\n  const parser = goMemo(ast, isDecoding)\n  return (input: unknown, overrideOptions?: AST.ParseOptions): Effect.Effect<any, ParseIssue, R> =>\n    parser(input, { ...mergeInternalOptions(options, overrideOptions), isEffectAllowed: true })\n}\n\n/**\n * @throws `ParseError`\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeUnknownSync = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => A => getSync(schema.ast, true, options)\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeUnknownOption = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A> => getOption(schema.ast, true, options)\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeUnknownEither = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue> =>\n  getEither(schema.ast, true, options)\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeUnknownPromise = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => {\n  const parser = decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeUnknown = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R> =>\n  getEffect(schema.ast, true, options)\n\n/**\n * @throws `ParseError`\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeUnknownSync = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => I => getSync(schema.ast, false, options)\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeUnknownOption = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<I> => getOption(schema.ast, false, options)\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeUnknownEither = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue> =>\n  getEither(schema.ast, false, options)\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeUnknownPromise = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => {\n  const parser = encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeUnknown = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R> =>\n  getEffect(schema.ast, false, options)\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeSync: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => A = decodeUnknownSync\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeOption: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => Option.Option<A> = decodeUnknownOption\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeEither: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue> = decodeUnknownEither\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodePromise: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => Promise<A> = decodeUnknownPromise\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decode: <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R> = decodeUnknown\n\n/**\n * @throws `ParseError`\n * @category validation\n * @since 0.67.0\n */\nexport const validateSync = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => A => getSync(AST.typeAST(schema.ast), true, options)\n\n/**\n * @category validation\n * @since 0.67.0\n */\nexport const validateOption = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A> =>\n  getOption(AST.typeAST(schema.ast), true, options)\n\n/**\n * @category validation\n * @since 0.67.0\n */\nexport const validateEither = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue> =>\n  getEither(AST.typeAST(schema.ast), true, options)\n\n/**\n * @category validation\n * @since 0.67.0\n */\nexport const validatePromise = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => {\n  const parser = validate(schema, options)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category validation\n * @since 0.67.0\n */\nexport const validate = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (a: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R> =>\n  getEffect(AST.typeAST(schema.ast), true, options)\n\n/**\n * By default the option `exact` is set to `true`.\n *\n * @category validation\n * @since 0.67.0\n */\nexport const is = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => {\n  const parser = goMemo(AST.typeAST(schema.ast), true)\n  return (u: unknown, overrideOptions?: AST.ParseOptions | number): u is A =>\n    Either.isRight(parser(u, { exact: true, ...mergeInternalOptions(options, overrideOptions) }) as any)\n}\n\n/**\n * By default the option `exact` is set to `true`.\n *\n * @throws `ParseError`\n * @category validation\n * @since 0.67.0\n */\nexport const asserts = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => {\n  const parser = goMemo(AST.typeAST(schema.ast), true)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): asserts u is A => {\n    const result: Either.Either<any, ParseIssue> = parser(u, {\n      exact: true,\n      ...mergeInternalOptions(options, overrideOptions)\n    }) as any\n    if (Either.isLeft(result)) {\n      throw parseError(result.left)\n    }\n  }\n}\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeSync: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (a: A, overrideOptions?: AST.ParseOptions) => I = encodeUnknownSync\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeOption: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (input: A, overrideOptions?: AST.ParseOptions) => Option.Option<I> = encodeUnknownOption\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeEither: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (a: A, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue> = encodeUnknownEither\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodePromise: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (a: A, overrideOptions?: AST.ParseOptions) => Promise<I> = encodeUnknownPromise\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encode: <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n) => (a: A, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R> = encodeUnknown\n\ninterface InternalOptions extends AST.ParseOptions {\n  readonly isEffectAllowed?: boolean\n}\n\ninterface Parser {\n  (i: any, options?: InternalOptions): Effect.Effect<any, ParseIssue, any>\n}\n\nconst decodeMemoMap = globalValue(\n  Symbol.for(\"@effect/schema/Parser/decodeMemoMap\"),\n  () => new WeakMap<AST.AST, Parser>()\n)\nconst encodeMemoMap = globalValue(\n  Symbol.for(\"@effect/schema/Parser/encodeMemoMap\"),\n  () => new WeakMap<AST.AST, Parser>()\n)\n\nconst goMemo = (ast: AST.AST, isDecoding: boolean): Parser => {\n  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap\n  const memo = memoMap.get(ast)\n  if (memo) {\n    return memo\n  }\n  const raw = go(ast, isDecoding)\n  const parseOptionsAnnotation = AST.getParseOptionsAnnotation(ast)\n  const parser: Parser = Option.isSome(parseOptionsAnnotation)\n    ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value))\n    : raw\n  memoMap.set(ast, parser)\n  return parser\n}\n\nconst getConcurrency = (ast: AST.AST): Concurrency | undefined =>\n  Option.getOrUndefined(AST.getConcurrencyAnnotation(ast))\n\nconst getBatching = (ast: AST.AST): boolean | \"inherit\" | undefined =>\n  Option.getOrUndefined(AST.getBatchingAnnotation(ast))\n\nconst go = (ast: AST.AST, isDecoding: boolean): Parser => {\n  switch (ast._tag) {\n    case \"Refinement\": {\n      if (isDecoding) {\n        const from = goMemo(ast.from, true)\n        return (i, options) =>\n          handleForbidden(\n            flatMap(\n              mapError(from(i, options), (e) => new Refinement(ast, i, \"From\", e)),\n              (a) =>\n                Option.match(\n                  ast.filter(a, options ?? AST.defaultParseOption, ast),\n                  {\n                    onNone: () => Either.right(a),\n                    onSome: (e) => Either.left(new Refinement(ast, i, \"Predicate\", e))\n                  }\n                )\n            ),\n            ast,\n            i,\n            options\n          )\n      } else {\n        const from = goMemo(AST.typeAST(ast), true)\n        const to = goMemo(dropRightRefinement(ast.from), false)\n        return (i, options) => handleForbidden(flatMap(from(i, options), (a) => to(a, options)), ast, i, options)\n      }\n    }\n    case \"Transformation\": {\n      const transform = getFinalTransformation(ast.transformation, isDecoding)\n      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false)\n      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false)\n      return (i1, options) =>\n        handleForbidden(\n          flatMap(\n            mapError(\n              from(i1, options),\n              (e) => new Transformation(ast, i1, isDecoding ? \"Encoded\" : \"Type\", e)\n            ),\n            (a) =>\n              flatMap(\n                mapError(\n                  transform(a, options ?? AST.defaultParseOption, ast),\n                  (e) => new Transformation(ast, i1, \"Transformation\", e)\n                ),\n                (i2) =>\n                  mapError(\n                    to(i2, options),\n                    (e) => new Transformation(ast, i1, isDecoding ? \"Type\" : \"Encoded\", e)\n                  )\n              )\n          ),\n          ast,\n          i1,\n          options\n        )\n    }\n    case \"Declaration\": {\n      const parse = isDecoding\n        ? ast.decodeUnknown(...ast.typeParameters)\n        : ast.encodeUnknown(...ast.typeParameters)\n      return (i, options) => handleForbidden(parse(i, options ?? AST.defaultParseOption, ast), ast, i, options)\n    }\n    case \"Literal\":\n      return fromRefinement(ast, (u): u is typeof ast.literal => u === ast.literal)\n    case \"UniqueSymbol\":\n      return fromRefinement(ast, (u): u is typeof ast.symbol => u === ast.symbol)\n    case \"UndefinedKeyword\":\n      return fromRefinement(ast, Predicate.isUndefined)\n    case \"VoidKeyword\":\n      return fromRefinement(ast, Predicate.isUndefined)\n    case \"NeverKeyword\":\n      return fromRefinement(ast, Predicate.isNever)\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return Either.right\n    case \"StringKeyword\":\n      return fromRefinement(ast, Predicate.isString)\n    case \"NumberKeyword\":\n      return fromRefinement(ast, Predicate.isNumber)\n    case \"BooleanKeyword\":\n      return fromRefinement(ast, Predicate.isBoolean)\n    case \"BigIntKeyword\":\n      return fromRefinement(ast, Predicate.isBigInt)\n    case \"SymbolKeyword\":\n      return fromRefinement(ast, Predicate.isSymbol)\n    case \"ObjectKeyword\":\n      return fromRefinement(ast, Predicate.isObject)\n    case \"Enums\":\n      return fromRefinement(ast, (u): u is any => ast.enums.some(([_, value]) => value === u))\n    case \"TemplateLiteral\": {\n      const regex = AST.getTemplateLiteralRegExp(ast)\n      return fromRefinement(ast, (u): u is any => Predicate.isString(u) && regex.test(u))\n    }\n    case \"TupleType\": {\n      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding))\n      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding))\n      let requiredTypes: Array<AST.Type> = ast.elements.filter((e) => !e.isOptional)\n      if (ast.rest.length > 0) {\n        requiredTypes = requiredTypes.concat(ast.rest.slice(1))\n      }\n      const requiredLen = requiredTypes.length\n      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(\" | \") : \"never\"\n      const concurrency = getConcurrency(ast)\n      const batching = getBatching(ast)\n      return (input: unknown, options) => {\n        if (!array_.isArray(input)) {\n          return Either.left(new Type(ast, input))\n        }\n        const allErrors = options?.errors === \"all\"\n        const es: Array<[number, ParseIssue]> = []\n        let stepKey = 0\n        const output: Array<[number, any]> = []\n        // ---------------------------------------------\n        // handle missing indexes\n        // ---------------------------------------------\n        const len = input.length\n        for (let i = len; i <= requiredLen - 1; i++) {\n          const e = new Pointer(i, input, new Missing(requiredTypes[i - len]))\n          if (allErrors) {\n            es.push([stepKey++, e])\n            continue\n          } else {\n            return Either.left(new Composite(ast, input, e, output))\n          }\n        }\n\n        // ---------------------------------------------\n        // handle excess indexes\n        // ---------------------------------------------\n        if (ast.rest.length === 0) {\n          for (let i = ast.elements.length; i <= len - 1; i++) {\n            const e = new Pointer(i, input, new Unexpected(input[i], `is unexpected, expected: ${expectedIndexes}`))\n            if (allErrors) {\n              es.push([stepKey++, e])\n              continue\n            } else {\n              return Either.left(new Composite(ast, input, e, output))\n            }\n          }\n        }\n\n        let i = 0\n        type State = {\n          es: typeof es\n          output: typeof output\n        }\n        let queue:\n          | Array<(_: State) => Effect.Effect<void, ParseIssue, any>>\n          | undefined = undefined\n\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        for (; i < elements.length; i++) {\n          if (len < i + 1) {\n            if (ast.elements[i].isOptional) {\n              // the input element is missing\n              continue\n            }\n          } else {\n            const parser = elements[i]\n            const te = parser(input[i], options)\n            const eu = eitherOrUndefined(te)\n            if (eu) {\n              if (Either.isLeft(eu)) {\n                // the input element is present but is not valid\n                const e = new Pointer(i, input, eu.left)\n                if (allErrors) {\n                  es.push([stepKey++, e])\n                  continue\n                } else {\n                  return Either.left(new Composite(ast, input, e, sortByIndex(output)))\n                }\n              }\n              output.push([stepKey++, eu.right])\n            } else {\n              const nk = stepKey++\n              const index = i\n              if (!queue) {\n                queue = []\n              }\n              queue.push(({ es, output }: State) =>\n                Effect.flatMap(Effect.either(te), (t) => {\n                  if (Either.isLeft(t)) {\n                    // the input element is present but is not valid\n                    const e = new Pointer(index, input, t.left)\n                    if (allErrors) {\n                      es.push([nk, e])\n                      return Effect.void\n                    } else {\n                      return Either.left(new Composite(ast, input, e, sortByIndex(output)))\n                    }\n                  }\n                  output.push([nk, t.right])\n                  return Effect.void\n                })\n              )\n            }\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (array_.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          for (; i < len - tail.length; i++) {\n            const te = head(input[i], options)\n            const eu = eitherOrUndefined(te)\n            if (eu) {\n              if (Either.isLeft(eu)) {\n                const e = new Pointer(i, input, eu.left)\n                if (allErrors) {\n                  es.push([stepKey++, e])\n                  continue\n                } else {\n                  return Either.left(new Composite(ast, input, e, sortByIndex(output)))\n                }\n              } else {\n                output.push([stepKey++, eu.right])\n              }\n            } else {\n              const nk = stepKey++\n              const index = i\n              if (!queue) {\n                queue = []\n              }\n              queue.push(\n                ({ es, output }: State) =>\n                  Effect.flatMap(Effect.either(te), (t) => {\n                    if (Either.isLeft(t)) {\n                      const e = new Pointer(index, input, t.left)\n                      if (allErrors) {\n                        es.push([nk, e])\n                        return Effect.void\n                      } else {\n                        return Either.left(new Composite(ast, input, e, sortByIndex(output)))\n                      }\n                    } else {\n                      output.push([nk, t.right])\n                      return Effect.void\n                    }\n                  })\n              )\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            i += j\n            if (len < i + 1) {\n              continue\n            } else {\n              const te = tail[j](input[i], options)\n              const eu = eitherOrUndefined(te)\n              if (eu) {\n                if (Either.isLeft(eu)) {\n                  // the input element is present but is not valid\n                  const e = new Pointer(i, input, eu.left)\n                  if (allErrors) {\n                    es.push([stepKey++, e])\n                    continue\n                  } else {\n                    return Either.left(new Composite(ast, input, e, sortByIndex(output)))\n                  }\n                }\n                output.push([stepKey++, eu.right])\n              } else {\n                const nk = stepKey++\n                const index = i\n                if (!queue) {\n                  queue = []\n                }\n                queue.push(\n                  ({ es, output }: State) =>\n                    Effect.flatMap(Effect.either(te), (t) => {\n                      if (Either.isLeft(t)) {\n                        // the input element is present but is not valid\n                        const e = new Pointer(index, input, t.left)\n                        if (allErrors) {\n                          es.push([nk, e])\n                          return Effect.void\n                        } else {\n                          return Either.left(new Composite(ast, input, e, sortByIndex(output)))\n                        }\n                      }\n                      output.push([nk, t.right])\n                      return Effect.void\n                    })\n                )\n              }\n            }\n          }\n        }\n\n        // ---------------------------------------------\n        // compute result\n        // ---------------------------------------------\n        const computeResult = ({ es, output }: State) =>\n          array_.isNonEmptyArray(es) ?\n            Either.left(new Composite(ast, input, sortByIndex(es), sortByIndex(output))) :\n            Either.right(sortByIndex(output))\n        if (queue && queue.length > 0) {\n          const cqueue = queue\n          return Effect.suspend(() => {\n            const state: State = {\n              es: array_.copy(es),\n              output: array_.copy(output)\n            }\n            return Effect.flatMap(\n              Effect.forEach(cqueue, (f) => f(state), { concurrency, batching, discard: true }),\n              () => computeResult(state)\n            )\n          })\n        }\n        return computeResult({ output, es })\n      }\n    }\n    case \"TypeLiteral\": {\n      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n        return fromRefinement(ast, Predicate.isNotNullable)\n      }\n\n      const propertySignatures: Array<readonly [Parser, AST.PropertySignature]> = []\n      const expectedKeysMap: Record<PropertyKey, null> = {}\n      const expectedKeys: Array<PropertyKey> = []\n      for (const ps of ast.propertySignatures) {\n        propertySignatures.push([goMemo(ps.type, isDecoding), ps])\n        expectedKeysMap[ps.name] = null\n        expectedKeys.push(ps.name)\n      }\n\n      const indexSignatures = ast.indexSignatures.map((is) =>\n        [\n          goMemo(is.parameter, isDecoding),\n          goMemo(is.type, isDecoding),\n          is.parameter\n        ] as const\n      )\n      const expectedAST = AST.Union.make(\n        ast.indexSignatures.map((is): AST.AST => is.parameter).concat(\n          expectedKeys.map((key) => Predicate.isSymbol(key) ? new AST.UniqueSymbol(key) : new AST.Literal(key))\n        )\n      )\n      const expected = goMemo(expectedAST, isDecoding)\n      const concurrency = getConcurrency(ast)\n      const batching = getBatching(ast)\n      return (input: unknown, options) => {\n        if (!Predicate.isRecord(input)) {\n          return Either.left(new Type(ast, input))\n        }\n        const allErrors = options?.errors === \"all\"\n        const es: Array<[number, ParseIssue]> = []\n        let stepKey = 0\n\n        // ---------------------------------------------\n        // handle excess properties\n        // ---------------------------------------------\n        const onExcessPropertyError = options?.onExcessProperty === \"error\"\n        const onExcessPropertyPreserve = options?.onExcessProperty === \"preserve\"\n        const output: Record<PropertyKey, unknown> = {}\n        let inputKeys: Array<PropertyKey> | undefined\n        if (onExcessPropertyError || onExcessPropertyPreserve) {\n          inputKeys = util_.ownKeys(input)\n          for (const key of inputKeys) {\n            const eu = eitherOrUndefined(expected(key, options))!\n            if (Either.isLeft(eu)) {\n              // key is unexpected\n              if (onExcessPropertyError) {\n                const e = new Pointer(\n                  key,\n                  input,\n                  new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`)\n                )\n                if (allErrors) {\n                  es.push([stepKey++, e])\n                  continue\n                } else {\n                  return Either.left(new Composite(ast, input, e, output))\n                }\n              } else {\n                // preserve key\n                output[key] = input[key]\n              }\n            }\n          }\n        }\n\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        type State = {\n          es: typeof es\n          output: typeof output\n        }\n        let queue:\n          | Array<(state: State) => Effect.Effect<void, ParseIssue, any>>\n          | undefined = undefined\n\n        const isExact = options?.exact === true\n        for (let i = 0; i < propertySignatures.length; i++) {\n          const ps = propertySignatures[i][1]\n          const name = ps.name\n          const hasKey = Object.prototype.hasOwnProperty.call(input, name)\n          if (!hasKey) {\n            if (ps.isOptional) {\n              continue\n            } else if (isExact) {\n              const e = new Pointer(name, input, new Missing(ps))\n              if (allErrors) {\n                es.push([stepKey++, e])\n                continue\n              } else {\n                return Either.left(new Composite(ast, input, e, output))\n              }\n            }\n          }\n          const parser = propertySignatures[i][0]\n          const te = parser(input[name], options)\n          const eu = eitherOrUndefined(te)\n          if (eu) {\n            if (Either.isLeft(eu)) {\n              const e = new Pointer(name, input, hasKey ? eu.left : new Missing(ps))\n              if (allErrors) {\n                es.push([stepKey++, e])\n                continue\n              } else {\n                return Either.left(new Composite(ast, input, e, output))\n              }\n            }\n            output[name] = eu.right\n          } else {\n            const nk = stepKey++\n            const index = name\n            if (!queue) {\n              queue = []\n            }\n            queue.push(\n              ({ es, output }: State) =>\n                Effect.flatMap(Effect.either(te), (t) => {\n                  if (Either.isLeft(t)) {\n                    const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps))\n                    if (allErrors) {\n                      es.push([nk, e])\n                      return Effect.void\n                    } else {\n                      return Either.left(new Composite(ast, input, e, output))\n                    }\n                  }\n                  output[index] = t.right\n                  return Effect.void\n                })\n            )\n          }\n        }\n\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const indexSignature = indexSignatures[i]\n          const parameter = indexSignature[0]\n          const type = indexSignature[1]\n          const keys = util_.getKeysForIndexSignature(input, indexSignature[2])\n          for (const key of keys) {\n            // ---------------------------------------------\n            // handle keys\n            // ---------------------------------------------\n            const keu = eitherOrUndefined(parameter(key, options))\n            if (keu && Either.isRight(keu)) {\n              // ---------------------------------------------\n              // handle values\n              // ---------------------------------------------\n              const vpr = type(input[key], options)\n              const veu = eitherOrUndefined(vpr)\n              if (veu) {\n                if (Either.isLeft(veu)) {\n                  const e = new Pointer(key, input, veu.left)\n                  if (allErrors) {\n                    es.push([stepKey++, e])\n                    continue\n                  } else {\n                    return Either.left(new Composite(ast, input, e, output))\n                  }\n                } else {\n                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {\n                    output[key] = veu.right\n                  }\n                }\n              } else {\n                const nk = stepKey++\n                const index = key\n                if (!queue) {\n                  queue = []\n                }\n                queue.push(\n                  ({ es, output }: State) =>\n                    Effect.flatMap(\n                      Effect.either(vpr),\n                      (tv) => {\n                        if (Either.isLeft(tv)) {\n                          const e = new Pointer(index, input, tv.left)\n                          if (allErrors) {\n                            es.push([nk, e])\n                            return Effect.void\n                          } else {\n                            return Either.left(new Composite(ast, input, e, output))\n                          }\n                        } else {\n                          if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {\n                            output[key] = tv.right\n                          }\n                          return Effect.void\n                        }\n                      }\n                    )\n                )\n              }\n            }\n          }\n        }\n        // ---------------------------------------------\n        // compute result\n        // ---------------------------------------------\n        const computeResult = ({ es, output }: State) => {\n          if (array_.isNonEmptyArray(es)) {\n            return Either.left(new Composite(ast, input, sortByIndex(es), output))\n          }\n          if (options?.propertyOrder === \"original\") {\n            // preserve input keys order\n            const keys = inputKeys || util_.ownKeys(input)\n            for (const name of expectedKeys) {\n              if (keys.indexOf(name) === -1) {\n                keys.push(name)\n              }\n            }\n            const out: any = {}\n            for (const key of keys) {\n              if (Object.prototype.hasOwnProperty.call(output, key)) {\n                out[key] = output[key]\n              }\n            }\n            return Either.right(out)\n          }\n          return Either.right(output)\n        }\n        if (queue && queue.length > 0) {\n          const cqueue = queue\n          return Effect.suspend(() => {\n            const state: State = {\n              es: array_.copy(es),\n              output: Object.assign({}, output)\n            }\n            return Effect.flatMap(\n              Effect.forEach(cqueue, (f) => f(state), { concurrency, batching, discard: true }),\n              () => computeResult(state)\n            )\n          })\n        }\n        return computeResult({ es, output })\n      }\n    }\n    case \"Union\": {\n      const searchTree = getSearchTree(ast.types, isDecoding)\n      const ownKeys = util_.ownKeys(searchTree.keys)\n      const len = ownKeys.length\n      const map = new Map<any, Parser>()\n      for (let i = 0; i < ast.types.length; i++) {\n        map.set(ast.types[i], goMemo(ast.types[i], isDecoding))\n      }\n      const concurrency = getConcurrency(ast) ?? 1\n      const batching = getBatching(ast)\n      return (input, options) => {\n        const es: Array<[number, ParseIssue]> = []\n        let stepKey = 0\n        let candidates: Array<AST.AST> = []\n        if (len > 0) {\n          // if there is at least one key then input must be an object\n          if (Predicate.isRecord(input)) {\n            for (let i = 0; i < len; i++) {\n              const name = ownKeys[i]\n              const buckets = searchTree.keys[name].buckets\n              // for each property that should contain a literal, check if the input contains that property\n              if (Object.prototype.hasOwnProperty.call(input, name)) {\n                const literal = String(input[name])\n                // check that the value obtained from the input for the property corresponds to an existing bucket\n                if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                  // retrive the minimal set of candidates for decoding\n                  candidates = candidates.concat(buckets[literal])\n                } else {\n                  const literals = AST.Union.make(searchTree.keys[name].literals)\n                  es.push([\n                    stepKey++,\n                    new Composite(\n                      new AST.TypeLiteral([\n                        new AST.PropertySignature(name, literals, false, true)\n                      ], []),\n                      input,\n                      new Pointer(name, input, new Type(literals, input[name]))\n                    )\n                  ])\n                }\n              } else {\n                const literals = AST.Union.make(searchTree.keys[name].literals)\n                const fakeps = new AST.PropertySignature(name, literals, false, true) // TODO: inherit message annotation from the union?\n                es.push([\n                  stepKey++,\n                  new Composite(\n                    new AST.TypeLiteral([fakeps], []),\n                    input,\n                    new Pointer(name, input, new Missing(fakeps))\n                  )\n                ])\n              }\n            }\n          } else {\n            es.push([stepKey++, new Type(ast, input)])\n          }\n        }\n        if (searchTree.otherwise.length > 0) {\n          candidates = candidates.concat(searchTree.otherwise)\n        }\n\n        let queue:\n          | Array<(state: State) => Effect.Effect<unknown, ParseIssue, any>>\n          | undefined = undefined\n\n        type State = {\n          finalResult?: any\n          es: typeof es\n        }\n\n        for (let i = 0; i < candidates.length; i++) {\n          const candidate = candidates[i]\n          const pr = map.get(candidate)!(input, options)\n          // the members of a union are ordered based on which one should be decoded first,\n          // therefore if one member has added a task, all subsequent members must\n          // also add a task to the queue even if they are synchronous\n          const eu = !queue || queue.length === 0 ? eitherOrUndefined(pr) : undefined\n          if (eu) {\n            if (Either.isRight(eu)) {\n              return Either.right(eu.right)\n            } else {\n              es.push([stepKey++, eu.left])\n            }\n          } else {\n            const nk = stepKey++\n            if (!queue) {\n              queue = []\n            }\n            queue.push(\n              (state) =>\n                Effect.suspend(() => {\n                  if (\"finalResult\" in state) {\n                    return Effect.void\n                  } else {\n                    return Effect.flatMap(Effect.either(pr), (t) => {\n                      if (Either.isRight(t)) {\n                        state.finalResult = Either.right(t.right)\n                      } else {\n                        state.es.push([nk, t.left])\n                      }\n                      return Effect.void\n                    })\n                  }\n                })\n            )\n          }\n        }\n\n        // ---------------------------------------------\n        // compute result\n        // ---------------------------------------------\n        const computeResult = (es: State[\"es\"]) =>\n          array_.isNonEmptyArray(es) ?\n            es.length === 1 && es[0][1]._tag === \"Type\" ?\n              Either.left(es[0][1]) :\n              Either.left(new Composite(ast, input, sortByIndex(es))) :\n            // this should never happen\n            Either.left(new Type(ast, input))\n\n        if (queue && queue.length > 0) {\n          const cqueue = queue\n          return Effect.suspend(() => {\n            const state: State = { es: array_.copy(es) }\n            return Effect.flatMap(\n              Effect.forEach(cqueue, (f) => f(state), { concurrency, batching, discard: true }),\n              () => {\n                if (\"finalResult\" in state) {\n                  return state.finalResult\n                }\n                return computeResult(state.es)\n              }\n            )\n          })\n        }\n        return computeResult(es)\n      }\n    }\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => goMemo(AST.annotations(ast.f(), ast.annotations), isDecoding))\n      return (a, options) => get()(a, options)\n    }\n  }\n}\n\nconst fromRefinement = <A>(ast: AST.AST, refinement: (u: unknown) => u is A): Parser => (u) =>\n  refinement(u) ? Either.right(u) : Either.left(new Type(ast, u))\n\n/** @internal */\nexport const getLiterals = (\n  ast: AST.AST,\n  isDecoding: boolean\n): ReadonlyArray<[PropertyKey, AST.Literal]> => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = AST.getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return getLiterals(annotation.value, isDecoding)\n      }\n      break\n    }\n    case \"TypeLiteral\": {\n      const out: Array<[PropertyKey, AST.Literal]> = []\n      for (let i = 0; i < ast.propertySignatures.length; i++) {\n        const propertySignature = ast.propertySignatures[i]\n        const type = isDecoding ? AST.encodedAST(propertySignature.type) : AST.typeAST(propertySignature.type)\n        if (AST.isLiteral(type) && !propertySignature.isOptional) {\n          out.push([propertySignature.name, type])\n        }\n      }\n      return out\n    }\n    case \"Refinement\":\n      return getLiterals(ast.from, isDecoding)\n    case \"Suspend\":\n      return getLiterals(ast.f(), isDecoding)\n    case \"Transformation\":\n      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding)\n  }\n  return []\n}\n\n/**\n * The purpose of the algorithm is to narrow down the pool of possible candidates for decoding as much as possible.\n *\n * This function separates the schemas into two groups, `keys` and `otherwise`:\n *\n * - `keys`: the schema has at least one property with a literal value\n * - `otherwise`: the schema has no properties with a literal value\n *\n * If a schema has at least one property with a literal value, so it ends up in `keys`, first a namespace is created for\n * the name of the property containing the literal, and then within this namespace a \"bucket\" is created for the literal\n * value in which to store all the schemas that have the same property and literal value.\n *\n * @internal\n */\nexport const getSearchTree = (\n  members: ReadonlyArray<AST.AST>,\n  isDecoding: boolean\n): {\n  keys: {\n    readonly [key: PropertyKey]: {\n      buckets: { [literal: string]: ReadonlyArray<AST.AST> }\n      literals: ReadonlyArray<AST.Literal> // this is for error messages\n    }\n  }\n  otherwise: ReadonlyArray<AST.AST>\n} => {\n  const keys: {\n    [key: PropertyKey]: {\n      buckets: { [literal: string]: Array<AST.AST> }\n      literals: Array<AST.Literal>\n    }\n  } = {}\n  const otherwise: Array<AST.AST> = []\n  for (let i = 0; i < members.length; i++) {\n    const member = members[i]\n    const tags = getLiterals(member, isDecoding)\n    if (tags.length > 0) {\n      for (let j = 0; j < tags.length; j++) {\n        const [key, literal] = tags[j]\n        const hash = String(literal.literal)\n        keys[key] = keys[key] || { buckets: {}, literals: [] }\n        const buckets = keys[key].buckets\n        if (Object.prototype.hasOwnProperty.call(buckets, hash)) {\n          if (j < tags.length - 1) {\n            continue\n          }\n          buckets[hash].push(member)\n          keys[key].literals.push(literal)\n        } else {\n          buckets[hash] = [member]\n          keys[key].literals.push(literal)\n          break\n        }\n      }\n    } else {\n      otherwise.push(member)\n    }\n  }\n  return { keys, otherwise }\n}\n\nconst dropRightRefinement = (ast: AST.AST): AST.AST => AST.isRefinement(ast) ? dropRightRefinement(ast.from) : ast\n\nconst handleForbidden = <R, A>(\n  effect: Effect.Effect<A, ParseIssue, R>,\n  ast: AST.AST,\n  actual: unknown,\n  options: InternalOptions | undefined\n): Effect.Effect<A, ParseIssue, R> => {\n  const eu = eitherOrUndefined(effect)\n  if (eu) {\n    return eu\n  }\n  if (options?.isEffectAllowed === true) {\n    return effect\n  }\n  try {\n    return Effect.runSync(Effect.either(effect as Effect.Effect<A, ParseIssue>))\n  } catch (e) {\n    return Either.left(\n      new Forbidden(\n        ast,\n        actual,\n        \"cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work\"\n      )\n    )\n  }\n}\n\nconst compare = ([a]: [number, ...Array<unknown>], [b]: [number, ...Array<unknown>]) => a > b ? 1 : a < b ? -1 : 0\n\nfunction sortByIndex<T>(\n  es: array_.NonEmptyArray<[number, T]>\n): array_.NonEmptyArray<T>\nfunction sortByIndex<T>(es: Array<[number, T]>): Array<T>\nfunction sortByIndex(es: Array<[number, any]>) {\n  return es.sort(compare).map((t) => t[1])\n}\n\n// -------------------------------------------------------------------------------------\n// transformations interpreter\n// -------------------------------------------------------------------------------------\n\n/** @internal */\nexport const getFinalTransformation = (\n  transformation: AST.TransformationKind,\n  isDecoding: boolean\n): (\n  input: any,\n  options: AST.ParseOptions,\n  self: AST.Transformation\n) => Effect.Effect<any, ParseIssue, any> => {\n  switch (transformation._tag) {\n    case \"FinalTransformation\":\n      return isDecoding ? transformation.decode : transformation.encode\n    case \"ComposeTransformation\":\n      return Either.right\n    case \"TypeLiteralTransformation\":\n      return (input) => {\n        let out: Effect.Effect<any, ParseIssue, any> = Either.right(input)\n\n        // ---------------------------------------------\n        // handle property signature transformations\n        // ---------------------------------------------\n        for (const pst of transformation.propertySignatureTransformations) {\n          const [from, to] = isDecoding ?\n            [pst.from, pst.to] :\n            [pst.to, pst.from]\n          const transformation = isDecoding ? pst.decode : pst.encode\n          const f = (input: any) => {\n            const o = transformation(\n              Object.prototype.hasOwnProperty.call(input, from) ?\n                Option.some(input[from]) :\n                Option.none()\n            )\n            delete input[from]\n            if (Option.isSome(o)) {\n              input[to] = o.value\n            }\n            return input\n          }\n          out = map(out, f)\n        }\n        return out\n      }\n  }\n}\n"],"names":["array_","TaggedError","Effect","Either","dual","globalValue","Inspectable","Option","Predicate","AST","util_","TreeFormatter","Pointer","path","actual","issue","_tag","constructor","Unexpected","message","Missing","ast","undefined","Composite","issues","output","isComposite","u","hasProperty","Refinement","kind","Transformation","Type","Forbidden","ParseErrorTypeId","Symbol","for","isParseError","ParseError","toString","formatIssueSync","toJSON","_id","NodeInspectSymbol","parseError","succeed","right","fail","left","_try","try","fromOption","flatMap","self","f","s","map","mapError","eitherOrUndefined","mapBoth","options","onFailure","onSuccess","orElse","catchAll","mergeInternalOptions","overrideOptions","isNumber","getEither","isDecoding","parser","goMemo","getSync","input","getOrThrowWith","getOption","getRight","getEffect","isEffectAllowed","decodeUnknownSync","schema","decodeUnknownOption","decodeUnknownEither","decodeUnknownPromise","decodeUnknown","runPromise","encodeUnknownSync","encodeUnknownOption","encodeUnknownEither","encodeUnknownPromise","encodeUnknown","decodeSync","decodeOption","decodeEither","decodePromise","decode","validateSync","typeAST","validateOption","validateEither","validatePromise","validate","is","isRight","exact","asserts","result","isLeft","encodeSync","encodeOption","encodeEither","encodePromise","encode","decodeMemoMap","WeakMap","encodeMemoMap","memoMap","memo","get","raw","go","parseOptionsAnnotation","getParseOptionsAnnotation","isSome","i","value","set","getConcurrency","getOrUndefined","getConcurrencyAnnotation","getBatching","getBatchingAnnotation","from","handleForbidden","e","a","match","filter","defaultParseOption","onNone","onSome","to","dropRightRefinement","transform","getFinalTransformation","transformation","i1","i2","parse","typeParameters","fromRefinement","literal","symbol","isUndefined","isNever","isString","isBoolean","isBigInt","isSymbol","isObject","enums","some","_","regex","getTemplateLiteralRegExp","test","elements","type","rest","annotatedAST","requiredTypes","isOptional","length","concat","slice","requiredLen","expectedIndexes","join","concurrency","batching","isArray","allErrors","errors","es","stepKey","len","push","queue","te","eu","sortByIndex","nk","index","either","t","void","isNonEmptyReadonlyArray","head","tail","j","computeResult","isNonEmptyArray","cqueue","suspend","state","copy","forEach","discard","propertySignatures","indexSignatures","isNotNullable","expectedKeysMap","expectedKeys","ps","name","parameter","expectedAST","Union","make","key","UniqueSymbol","Literal","expected","isRecord","onExcessPropertyError","onExcessProperty","onExcessPropertyPreserve","inputKeys","ownKeys","String","isExact","hasKey","Object","prototype","hasOwnProperty","call","indexSignature","keys","getKeysForIndexSignature","keu","vpr","veu","tv","propertyOrder","indexOf","out","assign","searchTree","getSearchTree","types","Map","candidates","buckets","literals","TypeLiteral","PropertySignature","fakeps","otherwise","candidate","pr","finalResult","memoizeThunk","annotations","refinement","getLiterals","annotation","getSurrogateAnnotation","propertySignature","encodedAST","isLiteral","members","member","tags","hash","isRefinement","effect","runSync","compare","b","sort","pst","propertySignatureTransformations","o","none"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 4472, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/Equivalence.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/Equivalence.ts"],"sourcesContent":["/**\n * @since 0.67.0\n */\n\nimport * as Arr from \"effect/Array\"\nimport * as Equal from \"effect/Equal\"\nimport * as Equivalence from \"effect/Equivalence\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as AST from \"./AST.js\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as util_ from \"./internal/util.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type * as Schema from \"./Schema.js\"\n\n/**\n * @category hooks\n * @since 0.67.0\n */\nexport const EquivalenceHookId: unique symbol = Symbol.for(\"@effect/schema/EquivalenceHookId\")\n\n/**\n * @category hooks\n * @since 0.67.0\n */\nexport type EquivalenceHookId = typeof EquivalenceHookId\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const equivalence =\n  <A>(handler: (...args: ReadonlyArray<Equivalence.Equivalence<any>>) => Equivalence.Equivalence<A>) =>\n  <I, R>(self: Schema.Schema<A, I, R>): Schema.Schema<A, I, R> => self.annotations({ [EquivalenceHookId]: handler })\n\n/**\n * @category Equivalence\n * @since 0.67.0\n */\nexport const make = <A, I, R>(schema: Schema.Schema<A, I, R>): Equivalence.Equivalence<A> => go(schema.ast, [])\n\nconst getHook = AST.getAnnotation<\n  (...args: ReadonlyArray<Equivalence.Equivalence<any>>) => Equivalence.Equivalence<any>\n>(\n  EquivalenceHookId\n)\n\nconst go = (ast: AST.AST, path: ReadonlyArray<PropertyKey>): Equivalence.Equivalence<any> => {\n  const hook = getHook(ast)\n  if (Option.isSome(hook)) {\n    switch (ast._tag) {\n      case \"Declaration\":\n        return hook.value(...ast.typeParameters.map((tp) => go(tp, path)))\n      case \"Refinement\":\n        return hook.value(go(ast.from, path))\n      default:\n        return hook.value()\n    }\n  }\n  switch (ast._tag) {\n    case \"NeverKeyword\":\n      throw new Error(errors_.getEquivalenceUnsupportedErrorMessage(ast, path))\n    case \"Transformation\":\n      return go(ast.to, path)\n    case \"Declaration\":\n    case \"Literal\":\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n    case \"UniqueSymbol\":\n    case \"SymbolKeyword\":\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"Enums\":\n    case \"ObjectKeyword\":\n      return Equal.equals\n    case \"Refinement\":\n      return go(ast.from, path)\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => go(ast.f(), path))\n      return (a, b) => get()(a, b)\n    }\n    case \"TupleType\": {\n      const elements = ast.elements.map((element, i) => go(element.type, path.concat(i)))\n      const rest = ast.rest.map((annotatedAST) => go(annotatedAST.type, path))\n      return Equivalence.make((a, b) => {\n        const len = a.length\n        if (len !== b.length) {\n          return false\n        }\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        let i = 0\n        for (; i < Math.min(len, ast.elements.length); i++) {\n          if (!elements[i](a[i], b[i])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (Arr.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          for (; i < len - tail.length; i++) {\n            if (!head(a[i], b[i])) {\n              return false\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            i += j\n            if (!tail[j](a[i], b[i])) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"TypeLiteral\": {\n      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n        return Equal.equals\n      }\n      const propertySignatures = ast.propertySignatures.map((ps) => go(ps.type, path.concat(ps.name)))\n      const indexSignatures = ast.indexSignatures.map((is) => go(is.type, path))\n      return Equivalence.make((a, b) => {\n        const aStringKeys = Object.keys(a)\n        const aSymbolKeys = Object.getOwnPropertySymbols(a)\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < propertySignatures.length; i++) {\n          const ps = ast.propertySignatures[i]\n          const name = ps.name\n          const aHas = Object.prototype.hasOwnProperty.call(a, name)\n          const bHas = Object.prototype.hasOwnProperty.call(b, name)\n          if (ps.isOptional) {\n            if (aHas !== bHas) {\n              return false\n            }\n          }\n          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        let bSymbolKeys: Array<symbol> | undefined\n        let bStringKeys: Array<string> | undefined\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const is = ast.indexSignatures[i]\n          const base = AST.getParameterBase(is.parameter)\n          const isSymbol = AST.isSymbolKeyword(base)\n          if (isSymbol) {\n            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b)\n            if (aSymbolKeys.length !== bSymbolKeys.length) {\n              return false\n            }\n          } else {\n            bStringKeys = bStringKeys || Object.keys(b)\n            if (aStringKeys.length !== bStringKeys.length) {\n              return false\n            }\n          }\n          const aKeys = isSymbol ? aSymbolKeys : aStringKeys\n          for (let j = 0; j < aKeys.length; j++) {\n            const key = aKeys[j]\n            if (\n              !Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])\n            ) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"Union\": {\n      const searchTree = ParseResult.getSearchTree(ast.types, true)\n      const ownKeys = util_.ownKeys(searchTree.keys)\n      const len = ownKeys.length\n      return Equivalence.make((a, b) => {\n        let candidates: Array<AST.AST> = []\n        if (len > 0 && Predicate.isRecord(a)) {\n          for (let i = 0; i < len; i++) {\n            const name = ownKeys[i]\n            const buckets = searchTree.keys[name].buckets\n            if (Object.prototype.hasOwnProperty.call(a, name)) {\n              const literal = String(a[name])\n              if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                candidates = candidates.concat(buckets[literal])\n              }\n            }\n          }\n        }\n        if (searchTree.otherwise.length > 0) {\n          candidates = candidates.concat(searchTree.otherwise)\n        }\n        const tuples = candidates.map((ast) => [go(ast, path), ParseResult.is({ ast } as any)] as const)\n        for (let i = 0; i < tuples.length; i++) {\n          const [equivalence, is] = tuples[i]\n          if (is(a) && is(b)) {\n            if (equivalence(a, b)) {\n              return true\n            }\n          }\n        }\n        return false\n      })\n    }\n  }\n}\n"],"names":["Arr","Equal","Equivalence","Option","Predicate","AST","errors_","util_","ParseResult","EquivalenceHookId","Symbol","for","equivalence","handler","self","annotations","make","schema","go","ast","getHook","getAnnotation","path","hook","isSome","_tag","value","typeParameters","map","tp","from","Error","getEquivalenceUnsupportedErrorMessage","to","equals","get","memoizeThunk","f","a","b","elements","element","i","type","concat","rest","annotatedAST","len","length","Math","min","isNonEmptyReadonlyArray","head","tail","j","propertySignatures","indexSignatures","ps","name","is","aStringKeys","Object","keys","aSymbolKeys","getOwnPropertySymbols","aHas","prototype","hasOwnProperty","call","bHas","isOptional","bSymbolKeys","bStringKeys","base","getParameterBase","parameter","isSymbol","isSymbolKeyword","aKeys","key","searchTree","getSearchTree","types","ownKeys","candidates","isRecord","buckets","literal","String","otherwise","tuples"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 4690, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/internal/serializable.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/internal/serializable.ts"],"sourcesContent":["/** @internal */\nexport const symbol: unique symbol = Symbol.for(\n  \"@effect/schema/Serializable/symbol\"\n)\n\n/** @internal */\nexport const symbolResult: unique symbol = Symbol.for(\n  \"@effect/schema/Serializable/symbolResult\"\n)\n"],"names":["symbol","Symbol","for","symbolResult"],"mappings":"AAAA,cAAA;;;;;;AACO,MAAMA,MAAM,GAAA,WAAA,GAAkBC,MAAM,CAACC,GAAG,CAC7C,oCAAoC,CACrC;AAGM,MAAMC,YAAY,GAAA,WAAA,GAAkBF,MAAM,CAACC,GAAG,CACnD,0CAA0C,CAC3C","ignoreList":[]}},
    {"offset": {"line": 4702, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/Pretty.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/Pretty.ts"],"sourcesContent":["/**\n * @since 0.67.0\n */\nimport * as Arr from \"effect/Array\"\nimport * as Option from \"effect/Option\"\nimport * as AST from \"./AST.js\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as util_ from \"./internal/util.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type * as Schema from \"./Schema.js\"\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport interface Pretty<To> {\n  (a: To): string\n}\n\n/**\n * @category hooks\n * @since 0.67.0\n */\nexport const PrettyHookId: unique symbol = Symbol.for(\"@effect/schema/PrettyHookId\")\n\n/**\n * @category hooks\n * @since 0.67.0\n */\nexport type PrettyHookId = typeof PrettyHookId\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const pretty =\n  <A>(handler: (...args: ReadonlyArray<Pretty<any>>) => Pretty<A>) =>\n  <I, R>(self: Schema.Schema<A, I, R>): Schema.Schema<A, I, R> => self.annotations({ [PrettyHookId]: handler })\n\n/**\n * @category prettify\n * @since 0.67.0\n */\nexport const make = <A, I, R>(schema: Schema.Schema<A, I, R>): (a: A) => string => compile(schema.ast, [])\n\nconst getHook = AST.getAnnotation<(...args: ReadonlyArray<Pretty<any>>) => Pretty<any>>(\n  PrettyHookId\n)\n\nconst getMatcher = (defaultPretty: Pretty<any>) => (ast: AST.AST): Pretty<any> =>\n  Option.match(getHook(ast), {\n    onNone: () => defaultPretty,\n    onSome: (handler) => handler()\n  })\n\nconst toString = getMatcher((a) => String(a))\n\nconst stringify = getMatcher((a) => JSON.stringify(a))\n\nconst formatUnknown = getMatcher(util_.formatUnknown)\n\n/**\n * @since 0.67.0\n */\nexport const match: AST.Match<Pretty<any>> = {\n  \"Declaration\": (ast, go, path) => {\n    const hook = getHook(ast)\n    if (Option.isSome(hook)) {\n      return hook.value(...ast.typeParameters.map((tp) => go(tp, path)))\n    }\n    throw new Error(errors_.getPrettyMissingAnnotationErrorMessage(path, ast))\n  },\n  \"VoidKeyword\": getMatcher(() => \"void(0)\"),\n  \"NeverKeyword\": getMatcher(() => {\n    throw new Error(errors_.getPrettyNeverErrorMessage)\n  }),\n  \"Literal\": getMatcher((literal: AST.LiteralValue): string =>\n    typeof literal === \"bigint\" ?\n      `${String(literal)}n` :\n      JSON.stringify(literal)\n  ),\n  \"SymbolKeyword\": toString,\n  \"UniqueSymbol\": toString,\n  \"TemplateLiteral\": stringify,\n  \"UndefinedKeyword\": toString,\n  \"UnknownKeyword\": formatUnknown,\n  \"AnyKeyword\": formatUnknown,\n  \"ObjectKeyword\": formatUnknown,\n  \"StringKeyword\": stringify,\n  \"NumberKeyword\": toString,\n  \"BooleanKeyword\": toString,\n  \"BigIntKeyword\": getMatcher((a) => `${String(a)}n`),\n  \"Enums\": stringify,\n  \"TupleType\": (ast, go, path) => {\n    const hook = getHook(ast)\n    if (Option.isSome(hook)) {\n      return hook.value()\n    }\n    const elements = ast.elements.map((e, i) => go(e.type, path.concat(i)))\n    const rest = ast.rest.map((annotatedAST) => go(annotatedAST.type, path))\n    return (input: ReadonlyArray<unknown>) => {\n      const output: Array<string> = []\n      let i = 0\n      // ---------------------------------------------\n      // handle elements\n      // ---------------------------------------------\n      for (; i < elements.length; i++) {\n        if (input.length < i + 1) {\n          if (ast.elements[i].isOptional) {\n            continue\n          }\n        } else {\n          output.push(elements[i](input[i]))\n        }\n      }\n      // ---------------------------------------------\n      // handle rest element\n      // ---------------------------------------------\n      if (Arr.isNonEmptyReadonlyArray(rest)) {\n        const [head, ...tail] = rest\n        for (; i < input.length - tail.length; i++) {\n          output.push(head(input[i]))\n        }\n        // ---------------------------------------------\n        // handle post rest elements\n        // ---------------------------------------------\n        for (let j = 0; j < tail.length; j++) {\n          i += j\n          output.push(tail[j](input[i]))\n        }\n      }\n\n      return \"[\" + output.join(\", \") + \"]\"\n    }\n  },\n  \"TypeLiteral\": (ast, go, path) => {\n    const hook = getHook(ast)\n    if (Option.isSome(hook)) {\n      return hook.value()\n    }\n    const propertySignaturesTypes = ast.propertySignatures.map((ps) => go(ps.type, path.concat(ps.name)))\n    const indexSignatureTypes = ast.indexSignatures.map((is) => go(is.type, path))\n    const expectedKeys: any = {}\n    for (let i = 0; i < propertySignaturesTypes.length; i++) {\n      expectedKeys[ast.propertySignatures[i].name] = null\n    }\n    return (input: { readonly [x: PropertyKey]: unknown }) => {\n      const output: Array<string> = []\n      // ---------------------------------------------\n      // handle property signatures\n      // ---------------------------------------------\n      for (let i = 0; i < propertySignaturesTypes.length; i++) {\n        const ps = ast.propertySignatures[i]\n        const name = ps.name\n        if (ps.isOptional && !Object.prototype.hasOwnProperty.call(input, name)) {\n          continue\n        }\n        output.push(\n          `${util_.formatPropertyKey(name)}: ${propertySignaturesTypes[i](input[name])}`\n        )\n      }\n      // ---------------------------------------------\n      // handle index signatures\n      // ---------------------------------------------\n      if (indexSignatureTypes.length > 0) {\n        for (let i = 0; i < indexSignatureTypes.length; i++) {\n          const type = indexSignatureTypes[i]\n          const keys = util_.getKeysForIndexSignature(input, ast.indexSignatures[i].parameter)\n          for (const key of keys) {\n            if (Object.prototype.hasOwnProperty.call(expectedKeys, key)) {\n              continue\n            }\n            output.push(`${util_.formatPropertyKey(key)}: ${type(input[key])}`)\n          }\n        }\n      }\n\n      return Arr.isNonEmptyReadonlyArray(output) ? \"{ \" + output.join(\", \") + \" }\" : \"{}\"\n    }\n  },\n  \"Union\": (ast, go, path) => {\n    const hook = getHook(ast)\n    if (Option.isSome(hook)) {\n      return hook.value()\n    }\n    const types = ast.types.map((ast) => [ParseResult.is({ ast } as any), go(ast, path)] as const)\n    return (a) => {\n      const index = types.findIndex(([is]) => is(a))\n      if (index === -1) {\n        throw new Error(errors_.getPrettyNoMatchingSchemaErrorMessage(a, path, ast))\n      }\n      return types[index][1](a)\n    }\n  },\n  \"Suspend\": (ast, go, path) => {\n    return Option.match(getHook(ast), {\n      onNone: () => {\n        const get = util_.memoizeThunk(() => go(ast.f(), path))\n        return (a) => get()(a)\n      },\n      onSome: (handler) => handler()\n    })\n  },\n  \"Refinement\": (ast, go, path) => {\n    return Option.match(getHook(ast), {\n      onNone: () => go(ast.from, path),\n      onSome: (handler) => handler()\n    })\n  },\n  \"Transformation\": (ast, go, path) => {\n    return Option.match(getHook(ast), {\n      onNone: () => go(ast.to, path),\n      onSome: (handler) => handler()\n    })\n  }\n}\n\nconst compile = AST.getCompiler(match)\n"],"names":["Arr","Option","AST","errors_","util_","ParseResult","PrettyHookId","Symbol","for","pretty","handler","self","annotations","make","schema","compile","ast","getHook","getAnnotation","getMatcher","defaultPretty","match","onNone","onSome","toString","a","String","stringify","JSON","formatUnknown","Declaration","go","path","hook","isSome","value","typeParameters","map","tp","Error","getPrettyMissingAnnotationErrorMessage","getPrettyNeverErrorMessage","literal","TupleType","elements","e","i","type","concat","rest","annotatedAST","input","output","length","isOptional","push","isNonEmptyReadonlyArray","head","tail","j","join","TypeLiteral","propertySignaturesTypes","propertySignatures","ps","name","indexSignatureTypes","indexSignatures","is","expectedKeys","Object","prototype","hasOwnProperty","call","formatPropertyKey","keys","getKeysForIndexSignature","parameter","key","Union","types","index","findIndex","getPrettyNoMatchingSchemaErrorMessage","Suspend","get","memoizeThunk","f","Refinement","from","Transformation","to","getCompiler"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 4893, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@lucid-evolution/utils/node_modules/@effect/schema/dist/esm/Schema.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40lucid-evolution/utils/node_modules/%40effect/schema/src/Schema.ts"],"sourcesContent":["/**\n * @since 0.67.0\n */\n\nimport * as array_ from \"effect/Array\"\nimport * as bigDecimal_ from \"effect/BigDecimal\"\nimport * as bigInt_ from \"effect/BigInt\"\nimport * as boolean_ from \"effect/Boolean\"\nimport type { Brand } from \"effect/Brand\"\nimport * as cause_ from \"effect/Cause\"\nimport * as chunk_ from \"effect/Chunk\"\nimport * as config_ from \"effect/Config\"\nimport * as configError_ from \"effect/ConfigError\"\nimport * as data_ from \"effect/Data\"\nimport * as duration_ from \"effect/Duration\"\nimport * as Effect from \"effect/Effect\"\nimport * as either_ from \"effect/Either\"\nimport * as Encoding from \"effect/Encoding\"\nimport * as Equal from \"effect/Equal\"\nimport * as Equivalence from \"effect/Equivalence\"\nimport * as exit_ from \"effect/Exit\"\nimport * as fiberId_ from \"effect/FiberId\"\nimport type { LazyArg } from \"effect/Function\"\nimport { dual, identity } from \"effect/Function\"\nimport * as hashMap_ from \"effect/HashMap\"\nimport * as hashSet_ from \"effect/HashSet\"\nimport * as list_ from \"effect/List\"\nimport * as number_ from \"effect/Number\"\nimport * as option_ from \"effect/Option\"\nimport type * as Order from \"effect/Order\"\nimport type { Pipeable } from \"effect/Pipeable\"\nimport { pipeArguments } from \"effect/Pipeable\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as record_ from \"effect/Record\"\nimport * as redacted_ from \"effect/Redacted\"\nimport * as Request from \"effect/Request\"\nimport * as sortedSet_ from \"effect/SortedSet\"\nimport * as string_ from \"effect/String\"\nimport * as struct_ from \"effect/Struct\"\nimport type * as Types from \"effect/Types\"\nimport type { LazyArbitrary } from \"./Arbitrary.js\"\nimport * as arbitrary_ from \"./Arbitrary.js\"\nimport type { ParseOptions } from \"./AST.js\"\nimport * as AST from \"./AST.js\"\nimport * as equivalence_ from \"./Equivalence.js\"\nimport * as fastCheck_ from \"./FastCheck.js\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as filters_ from \"./internal/filters.js\"\nimport * as serializable_ from \"./internal/serializable.js\"\nimport * as util_ from \"./internal/util.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport * as pretty_ from \"./Pretty.js\"\nimport type * as Serializable from \"./Serializable.js\"\nimport * as TreeFormatter from \"./TreeFormatter.js\"\n\n/**\n * @since 0.68.2\n */\nexport type Simplify<A> = { [K in keyof A]: A[K] } & {}\n\n/**\n * @since 0.67.0\n */\nexport type SimplifyMutable<A> = {\n  -readonly [K in keyof A]: A[K]\n} extends infer B ? B : never\n\n/**\n * @since 0.67.0\n * @category symbol\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/schema/Schema\")\n\n/**\n * @since 0.67.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {\n  readonly Type: A\n  readonly Encoded: I\n  readonly ast: AST.AST\n  annotations(annotations: Annotations.Schema<A>): Schema<A, I, R>\n}\n\n/**\n * @category model\n * @since 0.67.0\n */\nexport interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const make = <A, I = A, R = never>(ast: AST.AST): SchemaClass<A, I, R> =>\n  class SchemaClass {\n    [TypeId] = variance\n    static Type: A\n    static Encoded: I\n    static [TypeId] = variance\n    static ast = ast\n    static annotations(annotations: Annotations.Schema<A>) {\n      return make<A, I, R>(mergeSchemaAnnotations(this.ast, annotations))\n    }\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n    static toString() {\n      return String(ast)\n    }\n  }\n\nconst variance = {\n  /* c8 ignore next */\n  _A: (_: any) => _,\n  /* c8 ignore next */\n  _I: (_: any) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\ninterface AllAnnotations<A, TypeParameters extends ReadonlyArray<any>>\n  extends Annotations.Schema<A, TypeParameters>, PropertySignature.Annotations<A>\n{}\n\nconst toASTAnnotations = <A, TypeParameters extends ReadonlyArray<any>>(\n  annotations?: AllAnnotations<A, TypeParameters>\n): AST.Annotations => {\n  if (!annotations) {\n    return {}\n  }\n  const out: Types.Mutable<AST.Annotations> = {}\n\n  // symbols are reserved for custom annotations\n  const custom = Object.getOwnPropertySymbols(annotations)\n  for (const sym of custom) {\n    out[sym] = annotations[sym]\n  }\n\n  // string keys are reserved as /schema namespace\n  if (annotations.typeId !== undefined) {\n    const typeId = annotations.typeId\n    if (typeof typeId === \"object\") {\n      out[AST.TypeAnnotationId] = typeId.id\n      out[typeId.id] = typeId.annotation\n    } else {\n      out[AST.TypeAnnotationId] = typeId\n    }\n  }\n  const move = (from: keyof typeof annotations, to: symbol) => {\n    if (annotations[from] !== undefined) {\n      out[to] = annotations[from]\n    }\n  }\n  move(\"message\", AST.MessageAnnotationId)\n  move(\"missingMessage\", AST.MissingMessageAnnotationId)\n  move(\"identifier\", AST.IdentifierAnnotationId)\n  move(\"title\", AST.TitleAnnotationId)\n  move(\"description\", AST.DescriptionAnnotationId)\n  move(\"examples\", AST.ExamplesAnnotationId)\n  move(\"default\", AST.DefaultAnnotationId)\n  move(\"documentation\", AST.DocumentationAnnotationId)\n  move(\"jsonSchema\", AST.JSONSchemaAnnotationId)\n  move(\"arbitrary\", arbitrary_.ArbitraryHookId)\n  move(\"pretty\", pretty_.PrettyHookId)\n  move(\"equivalence\", equivalence_.EquivalenceHookId)\n  move(\"concurrency\", AST.ConcurrencyAnnotationId)\n  move(\"batching\", AST.BatchingAnnotationId)\n  move(\"parseIssueTitle\", AST.ParseIssueTitleAnnotationId)\n  move(\"parseOptions\", AST.ParseOptionsAnnotationId)\n\n  return out\n}\n\nconst mergeSchemaAnnotations = <A>(ast: AST.AST, annotations: Annotations.Schema<A>): AST.AST =>\n  AST.annotations(ast, toASTAnnotations(annotations))\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport declare namespace Annotable {\n  /**\n   * @since 0.67.0\n   */\n  export type Self<S extends All> = ReturnType<S[\"annotations\"]>\n\n  /**\n   * @since 0.67.0\n   */\n  export type Any = Annotable<any, any, any, unknown>\n\n  /**\n   * @since 0.67.0\n   */\n  export type All =\n    | Any\n    | Annotable<any, any, never, unknown>\n    | Annotable<any, never, any, unknown>\n    | Annotable<any, never, never, unknown>\n}\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.Schema<A>): Self\n}\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {\n  new(_: never): Schema.Variance<A, I, R>\n}\n\n/**\n * @since 0.67.0\n */\nexport const asSchema = <S extends Schema.All>(\n  schema: S\n): Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>> => schema as any\n\n/**\n * @category formatting\n * @since 0.67.0\n */\nexport const format = <A, I, R>(schema: Schema<A, I, R>): string => String(schema.ast)\n\n/**\n * @since 0.67.0\n */\nexport declare namespace Schema {\n  /**\n   * @since 0.67.0\n   */\n  export interface Variance<A, I, R> {\n    readonly [TypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _I: Types.Invariant<I>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n\n  /**\n   * @since 0.67.0\n   */\n  export type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never\n\n  /**\n   * @since 0.67.0\n   */\n  export type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never\n\n  /**\n   * @since 0.67.0\n   */\n  export type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never\n\n  /**\n   * @since 0.67.0\n   */\n  export type ToAsserts<S extends AnyNoContext> = (\n    input: unknown,\n    options?: AST.ParseOptions\n  ) => asserts input is Schema.Type<S>\n\n  /**\n   * Any schema, except for `never`.\n   *\n   * @since 0.67.0\n   */\n  export type Any = Schema<any, any, unknown>\n\n  /**\n   * Any schema with `Context = never`, except for `never`.\n   *\n   * @since 0.67.0\n   */\n  export type AnyNoContext = Schema<any, any, never>\n\n  /**\n   * Any schema, including `never`.\n   *\n   * @since 0.67.0\n   */\n  export type All =\n    | Any\n    | Schema<any, never, unknown>\n    | Schema<never, any, unknown>\n    | Schema<never, never, unknown>\n\n  /**\n   * Type-level counterpart of `Schema.asSchema` function.\n   *\n   * @since 0.67.0\n   */\n  export type AsSchema<S extends All> = Schema<Type<S>, Encoded<S>, Context<S>>\n}\n\n/**\n * The `encodedSchema` function allows you to extract the `Encoded` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without retaining any refinements or transformations that\n * were applied previously.\n *\n * @since 0.67.0\n */\nexport const encodedSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> => make(AST.encodedAST(schema.ast))\n\n/**\n * The `encodedBoundSchema` function is similar to `encodedSchema` but preserves\n * the refinements up to the first transformation point in the original schema.\n *\n * @since 0.67.17\n */\nexport const encodedBoundSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> =>\n  make(AST.encodedBoundAST(schema.ast))\n\n/**\n * The `typeSchema` function allows you to extract the `Type` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without considering the initial encoding or transformation\n * processes.\n *\n * @since 0.67.0\n */\nexport const typeSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<A> => make(AST.typeAST(schema.ast))\n\n/* c8 ignore start */\nexport {\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @throws `ParseError`\n   * @category validation\n   * @since 0.67.0\n   */\n  asserts,\n  /**\n   * @category decoding\n   * @since 0.67.0\n   */\n  decodeOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 0.67.0\n   */\n  decodeSync,\n  /**\n   * @category decoding\n   * @since 0.67.0\n   */\n  decodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 0.67.0\n   */\n  decodeUnknownSync,\n  /**\n   * @category encoding\n   * @since 0.67.0\n   */\n  encodeOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 0.67.0\n   */\n  encodeSync,\n  /**\n   * @category encoding\n   * @since 0.67.0\n   */\n  encodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 0.67.0\n   */\n  encodeUnknownSync,\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @category validation\n   * @since 0.67.0\n   */\n  is,\n  /**\n   * @category validation\n   * @since 0.67.0\n   */\n  validateOption,\n  /**\n   * @throws `ParseError`\n   * @category validation\n   * @since 0.67.0\n   */\n  validateSync\n} from \"./ParseResult.js\"\n/* c8 ignore end */\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const encodeUnknown = ParseResult.encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<I, ParseResult.ParseError, R> =>\n    ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<I, ParseResult.ParseError> =>\n    either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R> = encodeUnknown\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError> = encodeUnknownEither\n\n/**\n * @category encoding\n * @since 0.67.0\n */\nexport const encodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Promise<I> = encodeUnknownPromise\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const decodeUnknown = ParseResult.decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R> = decodeUnknown\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError> = decodeUnknownEither\n\n/**\n * @category decoding\n * @since 0.67.0\n */\nexport const decodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Promise<A> = decodeUnknownPromise\n\n/**\n * @category validation\n * @since 0.67.0\n */\nexport const validate = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validate = ParseResult.validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 0.67.0\n */\nexport const validateEither = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validateEither = ParseResult.validateEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 0.67.0\n */\nexport const validatePromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * Tests if a value is a `Schema`.\n *\n * @category guards\n * @since 0.67.0\n */\nexport const isSchema = (u: unknown): u is Schema.Any =>\n  Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId])\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>\n  extends AnnotableClass<Literal<Literals>, Literals[number]>\n{\n  readonly literals: Readonly<Literals>\n}\n\nconst getDefaultLiteralAST = <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals\n) =>\n  AST.isMembers(literals)\n    ? AST.Union.make(AST.mapMembers(literals, (literal) => new AST.Literal(literal)))\n    : new AST.Literal(literals[0])\n\nconst makeLiteralClass = <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals,\n  ast: AST.AST = getDefaultLiteralAST(literals)\n): Literal<Literals> =>\n  class LiteralClass extends make<Literals[number]>(ast) {\n    static override annotations(annotations: Annotations.Schema<Literals[number]>): Literal<Literals> {\n      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations))\n    }\n    static literals = [...literals] as Literals\n  }\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport function Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Literal<Literals>\nexport function Literal(): Never\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]>\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]> | Never {\n  return array_.isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never\n}\n\n/**\n * Creates a new `Schema` from a literal schema.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n * import { Either } from \"effect\"\n *\n * const schema = S.Literal(\"a\", \"b\", \"c\").pipe(S.pickLiteral(\"a\", \"b\"))\n *\n * assert.deepStrictEqual(S.decodeSync(schema)(\"a\"), \"a\")\n * assert.deepStrictEqual(S.decodeSync(schema)(\"b\"), \"b\")\n * assert.strictEqual(Either.isLeft(S.decodeUnknownEither(schema)(\"c\")), true)\n *\n * @category constructors\n * @since 0.67.0\n */\nexport const pickLiteral =\n  <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) =>\n  <I, R>(_schema: Schema<A, I, R>): Literal<[...L]> => Literal(...literals)\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const UniqueSymbolFromSelf = <S extends symbol>(symbol: S): SchemaClass<S> => make(new AST.UniqueSymbol(symbol))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {\n  readonly enums: A\n}\n\n/**\n * @since 0.67.0\n */\nexport type EnumsDefinition = { [x: string]: string | number }\n\nconst getDefaultEnumsAST = <A extends EnumsDefinition>(enums: A) =>\n  new AST.Enums(\n    Object.keys(enums).filter(\n      (key) => typeof enums[enums[key]] !== \"number\"\n    ).map((key) => [key, enums[key]])\n  )\n\nconst makeEnumsClass = <A extends EnumsDefinition>(\n  enums: A,\n  ast: AST.AST = getDefaultEnumsAST(enums)\n): Enums<A> =>\n  class EnumsClass extends make<A[keyof A]>(ast) {\n    static override annotations(annotations: Annotations.Schema<A[keyof A]>) {\n      return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static enums = { ...enums }\n  }\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const Enums = <A extends EnumsDefinition>(enums: A): Enums<A> => makeEnumsClass(enums)\n\ntype Join<T> = T extends [infer Head, ...infer Tail] ?\n  `${(Head extends Schema<infer A> ? A : Head) & (AST.LiteralValue)}${Join<Tail>}`\n  : \"\"\n\n/**\n * @category API interface\n * @since 0.67.17\n */\nexport interface TemplateLiteral<A> extends SchemaClass<A> {}\n\ntype TemplateLiteralParameter = Schema.AnyNoContext | AST.LiteralValue\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const TemplateLiteral = <\n  T extends readonly [TemplateLiteralParameter, ...Array<TemplateLiteralParameter>]\n>(\n  ...[head, ...tail]: T\n): TemplateLiteral<Join<T>> => {\n  let astOrs: ReadonlyArray<AST.TemplateLiteral | string> = getTemplateLiterals(\n    getTemplateLiteralParameterAST(head)\n  )\n  for (const span of tail) {\n    astOrs = array_.flatMap(\n      astOrs,\n      (a) => getTemplateLiterals(getTemplateLiteralParameterAST(span)).map((b) => combineTemplateLiterals(a, b))\n    )\n  }\n  return make(AST.Union.make(astOrs.map((astOr) => Predicate.isString(astOr) ? new AST.Literal(astOr) : astOr)))\n}\n\nconst getTemplateLiteralParameterAST = (span: TemplateLiteralParameter): AST.AST =>\n  isSchema(span) ? span.ast : new AST.Literal(String(span))\n\nconst combineTemplateLiterals = (\n  a: AST.TemplateLiteral | string,\n  b: AST.TemplateLiteral | string\n): AST.TemplateLiteral | string => {\n  if (Predicate.isString(a)) {\n    return Predicate.isString(b) ?\n      a + b :\n      new AST.TemplateLiteral(a + b.head, b.spans)\n  }\n  if (Predicate.isString(b)) {\n    return new AST.TemplateLiteral(\n      a.head,\n      array_.modifyNonEmptyLast(\n        a.spans,\n        (span) => new AST.TemplateLiteralSpan(span.type, span.literal + b)\n      )\n    )\n  }\n  return new AST.TemplateLiteral(\n    a.head,\n    array_.appendAll(\n      array_.modifyNonEmptyLast(\n        a.spans,\n        (span) => new AST.TemplateLiteralSpan(span.type, span.literal + String(b.head))\n      ),\n      b.spans\n    )\n  )\n}\n\nconst getTemplateLiterals = (\n  ast: AST.AST\n): ReadonlyArray<AST.TemplateLiteral | string> => {\n  switch (ast._tag) {\n    case \"Literal\":\n      return [String(ast.literal)]\n    case \"NumberKeyword\":\n    case \"StringKeyword\":\n      return [new AST.TemplateLiteral(\"\", [new AST.TemplateLiteralSpan(ast, \"\")])]\n    case \"Union\":\n      return array_.flatMap(ast.types, getTemplateLiterals)\n  }\n  throw new Error(errors_.getSchemaUnsupportedLiteralSpanErrorMessage(ast))\n}\n\nconst declareConstructor = <\n  const TypeParameters extends ReadonlyArray<Schema.Any>,\n  I,\n  A\n>(\n  typeParameters: TypeParameters,\n  options: {\n    readonly decode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n    readonly encode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n  },\n  annotations?: Annotations.Schema<A, TypeParameters>\n): SchemaClass<A, I, Schema.Context<TypeParameters[number]>> =>\n  make(\n    new AST.Declaration(\n      typeParameters.map((tp) => tp.ast),\n      (...typeParameters) => options.decode(...typeParameters.map(make) as any),\n      (...typeParameters) => options.encode(...typeParameters.map(make) as any),\n      toASTAnnotations(annotations)\n    )\n  )\n\nconst declarePrimitive = <A>(\n  is: (input: unknown) => input is A,\n  annotations?: Annotations.Schema<A>\n): SchemaClass<A> => {\n  const decodeUnknown = () => (input: unknown, _: ParseOptions, ast: AST.Declaration) =>\n    is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input))\n  const encodeUnknown = decodeUnknown\n  return make(new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)))\n}\n\n/**\n * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n *\n * @category constructors\n * @since 0.67.0\n */\nexport const declare: {\n  <A>(\n    is: (input: unknown) => input is A,\n    annotations?: Annotations.Schema<A>\n  ): SchemaClass<A>\n  <const P extends ReadonlyArray<Schema.Any>, I, A>(\n    typeParameters: P,\n    options: {\n      readonly decode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n      readonly encode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n    },\n    annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]> }>\n  ): SchemaClass<A, I, Schema.Context<P[number]>>\n} = function() {\n  if (Array.isArray(arguments[0])) {\n    const typeParameters = arguments[0]\n    const options = arguments[1]\n    const annotations = arguments[2]\n    return declareConstructor(typeParameters, options, annotations)\n  }\n  const is = arguments[0]\n  const annotations = arguments[1]\n  return declarePrimitive(is, annotations)\n} as any\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const BrandTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Brand\")\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const fromBrand = <C extends Brand<string | symbol>, A extends Brand.Unbranded<C>>(\n  constructor: Brand.Constructor<C>,\n  annotations?: Annotations.Filter<C, A>\n) =>\n<I, R>(self: Schema<A, I, R>): BrandSchema<A & C, I, R> =>\n  makeBrandClass<Schema<A & C, I, R>, string | symbol>(\n    new AST.Refinement(\n      self.ast,\n      function predicate(a: A, _: ParseOptions, ast: AST.AST): option_.Option<ParseResult.ParseIssue> {\n        const either = constructor.either(a)\n        return either_.isLeft(either) ?\n          option_.some(new ParseResult.Type(ast, a, either.left.map((v) => v.message).join(\", \"))) :\n          option_.none()\n      },\n      toASTAnnotations({ typeId: { id: BrandTypeId, annotation: { constructor } }, ...annotations })\n    )\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const InstanceOfTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/InstanceOf\")\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface instanceOf<A> extends AnnotableClass<instanceOf<A>, A> {}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const instanceOf = <A extends abstract new(...args: any) => any>(\n  constructor: A,\n  annotations?: Annotations.Schema<InstanceType<A>>\n): instanceOf<InstanceType<A>> =>\n  declare(\n    (u): u is InstanceType<A> => u instanceof constructor,\n    {\n      title: constructor.name,\n      description: `an instance of ${constructor.name}`,\n      pretty: (): pretty_.Pretty<InstanceType<A>> => String,\n      typeId: { id: InstanceOfTypeId, annotation: { constructor } },\n      ...annotations\n    }\n  )\n\n/**\n * @category primitives\n * @since 0.67.0\n */\nexport class Undefined extends make<undefined>(AST.undefinedKeyword) {}\n\n/**\n * @category primitives\n * @since 0.67.0\n */\nexport class Void extends make<void>(AST.voidKeyword) {}\n\n/**\n * @category primitives\n * @since 0.67.0\n */\nexport class Null extends make<null>(AST.null) {}\n\n/**\n * @category primitives\n * @since 0.67.0\n */\nexport class Never extends make<never>(AST.neverKeyword) {}\n\n/**\n * @category primitives\n * @since 0.67.0\n */\nexport class Unknown extends make<unknown>(AST.unknownKeyword) {}\n\n/**\n * @category primitives\n * @since 0.67.0\n */\nexport class Any extends make<any>(AST.anyKeyword) {}\n\n/**\n * @category primitives\n * @since 0.67.0\n */\nexport class BigIntFromSelf extends make<bigint>(AST.bigIntKeyword) {}\n\n/**\n * @category primitives\n * @since 0.67.0\n */\nexport class SymbolFromSelf extends make<symbol>(AST.symbolKeyword) {}\n\n/** @ignore */\nclass String$ extends make<string>(AST.stringKeyword) {}\n\n/** @ignore */\nclass Number$ extends make<number>(AST.numberKeyword) {}\n\n/** @ignore */\nclass Boolean$ extends make<boolean>(AST.booleanKeyword) {}\n\n/** @ignore */\nclass Object$ extends make<object>(AST.objectKeyword) {}\n\nexport {\n  /**\n   * @category primitives\n   * @since 0.67.0\n   */\n  Boolean$ as Boolean,\n  /**\n   * @category primitives\n   * @since 0.67.0\n   */\n  Number$ as Number,\n  /**\n   * @category primitives\n   * @since 0.67.0\n   */\n  Object$ as Object,\n  /**\n   * @category primitives\n   * @since 0.67.0\n   */\n  String$ as String\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Union<Members extends ReadonlyArray<Schema.Any>> extends\n  AnnotableClass<\n    Union<Members>,\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >\n{\n  readonly members: Readonly<Members>\n  annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members>\n}\n\nconst getDefaultUnionAST = <Members extends ReadonlyArray<Schema.Any>>(members: Members) =>\n  AST.Union.members(members.map((m) => m.ast))\n\nconst makeUnionClass = <Members extends ReadonlyArray<Schema.Any>>(\n  members: Members,\n  ast: AST.AST = getDefaultUnionAST(members)\n): Union<Members> =>\n  class UnionClass\n    extends make<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>(ast)\n  {\n    static override annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members> {\n      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static members = [...members] as any as Members\n  }\n\n/**\n * @category combinators\n * @since 0.67.0\n */\nexport function Union<Members extends AST.Members<Schema.Any>>(...members: Members): Union<Members>\nexport function Union<Member extends Schema.Any>(member: Member): Member\nexport function Union(): typeof Never\nexport function Union<Members extends ReadonlyArray<Schema.Any>>(\n  ...members: Members\n): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>\nexport function Union<Members extends ReadonlyArray<Schema.Any>>(\n  ...members: Members\n):\n  | Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>\n  | typeof Never\n{\n  return AST.isMembers(members)\n    ? makeUnionClass(members)\n    : array_.isNonEmptyReadonlyArray(members)\n    ? members[0] as any\n    : Never\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface NullOr<S extends Schema.Any> extends Union<[S, typeof Null]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>\n}\n\n/**\n * @category combinators\n * @since 0.67.0\n */\nexport const NullOr = <S extends Schema.Any>(self: S): NullOr<S> => Union(self, Null)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface UndefinedOr<S extends Schema.Any> extends Union<[S, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>\n}\n\n/**\n * @category combinators\n * @since 0.67.0\n */\nexport const UndefinedOr = <S extends Schema.Any>(self: S): UndefinedOr<S> => Union(self, Undefined)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface NullishOr<S extends Schema.Any> extends Union<[S, typeof Null, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>\n}\n\n/**\n * @category combinators\n * @since 0.67.0\n */\nexport const NullishOr = <S extends Schema.Any>(self: S): NullishOr<S> => Union(self, Null, Undefined)\n\n/**\n * @category combinators\n * @since 0.67.0\n */\nexport const keyof = <A, I, R>(self: Schema<A, I, R>): SchemaClass<keyof A> => make<keyof A>(AST.keyof(self.ast))\n\n/**\n * @since 0.68.0\n */\nexport declare namespace Element {\n  /**\n   * @since 0.68.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n\n  /**\n   * @since 0.68.0\n   */\n  export type Token = \"\" | \"?\"\n}\n\n/**\n * @category API interface\n * @since 0.68.0\n */\nexport interface Element<S extends Schema.Any, Token extends Element.Token>\n  extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly _Token: Token\n  readonly ast: AST.OptionalType\n  readonly from: S\n  annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>\n}\n\n/**\n * @since 0.68.0\n */\nexport const element = <S extends Schema.Any>(self: S): Element<S, \"\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, false), self)\n\n/**\n * @since 0.67.0\n */\nexport const optionalElement = <S extends Schema.Any>(self: S): Element<S, \"?\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, true), self)\n\nclass ElementImpl<S extends Schema.Any, Token extends Element.Token> implements Element<S, Token> {\n  readonly [TypeId]!: Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>[TypeId]\n  readonly _Token!: Token\n  constructor(\n    readonly ast: AST.OptionalType,\n    readonly from: S\n  ) {}\n  annotations(\n    annotations: Annotations.Schema<Schema.Type<S>>\n  ): ElementImpl<S, Token> {\n    return new ElementImpl(\n      new AST.OptionalType(\n        this.ast.type,\n        this.ast.isOptional,\n        { ...this.ast.annotations, ...toASTAnnotations(annotations) }\n      ),\n      this.from\n    )\n  }\n  toString() {\n    return `${this.ast.type}${this.ast.isOptional ? \"?\" : \"\"}`\n  }\n}\n\n/**\n * @since 0.67.0\n */\nexport declare namespace TupleType {\n  type ElementsType<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]>\n    : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]>\n    : Out\n\n  type ElementsEncoded<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]>\n    : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]>\n    : Out\n\n  /**\n   * @since 0.67.0\n   */\n  export type Elements = ReadonlyArray<Schema.Any | Element<Schema.Any, Element.Token>>\n\n  /**\n   * @since 0.68.0\n   */\n  export type Rest = ReadonlyArray<Schema.Any | Element<Schema.Any, \"\">>\n\n  /**\n   * @since 0.67.0\n   */\n  export type Type<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsType<Elements>,\n      ...ReadonlyArray<Schema.Type<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Type<Tail[K]> }\n    ]> :\n    ElementsType<Elements>\n\n  /**\n   * @since 0.67.0\n   */\n  export type Encoded<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsEncoded<Elements>,\n      ...ReadonlyArray<Schema.Encoded<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Encoded<Tail[K]> }\n    ]> :\n    ElementsEncoded<Elements>\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends\n  AnnotableClass<\n    TupleType<Elements, Rest>,\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >\n{\n  readonly elements: Readonly<Elements>\n  readonly rest: Readonly<Rest>\n}\n\nconst getDefaultTupleTypeAST = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest\n) =>\n  new AST.TupleType(\n    elements.map((el) => isSchema(el) ? new AST.OptionalType(el.ast, false) : el.ast),\n    rest.map((el) => isSchema(el) ? new AST.Type(el.ast) : el.ast),\n    true\n  )\n\nconst makeTupleTypeClass = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest,\n  ast: AST.AST = getDefaultTupleTypeAST(elements, rest)\n) =>\n  class TupleTypeClass extends make<\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >(ast) {\n    static override annotations(\n      annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>\n    ): TupleType<Elements, Rest> {\n      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static elements = [...elements] as any as Elements\n\n    static rest = [...rest] as any as Rest\n  }\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport function Tuple<\n  const Elements extends TupleType.Elements,\n  Rest extends array_.NonEmptyReadonlyArray<TupleType.Rest[number]>\n>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>\nexport function Tuple<Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>\nexport function Tuple(...args: ReadonlyArray<any>): any {\n  return Array.isArray(args[0])\n    ? makeTupleTypeClass(args[0], args.slice(1))\n    : makeTupleTypeClass(args, [])\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>\n}\n\nconst makeArrayClass = <Value extends Schema.Any>(value: Value, ast?: AST.AST): Array$<Value> =>\n  class ArrayClass extends makeTupleTypeClass<[], [Value]>([], [value], ast) {\n    static override annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>) {\n      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static value = value\n  }\n\nconst Array$ = <Value extends Schema.Any>(value: Value): Array$<Value> => makeArrayClass(value)\n\nexport {\n  /**\n   * @category constructors\n   * @since 0.67.0\n   */\n  Array$ as Array\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface NonEmptyArray<Value extends Schema.Any> extends TupleType<[Value], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>): NonEmptyArray<Value>\n}\n\nconst makeNonEmptyArrayClass = <Value extends Schema.Any>(value: Value, ast?: AST.AST): NonEmptyArray<Value> =>\n  class NonEmptyArrayClass extends makeTupleTypeClass<[Value], [Value]>([value], [value], ast) {\n    static override annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>) {\n      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static value = value\n  }\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const NonEmptyArray = <Value extends Schema.Any>(value: Value): NonEmptyArray<Value> =>\n  makeNonEmptyArrayClass(value)\n\n/**\n * @since 0.67.0\n */\nexport declare namespace PropertySignature {\n  /**\n   * @since 0.67.0\n   */\n  export type Token = \"?:\" | \":\"\n\n  /**\n   * @since 0.67.0\n   */\n  export type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<\n    Token,\n    any,\n    Key,\n    Token,\n    any,\n    boolean,\n    unknown\n  >\n\n  /**\n   * @since 0.67.0\n   */\n  export type All<Key extends PropertyKey = PropertyKey> =\n    | Any<Key>\n    | PropertySignature<Token, never, Key, Token, any, boolean, unknown>\n    | PropertySignature<Token, any, Key, Token, never, boolean, unknown>\n    | PropertySignature<Token, never, Key, Token, never, boolean, unknown>\n\n  /**\n   * @since 0.67.0\n   */\n  export type AST =\n    | PropertySignatureDeclaration\n    | PropertySignatureTransformation\n\n  /**\n   * @since 0.67.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n}\n\nconst formatPropertySignatureToken = (isOptional: boolean): string => isOptional ? \"\\\"?:\\\"\" : \"\\\":\\\"\"\n\n/**\n * @category PropertySignature\n * @since 0.67.0\n */\nexport class PropertySignatureDeclaration extends AST.OptionalType {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"PropertySignatureDeclaration\"\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    const token = formatPropertySignatureToken(this.isOptional)\n    const type = String(this.type)\n    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 0.67.0\n */\nexport class FromPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly fromKey?: PropertyKey | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 0.67.0\n */\nexport class ToPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\nconst formatPropertyKey = (p: PropertyKey | undefined): string => {\n  if (p === undefined) {\n    return \"never\"\n  }\n  if (Predicate.isString(p)) {\n    return JSON.stringify(p)\n  }\n  return String(p)\n}\n\n/**\n * @category PropertySignature\n * @since 0.67.0\n */\nexport class PropertySignatureTransformation {\n  /**\n   * @since 0.67.0\n   */\n  readonly _tag = \"PropertySignatureTransformation\"\n  constructor(\n    readonly from: FromPropertySignature,\n    readonly to: ToPropertySignature,\n    readonly decode: AST.PropertySignatureTransformation[\"decode\"],\n    readonly encode: AST.PropertySignatureTransformation[\"encode\"]\n  ) {}\n  /**\n   * @since 0.67.0\n   */\n  toString() {\n    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${\n      formatPropertyKey(this.from.fromKey)\n    }, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`\n  }\n}\n\nconst mergeSignatureAnnotations = (\n  ast: PropertySignature.AST,\n  annotations: AST.Annotations\n): PropertySignature.AST => {\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return new PropertySignatureDeclaration(\n        ast.type,\n        ast.isOptional,\n        ast.isReadonly,\n        { ...ast.annotations, ...annotations },\n        ast.defaultValue\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      return new PropertySignatureTransformation(\n        new FromPropertySignature(\n          ast.from.type,\n          ast.from.isOptional,\n          ast.from.isReadonly,\n          ast.from.annotations\n        ),\n        new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {\n          ...ast.to.annotations,\n          ...annotations\n        }, ast.to.defaultValue),\n        ast.decode,\n        ast.encode\n      )\n    }\n  }\n}\n\n/**\n * @since 0.68.0\n * @category symbol\n */\nexport const PropertySignatureTypeId: unique symbol = Symbol.for(\"@effect/schema/PropertySignature\")\n\n/**\n * @since 0.68.0\n * @category symbol\n */\nexport type PropertySignatureTypeId = typeof PropertySignatureTypeId\n\n/**\n * @category PropertySignature\n * @since 0.67.0\n */\nexport interface PropertySignature<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends Schema.Variance<Type, Encoded, R>, Pipeable {\n  readonly [PropertySignatureTypeId]: null\n  readonly _TypeToken: TypeToken\n  readonly _EncodedToken: EncodedToken\n  readonly _HasDefault: HasDefault\n  readonly _Key: Key\n  readonly ast: PropertySignature.AST\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n}\n\nclass PropertySignatureImpl<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> implements PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  readonly [TypeId]!: Schema.Variance<Type, Encoded, R>[TypeId]\n  readonly [PropertySignatureTypeId] = null\n  readonly _TypeToken!: TypeToken\n  readonly _Key!: Key\n  readonly _EncodedToken!: EncodedToken\n  readonly _HasDefault!: HasDefault\n\n  constructor(\n    readonly ast: PropertySignature.AST\n  ) {}\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)))\n  }\n\n  toString() {\n    return String(this.ast)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 0.67.15\n */\nexport const makePropertySignature = <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n>(ast: PropertySignature.AST) =>\n  new PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>(ast)\n\nclass PropertySignatureWithFromImpl<\n  From extends Schema.All,\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  constructor(ast: PropertySignature.AST, readonly from: From) {\n    super(ast)\n  }\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignatureWithFromImpl<From, TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureWithFromImpl(\n      mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)),\n      this.from\n    )\n  }\n}\n\n/**\n * @category API interface\n * @since 1.0.0\n */\nexport interface propertySignature<S extends Schema.All>\n  extends PropertySignature<\":\", Schema.Type<S>, never, \":\", Schema.Encoded<S>, false, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>\n}\n\n/**\n * Lifts a `Schema` into a `PropertySignature`.\n *\n * @category PropertySignature\n * @since 0.67.0\n */\nexport const propertySignature = <S extends Schema.All>(\n  self: S\n): propertySignature<S> =>\n  new PropertySignatureWithFromImpl(\n    new PropertySignatureDeclaration(self.ast, false, true, {}, undefined),\n    self\n  )\n\n/**\n * Enhances a property signature with a default constructor value.\n *\n * @category PropertySignature\n * @since 0.67.0\n */\nexport const withConstructorDefault: {\n  <Type>(defaultValue: () => Types.NoInfer<Type>): <\n    TypeToken extends PropertySignature.Token,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n  <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n    defaultValue: () => Types.NoInfer<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n} = dual(2, <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  R\n>(\n  self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n  defaultValue: () => Types.NoInfer<Type>\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\":\n      return makePropertySignature(\n        new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue)\n      )\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue),\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\nconst applyDefaultValue = <A>(o: option_.Option<A>, defaultValue: () => A) =>\n  option_.match(o, {\n    onNone: () => option_.some(defaultValue()),\n    onSome: (value) => option_.some(value === undefined ? defaultValue() : value)\n  })\n\n/**\n * Enhances a property signature with a default decoding value.\n *\n * @category PropertySignature\n * @since 0.67.0\n */\nexport const withDecodingDefault: {\n  <Type>(defaultValue: () => Types.NoInfer<Type>): <\n    Key extends PropertyKey,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, HasDefault, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, HasDefault, R>\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, HasDefault, R>,\n    defaultValue: () => Types.NoInfer<Type>\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, HasDefault, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n  defaultValue: () => Types.NoInfer<Type>\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast,\n          new ToPropertySignature(AST.typeAST(ast.type), false, true, {}, undefined),\n          (o) => applyDefaultValue(o, defaultValue),\n          identity\n        )\n      )\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(ast.to.type, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue),\n          (o) => applyDefaultValue(ast.decode(o), defaultValue),\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * Enhances a property signature with a default decoding value and a default constructor value.\n *\n * @category PropertySignature\n * @since 0.67.0\n */\nexport const withDefaults: {\n  <Type>(defaults: {\n    constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n    decoding: () => Types.NoInfer<Type>\n  }): <\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Type>\n    }\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n  defaults: {\n    constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n    decoding: () => Types.NoInfer<Type>\n  }\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R> =>\n  self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)))\n\n/**\n * Enhances a property signature by specifying a different key for it in the Encoded type.\n *\n * @category PropertySignature\n * @since 0.67.0\n */\nexport const fromKey: {\n  <Key extends PropertyKey>(key: Key): <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n  <\n    Type,\n    TypeToken extends PropertySignature.Token,\n    Encoded,\n    EncodedToken extends PropertySignature.Token,\n    HasDefault extends boolean,\n    R,\n    Key extends PropertyKey\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n    key: Key\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n} = dual(2, <\n  Type,\n  TypeToken extends PropertySignature.Token,\n  Encoded,\n  EncodedToken extends PropertySignature.Token,\n  HasDefault extends boolean,\n  R,\n  Key extends PropertyKey\n>(\n  self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n  key: Key\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.type,\n            ast.isOptional,\n            ast.isReadonly,\n            ast.annotations,\n            key\n          ),\n          new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue),\n          identity,\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.from.type,\n            ast.from.isOptional,\n            ast.from.isReadonly,\n            ast.from.annotations,\n            key\n          ),\n          ast.to,\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * Converts an optional property to a required one through a transformation `Option -> Type`.\n *\n * - `decode`: `none` as argument means the value is missing in the input.\n * - `encode`: `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 0.67.0\n */\nexport const optionalToRequired = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => TI\n    readonly encode: (ti: TI) => option_.Option<FA>\n  }\n): PropertySignature<\":\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, false, true, {}, undefined),\n      (o) => option_.some(options.decode(o)),\n      option_.flatMap(options.encode)\n    )\n  )\n\n/**\n * Converts an optional property to a required one through a transformation `Type -> Option`.\n *\n * - `decode`: `none` as return value means the value will be missing in the output.\n * - `encode`: `none` as argument means the value is missing in the input.\n *\n * @category PropertySignature\n * @since 0.67.15\n */\nexport const requiredToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (fa: FA) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => FA\n  }\n): PropertySignature<\"?:\", TA, never, \":\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, false, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      option_.flatMap(options.decode),\n      (o) => option_.some(options.encode(o))\n    )\n  )\n\n/**\n * Converts an optional property to another optional property through a transformation `Option -> Option`.\n *\n * - `decode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n * - `encode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 0.67.0\n */\nexport const optionalToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>\n  }\n): PropertySignature<\"?:\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      options.decode,\n      options.encode\n    )\n  )\n\n/**\n * @since 0.67.0\n */\nexport type OptionalOptions<A> = {\n  readonly default?: never\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly default: LazyArg<A>\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable?: never\n  readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable?: never\n  readonly onNoneEncoding?: never\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null>>\n} | undefined\n\n/**\n * @category api interface\n * @since 0.67.10\n */\nexport interface optional<S extends Schema.All> extends\n  PropertySignature<\n    \"?:\",\n    Schema.Type<S> | undefined,\n    never,\n    \"?:\",\n    Schema.Encoded<S> | undefined,\n    false,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>\n}\n\n/**\n * @category api interface\n * @since 0.67.10\n */\nexport interface optionalWithOptions<S extends Schema.All, Options> extends\n  PropertySignature<\n    Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n    | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n    | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n    never,\n    \"?:\",\n    | Schema.Encoded<S>\n    | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n    | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n    Types.Has<Options, \"default\">,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(\n    annotations: PropertySignature.Annotations<\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined)\n    >\n  ): optionalWithOptions<S, Options>\n}\n\nconst optionalPropertySignatureAST = <A, I, R>(\n  from: Schema<A, I, R>,\n  options?: {\n    readonly exact?: true\n    readonly default?: () => A\n    readonly nullable?: true\n    readonly as?: \"Option\"\n    readonly onNoneEncoding?: () => option_.Option<never>\n  }\n): PropertySignature.AST => {\n  const isExact = options?.exact\n  const defaultValue = options?.default\n  const isNullable = options?.nullable\n  const asOption = options?.as == \"Option\"\n  const asOptionEncode = options?.onNoneEncoding ? option_.orElse(options.onNoneEncoding) : identity\n\n  if (isExact) {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullOr(from),\n            typeSchema(from),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => a === null ? defaultValue() : a }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            from,\n            typeSchema(from),\n            { decode: option_.match({ onNone: defaultValue, onSome: identity }), encode: option_.some }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullOr(from),\n          OptionFromSelf(typeSchema(from)),\n          {\n            decode: option_.filter(Predicate.isNotNull<A | null>),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          from,\n          OptionFromSelf(typeSchema(from)),\n          { decode: identity, encode: identity }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullOr(from),\n          typeSchema(from),\n          { decode: option_.filter(Predicate.isNotNull<A | null>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(from.ast, true, true, {}, undefined)\n      }\n    }\n  } else {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullishOr(from),\n            typeSchema(from),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a == null ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            UndefinedOr(from),\n            typeSchema(from),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a === undefined ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullishOr(from),\n          OptionFromSelf(typeSchema(from)),\n          {\n            decode: option_.filter<A | null | undefined, A>((a): a is A => a != null),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          UndefinedOr(from),\n          OptionFromSelf(typeSchema(from)),\n          {\n            decode: option_.filter(Predicate.isNotUndefined<A | undefined>),\n            encode: asOptionEncode\n          }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullishOr(from),\n          UndefinedOr(typeSchema(from)),\n          { decode: option_.filter(Predicate.isNotNull<A | null | undefined>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(UndefinedOr(from).ast, true, true, {}, undefined)\n      }\n    }\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 0.67.0\n */\nexport const optional: {\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(\n    options?: Options\n  ): (self: S) => [undefined] extends [Options] ? optional<S> : optionalWithOptions<S, Options>\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(\n    self: S,\n    options?: Options\n  ): [undefined] extends [Options] ? optional<S> : optionalWithOptions<S, Options>\n} = dual((args) => isSchema(args[0]), (from, options) => {\n  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(from, options), from)\n})\n\n/**\n * @since 0.67.0\n */\nexport declare namespace Struct {\n  /**\n   * @since 0.67.0\n   */\n  export type Fields = {\n    readonly [x: PropertyKey]:\n      | Schema.All\n      | PropertySignature.All\n  }\n\n  type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never :\n    F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key :\n    K\n\n  type EncodedTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", any, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", never, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", any, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", never, boolean, unknown> ? K\n      : never\n  }[keyof Fields]\n\n  type TypeTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends OptionalPropertySignature ? K : never\n  }[keyof Fields]\n\n  type OptionalPropertySignature =\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n\n  /**\n   * @since 0.67.0\n   */\n  export type Type<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalPropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n\n  /**\n   * @since 0.67.0\n   */\n  export type Encoded<F extends Fields> =\n    & { readonly [K in Exclude<keyof F, EncodedTokenKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]> }\n    & { readonly [K in EncodedTokenKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]> }\n\n  /**\n   * @since 0.67.0\n   */\n  export type Context<F extends Fields> = Schema.Context<F[keyof F]>\n\n  type PropertySignatureWithDefault =\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, never, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, never, true, unknown>\n\n  /**\n   * @since 0.67.0\n   */\n  export type Constructor<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalPropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        F[K] extends PropertySignatureWithDefault ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n}\n\n/**\n * @since 0.67.0\n */\nexport declare namespace IndexSignature {\n  /**\n   * @since 0.67.0\n   */\n  export type Record = { readonly key: Schema.All; readonly value: Schema.All }\n\n  /**\n   * @since 0.67.0\n   */\n  export type Records = ReadonlyArray<Record>\n\n  /**\n   * @since 0.67.0\n   */\n  export type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>\n\n  /**\n   * @since 0.67.0\n   */\n  export type Type<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Type<Records[K][\"key\"]>]: Schema.Type<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 0.67.0\n   */\n  export type Encoded<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Encoded<Records[K][\"key\"]>]: Schema.Encoded<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 0.67.0\n   */\n  export type Context<Records extends IndexSignature.Records> = {\n    [K in keyof Records]: Schema.Context<Records[K][\"key\"]> | Schema.Context<Records[K][\"value\"]>\n  }[number]\n}\n\n/**\n * @since 0.67.0\n */\nexport declare namespace TypeLiteral {\n  /**\n   * @since 0.67.0\n   */\n  export type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Type<Fields>\n    & IndexSignature.Type<Records>\n\n  /**\n   * @since 0.67.0\n   */\n  export type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Encoded<Fields>\n    & IndexSignature.Encoded<Records>\n\n  /**\n   * @since 0.67.0\n   */\n  export type Constructor<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Constructor<Fields>\n    & IndexSignature.Type<Records>\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface TypeLiteral<\n  Fields extends Struct.Fields,\n  Records extends IndexSignature.Records\n> extends\n  AnnotableClass<\n    TypeLiteral<Fields, Records>,\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >\n{\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n  readonly records: Readonly<Records>\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records>\n  make(\n    props: Simplify<TypeLiteral.Constructor<Fields, Records>>,\n    options?: MakeOptions\n  ): Simplify<TypeLiteral.Type<Fields, Records>>\n}\n\nconst isPropertySignature = (u: unknown): u is PropertySignature.All =>\n  Predicate.hasProperty(u, PropertySignatureTypeId)\n\nconst getDefaultTypeLiteralAST = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(fields: Fields, records: Records) => {\n  const ownKeys = util_.ownKeys(fields)\n  const pss: Array<AST.PropertySignature> = []\n  if (ownKeys.length > 0) {\n    const from: Array<AST.PropertySignature> = []\n    const to: Array<AST.PropertySignature> = []\n    const transformations: Array<AST.PropertySignatureTransformation> = []\n    for (let i = 0; i < ownKeys.length; i++) {\n      const key = ownKeys[i]\n      const field = fields[key]\n      if (isPropertySignature(field)) {\n        const ast: PropertySignature.AST = field.ast\n        switch (ast._tag) {\n          case \"PropertySignatureDeclaration\": {\n            const type = ast.type\n            const isOptional = ast.isOptional\n            const toAnnotations = ast.annotations\n            from.push(new AST.PropertySignature(key, type, isOptional, true))\n            to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations))\n            pss.push(\n              new AST.PropertySignature(key, type, isOptional, true, toAnnotations)\n            )\n            break\n          }\n          case \"PropertySignatureTransformation\": {\n            const fromKey = ast.from.fromKey ?? key\n            from.push(\n              new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations)\n            )\n            to.push(\n              new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations)\n            )\n            transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode))\n            break\n          }\n        }\n      } else {\n        from.push(new AST.PropertySignature(key, field.ast, false, true))\n        to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true))\n        pss.push(new AST.PropertySignature(key, field.ast, false, true))\n      }\n    }\n    if (array_.isNonEmptyReadonlyArray(transformations)) {\n      const issFrom: Array<AST.IndexSignature> = []\n      const issTo: Array<AST.IndexSignature> = []\n      for (const r of records) {\n        const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n        propertySignatures.forEach((ps) => {\n          from.push(ps)\n          to.push(\n            new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations)\n          )\n        })\n        indexSignatures.forEach((is) => {\n          issFrom.push(is)\n          issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly))\n        })\n      }\n      return new AST.Transformation(\n        new AST.TypeLiteral(from, issFrom, { [AST.TitleAnnotationId]: \"Struct (Encoded side)\" }),\n        new AST.TypeLiteral(to, issTo, { [AST.TitleAnnotationId]: \"Struct (Type side)\" }),\n        new AST.TypeLiteralTransformation(transformations)\n      )\n    }\n  }\n  const iss: Array<AST.IndexSignature> = []\n  for (const r of records) {\n    const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n    propertySignatures.forEach((ps) => pss.push(ps))\n    indexSignatures.forEach((is) => iss.push(is))\n  }\n  return new AST.TypeLiteral(pss, iss)\n}\n\nconst lazilyMergeDefaults = (\n  fields: Struct.Fields,\n  out: Record<PropertyKey, unknown>\n): { [x: string | symbol]: unknown } => {\n  const ownKeys = util_.ownKeys(fields)\n  for (const key of ownKeys) {\n    const field = fields[key]\n    if (out[key] === undefined && isPropertySignature(field)) {\n      const ast = field.ast\n      const defaultValue = ast._tag === \"PropertySignatureDeclaration\" ? ast.defaultValue : ast.to.defaultValue\n      if (defaultValue !== undefined) {\n        out[key] = defaultValue()\n      }\n    }\n  }\n  return out\n}\n\nconst makeTypeLiteralClass = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(\n  fields: Fields,\n  records: Records,\n  ast: AST.AST = getDefaultTypeLiteralAST(fields, records)\n): TypeLiteral<Fields, Records> => {\n  return class TypeLiteralClass extends make<\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >(ast) {\n    static override annotations(\n      annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n    ): TypeLiteral<Fields, Records> {\n      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static fields = { ...fields }\n\n    static records = [...records] as Records\n\n    static make = (\n      props: Simplify<TypeLiteral.Constructor<Fields, Records>>,\n      options?: MakeOptions\n    ): Simplify<TypeLiteral.Type<Fields, Records>> => {\n      const propsWithDefaults: any = lazilyMergeDefaults(fields, { ...props as any })\n      return getDisableValidationMakeOption(options)\n        ? propsWithDefaults\n        : ParseResult.validateSync(this)(propsWithDefaults)\n    }\n\n    static pick(...keys: Array<keyof Fields>): Struct<Simplify<Pick<Fields, typeof keys[number]>>> {\n      return Struct(struct_.pick(fields, ...keys) as any)\n    }\n\n    static omit(...keys: Array<keyof Fields>): Struct<Simplify<Omit<Fields, typeof keys[number]>>> {\n      return Struct(struct_.omit(fields, ...keys) as any)\n    }\n  }\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Struct<Fields extends Struct.Fields> extends TypeLiteral<Fields, []> {\n  annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>\n  /** @since 0.68.17 */\n  pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>\n  /** @since 0.68.17 */\n  omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>\n}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records>\nexport function Struct<Fields extends Struct.Fields>(fields: Fields): Struct<Fields>\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records> {\n  return makeTypeLiteralClass(fields, records)\n}\n\n/**\n * @category api interface\n * @since 0.67.14\n */\nexport interface tag<Tag extends AST.LiteralValue> extends PropertySignature<\":\", Tag, never, \":\", Tag, true, never> {}\n\n/**\n * Returns a property signature that represents a tag.\n * A tag is a literal value that is used to distinguish between different types of objects.\n * The tag is optional when using the `make` method.\n *\n * @see {@link TaggedStruct}\n *\n * @example\n * import { Schema } from \"@effect/schema\"\n *\n * const User = Schema.Struct({\n *   _tag: Schema.tag(\"User\"),\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n *\n * @since 0.67.14\n */\nexport const tag = <Tag extends AST.LiteralValue>(tag: Tag): tag<Tag> =>\n  Literal(tag).pipe(propertySignature, withConstructorDefault(() => tag))\n\n/**\n * @category api interface\n * @since 0.67.14\n */\nexport type TaggedStruct<Tag extends AST.LiteralValue, Fields extends Struct.Fields> = Struct<\n  { _tag: tag<Tag> } & Fields\n>\n\n/**\n * A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.\n *\n * The tag is optional when using the `make` method.\n *\n * @example\n * import { Schema } from \"@effect/schema\"\n *\n * const User = Schema.TaggedStruct(\"User\", {\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n *\n * @category constructors\n * @since 0.67.14\n */\nexport const TaggedStruct = <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(\n  value: Tag,\n  fields: Fields\n): TaggedStruct<Tag, Fields> => Struct({ _tag: tag(value), ...fields })\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Record$<K extends Schema.All, V extends Schema.All> extends TypeLiteral<{}, [{ key: K; value: V }]> {\n  readonly key: K\n  readonly value: V\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n  ): Record$<K, V>\n}\n\nconst makeRecordClass = <K extends Schema.All, V extends Schema.All>(key: K, value: V, ast?: AST.AST): Record$<K, V> =>\n  class RecordClass extends makeTypeLiteralClass({}, [{ key, value }], ast) {\n    static override annotations(\n      annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n    ) {\n      return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static key = key\n\n    static value = value\n  }\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const Record = <K extends Schema.All, V extends Schema.All>(key: K, value: V): Record$<K, V> =>\n  makeRecordClass(key, value)\n\n/**\n * @category struct transformations\n * @since 0.67.0\n */\nexport const pick = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R> => make(AST.pick(self.ast, keys))\n\n/**\n * @category struct transformations\n * @since 0.67.0\n */\nexport const omit = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R> => make(AST.omit(self.ast, keys))\n\n/**\n * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * // ---------------------------------------------\n * // use case: pull out a single field from a\n * // struct through a transformation\n * // ---------------------------------------------\n *\n * const mytable = S.Struct({\n *   column1: S.NumberFromString,\n *   column2: S.Number\n * })\n *\n * // const pullOutColumn: S.Schema<number, {\n * //     readonly column1: string;\n * // }, never>\n * const pullOutColumn = mytable.pipe(S.pluck(\"column1\"))\n *\n * console.log(S.decodeUnknownEither(S.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n *\n * @category struct transformations\n * @since 0.67.0\n */\nexport const pluck: {\n  <A, I, K extends keyof A & keyof I>(\n    key: K\n  ): <R>(schema: Schema<A, I, R>) => Schema<A[K], { readonly [P in K]: I[P] }, R>\n  <A, I, R, K extends keyof A & keyof I>(\n    schema: Schema<A, I, R>,\n    key: K\n  ): Schema<A[K], { readonly [P in K]: I[P] }, R>\n} = dual(\n  2,\n  <A, I, R, K extends keyof A & keyof I>(\n    schema: Schema<A, I, R>,\n    key: K\n  ): Schema<A[K], Pick<I, K>, R> => {\n    const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key)\n    const value = make<A[K], A[K], R>(ps.isOptional ? AST.orUndefined(ps.type) : ps.type)\n    return transform(\n      schema.pipe(pick(key)),\n      value,\n      {\n        strict: true,\n        decode: (a: any) => a[key],\n        encode: (ak) => ps.isOptional && ak === undefined ? {} : { [key]: ak } as any\n      }\n    )\n  }\n)\n\n/**\n * @category branding\n * @since 0.67.0\n */\nexport interface BrandSchema<A extends Brand<any>, I = A, R = never>\n  extends AnnotableClass<BrandSchema<A, I, R>, A, I, R>\n{\n  make(a: Brand.Unbranded<A>, options?: MakeOptions): A\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface brand<S extends Schema.Any, B extends string | symbol>\n  extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>\n}\n\nconst makeBrandClass = <S extends Schema.Any, B extends string | symbol>(ast: AST.AST): brand<S, B> =>\n  class BrandClass extends make<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>(ast) {\n    static override annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B> {\n      return makeBrandClass(mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static make = (a: Brand.Unbranded<Schema.Type<S> & Brand<B>>, options?: MakeOptions): Schema.Type<S> & Brand<B> => {\n      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n    }\n  }\n\n/**\n * Returns a nominal branded schema by applying a brand to a given schema.\n *\n * ```\n * Schema<A> + B -> Schema<A & Brand<B>>\n * ```\n *\n * @param self - The input schema to be combined with the brand.\n * @param brand - The brand to apply.\n *\n * @example\n * import * as Schema from \"@effect/schema/Schema\"\n *\n * const Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\n * type Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">\n *\n * @category branding\n * @since 0.67.0\n */\nexport const brand = <S extends Schema.AnyNoContext, B extends string | symbol>(\n  brand: B,\n  annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>\n) =>\n(self: S): brand<S, B> => {\n  const annotation: AST.BrandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {\n    onNone: () => [brand],\n    onSome: (brands) => [...brands, brand]\n  })\n  const ast = AST.annotations(\n    self.ast,\n    toASTAnnotations({\n      // add a default title annotation containing the brand\n      title: String(self.ast) + ` & Brand<${util_.formatUnknown(brand)}>`,\n      ...annotations,\n      [AST.BrandAnnotationId]: annotation\n    })\n  )\n  return makeBrandClass(ast)\n}\n\n/**\n * @category combinators\n * @since 0.67.0\n */\nexport const partial: {\n  <const Options extends { readonly exact: true } | undefined>(\n    options?: Options\n  ): <A, I, R>(\n    self: Schema<A, I, R>\n  ) => SchemaClass<\n    { [K in keyof A]?: A[K] | ([undefined] extends [Options] ? undefined : never) },\n    { [K in keyof I]?: I[K] | ([undefined] extends [Options] ? undefined : never) },\n    R\n  >\n  <A, I, R, const Options extends { readonly exact: true } | undefined>(\n    self: Schema<A, I, R>,\n    options?: Options\n  ): SchemaClass<\n    { [K in keyof A]?: A[K] | ([undefined] extends [Options] ? undefined : never) },\n    { [K in keyof I]?: I[K] | ([undefined] extends [Options] ? undefined : never) },\n    R\n  >\n} = dual((args) => isSchema(args[0]), <A, I, R>(\n  self: Schema<A, I, R>,\n  options?: { readonly exact: true }\n): SchemaClass<Partial<A>, Partial<I>, R> => make(AST.partial(self.ast, options)))\n\n/**\n * @category combinators\n * @since 0.67.0\n */\nexport const required = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]-?: A[K] }, { [K in keyof I]-?: I[K] }, R> => make(AST.required(self.ast))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface mutable<S extends Schema.Any> extends\n  AnnotableClass<\n    mutable<S>,\n    SimplifyMutable<Schema.Type<S>>,\n    SimplifyMutable<Schema.Encoded<S>>,\n    Schema.Context<S>\n  >\n{}\n\n/**\n * Creates a new schema with shallow mutability applied to its properties.\n *\n * @param schema - The original schema to make properties mutable (shallowly).\n *\n * @category combinators\n * @since 0.67.0\n */\nexport const mutable = <S extends Schema.Any>(schema: S): mutable<S> => make(AST.mutable(schema.ast))\n\nconst intersectTypeLiterals = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.TypeLiteral => {\n  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {\n    const propertySignatures = [...x.propertySignatures]\n    for (const ps of y.propertySignatures) {\n      const name = ps.name\n      const i = propertySignatures.findIndex((ps) => ps.name === name)\n      if (i === -1) {\n        propertySignatures.push(ps)\n      } else {\n        const { isOptional, type } = propertySignatures[i]\n        propertySignatures[i] = new AST.PropertySignature(\n          name,\n          extendAST(type, ps.type, path.concat(name)),\n          isOptional,\n          true\n        )\n      }\n    }\n    return new AST.TypeLiteral(\n      propertySignatures,\n      x.indexSignatures.concat(y.indexSignatures)\n    )\n  }\n  throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n}\n\nconst preserveRefinementAnnotations = AST.preserveAnnotations([AST.MessageAnnotationId, AST.JSONSchemaAnnotationId])\n\nconst addRefinementToMembers = (refinement: AST.Refinement, asts: ReadonlyArray<AST.AST>): Array<AST.Refinement> =>\n  asts.map((ast) => new AST.Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)))\n\nconst extendAST = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.AST => AST.Union.make(intersectUnionMembers([x], [y], path))\n\nconst getTypes = (ast: AST.AST): ReadonlyArray<AST.AST> => AST.isUnion(ast) ? ast.types : [ast]\n\nconst intersectUnionMembers = (\n  xs: ReadonlyArray<AST.AST>,\n  ys: ReadonlyArray<AST.AST>,\n  path: ReadonlyArray<PropertyKey>\n): Array<AST.AST> =>\n  array_.flatMap(xs, (x) =>\n    array_.flatMap(ys, (y) => {\n      switch (x._tag) {\n        case \"Union\":\n          return intersectUnionMembers(x.types, getTypes(y), path)\n        case \"Suspend\":\n          return [new AST.Suspend(() => extendAST(x.f(), y, path))]\n        case \"Refinement\":\n          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), getTypes(y), path))\n        case \"TypeLiteral\": {\n          switch (y._tag) {\n            case \"Union\":\n              return intersectUnionMembers([x], y.types, path)\n            case \"Suspend\":\n              return [new AST.Suspend(() => extendAST(x, y.f(), path))]\n            case \"Refinement\":\n              return addRefinementToMembers(y, intersectUnionMembers([x], getTypes(y.from), path))\n            case \"TypeLiteral\":\n              return [intersectTypeLiterals(x, y, path)]\n            case \"Transformation\": {\n              if (AST.isTypeLiteralTransformation(y.transformation)) {\n                return [\n                  new AST.Transformation(\n                    intersectTypeLiterals(x, y.from, path),\n                    intersectTypeLiterals(AST.typeAST(x), y.to, path),\n                    new AST.TypeLiteralTransformation(\n                      y.transformation.propertySignatureTransformations\n                    )\n                  )\n                ]\n              }\n              break\n            }\n          }\n          break\n        }\n        case \"Transformation\": {\n          if (AST.isTypeLiteralTransformation(x.transformation)) {\n            switch (y._tag) {\n              case \"Union\":\n                return intersectUnionMembers([x], y.types, path)\n              case \"Suspend\":\n                return [new AST.Suspend(() => extendAST(x, y.f(), path))]\n              case \"Refinement\":\n                return addRefinementToMembers(y, intersectUnionMembers([x], getTypes(y.from), path))\n              case \"TypeLiteral\":\n                return [\n                  new AST.Transformation(\n                    intersectTypeLiterals(x.from, y, path),\n                    intersectTypeLiterals(x.to, AST.typeAST(y), path),\n                    new AST.TypeLiteralTransformation(\n                      x.transformation.propertySignatureTransformations\n                    )\n                  )\n                ]\n              case \"Transformation\":\n                {\n                  if (AST.isTypeLiteralTransformation(y.transformation)) {\n                    return [\n                      new AST.Transformation(\n                        intersectTypeLiterals(x.from, y.from, path),\n                        intersectTypeLiterals(x.to, y.to, path),\n                        new AST.TypeLiteralTransformation(\n                          x.transformation.propertySignatureTransformations.concat(\n                            y.transformation.propertySignatureTransformations\n                          )\n                        )\n                      )\n                    ]\n                  }\n                }\n                break\n            }\n          }\n          break\n        }\n      }\n      throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n    }))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface extend<Self extends Schema.Any, That extends Schema.Any> extends\n  AnnotableClass<\n    extend<Self, That>,\n    Schema.Type<Self> & Schema.Type<That>,\n    Schema.Encoded<Self> & Schema.Encoded<That>,\n    Schema.Context<Self> | Schema.Context<That>\n  >\n{}\n\n/**\n * Extends a schema by adding additional fields or index signatures.\n *\n * 1) It only supports **structs**, refinements of structs, unions of structs, suspensions of structs\n * (informally `Supported = Struct | Refinement of Supported | Union of Supported | suspend(() => Supported)`)\n * 2) The arguments must represent disjoint types (e.g., `extend(Struct({ a: String }), Struct({ a: String })))` raises an error)\n *\n * @example\n * import * as Schema from \"@effect/schema/Schema\"\n *\n * const schema = Schema.Struct({\n *   a: Schema.String,\n *   b: Schema.String\n * })\n *\n * // const extended: S.Schema<{\n * //     readonly [x: string]: string;\n * //     readonly a: string;\n * //     readonly b: string;\n * //     readonly c: string;\n * // }>\n * const extended = Schema.asSchema(schema.pipe(\n *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n *   Schema.extend(Schema.Record(Schema.String, Schema.String)) // <= you can add index signatures\n * ))\n *\n * @category combinators\n * @since 0.67.0\n */\nexport const extend: {\n  <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>\n} = dual(\n  2,\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That) => make(extendAST(self.ast, that.ast, []))\n)\n\n/**\n * @category combinators\n * @since 0.67.0\n */\nexport const compose: {\n  <D, C extends B, R2, B>(\n    to: Schema<D, C, R2>\n  ): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n  <D, C, R2>(\n    to: Schema<D, C, R2>\n  ): <B extends C, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n  <C, B, R2>(\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<C, A, R1 | R2>\n  <D, C, R2>(\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): <B, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n\n  <B, A, R1, D, C extends B, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<D, C, R2>\n  ): SchemaClass<D, A, R1 | R2>\n  <B extends C, A, R1, D, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<D, C, R2>\n  ): SchemaClass<D, A, R1 | R2>\n  <B, A, R1, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): SchemaClass<C, A, R1 | R2>\n  <B, A, R1, D, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): SchemaClass<D, A, R1 | R2>\n} = dual(\n  (args) => isSchema(args[1]),\n  <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2> =>\n    make(AST.compose(from.ast, to.ast))\n)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 0.67.0\n */\nexport const suspend = <A, I, R>(f: () => Schema<A, I, R>): suspend<A, I, R> => make(new AST.Suspend(() => f().ast))\n\n/**\n * @since 0.68.8\n * @category symbol\n */\nexport const refineTypeId: unique symbol = Symbol.for(\"@effect/schema/refine\")\n\n/**\n * @since 0.68.8\n * @category symbol\n */\nexport type refineTypeId = typeof refineTypeId\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface refine<A, From extends Schema.Any>\n  extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>>\n{\n  readonly [refineTypeId]: From\n  readonly from: From\n  readonly filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>\n  make(a: Schema.Type<From>, options?: MakeOptions): A\n}\n\nconst makeRefineClass = <From extends Schema.Any, A>(\n  from: From,\n  filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>,\n  ast: AST.AST\n): refine<A, From> =>\n  class RefineClass extends make<A, Schema.Encoded<From>, Schema.Context<From>>(ast) {\n    static override annotations(annotations: Annotations.Schema<A>): refine<A, From> {\n      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static [refineTypeId] = from\n\n    static from = from\n\n    static filter = filter\n\n    static make = (a: Schema.Type<From>, options?: MakeOptions): A => {\n      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n    }\n  }\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {}\n\nconst fromFilterPredicateReturnTypeItem = (\n  item: FilterOutput,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (Predicate.isBoolean(item)) {\n    return item\n      ? option_.none()\n      : option_.some(new ParseResult.Type(ast, input))\n  }\n  if (Predicate.isString(item)) {\n    return option_.some(new ParseResult.Type(ast, input, item))\n  }\n  if (item !== undefined) {\n    if (\"_tag\" in item) {\n      return option_.some(item)\n    }\n    const issue = new ParseResult.Type(ast, input, item.message)\n    return option_.some(\n      array_.isNonEmptyReadonlyArray(item.path) ? new ParseResult.Pointer(item.path, input, issue) : issue\n    )\n  }\n  return option_.none()\n}\n\nconst toFilterParseIssue = (\n  out: FilterReturnType,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (util_.isSingle(out)) {\n    return fromFilterPredicateReturnTypeItem(out, ast, input)\n  }\n  if (array_.isNonEmptyReadonlyArray(out)) {\n    const issues = array_.filterMap(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input))\n    if (array_.isNonEmptyReadonlyArray(issues)) {\n      return option_.some(issues.length === 1 ? issues[0] : new ParseResult.Composite(ast, input, issues))\n    }\n  }\n  return option_.none()\n}\n\n/**\n * @category filtering\n * @since 0.68.0\n */\nexport interface FilterIssue {\n  readonly path: ReadonlyArray<PropertyKey>\n  readonly message: string\n}\n\n/**\n * @category filtering\n * @since 0.68.0\n */\nexport type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue\n\ntype FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>\n\n/**\n * @category filtering\n * @since 0.67.0\n */\nexport function filter<C extends A, B extends A, A = C>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<C & B, C>\n): <I, R>(self: Schema<C, I, R>) => refine<C & B, Schema<A, I, R>>\nexport function filter<A, B extends A>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<B, A>\n): <I, R>(self: Schema<A, I, R>) => refine<B, Schema<A, I, R>>\nexport function filter<S extends Schema.Any>(\n  predicate: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<Types.NoInfer<Schema.Type<S>>>\n): (self: S) => filter<S>\nexport function filter<A>(\n  predicate: (\n    a: A,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => refine<A, Schema<A, I, R>> {\n  return <I, R>(self: Schema<A, I, R>) => {\n    function filter(input: A, options: AST.ParseOptions, ast: AST.Refinement) {\n      return toFilterParseIssue(predicate(input, options, ast), ast, input)\n    }\n    const ast = new AST.Refinement(\n      self.ast,\n      filter,\n      toASTAnnotations(annotations)\n    )\n    return makeRefineClass(self, filter, ast)\n  }\n}\n\n/**\n * @category api interface\n * @since 0.68.17\n */\nexport interface filterEffect<S extends Schema.Any, FD = never>\n  extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD>\n{}\n\n/**\n * @category transformations\n * @since 0.68.17\n */\nexport const filterEffect: {\n  <S extends Schema.Any, FD>(\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, FD>\n  ): (self: S) => filterEffect<S, FD>\n  <S extends Schema.Any, RD>(\n    self: S,\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, RD>\n  ): filterEffect<S, RD>\n} = dual(2, <S extends Schema.Any, FD>(\n  self: S,\n  f: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Transformation\n  ) => Effect.Effect<FilterReturnType, never, FD>\n): filterEffect<S, FD> =>\n  transformOrFail(\n    self,\n    typeSchema(self),\n    {\n      strict: true,\n      decode: (a, options, ast) =>\n        ParseResult.flatMap(\n          f(a, options, ast),\n          (filterReturnType) =>\n            option_.match(toFilterParseIssue(filterReturnType, ast, a), {\n              onNone: () => ParseResult.succeed(a),\n              onSome: ParseResult.fail\n            })\n        ),\n      encode: ParseResult.succeed\n    }\n  ))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface transformOrFail<From extends Schema.Any, To extends Schema.Any, R = never> extends\n  AnnotableClass<\n    transformOrFail<From, To, R>,\n    Schema.Type<To>,\n    Schema.Encoded<From>,\n    Schema.Context<From> | Schema.Context<To> | R\n  >\n{\n  readonly from: From\n  readonly to: To\n}\n\nconst makeTransformationClass = <From extends Schema.Any, To extends Schema.Any, R>(\n  from: From,\n  to: To,\n  ast: AST.AST\n): transformOrFail<From, To, R> =>\n  class TransformationClass\n    extends make<Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R>(ast)\n  {\n    static override annotations(annotations: Annotations.Schema<Schema.Type<To>>) {\n      return makeTransformationClass<From, To, R>(\n        this.from,\n        this.to,\n        mergeSchemaAnnotations(this.ast, annotations)\n      )\n    }\n\n    static from = from\n\n    static to = to\n  }\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided decoding functions.\n *\n * @category transformations\n * @since 0.67.0\n */\nexport const transformOrFail: {\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): (from: From) => transformOrFail<From, To, RD | RE>\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): transformOrFail<From, To, RD | RE>\n} = dual((args) => isSchema(args[0]) && isSchema(args[1]), <FromA, FromI, FromR, ToA, ToI, ToR, RD, RE>(\n  from: Schema<FromA, FromI, FromR>,\n  to: Schema<ToA, ToI, ToR>,\n  options: {\n    readonly decode: (\n      fromA: FromA,\n      options: ParseOptions,\n      ast: AST.Transformation\n    ) => Effect.Effect<ToI, ParseResult.ParseIssue, RD>\n    readonly encode: (\n      toI: ToI,\n      options: ParseOptions,\n      ast: AST.Transformation\n    ) => Effect.Effect<FromA, ParseResult.ParseIssue, RE>\n  }\n): Schema<ToA, FromI, FromR | ToR | RD | RE> =>\n  makeTransformationClass(\n    from,\n    to,\n    new AST.Transformation(\n      from.ast,\n      to.ast,\n      new AST.FinalTransformation(options.decode, options.encode)\n    )\n  ))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface transform<From extends Schema.Any, To extends Schema.Any> extends transformOrFail<From, To> {\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided mapping functions.\n *\n * @category transformations\n * @since 0.67.0\n */\nexport const transform: {\n  <To extends Schema.Any, From extends Schema.Any>(\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>) => unknown\n      readonly strict: false\n    }\n  ): (from: From) => transform<From, To>\n  <To extends Schema.Any, From extends Schema.Any>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>) => unknown\n      readonly strict: false\n    }\n  ): transform<From, To>\n} = dual(\n  (args) => isSchema(args[0]) && isSchema(args[1]),\n  <FromA, FromI, FromR, ToA, ToI, ToR>(\n    from: Schema<FromA, FromI, FromR>,\n    to: Schema<ToA, ToI, ToR>,\n    options: {\n      readonly decode: (fromA: FromA) => ToI\n      readonly encode: (toI: ToI) => FromA\n    }\n  ): Schema<ToA, FromI, FromR | ToR> =>\n    transformOrFail(\n      from,\n      to,\n      {\n        strict: true,\n        decode: (fromA) => ParseResult.succeed(options.decode(fromA)),\n        encode: (toI) => ParseResult.succeed(options.encode(toI))\n      }\n    )\n)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface transformLiteral<Type, Encoded> extends Annotable<transformLiteral<Type, Encoded>, Type, Encoded> {}\n\n/**\n * Creates a new `Schema` which transforms literal values.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * const schema = S.transformLiteral(0, \"a\")\n *\n * assert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")\n *\n * @category constructors\n * @since 0.67.0\n */\nexport const transformLiteral = <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  from: Encoded,\n  to: Type\n): transformLiteral<Type, Encoded> =>\n  transform(Literal(from), Literal(to), { strict: true, decode: () => to, encode: () => from })\n\n/**\n * Creates a new `Schema` which maps between corresponding literal values.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * const Animal = S.transformLiterals(\n *   [0, \"cat\"],\n *   [1, \"dog\"],\n *   [2, \"cow\"]\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Animal)(1), \"dog\")\n *\n * @category constructors\n * @since 0.67.0\n */\nexport function transformLiterals<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(\n  ...pairs: A\n): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]> }>\nexport function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  pairs: [Encoded, Type]\n): transformLiteral<Type, Encoded>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]> {\n  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)))\n}\n\n/**\n * Attaches a property signature with the specified key and value to the schema.\n * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n *\n * @param self - The input schema.\n * @param key - The name of the property to add to the schema.\n * @param value - The value of the property to add to the schema.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n * import { pipe } from \"effect/Function\"\n *\n * const Circle = S.Struct({ radius: S.Number })\n * const Square = S.Struct({ sideLength: S.Number })\n * const Shape = S.Union(\n *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n *   kind: \"circle\",\n *   radius: 10\n * })\n *\n * @category combinators\n * @since 0.67.0\n */\nexport const attachPropertySignature: {\n  <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): <I, R>(\n    schema: SchemaClass<A, I, R>\n  ) => Schema<Simplify<A & { readonly [k in K]: V }>, I, R>\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R> => {\n    const ast = extend(\n      typeSchema(schema),\n      Struct({ [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value) })\n    ).ast\n    return make(\n      new AST.Transformation(\n        schema.ast,\n        annotations ? mergeSchemaAnnotations(ast, annotations) : ast,\n        new AST.TypeLiteralTransformation(\n          [\n            new AST.PropertySignatureTransformation(\n              key,\n              key,\n              () => option_.some(value),\n              () => option_.none()\n            )\n          ]\n        )\n      )\n    )\n  }\n)\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport declare namespace Annotations {\n  /**\n   * @category annotations\n   * @since 0.67.0\n   */\n  export interface Doc<A> extends AST.Annotations {\n    readonly title?: AST.TitleAnnotation\n    readonly description?: AST.DescriptionAnnotation\n    readonly documentation?: AST.DocumentationAnnotation\n    readonly examples?: AST.ExamplesAnnotation<A>\n    readonly default?: AST.DefaultAnnotation<A>\n  }\n\n  /**\n   * @since 0.67.0\n   */\n  export interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {\n    readonly identifier?: AST.IdentifierAnnotation\n    readonly message?: AST.MessageAnnotation\n    readonly typeId?: AST.TypeAnnotation | { id: AST.TypeAnnotation; annotation: unknown }\n    readonly jsonSchema?: AST.JSONSchemaAnnotation\n    readonly arbitrary?: (\n      ...arbitraries: { readonly [K in keyof TypeParameters]: LazyArbitrary<TypeParameters[K]> }\n    ) => LazyArbitrary<A>\n    readonly pretty?: (\n      ...pretties: { readonly [K in keyof TypeParameters]: pretty_.Pretty<TypeParameters[K]> }\n    ) => pretty_.Pretty<A>\n    readonly equivalence?: (\n      ...equivalences: { readonly [K in keyof TypeParameters]: Equivalence.Equivalence<TypeParameters[K]> }\n    ) => Equivalence.Equivalence<A>\n    readonly concurrency?: AST.ConcurrencyAnnotation\n    readonly batching?: AST.BatchingAnnotation\n    readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation\n    readonly parseOptions?: AST.ParseOptions\n  }\n\n  /**\n   * @since 0.67.0\n   */\n  export interface Filter<A, P = A> extends Schema<A, readonly [P]> {}\n}\n\n/**\n * @category annotations\n * @since 0.67.0\n */\nexport const annotations: {\n  <S extends Annotable.All>(annotations: Annotations.Schema<Schema.Type<S>>): (self: S) => Annotable.Self<S>\n  <S extends Annotable.All>(self: S, annotations: Annotations.Schema<Schema.Type<S>>): Annotable.Self<S>\n} = dual(\n  2,\n  <A, I, R>(self: Schema<A, I, R>, annotations: Annotations.Schema<A>): Schema<A, I, R> => self.annotations(annotations)\n)\n\ntype Rename<A, M> = {\n  [\n    K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K]\n      : never\n      : K\n  ]: A[K]\n}\n\n/**\n * @category renaming\n * @since 0.67.0\n */\nexport const rename: {\n  <\n    A,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    mapping: M\n  ): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    self: Schema<A, I, R>,\n    mapping: M\n  ): SchemaClass<Simplify<Rename<A, M>>, I, R>\n} = dual(\n  2,\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    self: Schema<A, I, R>,\n    mapping: M\n  ): SchemaClass<Simplify<Rename<A, M>>, I, R> => make(AST.rename(self.ast, mapping))\n)\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const TrimmedTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Trimmed\")\n\n/**\n * Verifies that a string contains no leading or trailing whitespaces.\n *\n * Note. This combinator does not make any transformations, it only validates.\n * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.\n *\n * @category string filters\n * @since 0.67.0\n */\nexport const trimmed =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.trim(), {\n        typeId: TrimmedTypeId,\n        description: \"a string with no leading or trailing whitespace\",\n        jsonSchema: { pattern: \"^\\\\S[\\\\s\\\\S]*\\\\S$|^\\\\S$|^$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const MaxLengthTypeId: unique symbol = filters_.MaxLengthTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type MaxLengthTypeId = typeof MaxLengthTypeId\n\n/**\n * @category string filters\n * @since 0.67.0\n */\nexport const maxLength = <A extends string>(\n  maxLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.length <= maxLength,\n      {\n        typeId: MaxLengthTypeId,\n        description: `a string at most ${maxLength} character(s) long`,\n        jsonSchema: { maxLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const MinLengthTypeId: unique symbol = filters_.MinLengthTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type MinLengthTypeId = typeof MinLengthTypeId\n\n/**\n * @category string filters\n * @since 0.67.0\n */\nexport const minLength = <A extends string>(\n  minLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.length >= minLength,\n      {\n        typeId: MinLengthTypeId,\n        description: `a string at least ${minLength} character(s) long`,\n        jsonSchema: { minLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const PatternTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Pattern\")\n\n/**\n * @category string filters\n * @since 0.67.0\n */\nexport const pattern = <A extends string>(\n  regex: RegExp,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const pattern = regex.source\n  return self.pipe(\n    filter(\n      (a): a is A => {\n        // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag\n        regex.lastIndex = 0\n        return regex.test(a)\n      },\n      {\n        typeId: { id: PatternTypeId, annotation: { regex } },\n        description: `a string matching the pattern ${pattern}`,\n        jsonSchema: { pattern },\n        arbitrary: () => (fc) => fc.stringMatching(regex) as any,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const StartsWithTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/StartsWith\")\n\n/**\n * @category string filters\n * @since 0.67.0\n */\nexport const startsWith = <A extends string>(\n  startsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.startsWith(startsWith),\n      {\n        typeId: { id: StartsWithTypeId, annotation: { startsWith } },\n        description: `a string starting with ${JSON.stringify(startsWith)}`,\n        jsonSchema: { pattern: `^${startsWith}` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const EndsWithTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/EndsWith\")\n\n/**\n * @category string filters\n * @since 0.67.0\n */\nexport const endsWith = <A extends string>(\n  endsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.endsWith(endsWith),\n      {\n        typeId: { id: EndsWithTypeId, annotation: { endsWith } },\n        description: `a string ending with ${JSON.stringify(endsWith)}`,\n        jsonSchema: { pattern: `^.*${endsWith}$` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const IncludesTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Includes\")\n\n/**\n * @category string filters\n * @since 0.67.0\n */\nexport const includes = <A extends string>(\n  searchString: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.includes(searchString),\n      {\n        typeId: { id: IncludesTypeId, annotation: { includes: searchString } },\n        description: `a string including ${JSON.stringify(searchString)}`,\n        jsonSchema: { pattern: `.*${searchString}.*` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LowercasedTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Lowercased\")\n\n/**\n * Verifies that a string is lowercased.\n *\n * @category string filters\n * @since 0.67.0\n */\nexport const lowercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.toLowerCase(), {\n        typeId: LowercasedTypeId,\n        description: \"a lowercase string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 0.67.0\n */\nexport class Lowercased extends String$.pipe(\n  lowercased({ identifier: \"Lowercased\", title: \"Lowercased\" })\n) {}\n\n/**\n * @category type id\n * @since 0.68.18\n */\nexport const CapitalizedTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Capitalized\")\n\n/**\n * Verifies that a string is capitalized.\n *\n * @category string filters\n * @since 0.68.18\n */\nexport const capitalized =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a[0]?.toUpperCase() === a[0], {\n        typeId: CapitalizedTypeId,\n        description: \"a capitalized string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 0.68.18\n */\nexport class Capitalized extends String$.pipe(\n  capitalized({ identifier: \"Capitalized\", title: \"Capitalized\" })\n) {}\n\n/**\n * @category type id\n * @since 0.68.18\n */\nexport const UncapitalizedTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Uncapitalized\")\n\n/**\n * Verifies that a string is uncapitalized.\n *\n * @category string filters\n * @since 0.68.18\n */\nexport const uncapitalized =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a[0]?.toLowerCase() === a[0], {\n        typeId: UncapitalizedTypeId,\n        description: \"a uncapitalized string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 0.68.18\n */\nexport class Uncapitalized extends String$.pipe(\n  uncapitalized({ identifier: \"Uncapitalized\", title: \"Uncapitalized\" })\n) {}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const UppercasedTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Uppercased\")\n\n/**\n * Verifies that a string is uppercased.\n *\n * @category string filters\n * @since 0.67.0\n */\nexport const uppercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.toUpperCase(), {\n        typeId: UppercasedTypeId,\n        description: \"an uppercase string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 0.67.0\n */\nexport class Uppercased extends String$.pipe(\n  uppercased({ identifier: \"Uppercased\", title: \"Uppercased\" })\n) {}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LengthTypeId: unique symbol = filters_.LengthTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type LengthTypeId = typeof LengthTypeId\n\n/**\n * @category string filters\n * @since 0.67.0\n */\nexport const length = <A extends string>(\n  length: number | { readonly min: number; readonly max: number },\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length))\n  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength\n  if (minLength !== maxLength) {\n    return self.pipe(\n      filter((a) => a.length >= minLength && a.length <= maxLength, {\n        typeId: LengthTypeId,\n        description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,\n        jsonSchema: { minLength, maxLength },\n        ...annotations\n      })\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length === minLength, {\n      typeId: LengthTypeId,\n      description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,\n      jsonSchema: { minLength, maxLength: minLength },\n      ...annotations\n    })\n  )\n}\n\n/**\n * A schema representing a single character.\n *\n * @category string constructors\n * @since 0.67.0\n */\nexport class Char extends String$.pipe(length(1, { identifier: \"Char\" })) {}\n\n/**\n * @category string filters\n * @since 0.67.0\n */\nexport const nonEmpty = <A extends string>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  minLength(1, {\n    description: \"a non empty string\",\n    ...annotations\n  })\n\n/**\n * This schema converts a string to lowercase.\n *\n * @category string transformations\n * @since 0.67.0\n */\nexport class Lowercase extends transform(\n  String$,\n  Lowercased,\n  { strict: true, decode: (s) => s.toLowerCase(), encode: identity }\n).annotations({ identifier: \"Lowercase\" }) {}\n\n/**\n * This schema converts a string to uppercase.\n *\n * @category string transformations\n * @since 0.67.0\n */\nexport class Uppercase extends transform(\n  String$,\n  Uppercased,\n  { strict: true, decode: (s) => s.toUpperCase(), encode: identity }\n).annotations({ identifier: \"Uppercase\" }) {}\n\n/**\n * This schema converts a string to capitalized one.\n *\n * @category string transformations\n * @since 0.68.18\n */\nexport class Capitalize extends transform(\n  String$,\n  Capitalized,\n  { strict: true, decode: (s) => string_.capitalize(s), encode: identity }\n).annotations({ identifier: \"Capitalize\" }) {}\n\n/**\n * This schema converts a string to uncapitalized one.\n *\n * @category string transformations\n * @since 0.68.18\n */\nexport class Uncapitalize extends transform(\n  String$,\n  Uncapitalized,\n  { strict: true, decode: (s) => string_.uncapitalize(s), encode: identity }\n).annotations({ identifier: \"Uncapitalize\" }) {}\n\n/**\n * @category string constructors\n * @since 0.67.0\n */\nexport class Trimmed extends String$.pipe(\n  trimmed({ identifier: \"Trimmed\", title: \"Trimmed\" })\n) {}\n\n/**\n * This schema allows removing whitespaces from the beginning and end of a string.\n *\n * @category string transformations\n * @since 0.67.0\n */\nexport class Trim extends transform(\n  String$,\n  Trimmed,\n  { strict: true, decode: (s) => s.trim(), encode: identity }\n).annotations({ identifier: \"Trim\" }) {}\n\n/**\n * Returns a schema that allows splitting a string into an array of strings.\n *\n * @category string transformations\n * @since 0.67.0\n */\nexport const split = (separator: string): transform<typeof String$, Array$<typeof String$>> =>\n  transform(\n    String$,\n    Array$(String$),\n    { strict: true, decode: string_.split(separator), encode: array_.join(separator) }\n  )\n\n/**\n * @since 0.67.0\n */\nexport type ParseJsonOptions = {\n  readonly reviver?: Parameters<typeof JSON.parse>[1]\n  readonly replacer?: Parameters<typeof JSON.stringify>[1]\n  readonly space?: Parameters<typeof JSON.stringify>[2]\n}\n\nconst JsonString = String$.annotations({\n  [AST.IdentifierAnnotationId]: \"JsonString\",\n  [AST.TitleAnnotationId]: \"JsonString\",\n  [AST.DescriptionAnnotationId]: \"a JSON string\"\n})\n\nconst getParseJsonTransformation = (options?: ParseJsonOptions) =>\n  transformOrFail(\n    JsonString,\n    Unknown,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.parse(s, options?.reviver),\n          catch: (e: any) => new ParseResult.Type(ast, s, e.message)\n        }),\n      encode: (u, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.stringify(u, options?.replacer, options?.space),\n          catch: (e: any) => new ParseResult.Type(ast, u, e.message)\n        })\n    }\n  ).annotations({ typeId: filters_.ParseJsonTypeId })\n\n/**\n * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n *\n * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n *\n * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson(S.Struct({ a: S.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n *\n * @category string transformations\n * @since 0.67.0\n */\nexport const parseJson: {\n  <A, I, R>(schema: Schema<A, I, R>, options?: ParseJsonOptions): SchemaClass<A, string, R>\n  (options?: ParseJsonOptions): SchemaClass<unknown, string>\n} = <A, I, R>(schema?: Schema<A, I, R> | ParseJsonOptions, o?: ParseJsonOptions) =>\n  isSchema(schema)\n    ? compose(parseJson(o), schema) as any\n    : getParseJsonTransformation(schema as ParseJsonOptions | undefined)\n\n/**\n * @category string constructors\n * @since 0.67.0\n */\nexport class NonEmpty extends String$.pipe(\n  nonEmpty({ identifier: \"NonEmpty\", title: \"NonEmpty\" })\n) {}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const UUIDTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/UUID\")\n\nconst uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i\n\n/**\n * Represents a Universally Unique Identifier (UUID).\n *\n * This schema ensures that the provided string adheres to the standard UUID format.\n *\n * @category string constructors\n * @since 0.67.0\n */\nexport class UUID extends String$.pipe(\n  pattern(uuidRegexp, {\n    typeId: UUIDTypeId,\n    identifier: \"UUID\",\n    title: \"UUID\",\n    description: \"a Universally Unique Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.uuid()\n  })\n) {}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const ULIDTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/ULID\")\n\nconst ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i\n\n/**\n * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).\n *\n * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.\n * This schema ensures that the provided string adheres to the standard ULID format.\n *\n * @category string constructors\n * @since 0.67.0\n */\nexport class ULID extends String$.pipe(\n  pattern(ulidRegexp, {\n    typeId: ULIDTypeId,\n    identifier: \"ULID\",\n    title: \"ULID\",\n    description: \"a Universally Unique Lexicographically Sortable Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.ulid()\n  })\n) {}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const FiniteTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Finite\")\n\n/**\n * Ensures that the provided value is a finite number.\n *\n * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.\n *\n * @category number filters\n * @since 0.67.0\n */\nexport const finite =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => Number.isFinite(a), {\n        typeId: FiniteTypeId,\n        description: \"a finite number\",\n        ...annotations\n      })\n    )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const GreaterThanTypeId: unique symbol = filters_.GreaterThanTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type GreaterThanTypeId = typeof GreaterThanTypeId\n\n/**\n * This filter checks whether the provided number is greater than the specified minimum.\n *\n * @category number filters\n * @since 0.67.0\n */\nexport const greaterThan = <A extends number>(\n  min: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      typeId: GreaterThanTypeId,\n      description: min === 0 ? \"a positive number\" : `a number greater than ${min}`,\n      jsonSchema: { exclusiveMinimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const GreaterThanOrEqualToTypeId: unique symbol = filters_.GreaterThanOrEqualToTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type GreaterThanOrEqualToTypeId = typeof GreaterThanOrEqualToTypeId\n\n/**\n * This filter checks whether the provided number is greater than or equal to the specified minimum.\n *\n * @category number filters\n * @since 0.67.0\n */\nexport const greaterThanOrEqualTo = <A extends number>(\n  min: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      typeId: GreaterThanOrEqualToTypeId,\n      description: min === 0 ? \"a non-negative number\" : `a number greater than or equal to ${min}`,\n      jsonSchema: { minimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const MultipleOfTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/MultipleOf\")\n\n/**\n * @category number filters\n * @since 0.67.0\n */\nexport const multipleOf = <A extends number>(\n  divisor: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => number_.remainder(a, divisor) === 0, {\n      typeId: MultipleOfTypeId,\n      description: `a number divisible by ${divisor}`,\n      jsonSchema: { multipleOf: Math.abs(divisor) }, // spec requires positive divisor\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const IntTypeId: unique symbol = filters_.IntTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type IntTypeId = typeof IntTypeId\n\n/**\n * @category number filters\n * @since 0.67.0\n */\nexport const int =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => Number.isSafeInteger(a), {\n        typeId: IntTypeId,\n        title: \"integer\",\n        description: \"an integer\",\n        jsonSchema: { type: \"integer\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LessThanTypeId: unique symbol = filters_.LessThanTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type LessThanTypeId = typeof LessThanTypeId\n\n/**\n * This filter checks whether the provided number is less than the specified maximum.\n *\n * @category number filters\n * @since 0.67.0\n */\nexport const lessThan =\n  <A extends number>(max: number, annotations?: Annotations.Filter<A>) =>\n  <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a < max, {\n        typeId: LessThanTypeId,\n        description: max === 0 ? \"a negative number\" : `a number less than ${max}`,\n        jsonSchema: { exclusiveMaximum: max },\n        ...annotations\n      })\n    )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LessThanOrEqualToTypeId: unique symbol = filters_.LessThanOrEqualToTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type LessThanOrEqualToTypeId = typeof LessThanOrEqualToTypeId\n\n/**\n * This schema checks whether the provided number is less than or equal to the specified maximum.\n *\n * @category number filters\n * @since 0.67.0\n */\nexport const lessThanOrEqualTo = <A extends number>(\n  max: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      typeId: LessThanOrEqualToTypeId,\n      description: max === 0 ? \"a non-positive number\" : `a number less than or equal to ${max}`,\n      jsonSchema: { maximum: max },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const BetweenTypeId: unique symbol = filters_.BetweenTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type BetweenTypeId = typeof BetweenTypeId\n\n/**\n * This filter checks whether the provided number falls within the specified minimum and maximum values.\n *\n * @category number filters\n * @since 0.67.0\n */\nexport const between = <A extends number>(\n  min: number,\n  max: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min && a <= max, {\n      typeId: BetweenTypeId,\n      description: `a number between ${min} and ${max}`,\n      jsonSchema: { maximum: max, minimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const NonNaNTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/NonNaN\")\n\n/**\n * @category number filters\n * @since 0.67.0\n */\nexport const nonNaN =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a), {\n        typeId: NonNaNTypeId,\n        description: \"a number excluding NaN\",\n        ...annotations\n      })\n    )\n\n/**\n * @category number filters\n * @since 0.67.0\n */\nexport const positive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThan(0, annotations)\n\n/**\n * @category number filters\n * @since 0.67.0\n */\nexport const negative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThan(0, annotations)\n\n/**\n * @category number filters\n * @since 0.67.0\n */\nexport const nonPositive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThanOrEqualTo(0, annotations)\n\n/**\n * @category number filters\n * @since 0.67.0\n */\nexport const nonNegative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThanOrEqualTo(0, annotations)\n\n/**\n * Clamps a number between a minimum and a maximum value.\n *\n * @category number transformations\n * @since 0.67.0\n */\nexport const clamp =\n  (minimum: number, maximum: number) =>\n  <A extends number, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, between(minimum, maximum)),\n      { strict: false, decode: (self) => number_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * Transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number transformations\n * @since 0.67.0\n */\nexport const parseNumber = <A extends string, I, R>(\n  self: Schema<A, I, R>\n): transformOrFail<Schema<A, I, R>, typeof Number$> =>\n  transformOrFail(\n    self,\n    Number$,\n    {\n      strict: false,\n      decode: (s, _, ast) => ParseResult.fromOption(number_.parse(s), () => new ParseResult.Type(ast, s)),\n      encode: (n) => ParseResult.succeed(String(n))\n    }\n  )\n\n/**\n * This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number constructors\n * @since 0.67.0\n */\nexport class NumberFromString extends parseNumber(String$).annotations({ identifier: \"NumberFromString\" }) {}\n\n/**\n * @category number constructors\n * @since 0.67.0\n */\nexport class Finite extends Number$.pipe(finite({ identifier: \"Finite\", title: \"Finite\" })) {}\n\n/**\n * @category number constructors\n * @since 0.67.0\n */\nexport class Int extends Number$.pipe(int({ identifier: \"Int\", title: \"Int\" })) {}\n\n/**\n * @category number constructors\n * @since 0.67.0\n */\nexport class NonNaN extends Number$.pipe(nonNaN({ identifier: \"NonNaN\", title: \"NonNaN\" })) {}\n\n/**\n * @category number constructors\n * @since 0.67.0\n */\nexport class Positive extends Number$.pipe(\n  positive({ identifier: \"Positive\", title: \"Positive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 0.67.0\n */\nexport class Negative extends Number$.pipe(\n  negative({ identifier: \"Negative\", title: \"Negative\" })\n) {}\n\n/**\n * @category number constructors\n * @since 0.67.0\n */\nexport class NonPositive extends Number$.pipe(\n  nonPositive({ identifier: \"NonPositive\", title: \"NonPositive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 0.67.0\n */\nexport class NonNegative extends Number$.pipe(\n  nonNegative({ identifier: \"NonNegative\", title: \"NonNegative\" })\n) {}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const JsonNumberTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/JsonNumber\")\n\n/**\n * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\n * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\n * format.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * const is = S.is(S.JsonNumber)\n *\n * assert.deepStrictEqual(is(42), true)\n * assert.deepStrictEqual(is(Number.NaN), false)\n * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\n * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n *\n * @category number constructors\n * @since 0.67.0\n */\nexport class JsonNumber extends Number$.pipe(\n  filter((n) => !Number.isNaN(n) && Number.isFinite(n), {\n    typeId: JsonNumberTypeId,\n    identifier: \"JsonNumber\",\n    title: \"JSON-compatible number\",\n    description: \"a JSON-compatible number, excluding NaN, +Infinity, and -Infinity\",\n    jsonSchema: { type: \"number\" }\n  })\n) {}\n\n/**\n * @category boolean transformations\n * @since 0.67.0\n */\nexport class Not extends transform(Boolean$, Boolean$, { strict: true, decode: boolean_.not, encode: boolean_.not }) {}\n\n/** @ignore */\nclass Symbol$ extends transform(\n  String$,\n  SymbolFromSelf,\n  { strict: false, decode: (s) => Symbol.for(s), encode: (sym) => sym.description }\n).annotations({ identifier: \"symbol\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `symbol`.\n   *\n   * @category symbol transformations\n   * @since 0.67.0\n   */\n  Symbol$ as Symbol\n}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const GreaterThanBigIntTypeId: unique symbol = filters_.GreaterThanBigintTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type GreaterThanBigIntTypeId = typeof GreaterThanBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 0.67.0\n */\nexport const greaterThanBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      typeId: { id: GreaterThanBigIntTypeId, annotation: { min } },\n      description: min === 0n ? \"a positive bigint\" : `a bigint greater than ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const GreaterThanOrEqualToBigIntTypeId: unique symbol = filters_.GreaterThanOrEqualToBigIntTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type GreaterThanOrEqualToBigIntTypeId = typeof GreaterThanOrEqualToBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 0.67.0\n */\nexport const greaterThanOrEqualToBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      typeId: { id: GreaterThanOrEqualToBigIntTypeId, annotation: { min } },\n      description: min === 0n\n        ? \"a non-negative bigint\"\n        : `a bigint greater than or equal to ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LessThanBigIntTypeId: unique symbol = filters_.LessThanBigIntTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type LessThanBigIntTypeId = typeof LessThanBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 0.67.0\n */\nexport const lessThanBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a < max, {\n      typeId: { id: LessThanBigIntTypeId, annotation: { max } },\n      description: max === 0n ? \"a negative bigint\" : `a bigint less than ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LessThanOrEqualToBigIntTypeId: unique symbol = filters_.LessThanOrEqualToBigIntTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type LessThanOrEqualToBigIntTypeId = typeof LessThanOrEqualToBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 0.67.0\n */\nexport const lessThanOrEqualToBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      typeId: { id: LessThanOrEqualToBigIntTypeId, annotation: { max } },\n      description: max === 0n ? \"a non-positive bigint\" : `a bigint less than or equal to ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const BetweenBigIntTypeId: unique symbol = filters_.BetweenBigintTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type BetweenBigIntTypeId = typeof BetweenBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 0.67.0\n */\nexport const betweenBigInt = <A extends bigint>(\n  min: bigint,\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min && a <= max, {\n      typeId: { id: BetweenBigIntTypeId, annotation: { max, min } },\n      description: `a bigint between ${min}n and ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category bigint filters\n * @since 0.67.0\n */\nexport const positiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThanBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 0.67.0\n */\nexport const negativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThanBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 0.67.0\n */\nexport const nonNegativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThanOrEqualToBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 0.67.0\n */\nexport const nonPositiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThanOrEqualToBigInt(0n, annotations)\n\n/**\n * Clamps a bigint between a minimum and a maximum value.\n *\n * @category bigint transformations\n * @since 0.67.0\n */\nexport const clampBigInt =\n  (minimum: bigint, maximum: bigint) =>\n  <A extends bigint, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigInt(minimum, maximum)),\n      { strict: false, decode: (self) => bigInt_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/** @ignore */\nclass BigInt$ extends transformOrFail(\n  String$,\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) => ParseResult.fromOption(bigInt_.fromString(s), () => new ParseResult.Type(ast, s)),\n    encode: (n) => ParseResult.succeed(String(n))\n  }\n).annotations({ identifier: \"bigint\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n   *\n   * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n   *\n   * @category bigint transformations\n   * @since 0.67.0\n   */\n  BigInt$ as BigInt\n}\n\n/**\n * @category bigint constructors\n * @since 0.67.0\n */\nexport const PositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  positiveBigInt({ identifier: \"PositiveBigintFromSelf\", title: \"PositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 0.67.0\n */\nexport const PositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  positiveBigInt({ identifier: \"PositiveBigint\", title: \"PositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 0.67.0\n */\nexport const NegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  negativeBigInt({ identifier: \"NegativeBigintFromSelf\", title: \"NegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 0.67.0\n */\nexport const NegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  negativeBigInt({ identifier: \"NegativeBigint\", title: \"NegativeBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 0.67.0\n */\nexport const NonPositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigintFromSelf\", title: \"NonPositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 0.67.0\n */\nexport const NonPositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigint\", title: \"NonPositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 0.67.0\n */\nexport const NonNegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigintFromSelf\", title: \"NonNegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 0.67.0\n */\nexport const NonNegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigint\", title: \"NonNegativeBigint\" })\n)\n\n/**\n * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n *\n * It returns an error if the value can't be safely encoded as a `number` due to being out of range.\n *\n * @category bigint transformations\n * @since 0.67.0\n */\nexport class BigIntFromNumber extends transformOrFail(\n  Number$,\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (n, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.fromNumber(n),\n        () => new ParseResult.Type(ast, n)\n      ),\n    encode: (b, _, ast) => ParseResult.fromOption(bigInt_.toNumber(b), () => new ParseResult.Type(ast, b))\n  }\n).annotations({ identifier: \"BigintFromNumber\" }) {}\n\nconst redactedArbitrary = <A>(value: LazyArbitrary<A>): LazyArbitrary<redacted_.Redacted<A>> => (fc) =>\n  value(fc).map((x) => redacted_.make(x))\n\nconst toComposite = <A, R, B>(\n  eff: Effect.Effect<A, ParseResult.ParseIssue, R>,\n  onSuccess: (a: A) => B,\n  ast: AST.AST,\n  actual: unknown\n): Effect.Effect<B, ParseResult.Composite, R> =>\n  ParseResult.mapBoth(eff, {\n    onFailure: (e) => new ParseResult.Composite(ast, actual, e),\n    onSuccess\n  })\n\nconst redactedParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<redacted_.Redacted<A>, R> =>\n(u, options, ast) =>\n  redacted_.isRedacted(u) ?\n    toComposite(decodeUnknown(redacted_.value(u), options), redacted_.make, ast, u) :\n    ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.21\n */\nexport interface RedactedFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    RedactedFromSelf<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    redacted_.Redacted<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Redacted constructors\n * @since 0.67.21\n */\nexport const RedactedFromSelf = <Value extends Schema.Any>(\n  value: Value\n): RedactedFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (value) => redactedParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => redactedParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: \"Redacted(<redacted>)\",\n      pretty: () => () => \"Redacted(<redacted>)\",\n      arbitrary: redactedArbitrary,\n      equivalence: redacted_.getEquivalence\n    }\n  )\n\n/**\n * @category api interface\n * @since 0.67.21\n */\nexport interface Redacted<Value extends Schema.Any> extends\n  AnnotableClass<\n    Redacted<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    Schema.Encoded<Value>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * A schema that transforms any type `A` into a `Redacted<A>`.\n *\n * @category Redacted transformations\n * @since 0.67.21\n */\nexport const Redacted = <Value extends Schema.Any>(\n  value: Value\n): Redacted<Value> => {\n  return transform(\n    value,\n    RedactedFromSelf(typeSchema(value)),\n    {\n      strict: true,\n      decode: (value) => redacted_.make(value),\n      encode: (value) => redacted_.value(value)\n    }\n  )\n}\n\n/**\n * @category Duration constructors\n * @since 0.67.0\n */\nexport class DurationFromSelf extends declare(\n  duration_.isDuration,\n  {\n    identifier: \"DurationFromSelf\",\n    pretty: (): pretty_.Pretty<duration_.Duration> => String,\n    arbitrary: (): LazyArbitrary<duration_.Duration> => (fc) =>\n      fc.oneof(\n        fc.constant(duration_.infinity),\n        fc.bigUint().map((_) => duration_.nanos(_)),\n        fc.bigUint().map((_) => duration_.micros(_)),\n        fc.maxSafeNat().map((_) => duration_.millis(_)),\n        fc.maxSafeNat().map((_) => duration_.seconds(_)),\n        fc.maxSafeNat().map((_) => duration_.minutes(_)),\n        fc.maxSafeNat().map((_) => duration_.hours(_)),\n        fc.maxSafeNat().map((_) => duration_.days(_)),\n        fc.maxSafeNat().map((_) => duration_.weeks(_))\n      ),\n    equivalence: (): Equivalence.Equivalence<duration_.Duration> => duration_.Equivalence\n  }\n) {}\n\n/**\n * A schema that transforms a `bigint` tuple into a `Duration`.\n * Treats the value as the number of nanoseconds.\n *\n * @category Duration transformations\n * @since 0.67.0\n */\nexport class DurationFromNanos extends transformOrFail(\n  BigIntFromSelf,\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: (nanos) => ParseResult.succeed(duration_.nanos(nanos)),\n    encode: (duration, _, ast) =>\n      option_.match(duration_.toNanos(duration), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, duration)),\n        onSome: (val) => ParseResult.succeed(val)\n      })\n  }\n).annotations({ identifier: \"DurationFromNanos\" }) {}\n\n/**\n * A schema that transforms a `number` tuple into a `Duration`.\n * Treats the value as the number of milliseconds.\n *\n * @category Duration transformations\n * @since 0.67.0\n */\nexport class DurationFromMillis extends transform(\n  Number$,\n  DurationFromSelf,\n  { strict: true, decode: (ms) => duration_.millis(ms), encode: (n) => duration_.toMillis(n) }\n).annotations({ identifier: \"DurationFromMillis\" }) {}\n\nconst hrTime: Schema<readonly [seconds: number, nanos: number]> = Tuple(\n  NonNegative.pipe(\n    finite({\n      [AST.TitleAnnotationId]: \"seconds\",\n      [AST.DescriptionAnnotationId]: \"seconds\"\n    })\n  ),\n  NonNegative.pipe(\n    finite({\n      [AST.TitleAnnotationId]: \"nanos\",\n      [AST.DescriptionAnnotationId]: \"nanos\"\n    })\n  )\n)\n\n/**\n * A schema that transforms a `[number, number]` tuple into a `Duration`.\n *\n * @category Duration transformations\n * @since 0.67.0\n */\nexport class Duration extends transform(\n  hrTime,\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: ([seconds, nanos]) => duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos)),\n    encode: (duration) => duration_.toHrTime(duration)\n  }\n).annotations({ identifier: \"Duration\" }) {}\n\n/**\n * Clamps a `Duration` between a minimum and a maximum value.\n *\n * @category Duration transformations\n * @since 0.67.0\n */\nexport const clampDuration =\n  (minimum: duration_.DurationInput, maximum: duration_.DurationInput) =>\n  <A extends duration_.Duration, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenDuration(minimum, maximum)),\n      { strict: false, decode: (self) => duration_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LessThanDurationTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/LessThanDuration\")\n\n/**\n * @category Duration filters\n * @since 0.67.0\n */\nexport const lessThanDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.lessThan(a, max), {\n      typeId: { id: LessThanDurationTypeId, annotation: { max } },\n      description: `a Duration less than ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LessThanOrEqualToDurationTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/LessThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 0.67.0\n */\nexport const lessThanOrEqualToDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.lessThanOrEqualTo(a, max), {\n      typeId: { id: LessThanDurationTypeId, annotation: { max } },\n      description: `a Duration less than or equal to ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const GreaterThanDurationTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/GreaterThanDuration\")\n\n/**\n * @category Duration filters\n * @since 0.67.0\n */\nexport const greaterThanDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.greaterThan(a, min), {\n      typeId: { id: GreaterThanDurationTypeId, annotation: { min } },\n      description: `a Duration greater than ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const GreaterThanOrEqualToDurationTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 0.67.0\n */\nexport const greaterThanOrEqualToDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.greaterThanOrEqualTo(a, min), {\n      typeId: { id: GreaterThanOrEqualToDurationTypeId, annotation: { min } },\n      description: `a Duration greater than or equal to ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const BetweenDurationTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/BetweenDuration\")\n\n/**\n * @category Duration filters\n * @since 0.67.0\n */\nexport const betweenDuration = <A extends duration_.Duration>(\n  minimum: duration_.DurationInput,\n  maximum: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.between(a, { minimum, maximum }), {\n      typeId: { id: BetweenDurationTypeId, annotation: { maximum, minimum } },\n      description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category Uint8Array constructors\n * @since 0.67.0\n */\nexport const Uint8ArrayFromSelf: Schema<Uint8Array> = declare(\n  Predicate.isUint8Array,\n  {\n    identifier: \"Uint8ArrayFromSelf\",\n    pretty: (): pretty_.Pretty<Uint8Array> => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,\n    arbitrary: (): LazyArbitrary<Uint8Array> => (fc) => fc.uint8Array(),\n    equivalence: (): Equivalence.Equivalence<Uint8Array> => array_.getEquivalence(Equal.equals) as any\n  }\n)\n\nconst Uint8Array$: Schema<Uint8Array, ReadonlyArray<number>> = transform(\n  Array$(Number$.pipe(\n    between(0, 255, {\n      title: \"8-bit unsigned integer\",\n      description: \"a 8-bit unsigned integer\"\n    })\n  )).annotations({ description: \"an array of 8-bit unsigned integers\" }),\n  Uint8ArrayFromSelf,\n  { strict: true, decode: (numbers) => Uint8Array.from(numbers), encode: (uint8Array) => Array.from(uint8Array) }\n).annotations({ identifier: \"Uint8Array\" })\n\nexport {\n  /**\n   * A schema that transforms a `number` array into a `Uint8Array`.\n   *\n   * @category Uint8Array transformations\n   * @since 0.67.0\n   */\n  Uint8Array$ as Uint8Array\n}\n\nconst makeEncodingTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<Uint8Array, Encoding.DecodeException>,\n  encode: (u: Uint8Array) => string\n): Schema<Uint8Array, string> =>\n  transformOrFail(\n    String$,\n    Uint8ArrayFromSelf,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        either_.mapLeft(\n          decode(s),\n          (decodeException) => new ParseResult.Type(ast, s, decodeException.message)\n        ),\n      encode: (u) => ParseResult.succeed(encode(u))\n    }\n  ).annotations({ identifier: id })\n\n/**\n * @category Encoding transformations\n * @since 0.67.0\n */\nexport const Base64: Schema<Uint8Array, string> = makeEncodingTransformation(\n  \"Base64\",\n  Encoding.decodeBase64,\n  Encoding.encodeBase64\n)\n\n/**\n * @category Encoding transformations\n * @since 0.67.0\n */\nexport const Base64Url: Schema<Uint8Array, string> = makeEncodingTransformation(\n  \"Base64Url\",\n  Encoding.decodeBase64Url,\n  Encoding.encodeBase64Url\n)\n\n/**\n * @category Encoding transformations\n * @since 0.67.0\n */\nexport const Hex: Schema<Uint8Array, string> = makeEncodingTransformation(\n  \"Hex\",\n  Encoding.decodeHex,\n  Encoding.encodeHex\n)\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const MinItemsTypeId: unique symbol = filters_.MinItemsTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type MinItemsTypeId = typeof MinItemsTypeId\n\n/**\n * @category ReadonlyArray filters\n * @since 0.67.0\n */\nexport const minItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> => {\n  const minItems = Math.floor(n)\n  if (minItems < 1) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter(\n      (a) => a.length >= minItems,\n      {\n        typeId: MinItemsTypeId,\n        description: `an array of at least ${minItems} items`,\n        jsonSchema: { minItems },\n        [AST.StableFilterAnnotationId]: true,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const MaxItemsTypeId: unique symbol = filters_.MaxItemsTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type MaxItemsTypeId = typeof MaxItemsTypeId\n\n/**\n * @category ReadonlyArray filters\n * @since 0.67.0\n */\nexport const maxItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> =>\n  self.pipe(\n    filter((a) => a.length <= n, {\n      typeId: MaxItemsTypeId,\n      description: `an array of at most ${n} items`,\n      jsonSchema: { maxItems: n },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const ItemsCountTypeId: unique symbol = filters_.ItemsCountTypeId\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport type ItemsCountTypeId = typeof ItemsCountTypeId\n\n/**\n * @category ReadonlyArray filters\n * @since 0.67.0\n */\nexport const itemsCount = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> =>\n  self.pipe(\n    filter((a) => a.length === n, {\n      typeId: ItemsCountTypeId,\n      description: `an array of exactly ${n} item(s)`,\n      jsonSchema: { minItems: n, maxItems: n },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n\n/**\n * @category ReadonlyArray transformations\n * @since 0.67.0\n */\nexport const getNumberIndexedAccess = <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(\n  self: Schema<A, I, R>\n): SchemaClass<A[number], I[number], R> => make(AST.getNumberIndexedAccess(self.ast))\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.\n *\n * @category ReadonlyArray transformations\n * @since 0.67.0\n */\nexport const head = <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>): SchemaClass<option_.Option<A>, I, R> =>\n  transform(\n    self,\n    OptionFromSelf(getNumberIndexedAccess(typeSchema(self))),\n    { strict: true, decode: array_.head, encode: option_.match({ onNone: () => [], onSome: array_.of }) }\n  )\n\n/**\n * Retrieves the first element of a `ReadonlyArray`.\n *\n * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n *\n * @category ReadonlyArray transformations\n * @since 0.67.0\n */\nexport const headOrElse: {\n  <A>(fallback?: LazyArg<A>): <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => SchemaClass<A, I, R>\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R> =>\n    transformOrFail(\n      self,\n      getNumberIndexedAccess(typeSchema(self)),\n      {\n        strict: true,\n        decode: (as, _, ast) =>\n          as.length > 0\n            ? ParseResult.succeed(as[0])\n            : fallback\n            ? ParseResult.succeed(fallback())\n            : ParseResult.fail(new ParseResult.Type(ast, as)),\n        encode: (a) => ParseResult.succeed(array_.of(a))\n      }\n    )\n)\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const ValidDateTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/ValidDate\")\n\n/**\n * Defines a filter that specifically rejects invalid dates, such as `new\n * Date(\"Invalid Date\")`. This filter ensures that only properly formatted and\n * valid date objects are accepted, enhancing data integrity by preventing\n * erroneous date values from being processed.\n *\n * @category Date filters\n * @since 0.67.0\n */\nexport const validDate =\n  (annotations?: Annotations.Filter<Date>) => <I, R>(self: Schema<Date, I, R>): filter<Schema<Date, I, R>> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a.getTime()), {\n        typeId: ValidDateTypeId,\n        description: \"a valid Date\",\n        ...annotations\n      })\n    )\n\n/**\n * Describes a schema that accommodates potentially invalid `Date` instances,\n * such as `new Date(\"Invalid Date\")`, without rejection.\n *\n * @category Date constructors\n * @since 0.67.0\n */\nexport class DateFromSelf extends declare(\n  Predicate.isDate,\n  {\n    identifier: \"DateFromSelf\",\n    description: \"a potentially invalid Date instance\",\n    pretty: (): pretty_.Pretty<Date> => (date) => `new Date(${JSON.stringify(date)})`,\n    arbitrary: (): LazyArbitrary<Date> => (fc) => fc.date({ noInvalidDate: false }),\n    equivalence: () => Equivalence.Date\n  }\n) {}\n\n/**\n * Defines a schema that ensures only valid dates are accepted. This schema\n * rejects values like `new Date(\"Invalid Date\")`, which, despite being a `Date`\n * instance, represents an invalid date. Such stringent validation ensures that\n * all date objects processed through this schema are properly formed and\n * represent real dates.\n *\n * @category Date constructors\n * @since 0.67.0\n */\nexport class ValidDateFromSelf extends DateFromSelf.pipe(\n  validDate({\n    identifier: \"ValidDateFromSelf\",\n    description: \"a valid Date instance\"\n  })\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `Date` object using\n * the `new Date` constructor. This conversion is lenient, meaning it does not\n * reject strings that do not form valid dates (e.g., using `new Date(\"Invalid\n * Date\")` results in a `Date` object, despite being invalid).\n *\n * @category Date transformations\n * @since 0.67.0\n */\nexport class DateFromString extends transform(\n  String$,\n  DateFromSelf,\n  { strict: true, decode: (s) => new Date(s), encode: (d) => d.toISOString() }\n).annotations({ identifier: \"DateFromString\" }) {}\n\n/** @ignore */\nclass Date$ extends DateFromString.pipe(\n  validDate({ identifier: \"Date\" })\n) {}\n\nexport {\n  /**\n   * This schema converts a `string` into a `Date` object using the `new Date`\n   * constructor. It ensures that only valid date strings are accepted,\n   * rejecting any strings that would result in an invalid date, such as `new\n   * Date(\"Invalid Date\")`.\n   *\n   * @category Date transformations\n   * @since 0.67.0\n   */\n  Date$ as Date\n}\n\n/**\n * Defines a schema that converts a `number` into a `Date` object using the `new\n * Date` constructor. This schema does not validate the numerical input,\n * allowing potentially invalid values such as `NaN`, `Infinity`, and\n * `-Infinity` to be converted into `Date` objects. During the encoding process,\n * any invalid `Date` object will be encoded to `NaN`.\n *\n * @category Date transformations\n * @since 0.67.0\n */\nexport class DateFromNumber extends transform(\n  Number$,\n  DateFromSelf,\n  { strict: true, decode: (n) => new Date(n), encode: (d) => d.getTime() }\n).annotations({ identifier: \"DateFromNumber\" }) {}\n\n/**\n * @category Option utils\n * @since 0.67.0\n */\nexport type OptionEncoded<I> =\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Some\"\n    readonly value: I\n  }\n\nconst OptionNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ description: \"NoneEncoded\" })\n\nconst optionSomeEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Struct({\n    _tag: Literal(\"Some\"),\n    value\n  }).annotations({ description: `SomeEncoded<${format(value)}>` })\n\nconst optionEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Union(\n    OptionNoneEncoded,\n    optionSomeEncoded(value)\n  ).annotations({\n    description: `OptionEncoded<${format(value)}>`\n  })\n\nconst optionDecode = <A>(input: OptionEncoded<A>): option_.Option<A> =>\n  input._tag === \"None\" ? option_.none() : option_.some(input.value)\n\nconst optionArbitrary = <A>(value: LazyArbitrary<A>): LazyArbitrary<option_.Option<A>> => (fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"None\" as const) }),\n    fc.record({ _tag: fc.constant(\"Some\" as const), value: value(fc) })\n  ).map(optionDecode)\n\nconst optionPretty = <A>(value: pretty_.Pretty<A>): pretty_.Pretty<option_.Option<A>> =>\n  option_.match({\n    onNone: () => \"none()\",\n    onSome: (a) => `some(${value(a)})`\n  })\n\nconst optionParse =\n  <A, R>(decodeUnknown: ParseResult.DecodeUnknown<A, R>): ParseResult.DeclarationDecodeUnknown<option_.Option<A>, R> =>\n  (u, options, ast) =>\n    option_.isOption(u) ?\n      option_.isNone(u) ?\n        ParseResult.succeed(option_.none())\n        : toComposite(decodeUnknown(u.value, options), option_.some, ast, u)\n      : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface OptionFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromSelf<Value>,\n    option_.Option<Schema.Type<Value>>,\n    option_.Option<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 0.67.0\n */\nexport const OptionFromSelf = <Value extends Schema.Any>(\n  value: Value\n): OptionFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (value) => optionParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => optionParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: `Option<${format(value)}>`,\n      pretty: optionPretty,\n      arbitrary: optionArbitrary,\n      equivalence: option_.getEquivalence\n    }\n  )\n}\n\nconst makeNoneEncoded = {\n  _tag: \"None\"\n} as const\nconst makeSomeEncoded = <A>(value: A) => ({\n  _tag: \"Some\",\n  value\n} as const)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Option<Value extends Schema.Any> extends\n  AnnotableClass<\n    Option<Value>,\n    option_.Option<Schema.Type<Value>>,\n    OptionEncoded<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 0.67.0\n */\nexport const Option = <Value extends Schema.Any>(value: Value): Option<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    optionEncoded(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: optionDecode,\n      encode: option_.match({\n        onNone: () => makeNoneEncoded,\n        onSome: makeSomeEncoded\n      })\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface OptionFromNullOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromNullOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 0.67.0\n */\nexport const OptionFromNullOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromNullOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(NullOr(value_), OptionFromSelf(typeSchema(value_)), {\n    strict: true,\n    decode: option_.fromNullable,\n    encode: option_.getOrNull\n  })\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface OptionFromNullishOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromNullishOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 0.67.0\n */\nexport const OptionFromNullishOr = <Value extends Schema.Any>(\n  value: Value,\n  onNoneEncoding: null | undefined\n): OptionFromNullishOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    NullishOr(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: option_.fromNullable,\n      encode: onNoneEncoding === null ? option_.getOrNull : option_.getOrUndefined\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface OptionFromUndefinedOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromUndefinedOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 0.67.0\n */\nexport const OptionFromUndefinedOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromUndefinedOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(UndefinedOr(value_), OptionFromSelf(typeSchema(value_)), {\n    strict: true,\n    decode: option_.fromNullable,\n    encode: option_.getOrUndefined\n  })\n}\n\n/**\n * @category Either utils\n * @since 0.67.0\n */\nexport type RightEncoded<IA> = {\n  readonly _tag: \"Right\"\n  readonly right: IA\n}\n\n/**\n * @category Either utils\n * @since 0.67.0\n */\nexport type LeftEncoded<IE> = {\n  readonly _tag: \"Left\"\n  readonly left: IE\n}\n\n/**\n * @category Either utils\n * @since 0.67.0\n */\nexport type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>\n\nconst rightEncoded = <RA, RI, RR>(right: Schema<RA, RI, RR>): Schema<RightEncoded<RA>, RightEncoded<RI>, RR> =>\n  Struct({\n    _tag: Literal(\"Right\"),\n    right\n  }).annotations({ description: `RightEncoded<${format(right)}>` })\n\nconst leftEncoded = <LA, LI, LR>(left: Schema<LA, LI, LR>): Schema<LeftEncoded<LA>, LeftEncoded<LI>, LR> =>\n  Struct({\n    _tag: Literal(\"Left\"),\n    left\n  }).annotations({ description: `LeftEncoded<${format(left)}>` })\n\nconst eitherEncoded = <RA, RI, RR, LA, LI, LR>(\n  right: Schema<RA, RI, RR>,\n  left: Schema<LA, LI, LR>\n) =>\n  Union(rightEncoded(right), leftEncoded(left)).annotations({\n    description: `EitherEncoded<${format(left)}, ${format(right)}>`\n  })\n\nconst eitherDecode = <R, L>(input: EitherEncoded<R, L>): either_.Either<R, L> =>\n  input._tag === \"Left\" ? either_.left(input.left) : either_.right(input.right)\n\nconst eitherArbitrary = <R, L>(\n  right: LazyArbitrary<R>,\n  left: LazyArbitrary<L>\n): LazyArbitrary<either_.Either<R, L>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Left\" as const), left: left(fc) }),\n    fc.record({ _tag: fc.constant(\"Right\" as const), right: right(fc) })\n  ).map(eitherDecode)\n\nconst eitherPretty = <R, L>(\n  right: pretty_.Pretty<R>,\n  left: pretty_.Pretty<L>\n): pretty_.Pretty<either_.Either<R, L>> =>\n  either_.match({\n    onLeft: (e) => `left(${left(e)})`,\n    onRight: (a) => `right(${right(a)})`\n  })\n\nconst eitherParse = <RR, R, LR, L>(\n  parseRight: ParseResult.DecodeUnknown<R, RR>,\n  decodeUnknownLeft: ParseResult.DecodeUnknown<L, LR>\n): ParseResult.DeclarationDecodeUnknown<either_.Either<R, L>, LR | RR> =>\n(u, options, ast) =>\n  either_.isEither(u) ?\n    either_.match(u, {\n      onLeft: (left) => toComposite(decodeUnknownLeft(left, options), either_.left, ast, u),\n      onRight: (right) => toComposite(parseRight(right, options), either_.right, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface EitherFromSelf<R extends Schema.Any, L extends Schema.Any> extends\n  AnnotableClass<\n    EitherFromSelf<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 0.67.0\n */\nexport const EitherFromSelf = <R extends Schema.Any, L extends Schema.Any>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromSelf<R, L> => {\n  return declare(\n    [right, left],\n    {\n      decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),\n      encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))\n    },\n    {\n      description: `Either<${format(right)}, ${format(left)}>`,\n      pretty: eitherPretty,\n      arbitrary: eitherArbitrary,\n      equivalence: (right, left) => either_.getEquivalence({ left, right })\n    }\n  )\n}\n\nconst makeLeftEncoded = <E>(left: E) => (({\n  _tag: \"Left\",\n  left\n}) as const)\nconst makeRightEncoded = <A>(right: A) => (({\n  _tag: \"Right\",\n  right\n}) as const)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Either<R extends Schema.Any, L extends Schema.Any> extends\n  AnnotableClass<\n    Either<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    EitherEncoded<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 0.67.0\n */\nexport const Either = <R extends Schema.Any, L extends Schema.Any>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): Either<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  return transform(\n    eitherEncoded(right_, left_),\n    EitherFromSelf({ left: typeSchema(left_), right: typeSchema(right_) }),\n    {\n      strict: true,\n      decode: eitherDecode,\n      encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded })\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface EitherFromUnion<R extends Schema.Any, L extends Schema.Any> extends\n  AnnotableClass<\n    EitherFromUnion<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    Schema.Encoded<R> | Schema.Encoded<L>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @example\n * import * as Schema from \"@effect/schema/Schema\"\n *\n * // Schema<string | number, Either<string, number>>\n * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })\n *\n * @category Either transformations\n * @since 0.67.0\n */\nexport const EitherFromUnion = <R extends Schema.Any, L extends Schema.Any>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromUnion<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  const toright = typeSchema(right_)\n  const toleft = typeSchema(left_)\n  const fromRight = transform(right_, rightEncoded(toright), {\n    strict: true,\n    decode: makeRightEncoded,\n    encode: (r) => r.right\n  })\n  const fromLeft = transform(left_, leftEncoded(toleft), {\n    strict: true,\n    decode: makeLeftEncoded,\n    encode: (l) => l.left\n  })\n  return transform(\n    Union(fromRight, fromLeft),\n    EitherFromSelf({ left: toleft, right: toright }),\n    {\n      strict: true,\n      decode: (from) => from._tag === \"Left\" ? either_.left(from.left) : either_.right(from.right),\n      encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded })\n    }\n  )\n}\n\nconst mapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>\n): LazyArbitrary<Map<K, V>> =>\n(fc) => fc.array(fc.tuple(key(fc), value(fc))).map((as) => new Map(as))\n\nconst readonlyMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<ReadonlyMap<K, V>> =>\n(map) =>\n  `new Map([${\n    Array.from(map.entries())\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst readonlyMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<ReadonlyMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())))\n}\n\nconst readonlyMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlyMap<K, V>, R> =>\n(u, options, ast) =>\n  Predicate.isMap(u) ?\n    toComposite(decodeUnknown(Array.from(u.entries()), options), (as) => new Map(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlyMapFromSelf<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst mapFromSelf_ = <K extends Schema.Any, V extends Schema.Any>(\n  key: K,\n  value: V,\n  description: string\n): ReadonlyMapFromSelf<K, V> =>\n  declare(\n    [key, value],\n    {\n      decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown(Array$(Tuple(Key, Value)))),\n      encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown(Array$(Tuple(Key, Value))))\n    },\n    {\n      description,\n      pretty: readonlyMapPretty,\n      arbitrary: mapArbitrary,\n      equivalence: readonlyMapEquivalence\n    }\n  )\n\n/**\n * @category ReadonlyMap\n * @since 0.67.0\n */\nexport const ReadonlyMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMapFromSelf<K, V> => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    MapFromSelf<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category Map\n * @since 0.67.0\n */\nexport const MapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): MapFromSelf<K, V> => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlyMap$<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category ReadonlyMap transformations\n * @since 0.67.0\n */\nexport const ReadonlyMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMap$<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    ReadonlyMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Map$<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    Map$<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst map = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): Map$<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    MapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\nexport {\n  /**\n   * @category Map transformations\n   * @since 0.67.0\n   */\n  map as Map\n}\n\n/**\n * @category ReadonlyMap transformations\n * @since 0.68.15\n */\nexport const ReadonlyMapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): Schema<ReadonlyMap<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(Record(encodedBoundSchema(key), value), ReadonlyMapFromSelf({ key, value: typeSchema(value) }), {\n    strict: true,\n    decode: (record) => new Map(Object.entries(record)),\n    encode: record_.fromEntries\n  })\n\n/**\n * @category Map transformations\n * @since 0.68.15\n */\nexport const MapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): Schema<Map<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(Record(encodedBoundSchema(key), value), MapFromSelf({ key, value: typeSchema(value) }), {\n    strict: true,\n    decode: (record) => new Map(Object.entries(record)),\n    encode: record_.fromEntries\n  })\n\nconst setArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<ReadonlySet<A>> => (fc) =>\n  fc.array(item(fc)).map((as) => new Set(as))\n\nconst readonlySetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<ReadonlySet<A>> => (set) =>\n  `new Set([${Array.from(set.values()).map((a) => item(a)).join(\", \")}])`\n\nconst readonlySetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<ReadonlySet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())))\n}\n\nconst readonlySetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlySet<A>, R> =>\n(u, options, ast) =>\n  Predicate.isSet(u) ?\n    toComposite(decodeUnknown(Array.from(u.values()), options), (as) => new Set(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface ReadonlySetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlySetFromSelf<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst setFromSelf_ = <Value extends Schema.Any>(value: Value, description: string): ReadonlySetFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (item) => readonlySetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => readonlySetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description,\n      pretty: readonlySetPretty,\n      arbitrary: setArbitrary,\n      equivalence: readonlySetEquivalence\n    }\n  )\n\n/**\n * @category ReadonlySet\n * @since 0.67.0\n */\nexport const ReadonlySetFromSelf = <Value extends Schema.Any>(value: Value): ReadonlySetFromSelf<Value> =>\n  setFromSelf_(value, `ReadonlySet<${format(value)}>`)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface SetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    SetFromSelf<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Set\n * @since 0.67.0\n */\nexport const SetFromSelf = <Value extends Schema.Any>(value: Value): SetFromSelf<Value> =>\n  setFromSelf_(value, `Set<${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface ReadonlySet$<Value extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlySet$<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category ReadonlySet transformations\n * @since 0.67.0\n */\nexport const ReadonlySet = <Value extends Schema.Any>(value: Value): ReadonlySet$<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ReadonlySetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Set$<Value extends Schema.Any> extends\n  AnnotableClass<\n    Set$<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst set = <Value extends Schema.Any>(value: Value): Set$<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    SetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\nexport {\n  /**\n   * @category Set transformations\n   * @since 0.67.0\n   */\n  set as Set\n}\n\nconst bigDecimalPretty = (): pretty_.Pretty<bigDecimal_.BigDecimal> => (val) =>\n  `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`\n\nconst bigDecimalArbitrary = (): LazyArbitrary<bigDecimal_.BigDecimal> => (fc) =>\n  fc.tuple(fc.bigInt(), fc.integer()).map(([value, scale]) => bigDecimal_.make(value, scale))\n\n/**\n * @category BigDecimal constructors\n * @since 0.67.0\n */\nexport class BigDecimalFromSelf extends declare(\n  bigDecimal_.isBigDecimal,\n  {\n    identifier: \"BigDecimalFromSelf\",\n    pretty: bigDecimalPretty,\n    arbitrary: bigDecimalArbitrary,\n    equivalence: () => bigDecimal_.Equivalence\n  }\n) {}\n\n/**\n * @category BigDecimal transformations\n * @since 0.67.0\n */\nexport class BigDecimal extends transformOrFail(\n  String$,\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (num, _, ast) =>\n      bigDecimal_.fromString(num).pipe(option_.match({\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, num)),\n        onSome: (val) => ParseResult.succeed(bigDecimal_.normalize(val))\n      })),\n    encode: (val) => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(val)))\n  }\n).annotations({ identifier: \"BigDecimal\" }) {}\n\n/**\n * A schema that transforms a `number` into a `BigDecimal`.\n * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.\n *\n * @category BigDecimal transformations\n * @since 0.67.0\n */\nexport class BigDecimalFromNumber extends transformOrFail(\n  Number$,\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (num) => ParseResult.succeed(bigDecimal_.fromNumber(num)),\n    encode: (val) => ParseResult.succeed(bigDecimal_.unsafeToNumber(val))\n  }\n).annotations({ identifier: \"BigDecimalFromNumber\" }) {}\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const GreaterThanBigDecimalTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/GreaterThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 0.67.0\n */\nexport const greaterThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.greaterThan(a, min), {\n      typeId: { id: GreaterThanBigDecimalTypeId, annotation: { min } },\n      description: `a BigDecimal greater than ${bigDecimal_.format(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const GreaterThanOrEqualToBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 0.67.0\n */\nexport const greaterThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.greaterThanOrEqualTo(a, min), {\n      typeId: { id: GreaterThanOrEqualToBigDecimalTypeId, annotation: { min } },\n      description: `a BigDecimal greater than or equal to ${bigDecimal_.format(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LessThanBigDecimalTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/LessThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 0.67.0\n */\nexport const lessThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.lessThan(a, max), {\n      typeId: { id: LessThanBigDecimalTypeId, annotation: { max } },\n      description: `a BigDecimal less than ${bigDecimal_.format(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const LessThanOrEqualToBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/LessThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 0.67.0\n */\nexport const lessThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.lessThanOrEqualTo(a, max), {\n      typeId: { id: LessThanOrEqualToBigDecimalTypeId, annotation: { max } },\n      description: `a BigDecimal less than or equal to ${bigDecimal_.format(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const PositiveBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/PositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 0.67.0\n */\nexport const positiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.isPositive(a), {\n      typeId: { id: PositiveBigDecimalTypeId, annotation: {} },\n      description: `a positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 0.67.0\n */\nexport const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  positiveBigDecimal({\n    identifier: \"PositiveBigDecimalFromSelf\",\n    title: \"PositiveBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const NonNegativeBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/NonNegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 0.67.0\n */\nexport const nonNegativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a.value >= 0n, {\n      typeId: { id: NonNegativeBigDecimalTypeId, annotation: {} },\n      description: `a non-negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 0.67.0\n */\nexport const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonNegativeBigDecimal({\n    identifier: \"NonNegativeBigDecimalFromSelf\",\n    title: \"NonNegativeBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const NegativeBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/NegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 0.67.0\n */\nexport const negativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.isNegative(a), {\n      typeId: { id: NegativeBigDecimalTypeId, annotation: {} },\n      description: `a negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 0.67.0\n */\nexport const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  negativeBigDecimal({\n    identifier: \"NegativeBigDecimalFromSelf\",\n    title: \"NegativeBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const NonPositiveBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/NonPositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 0.67.0\n */\nexport const nonPositiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a.value <= 0n, {\n      typeId: { id: NonPositiveBigDecimalTypeId, annotation: {} },\n      description: `a non-positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 0.67.0\n */\nexport const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonPositiveBigDecimal({\n    identifier: \"NonPositiveBigDecimalFromSelf\",\n    title: \"NonPositiveBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category type id\n * @since 0.67.0\n */\nexport const BetweenBigDecimalTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/BetweenBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 0.67.0\n */\nexport const betweenBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  minimum: bigDecimal_.BigDecimal,\n  maximum: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.between(a, { minimum, maximum }), {\n      typeId: { id: BetweenBigDecimalTypeId, annotation: { maximum, minimum } },\n      description: `a BigDecimal between ${bigDecimal_.format(minimum)} and ${bigDecimal_.format(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * Clamps a `BigDecimal` between a minimum and a maximum value.\n *\n * @category BigDecimal transformations\n * @since 0.67.0\n */\nexport const clampBigDecimal =\n  (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) =>\n  <A extends bigDecimal_.BigDecimal, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)),\n      { strict: false, decode: (self) => bigDecimal_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\nconst chunkArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<chunk_.Chunk<A>> => (fc) =>\n  fc.array(item(fc)).map(chunk_.fromIterable)\n\nconst chunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.Chunk<A>> => (c) =>\n  `Chunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst chunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.Chunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) ?\n    chunk_.isEmpty(u) ?\n      ParseResult.succeed(chunk_.empty())\n      : toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface ChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ChunkFromSelf<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    chunk_.Chunk<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk\n * @since 0.67.0\n */\nexport const ChunkFromSelf = <Value extends Schema.Any>(value: Value): ChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => chunkParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => chunkParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `Chunk<${format(value)}>`,\n      pretty: chunkPretty,\n      arbitrary: chunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Chunk<Value extends Schema.Any> extends\n  AnnotableClass<\n    Chunk<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 0.67.0\n */\nexport const Chunk = <Value extends Schema.Any>(value: Value): Chunk<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ChunkFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: (as) => as.length === 0 ? chunk_.empty() : chunk_.fromIterable(as),\n      encode: chunk_.toReadonlyArray\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.23\n */\nexport interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyChunkFromSelf<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    chunk_.NonEmptyChunk<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst nonEmptyChunkArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<chunk_.NonEmptyChunk<A>> => (fc) =>\n  fastCheck_.array(item(fc), { minLength: 1 }).map((as) => chunk_.unsafeFromNonEmptyArray(as as any))\n\nconst nonEmptyChunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.NonEmptyChunk<A>> => (c) =>\n  `NonEmptyChunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst nonEmptyChunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<array_.NonEmptyReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.NonEmptyChunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) && chunk_.isNonEmpty(u)\n    ? toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.unsafeFromNonEmptyArray, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Chunk\n * @since 0.67.23\n */\nexport const NonEmptyChunkFromSelf = <Value extends Schema.Any>(value: Value): NonEmptyChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => nonEmptyChunkParse(ParseResult.decodeUnknown(NonEmptyArray(item))),\n      encode: (item) => nonEmptyChunkParse(ParseResult.encodeUnknown(NonEmptyArray(item)))\n    },\n    {\n      description: `NonEmptyChunk<${format(value)}>`,\n      pretty: nonEmptyChunkPretty,\n      arbitrary: nonEmptyChunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.23\n */\nexport interface NonEmptyChunk<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyChunk<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 0.67.23\n */\nexport const NonEmptyChunk = <Value extends Schema.Any>(value: Value): NonEmptyChunk<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    NonEmptyArray(value_),\n    NonEmptyChunkFromSelf(typeSchema(value_)),\n    { strict: true, decode: chunk_.unsafeFromNonEmptyArray, encode: chunk_.toReadonlyArray }\n  )\n}\n\nconst toData = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(a: A): A =>\n  Array.isArray(a) ? data_.array(a) : data_.struct(a)\n\nconst dataArbitrary = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: LazyArbitrary<A>\n): LazyArbitrary<A> =>\n(fc) => item(fc).map(toData)\n\nconst dataPretty = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: pretty_.Pretty<A>\n): pretty_.Pretty<A> =>\n(d) => `Data(${item(d)})`\n\nconst dataParse = <R, A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<A, R> =>\n(u, options, ast) =>\n  Equal.isEqual(u) ?\n    toComposite(decodeUnknown(u, options), toData, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Data transformations\n * @since 0.67.0\n */\nexport const DataFromSelf = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): SchemaClass<A, I, R> =>\n  declare(\n    [item],\n    {\n      decode: (item) => dataParse(ParseResult.decodeUnknown(item)),\n      encode: (item) => dataParse(ParseResult.encodeUnknown(item))\n    },\n    {\n      description: `Data<${format(item)}>`,\n      pretty: dataPretty,\n      arbitrary: dataArbitrary\n    }\n  )\n\n/**\n * @category Data transformations\n * @since 0.67.0\n */\nexport const Data = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): SchemaClass<A, I, R> =>\n  transform(\n    item,\n    DataFromSelf(typeSchema(item)),\n    { strict: false, decode: toData, encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a) }\n  )\n\ntype MissingSelfGeneric<Usage extends string, Params extends string = \"\"> =\n  `Missing \\`Self\\` generic - use \\`class Self extends ${Usage}<Self>()(${Params}{ ... })\\``\n\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto>\n  extends Schema<Self, Simplify<I>, R>\n{\n  new(\n    props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>,\n    options?: MakeOptions\n  ): Struct.Type<Fields> & Omit<Inherited, keyof Fields> & Proto\n\n  make<Args extends Array<any>, X>(this: { new(...args: Args): X }, ...args: Args): X\n\n  annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>\n\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n\n  readonly identifier: string\n\n  extend<Extended = never>(identifier: string): <newFields extends Struct.Fields>(\n    fields: newFields | HasFields<newFields>,\n    annotations?: Annotations.Schema<Extended>\n  ) => [Extended] extends [never] ? MissingSelfGeneric<\"Base.extend\">\n    : Class<\n      Extended,\n      Fields & newFields,\n      I & Struct.Encoded<newFields>,\n      R | Struct.Context<newFields>,\n      C & Struct.Constructor<newFields>,\n      Self,\n      Proto\n    >\n\n  transformOrFail<Transformed = never>(identifier: string): <\n    newFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: newFields,\n    options: {\n      readonly decode: (\n        input: Simplify<Struct.Type<Fields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<Struct.Type<Fields & newFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<Struct.Type<Fields & newFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>\n    },\n    annotations?: Annotations.Schema<Transformed>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transform\">\n    : Class<\n      Transformed,\n      Fields & newFields,\n      I,\n      R | Struct.Context<newFields> | R2 | R3,\n      C & Struct.Constructor<newFields>,\n      Self,\n      Proto\n    >\n\n  transformOrFailFrom<Transformed = never>(identifier: string): <\n    newFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: newFields,\n    options: {\n      readonly decode: (\n        input: Simplify<I>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<I & Struct.Encoded<newFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<I & Struct.Encoded<newFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>\n    },\n    annotations?: Annotations.Schema<Transformed>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformFrom\">\n    : Class<\n      Transformed,\n      Fields & newFields,\n      I,\n      R | Struct.Context<newFields> | R2 | R3,\n      C & Struct.Constructor<newFields>,\n      Self,\n      Proto\n    >\n}\n\ntype HasFields<Fields extends Struct.Fields> = Struct<Fields> | {\n  readonly [refineTypeId]: HasFields<Fields>\n}\n\nconst isField = (u: unknown) => isSchema(u) || isPropertySignature(u)\n\nconst isFields = <Fields extends Struct.Fields>(fields: object): fields is Fields =>\n  util_.ownKeys(fields).every((key) => isField((fields as any)[key]))\n\nconst getFields = <Fields extends Struct.Fields>(hasFields: HasFields<Fields>): Fields =>\n  \"fields\" in hasFields ? hasFields.fields : getFields(hasFields[refineTypeId])\n\nconst getSchemaFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Schema.Any =>\n  isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr))\n\nconst getFieldsFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Fields =>\n  isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr)\n\n/**\n * @category classes\n * @since 0.67.0\n */\nexport const Class = <Self = never>(identifier: string) =>\n<Fields extends Struct.Fields>(\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"Class\">\n  : Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Fields>,\n    {},\n    {}\n  > =>\n  makeClass({\n    kind: \"Class\",\n    identifier,\n    schema: getSchemaFromFieldsOr(fieldsOr),\n    fields: getFieldsFromFieldsOr(fieldsOr),\n    Base: data_.Class,\n    annotations\n  })\n\n/** @internal */\nexport const getClassTag = <Tag extends string>(tag: Tag) =>\n  withConstructorDefault(propertySignature(Literal(tag)), () => tag)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    {}\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @category classes\n * @since 0.67.0\n */\nexport const TaggedClass = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedClass\", `\"Tag\", `>\n  : TaggedClass<Self, Tag, { readonly _tag: PropertySignature<\":\", Tag, never, \":\", Tag, true, never> } & Fields> =>\n{\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedClass extends makeClass({\n    kind: \"TaggedClass\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base: data_.Class,\n    annotations\n  }) {\n    static _tag = tag\n  } as any\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    cause_.YieldableError\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @category classes\n * @since 0.67.0\n */\nexport const TaggedError = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedError\", `\"Tag\", `>\n  : TaggedErrorClass<\n    Self,\n    Tag,\n    { readonly _tag: PropertySignature<\":\", Tag, never, \":\", Tag, true, never> } & Fields\n  > =>\n{\n  class Base extends data_.Error {}\n  ;(Base.prototype as any).name = tag\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedErrorClass extends makeClass({\n    kind: \"TaggedError\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base,\n    annotations,\n    disableToString: true\n  }) {\n    static _tag = tag\n    get message(): string {\n      return `{ ${\n        util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n          .join(\", \")\n      } }`\n    }\n  } as any\n}\n\n/**\n * @category classes\n * @since 0.67.0\n */\nexport interface TaggedRequest<\n  Tag extends string,\n  A,\n  I,\n  R,\n  SuccessType,\n  SuccessEncoded,\n  FailureType,\n  FailureEncoded,\n  SuccessAndFailureR\n> extends\n  Request.Request<SuccessType, FailureType>,\n  Serializable.SerializableWithResult<\n    A,\n    I,\n    R,\n    SuccessType,\n    SuccessEncoded,\n    FailureType,\n    FailureEncoded,\n    SuccessAndFailureR\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @category classes\n * @since 0.67.0\n */\nexport declare namespace TaggedRequest {\n  /**\n   * @category classes\n   * @since 0.67.0\n   */\n  export type Any =\n    | TaggedRequest<string, any, any, any, any, any, any, any, any>\n    | TaggedRequest<string, any, any, any, any, any, never, never, any>\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface TaggedRequestClass<\n  Self,\n  Tag extends string,\n  Fields extends Struct.Fields,\n  Failure extends Schema.All,\n  Success extends Schema.All\n> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    TaggedRequest<\n      Tag,\n      Self,\n      Struct.Encoded<Fields>,\n      Struct.Context<Fields>,\n      Schema.Type<Success>,\n      Schema.Encoded<Success>,\n      Schema.Type<Failure>,\n      Schema.Encoded<Failure>,\n      Schema.Context<Success> | Schema.Context<Failure>\n    >,\n    {}\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @category classes\n * @since 0.67.0\n */\nexport const TaggedRequest =\n  <Self = never>(identifier?: string) =>\n  <Tag extends string, Fields extends Struct.Fields, Failure extends Schema.All, Success extends Schema.All>(\n    tag: Tag,\n    Failure: Failure,\n    Success: Success,\n    fields: Fields,\n    annotations?: Annotations.Schema<Self>\n  ): [Self] extends [never] ? MissingSelfGeneric<\"TaggedRequest\", `\"Tag\", SuccessSchema, FailureSchema, `>\n    : TaggedRequestClass<\n      Self,\n      Tag,\n      { readonly _tag: PropertySignature<\":\", Tag, never, \":\", Tag, true, never> } & Fields,\n      Failure,\n      Success\n    > =>\n  {\n    const taggedFields = extendFields({ _tag: getClassTag(tag) }, fields)\n    return class TaggedRequestClass extends makeClass({\n      kind: \"TaggedRequest\",\n      identifier: identifier ?? tag,\n      schema: Struct(taggedFields),\n      fields: taggedFields,\n      Base: Request.Class<any, any, { readonly _tag: string }>,\n      annotations\n    }) {\n      static _tag = tag\n      get [serializable_.symbol]() {\n        return this.constructor\n      }\n      get [serializable_.symbolResult]() {\n        return { Failure, Success }\n      }\n    } as any\n  }\n\nconst extendFields = (a: Struct.Fields, b: Struct.Fields): Struct.Fields => {\n  const out = { ...a }\n  for (const key of util_.ownKeys(b)) {\n    if (key in a) {\n      throw new Error(errors_.getASTDuplicatePropertySignatureErrorMessage(key))\n    }\n    out[key] = b[key]\n  }\n  return out\n}\n\n// does not overwrite existing title annotation\nconst orElseTitleAnnotation = <A, I, R>(schema: Schema<A, I, R>, title: string): Schema<A, I, R> => {\n  const annotation = AST.getTitleAnnotation(schema.ast)\n  if (option_.isNone(annotation)) {\n    return schema.annotations({ title })\n  }\n  return schema\n}\n\ntype MakeOptions = boolean | {\n  readonly disableValidation?: boolean\n}\n\nconst getDisableValidationMakeOption = (options: MakeOptions | undefined): boolean =>\n  Predicate.isBoolean(options) ? options : options?.disableValidation ?? false\n\nconst makeClass = ({ Base, annotations, disableToString, fields, identifier, kind, schema }: {\n  kind: \"Class\" | \"TaggedClass\" | \"TaggedError\" | \"TaggedRequest\"\n  identifier: string\n  schema: Schema.Any\n  fields: Struct.Fields\n  Base: new(...args: ReadonlyArray<any>) => any\n  annotations?: Annotations.Schema<any> | undefined\n  disableToString?: boolean | undefined\n}): any => {\n  const classSymbol = Symbol.for(`@effect/schema/${kind}/${identifier}`)\n  const validateSchema = orElseTitleAnnotation(schema, `${identifier} (Constructor)`)\n  const encodedSide: Schema.Any = orElseTitleAnnotation(schema, `${identifier} (Encoded side)`)\n  const typeSide = orElseTitleAnnotation(typeSchema(schema), `${identifier} (Type side)`)\n  const fallbackInstanceOf = (u: unknown) => Predicate.hasProperty(u, classSymbol) && ParseResult.is(typeSide)(u)\n  const klass = class extends Base {\n    constructor(\n      props: { [x: string | symbol]: unknown } = {},\n      options: MakeOptions = false\n    ) {\n      props = { ...props }\n      if (kind !== \"Class\") {\n        delete props[\"_tag\"]\n      }\n      props = lazilyMergeDefaults(fields, props)\n      if (!getDisableValidationMakeOption(options)) {\n        props = ParseResult.validateSync(validateSchema)(props)\n      }\n      super(props, true)\n    }\n\n    // ----------------\n    // Schema interface\n    // ----------------\n\n    static [TypeId] = variance\n\n    static get ast() {\n      const declaration: Schema.Any = declare(\n        [typeSide],\n        {\n          decode: () => (input, _, ast) =>\n            input instanceof this || fallbackInstanceOf(input)\n              ? ParseResult.succeed(input)\n              : ParseResult.fail(new ParseResult.Type(ast, input)),\n          encode: () => (input, options) =>\n            input instanceof this\n              ? ParseResult.succeed(input)\n              : ParseResult.map(\n                ParseResult.encodeUnknown(typeSide)(input, options),\n                (props) => new this(props, true)\n              )\n        },\n        {\n          identifier,\n          title: identifier,\n          description: `an instance of ${identifier}`,\n          pretty: (pretty) => (self: any) => `${identifier}(${pretty(self)})`,\n          arbitrary: (arb) => (fc: any) => arb(fc).map((props: any) => new this(props)),\n          equivalence: identity,\n          [AST.SurrogateAnnotationId]: typeSide.ast,\n          ...annotations\n        }\n      )\n      const transformation = transform(\n        encodedSide,\n        declaration,\n        { strict: true, decode: (input) => new this(input, true), encode: identity }\n      ).annotations({ [AST.SurrogateAnnotationId]: schema.ast })\n      return transformation.ast\n    }\n\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n\n    static annotations(annotations: Annotations.Schema<any>) {\n      return make(this.ast).annotations(annotations)\n    }\n\n    static toString() {\n      return `(${String(encodedSide)} <-> ${identifier})`\n    }\n\n    // ----------------\n    // Class interface\n    // ----------------\n\n    static make(...args: Array<any>) {\n      return new this(...args)\n    }\n\n    static fields = { ...fields }\n\n    static identifier = identifier\n\n    static extend<Extended>(identifier: string) {\n      return (newFieldsOr: Struct.Fields | HasFields<Struct.Fields>, annotations?: Annotations.Schema<Extended>) => {\n        const newFields = getFieldsFromFieldsOr(newFieldsOr)\n        const newSchema = getSchemaFromFieldsOr(newFieldsOr)\n        const extendedFields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: extend(schema, newSchema),\n          fields: extendedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFail<Transformed>(identifier: string) {\n      return (newFields: Struct.Fields, options: any, annotations?: Annotations.Schema<Transformed>) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            schema,\n            typeSchema(Struct(transformedFields)),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFailFrom<Transformed>(identifier: string) {\n      return (newFields: Struct.Fields, options: any, annotations?: Annotations.Schema<Transformed>) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            encodedSchema(schema),\n            Struct(transformedFields),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    // ----------------\n    // other\n    // ----------------\n\n    get [classSymbol]() {\n      return classSymbol\n    }\n  }\n  if (disableToString !== true) {\n    Object.defineProperty(klass.prototype, \"toString\", {\n      value() {\n        return `${identifier}({ ${\n          util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n            .join(\", \")\n        } })`\n      },\n      configurable: true\n    })\n  }\n  return klass\n}\n\n/**\n * @category FiberId\n * @since 0.67.0\n */\nexport type FiberIdEncoded =\n  | {\n    readonly _tag: \"Composite\"\n    readonly left: FiberIdEncoded\n    readonly right: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Runtime\"\n    readonly id: number\n    readonly startTimeMillis: number\n  }\n\nconst FiberIdNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ identifier: \"FiberIdNoneEncoded\" })\n\nconst FiberIdRuntimeEncoded = Struct({\n  _tag: Literal(\"Runtime\"),\n  id: Int.annotations({\n    title: \"id\",\n    description: \"id\"\n  }),\n  startTimeMillis: Int.annotations({\n    title: \"startTimeMillis\",\n    description: \"startTimeMillis\"\n  })\n}).annotations({ identifier: \"FiberIdRuntimeEncoded\" })\n\nconst FiberIdCompositeEncoded = Struct({\n  _tag: Literal(\"Composite\"),\n  left: suspend(() => FiberIdEncoded),\n  right: suspend(() => FiberIdEncoded)\n}).annotations({ identifier: \"FiberIdCompositeEncoded\" })\n\nconst FiberIdEncoded: Schema<FiberIdEncoded> = Union(\n  FiberIdNoneEncoded,\n  FiberIdRuntimeEncoded,\n  FiberIdCompositeEncoded\n).annotations({ identifier: \"FiberIdEncoded\" })\n\nconst fiberIdArbitrary: LazyArbitrary<fiberId_.FiberId> = (fc) =>\n  fc.letrec((tie) => ({\n    None: fc.record({ _tag: fc.constant(\"None\" as const) }),\n    Runtime: fc.record({ _tag: fc.constant(\"Runtime\" as const), id: fc.integer(), startTimeMillis: fc.integer() }),\n    Composite: fc.record({ _tag: fc.constant(\"Composite\" as const), left: tie(\"FiberId\"), right: tie(\"FiberId\") }),\n    FiberId: fc.oneof(tie(\"None\"), tie(\"Runtime\"), tie(\"Composite\")) as any as fastCheck_.Arbitrary<fiberId_.FiberId>\n  })).FiberId.map(fiberIdDecode)\n\nconst fiberIdPretty: pretty_.Pretty<fiberId_.FiberId> = (fiberId) => {\n  switch (fiberId._tag) {\n    case \"None\":\n      return \"FiberId.none\"\n    case \"Runtime\":\n      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`\n    case \"Composite\":\n      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`\n  }\n}\n\n/**\n * @category FiberId constructors\n * @since 0.67.0\n */\nexport class FiberIdFromSelf extends declare(\n  fiberId_.isFiberId,\n  {\n    identifier: \"FiberIdFromSelf\",\n    pretty: () => fiberIdPretty,\n    arbitrary: () => fiberIdArbitrary\n  }\n) {}\n\nconst fiberIdDecode = (input: FiberIdEncoded): fiberId_.FiberId => {\n  switch (input._tag) {\n    case \"None\":\n      return fiberId_.none\n    case \"Runtime\":\n      return fiberId_.runtime(input.id, input.startTimeMillis)\n    case \"Composite\":\n      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right))\n  }\n}\n\nconst fiberIdEncode = (input: fiberId_.FiberId): FiberIdEncoded => {\n  switch (input._tag) {\n    case \"None\":\n      return { _tag: \"None\" }\n    case \"Runtime\":\n      return { _tag: \"Runtime\", id: input.id, startTimeMillis: input.startTimeMillis }\n    case \"Composite\":\n      return {\n        _tag: \"Composite\",\n        left: fiberIdEncode(input.left),\n        right: fiberIdEncode(input.right)\n      }\n  }\n}\n\n/**\n * @category FiberId transformations\n * @since 0.67.0\n */\nexport class FiberId extends transform(\n  FiberIdEncoded,\n  FiberIdFromSelf,\n  { strict: true, decode: fiberIdDecode, encode: fiberIdEncode }\n).annotations({ identifier: \"FiberId\" }) {}\n\n/**\n * @category Cause utils\n * @since 0.67.0\n */\nexport type CauseEncoded<E> =\n  | {\n    readonly _tag: \"Empty\"\n  }\n  | {\n    readonly _tag: \"Fail\"\n    readonly error: E\n  }\n  | {\n    readonly _tag: \"Die\"\n    readonly defect: unknown\n  }\n  | {\n    readonly _tag: \"Interrupt\"\n    readonly fiberId: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"Sequential\"\n    readonly left: CauseEncoded<E>\n    readonly right: CauseEncoded<E>\n  }\n  | {\n    readonly _tag: \"Parallel\"\n    readonly left: CauseEncoded<E>\n    readonly right: CauseEncoded<E>\n  }\n\nconst causeDieEncoded = <R>(defect: Schema<unknown, unknown, R>) =>\n  Struct({\n    _tag: Literal(\"Die\"),\n    defect\n  })\n\nconst CauseEmptyEncoded = Struct({\n  _tag: Literal(\"Empty\")\n})\n\nconst causeFailEncoded = <E, EI, R>(error: Schema<E, EI, R>) =>\n  Struct({\n    _tag: Literal(\"Fail\"),\n    error\n  })\n\nconst CauseInterruptEncoded = Struct({\n  _tag: Literal(\"Interrupt\"),\n  fiberId: FiberIdEncoded\n})\n\nconst causeParallelEncoded = <E, EI, R>(causeEncoded: Schema<CauseEncoded<E>, CauseEncoded<EI>, R>) =>\n  Struct({\n    _tag: Literal(\"Parallel\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeSequentialEncoded = <E, EI, R>(causeEncoded: Schema<CauseEncoded<E>, CauseEncoded<EI>, R>) =>\n  Struct({\n    _tag: Literal(\"Sequential\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeEncoded = <E, EI, R1, R2>(\n  error: Schema<E, EI, R1>,\n  defect: Schema<unknown, unknown, R2>\n): Schema<CauseEncoded<E>, CauseEncoded<EI>, R1 | R2> => {\n  const recur = suspend(() => out)\n  const out: Schema<CauseEncoded<E>, CauseEncoded<EI>, R1 | R2> = Union(\n    CauseEmptyEncoded,\n    causeFailEncoded(error),\n    causeDieEncoded(defect),\n    CauseInterruptEncoded,\n    causeSequentialEncoded(recur),\n    causeParallelEncoded(recur)\n  ).annotations({ description: `CauseEncoded<${format(error)}>` })\n  return out\n}\n\nconst causeArbitrary = <E>(\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<cause_.Cause<E>> =>\n(fc) =>\n  fc.letrec((tie) => ({\n    Empty: fc.record({ _tag: fc.constant(\"Empty\" as const) }),\n    Fail: fc.record({ _tag: fc.constant(\"Fail\" as const), error: error(fc) }),\n    Die: fc.record({ _tag: fc.constant(\"Die\" as const), defect: defect(fc) }),\n    Interrupt: fc.record({ _tag: fc.constant(\"Interrupt\" as const), fiberId: fiberIdArbitrary(fc) }),\n    Sequential: fc.record({ _tag: fc.constant(\"Sequential\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Parallel: fc.record({ _tag: fc.constant(\"Parallel\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Cause: fc.oneof(\n      tie(\"Empty\"),\n      tie(\"Fail\"),\n      tie(\"Die\"),\n      tie(\"Interrupt\"),\n      tie(\"Sequential\"),\n      tie(\"Parallel\")\n    ) as any as fastCheck_.Arbitrary<cause_.Cause<E>>\n  })).Cause.map(causeDecode)\n\nconst causePretty = <E>(error: pretty_.Pretty<E>): pretty_.Pretty<cause_.Cause<E>> => (cause) => {\n  const f = (cause: cause_.Cause<E>): string => {\n    switch (cause._tag) {\n      case \"Empty\":\n        return \"Cause.empty\"\n      case \"Fail\":\n        return `Cause.fail(${error(cause.error)})`\n      case \"Die\":\n        return `Cause.die(${cause_.pretty(cause)})`\n      case \"Interrupt\":\n        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`\n      case \"Sequential\":\n        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`\n      case \"Parallel\":\n        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`\n    }\n  }\n  return f(cause)\n}\n\nconst causeParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<CauseEncoded<A>, R>\n): ParseResult.DeclarationDecodeUnknown<cause_.Cause<A>, R> =>\n(u, options, ast) =>\n  cause_.isCause(u) ?\n    toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface CauseFromSelf<E extends Schema.Any, DR> extends\n  AnnotableClass<\n    CauseFromSelf<E, DR>,\n    cause_.Cause<Schema.Type<E>>,\n    cause_.Cause<Schema.Encoded<E>>,\n    Schema.Context<E> | DR\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 0.67.0\n */\nexport const CauseFromSelf = <E extends Schema.Any, DR = never>({ defect = Unknown, error }: {\n  readonly error: E\n  readonly defect?: Schema<unknown, unknown, DR> | undefined\n}): CauseFromSelf<E, DR> => {\n  return declare(\n    [error, defect],\n    {\n      decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),\n      encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))\n    },\n    {\n      description: `Cause<${format(error)}>`,\n      pretty: causePretty,\n      arbitrary: causeArbitrary\n    }\n  )\n}\n\nfunction causeDecode<E>(cause: CauseEncoded<E>): cause_.Cause<E> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return cause_.empty\n    case \"Fail\":\n      return cause_.fail(cause.error)\n    case \"Die\":\n      return cause_.die(cause.defect)\n    case \"Interrupt\":\n      return cause_.interrupt(fiberIdDecode(cause.fiberId))\n    case \"Sequential\":\n      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right))\n    case \"Parallel\":\n      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right))\n  }\n}\n\nfunction causeEncode<E>(cause: cause_.Cause<E>): CauseEncoded<E> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return { _tag: \"Empty\" }\n    case \"Fail\":\n      return { _tag: \"Fail\", error: cause.error }\n    case \"Die\":\n      return { _tag: \"Die\", defect: cause.defect }\n    case \"Interrupt\":\n      return { _tag: \"Interrupt\", fiberId: cause.fiberId }\n    case \"Sequential\":\n      return {\n        _tag: \"Sequential\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n    case \"Parallel\":\n      return {\n        _tag: \"Parallel\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n  }\n}\n\n/**\n * @category Cause transformations\n * @since 0.67.0\n */\nexport const CauseDefectUnknown = transform(\n  Unknown,\n  Unknown,\n  {\n    strict: true,\n    decode: (u) => {\n      if (Predicate.isObject(u) && \"message\" in u && typeof u.message === \"string\") {\n        const err = new Error(u.message, { cause: u })\n        if (\"name\" in u && typeof u.name === \"string\") {\n          err.name = u.name\n        }\n        err.stack = \"stack\" in u && typeof u.stack === \"string\" ? u.stack : \"\"\n        return err\n      }\n      return String(u)\n    },\n    encode: (defect) => {\n      if (defect instanceof Error) {\n        return {\n          name: defect.name,\n          message: defect.message\n        }\n      }\n      return String(defect)\n    }\n  }\n)\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Cause<E extends Schema.All, DR> extends\n  AnnotableClass<\n    Cause<E, DR>,\n    cause_.Cause<Schema.Type<E>>,\n    CauseEncoded<Schema.Encoded<E>>,\n    Schema.Context<E> | DR\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 0.67.0\n */\nexport const Cause = <E extends Schema.All, DR = never>({ defect = CauseDefectUnknown, error }: {\n  readonly error: E\n  readonly defect?: Schema<unknown, unknown, DR> | undefined\n}): Cause<E, DR> => {\n  const error_ = asSchema(error)\n  return transform(\n    causeEncoded(error_, defect),\n    CauseFromSelf({ error: typeSchema(error_), defect: typeSchema(defect) }),\n    { strict: true, decode: causeDecode, encode: causeEncode }\n  )\n}\n\n/**\n * @category Exit utils\n * @since 0.67.0\n */\nexport type ExitEncoded<A, E> =\n  | {\n    readonly _tag: \"Failure\"\n    readonly cause: CauseEncoded<E>\n  }\n  | {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }\n\nconst exitFailureEncoded = <E, EI, ER, DR>(\n  error: Schema<E, EI, ER>,\n  defect: Schema<unknown, unknown, DR>\n) =>\n  Struct({\n    _tag: Literal(\"Failure\"),\n    cause: causeEncoded(error, defect)\n  }).annotations({ description: `FailureEncoded<${format(error)}>` })\n\nconst exitSuccessEncoded = <A, I, R>(\n  value: Schema<A, I, R>\n) =>\n  Struct({\n    _tag: Literal(\"Success\"),\n    value\n  }).annotations({ description: `SuccessEncoded<${format(value)}>` })\n\nconst exitEncoded = <A, I, R, E, EI, ER, DR>(\n  value: Schema<A, I, R>,\n  error: Schema<E, EI, ER>,\n  defect: Schema<unknown, unknown, DR>\n): Schema<ExitEncoded<A, E>, ExitEncoded<I, EI>, ER | R | DR> =>\n  Union(\n    exitFailureEncoded(error, defect),\n    exitSuccessEncoded(value)\n  ).annotations({\n    description: `ExitEncoded<${format(value)}, ${format(error)}>`\n  })\n\nconst exitDecode = <A, E>(input: ExitEncoded<A, E>): exit_.Exit<A, E> => {\n  switch (input._tag) {\n    case \"Failure\":\n      return exit_.failCause(causeDecode(input.cause))\n    case \"Success\":\n      return exit_.succeed(input.value)\n  }\n}\n\nconst exitArbitrary = <A, E>(\n  value: LazyArbitrary<A>,\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<exit_.Exit<A, E>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Failure\" as const), cause: causeArbitrary(error, defect)(fc) }),\n    fc.record({ _tag: fc.constant(\"Success\" as const), value: value(fc) })\n  ).map(exitDecode)\n\nconst exitPretty =\n  <A, E>(value: pretty_.Pretty<A>, error: pretty_.Pretty<E>): pretty_.Pretty<exit_.Exit<A, E>> => (exit) =>\n    exit._tag === \"Failure\"\n      ? `Exit.failCause(${causePretty(error)(exit.cause)})`\n      : `Exit.succeed(${value(exit.value)})`\n\nconst exitParse = <A, R, E, ER>(\n  decodeUnknownValue: ParseResult.DecodeUnknown<A, R>,\n  decodeUnknownCause: ParseResult.DecodeUnknown<cause_.Cause<E>, ER>\n): ParseResult.DeclarationDecodeUnknown<exit_.Exit<A, E>, ER | R> =>\n(u, options, ast) =>\n  exit_.isExit(u) ?\n    exit_.match(u, {\n      onFailure: (cause) => toComposite(decodeUnknownCause(cause, options), exit_.failCause, ast, u),\n      onSuccess: (value) => toComposite(decodeUnknownValue(value, options), exit_.succeed, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface ExitFromSelf<A extends Schema.Any, E extends Schema.Any, DR> extends\n  AnnotableClass<\n    ExitFromSelf<A, E, DR>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,\n    Schema.Context<A> | Schema.Context<E> | DR\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 0.67.0\n */\nexport const ExitFromSelf = <A extends Schema.Any, E extends Schema.Any, DR = never>(\n  { defect = Unknown, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect?: Schema<unknown, unknown, DR> | undefined\n  }\n): ExitFromSelf<A, E, DR> =>\n  declare(\n    [success, failure, defect],\n    {\n      decode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.decodeUnknown(success),\n          ParseResult.decodeUnknown(CauseFromSelf({ error: failure, defect }))\n        ),\n      encode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.encodeUnknown(success),\n          ParseResult.encodeUnknown(CauseFromSelf({ error: failure, defect }))\n        )\n    },\n    {\n      description: `Exit<${format(success)}, ${format(failure)}>`,\n      pretty: exitPretty,\n      arbitrary: exitArbitrary\n    }\n  )\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface Exit<A extends Schema.All, E extends Schema.All, DR> extends\n  AnnotableClass<\n    Exit<A, E, DR>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    ExitEncoded<Schema.Encoded<A>, Schema.Encoded<E>>,\n    Schema.Context<A> | Schema.Context<E> | DR\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 0.67.0\n */\nexport const Exit = <A extends Schema.All, E extends Schema.All, DR = never>(\n  { defect = CauseDefectUnknown, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect?: Schema<unknown, unknown, DR> | undefined\n  }\n): Exit<A, E, DR> => {\n  const success_ = asSchema(success)\n  const failure_ = asSchema(failure)\n  return transform(\n    exitEncoded(success_, failure_, defect),\n    ExitFromSelf({ failure: typeSchema(failure_), success: typeSchema(success_), defect: typeSchema(defect) }),\n    {\n      strict: true,\n      decode: exitDecode,\n      encode: (exit) =>\n        exit._tag === \"Failure\"\n          ? { _tag: \"Failure\", cause: exit.cause } as const\n          : { _tag: \"Success\", value: exit.value } as const\n    }\n  )\n}\n\nconst hashSetArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<hashSet_.HashSet<A>> => (fc) =>\n  fc.array(item(fc)).map((as) => hashSet_.fromIterable(as))\n\nconst hashSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<hashSet_.HashSet<A>> => (set) =>\n  `HashSet(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst hashSetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<hashSet_.HashSet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<hashSet_.HashSet<A>, R> =>\n(u, options, ast) =>\n  hashSet_.isHashSet(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashSet_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface HashSetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    HashSetFromSelf<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    hashSet_.HashSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 0.67.0\n */\nexport const HashSetFromSelf = <Value extends Schema.Any>(\n  value: Value\n): HashSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => hashSetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => hashSetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `HashSet<${format(value)}>`,\n      pretty: hashSetPretty,\n      arbitrary: hashSetArbitrary,\n      equivalence: hashSetEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface HashSet<Value extends Schema.Any> extends\n  AnnotableClass<\n    HashSet<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 0.67.0\n */\nexport const HashSet = <Value extends Schema.Any>(value: Value): HashSet<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    HashSetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => hashSet_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst hashMapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>\n): LazyArbitrary<hashMap_.HashMap<K, V>> =>\n(fc) => fc.array(fc.tuple(key(fc), value(fc))).map((as) => hashMap_.fromIterable(as))\n\nconst hashMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<hashMap_.HashMap<K, V>> =>\n(map) =>\n  `HashMap([${\n    Array.from(map)\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst hashMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<hashMap_.HashMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<hashMap_.HashMap<K, V>, R> =>\n(u, options, ast) =>\n  hashMap_.isHashMap(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashMap_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    HashMapFromSelf<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 0.67.0\n */\nexport const HashMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMapFromSelf<K, V> => {\n  return declare(\n    [key, value],\n    {\n      decode: (key, value) => hashMapParse(ParseResult.decodeUnknown(Array$(Tuple(key, value)))),\n      encode: (key, value) => hashMapParse(ParseResult.encodeUnknown(Array$(Tuple(key, value))))\n    },\n    {\n      description: `HashMap<${format(key)}, ${format(value)}>`,\n      pretty: hashMapPretty,\n      arbitrary: hashMapArbitrary,\n      equivalence: hashMapEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface HashMap<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    HashMap<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 0.67.0\n */\nexport const HashMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMap<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    HashMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => hashMap_.fromIterable(as), encode: (map) => Array.from(map) }\n  )\n}\n\nconst listArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<list_.List<A>> => (fc) =>\n  fc.array(item(fc)).map((as) => list_.fromIterable(as))\n\nconst listPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<list_.List<A>> => (set) =>\n  `List(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst listEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<list_.List<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst listParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<list_.List<A>, R> =>\n(u, options, ast) =>\n  list_.isList(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), list_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface ListFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ListFromSelf<Value>,\n    list_.List<Schema.Type<Value>>,\n    list_.List<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 0.67.0\n */\nexport const ListFromSelf = <Value extends Schema.Any>(\n  value: Value\n): ListFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => listParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => listParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `List<${format(value)}>`,\n      pretty: listPretty,\n      arbitrary: listArbitrary,\n      equivalence: listEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface List<Value extends Schema.Any> extends\n  AnnotableClass<\n    List<Value>,\n    list_.List<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 0.67.0\n */\nexport const List = <Value extends Schema.Any>(value: Value): List<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ListFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => list_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst sortedSetArbitrary =\n  <A>(item: LazyArbitrary<A>, ord: Order.Order<A>): LazyArbitrary<sortedSet_.SortedSet<A>> => (fc) =>\n    fc.array(item(fc)).map((as) => sortedSet_.fromIterable(as, ord))\n\nconst sortedSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<sortedSet_.SortedSet<A>> => (set) =>\n  `new SortedSet([${Array.from(sortedSet_.values(set)).map((a) => item(a)).join(\", \")}])`\n\nconst sortedSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>,\n  ord: Order.Order<A>\n): ParseResult.DeclarationDecodeUnknown<sortedSet_.SortedSet<A>, R> =>\n(u, options, ast) =>\n  sortedSet_.isSortedSet(u) ?\n    toComposite(\n      decodeUnknown(Array.from(sortedSet_.values(u)), options),\n      (as): sortedSet_.SortedSet<A> => sortedSet_.fromIterable(as, ord),\n      ast,\n      u\n    )\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface SortedSetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    SortedSetFromSelf<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    sortedSet_.SortedSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 0.67.0\n */\nexport const SortedSetFromSelf = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>,\n  ordI: Order.Order<Schema.Encoded<Value>>\n): SortedSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => sortedSetParse(ParseResult.decodeUnknown(Array$(item)), ordA),\n      encode: (item) => sortedSetParse(ParseResult.encodeUnknown(Array$(item)), ordI)\n    },\n    {\n      description: `SortedSet<${format(value)}>`,\n      pretty: sortedSetPretty,\n      arbitrary: (arb) => sortedSetArbitrary(arb, ordA),\n      equivalence: () => sortedSet_.getEquivalence<Schema.Type<Value>>()\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 0.67.0\n */\nexport interface SortedSet<Value extends Schema.Any> extends\n  AnnotableClass<\n    SortedSet<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 0.67.0\n */\nexport const SortedSet = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>\n): SortedSet<Value> => {\n  const value_ = asSchema(value)\n  const to = typeSchema(value_)\n  return transform(\n    Array$(value_),\n    SortedSetFromSelf<typeof to>(to, ordA, ordA),\n    {\n      strict: true,\n      decode: (as) => sortedSet_.fromIterable(as, ordA),\n      encode: (set) => Array.from(sortedSet_.values(set))\n    }\n  )\n}\n\n/**\n * Converts an arbitrary value to a `boolean` by testing whether it is truthy.\n * Uses `!!val` to coerce the value to a `boolean`.\n *\n * @see https://developer.mozilla.org/docs/Glossary/Truthy\n * @category boolean constructors\n * @since 0.67.0\n */\nexport class BooleanFromUnknown extends transform(\n  Unknown,\n  Boolean$,\n  { strict: true, decode: Predicate.isTruthy, encode: identity }\n).annotations({ identifier: \"BooleanFromUnknown\" }) {}\n\n/**\n * @category Config validations\n * @since 0.67.12\n */\nexport const Config = <A>(name: string, schema: Schema<A, string>): config_.Config<A> => {\n  const decodeEither_ = decodeEither(schema)\n  return config_.string(name).pipe(\n    config_.mapOrFail((a) =>\n      decodeEither_(a).pipe(\n        either_.mapLeft((error) => configError_.InvalidData([], TreeFormatter.formatErrorSync(error)))\n      )\n    )\n  )\n}\n"],"names":["array_","bigDecimal_","bigInt_","boolean_","cause_","chunk_","config_","configError_","data_","duration_","Effect","either_","Encoding","Equal","Equivalence","exit_","fiberId_","dual","identity","hashMap_","hashSet_","list_","number_","option_","pipeArguments","Predicate","record_","redacted_","Request","sortedSet_","string_","struct_","arbitrary_","AST","equivalence_","fastCheck_","errors_","filters_","serializable_","util_","ParseResult","pretty_","TreeFormatter","TypeId","Symbol","for","make","ast","SchemaClass","variance","Type","Encoded","annotations","mergeSchemaAnnotations","pipe","arguments","toString","String","_A","_","_I","_R","toASTAnnotations","out","custom","Object","getOwnPropertySymbols","sym","typeId","undefined","TypeAnnotationId","id","annotation","move","from","to","MessageAnnotationId","MissingMessageAnnotationId","IdentifierAnnotationId","TitleAnnotationId","DescriptionAnnotationId","ExamplesAnnotationId","DefaultAnnotationId","DocumentationAnnotationId","JSONSchemaAnnotationId","ArbitraryHookId","PrettyHookId","EquivalenceHookId","ConcurrencyAnnotationId","BatchingAnnotationId","ParseIssueTitleAnnotationId","ParseOptionsAnnotationId","asSchema","schema","format","encodedSchema","encodedAST","encodedBoundSchema","encodedBoundAST","typeSchema","typeAST","asserts","decodeOption","decodeSync","decodeUnknownOption","decodeUnknownSync","encodeOption","encodeSync","encodeUnknownOption","encodeUnknownSync","is","validateOption","validateSync","encodeUnknown","options","u","overrideOptions","mapError","parseError","encodeUnknownEither","mapLeft","encodeUnknownPromise","parser","runPromise","encode","encodeEither","encodePromise","decodeUnknown","decodeUnknownEither","decodeUnknownPromise","decode","decodeEither","decodePromise","validate","validateEither","validatePromise","isSchema","hasProperty","isObject","getDefaultLiteralAST","literals","isMembers","Union","mapMembers","literal","Literal","makeLiteralClass","LiteralClass","isNonEmptyReadonlyArray","Never","pickLiteral","_schema","UniqueSymbolFromSelf","symbol","UniqueSymbol","getDefaultEnumsAST","enums","Enums","keys","filter","key","map","makeEnumsClass","EnumsClass","TemplateLiteral","head","tail","astOrs","getTemplateLiterals","getTemplateLiteralParameterAST","span","flatMap","a","b","combineTemplateLiterals","astOr","isString","spans","modifyNonEmptyLast","TemplateLiteralSpan","type","appendAll","_tag","types","Error","getSchemaUnsupportedLiteralSpanErrorMessage","declareConstructor","typeParameters","Declaration","tp","declarePrimitive","input","succeed","fail","declare","Array","isArray","BrandTypeId","fromBrand","constructor","self","makeBrandClass","Refinement","predicate","either","isLeft","some","left","v","message","join","none","InstanceOfTypeId","instanceOf","title","name","description","pretty","Undefined","undefinedKeyword","Void","voidKeyword","Null","null","neverKeyword","Unknown","unknownKeyword","Any","anyKeyword","BigIntFromSelf","bigIntKeyword","SymbolFromSelf","symbolKeyword","String$","stringKeyword","Number$","numberKeyword","Boolean$","booleanKeyword","Object$","objectKeyword","Boolean","Number","getDefaultUnionAST","members","m","makeUnionClass","UnionClass","NullOr","UndefinedOr","NullishOr","keyof","element","ElementImpl","OptionalType","optionalElement","_Token","isOptional","getDefaultTupleTypeAST","elements","rest","TupleType","el","makeTupleTypeClass","TupleTypeClass","Tuple","args","slice","makeArrayClass","value","ArrayClass","Array$","makeNonEmptyArrayClass","NonEmptyArrayClass","NonEmptyArray","formatPropertySignatureToken","PropertySignatureDeclaration","isReadonly","defaultValue","token","FromPropertySignature","fromKey","ToPropertySignature","formatPropertyKey","p","JSON","stringify","PropertySignatureTransformation","mergeSignatureAnnotations","PropertySignatureTypeId","PropertySignatureImpl","_TypeToken","_Key","_EncodedToken","_HasDefault","makePropertySignature","PropertySignatureWithFromImpl","propertySignature","withConstructorDefault","applyDefaultValue","o","match","onNone","onSome","withDecodingDefault","withDefaults","defaults","decoding","optionalToRequired","requiredToOptional","optionalToOptional","optionalPropertySignatureAST","isExact","exact","default","isNullable","nullable","asOption","as","asOptionEncode","onNoneEncoding","orElse","OptionFromSelf","isNotNull","isNotUndefined","optional","isPropertySignature","getDefaultTypeLiteralAST","fields","records","ownKeys","pss","length","transformations","i","field","toAnnotations","push","PropertySignature","issFrom","issTo","r","indexSignatures","propertySignatures","record","forEach","ps","IndexSignature","parameter","Transformation","TypeLiteral","TypeLiteralTransformation","iss","lazilyMergeDefaults","makeTypeLiteralClass","TypeLiteralClass","props","propsWithDefaults","getDisableValidationMakeOption","pick","Struct","omit","tag","TaggedStruct","makeRecordClass","RecordClass","Record","pluck","getPropertyKeyIndexedAccess","orUndefined","transform","strict","ak","BrandClass","brand","getBrandAnnotation","brands","formatUnknown","BrandAnnotationId","partial","required","mutable","intersectTypeLiterals","x","y","path","isTypeLiteral","findIndex","extendAST","concat","getSchemaExtendErrorMessage","preserveRefinementAnnotations","preserveAnnotations","addRefinementToMembers","refinement","asts","intersectUnionMembers","getTypes","isUnion","xs","ys","Suspend","f","isTypeLiteralTransformation","transformation","propertySignatureTransformations","extend","that","compose","suspend","refineTypeId","makeRefineClass","RefineClass","fromFilterPredicateReturnTypeItem","item","isBoolean","issue","Pointer","toFilterParseIssue","isSingle","issues","filterMap","Composite","filterEffect","transformOrFail","filterReturnType","makeTransformationClass","TransformationClass","FinalTransformation","fromA","toI","transformLiteral","transformLiterals","pairs","attachPropertySignature","isSymbol","rename","mapping","TrimmedTypeId","trimmed","trim","jsonSchema","pattern","MaxLengthTypeId","maxLength","MinLengthTypeId","minLength","PatternTypeId","regex","source","lastIndex","test","arbitrary","fc","stringMatching","StartsWithTypeId","startsWith","EndsWithTypeId","endsWith","IncludesTypeId","includes","searchString","LowercasedTypeId","lowercased","toLowerCase","Lowercased","identifier","CapitalizedTypeId","capitalized","toUpperCase","Capitalized","UncapitalizedTypeId","uncapitalized","Uncapitalized","UppercasedTypeId","uppercased","Uppercased","LengthTypeId","Math","max","floor","min","Char","nonEmpty","Lowercase","s","Uppercase","Capitalize","capitalize","Uncapitalize","uncapitalize","Trimmed","Trim","split","separator","JsonString","getParseJsonTransformation","try","parse","reviver","catch","e","replacer","space","ParseJsonTypeId","parseJson","NonEmpty","UUIDTypeId","uuidRegexp","UUID","uuid","ULIDTypeId","ulidRegexp","ULID","ulid","FiniteTypeId","finite","isFinite","GreaterThanTypeId","greaterThan","exclusiveMinimum","GreaterThanOrEqualToTypeId","greaterThanOrEqualTo","minimum","MultipleOfTypeId","multipleOf","divisor","remainder","abs","IntTypeId","int","isSafeInteger","LessThanTypeId","lessThan","exclusiveMaximum","LessThanOrEqualToTypeId","lessThanOrEqualTo","maximum","BetweenTypeId","between","NonNaNTypeId","nonNaN","isNaN","positive","negative","nonPositive","nonNegative","clamp","parseNumber","fromOption","n","NumberFromString","Finite","Int","NonNaN","Positive","Negative","NonPositive","NonNegative","JsonNumberTypeId","JsonNumber","Not","not","Symbol$","GreaterThanBigIntTypeId","GreaterThanBigintTypeId","greaterThanBigInt","GreaterThanOrEqualToBigIntTypeId","greaterThanOrEqualToBigInt","LessThanBigIntTypeId","lessThanBigInt","LessThanOrEqualToBigIntTypeId","lessThanOrEqualToBigInt","BetweenBigIntTypeId","BetweenBigintTypeId","betweenBigInt","positiveBigInt","negativeBigInt","nonNegativeBigInt","nonPositiveBigInt","clampBigInt","BigInt$","fromString","BigInt","PositiveBigIntFromSelf","PositiveBigInt","NegativeBigIntFromSelf","NegativeBigInt","NonPositiveBigIntFromSelf","NonPositiveBigInt","NonNegativeBigIntFromSelf","NonNegativeBigInt","BigIntFromNumber","fromNumber","toNumber","redactedArbitrary","toComposite","eff","onSuccess","actual","mapBoth","onFailure","redactedParse","isRedacted","RedactedFromSelf","equivalence","getEquivalence","Redacted","DurationFromSelf","isDuration","oneof","constant","infinity","bigUint","nanos","micros","maxSafeNat","millis","seconds","minutes","hours","days","weeks","DurationFromNanos","duration","toNanos","val","DurationFromMillis","ms","toMillis","hrTime","Duration","toHrTime","clampDuration","betweenDuration","LessThanDurationTypeId","lessThanDuration","LessThanOrEqualToDurationTypeId","lessThanOrEqualToDuration","GreaterThanDurationTypeId","greaterThanDuration","GreaterThanOrEqualToDurationTypeId","greaterThanOrEqualToDuration","BetweenDurationTypeId","Uint8ArrayFromSelf","isUint8Array","u8arr","uint8Array","equals","Uint8Array$","numbers","Uint8Array","makeEncodingTransformation","decodeException","Base64","decodeBase64","encodeBase64","Base64Url","decodeBase64Url","encodeBase64Url","Hex","decodeHex","encodeHex","MinItemsTypeId","minItems","getInvalidArgumentErrorMessage","StableFilterAnnotationId","MaxItemsTypeId","maxItems","ItemsCountTypeId","itemsCount","getNumberIndexedAccess","of","headOrElse","fallback","ValidDateTypeId","validDate","getTime","DateFromSelf","isDate","date","noInvalidDate","Date","ValidDateFromSelf","DateFromString","d","toISOString","Date$","DateFromNumber","OptionNoneEncoded","optionSomeEncoded","optionEncoded","optionDecode","optionArbitrary","optionPretty","optionParse","isOption","isNone","makeNoneEncoded","makeSomeEncoded","Option","value_","OptionFromNullOr","fromNullable","getOrNull","OptionFromNullishOr","getOrUndefined","OptionFromUndefinedOr","rightEncoded","right","leftEncoded","eitherEncoded","eitherDecode","eitherArbitrary","eitherPretty","onLeft","onRight","eitherParse","parseRight","decodeUnknownLeft","isEither","EitherFromSelf","makeLeftEncoded","makeRightEncoded","Either","right_","left_","EitherFromUnion","toright","toleft","fromRight","fromLeft","l","mapArbitrary","array","tuple","Map","readonlyMapPretty","entries","k","readonlyMapEquivalence","arrayEquivalence","ka","va","kb","vb","readonlyMapParse","isMap","mapFromSelf_","Key","Value","ReadonlyMapFromSelf","MapFromSelf","ReadonlyMap","key_","ReadonlyMapFromRecord","fromEntries","MapFromRecord","setArbitrary","Set","readonlySetPretty","set","values","readonlySetEquivalence","readonlySetParse","isSet","setFromSelf_","ReadonlySetFromSelf","SetFromSelf","ReadonlySet","bigDecimalPretty","normalize","bigDecimalArbitrary","bigInt","integer","scale","BigDecimalFromSelf","isBigDecimal","BigDecimal","num","BigDecimalFromNumber","unsafeToNumber","GreaterThanBigDecimalTypeId","greaterThanBigDecimal","GreaterThanOrEqualToBigDecimalTypeId","greaterThanOrEqualToBigDecimal","LessThanBigDecimalTypeId","lessThanBigDecimal","LessThanOrEqualToBigDecimalTypeId","lessThanOrEqualToBigDecimal","PositiveBigDecimalTypeId","positiveBigDecimal","isPositive","PositiveBigDecimalFromSelf","NonNegativeBigDecimalTypeId","nonNegativeBigDecimal","NonNegativeBigDecimalFromSelf","NegativeBigDecimalTypeId","negativeBigDecimal","isNegative","NegativeBigDecimalFromSelf","NonPositiveBigDecimalTypeId","nonPositiveBigDecimal","NonPositiveBigDecimalFromSelf","BetweenBigDecimalTypeId","betweenBigDecimal","clampBigDecimal","chunkArbitrary","fromIterable","chunkPretty","c","toReadonlyArray","chunkParse","isChunk","isEmpty","empty","ChunkFromSelf","Chunk","nonEmptyChunkArbitrary","unsafeFromNonEmptyArray","nonEmptyChunkPretty","nonEmptyChunkParse","isNonEmpty","NonEmptyChunkFromSelf","NonEmptyChunk","toData","struct","dataArbitrary","dataPretty","dataParse","isEqual","DataFromSelf","Data","assign","isField","isFields","every","getFields","hasFields","getSchemaFromFieldsOr","fieldsOr","getFieldsFromFieldsOr","Class","makeClass","kind","Base","getClassTag","TaggedClass","newFields","taggedFields","extendFields","TaggedError","prototype","TaggedErrorClass","disableToString","TaggedRequest","Failure","Success","TaggedRequestClass","symbolResult","getASTDuplicatePropertySignatureErrorMessage","orElseTitleAnnotation","getTitleAnnotation","disableValidation","classSymbol","validateSchema","encodedSide","typeSide","fallbackInstanceOf","klass","declaration","arb","SurrogateAnnotationId","newFieldsOr","newSchema","extendedFields","transformedFields","transformOrFailFrom","defineProperty","configurable","FiberIdNoneEncoded","FiberIdRuntimeEncoded","startTimeMillis","FiberIdCompositeEncoded","FiberIdEncoded","fiberIdArbitrary","letrec","tie","None","Runtime","FiberId","fiberIdDecode","fiberIdPretty","fiberId","FiberIdFromSelf","isFiberId","runtime","composite","fiberIdEncode","causeDieEncoded","defect","CauseEmptyEncoded","causeFailEncoded","error","CauseInterruptEncoded","causeParallelEncoded","causeEncoded","causeSequentialEncoded","recur","causeArbitrary","Empty","Fail","Die","Interrupt","Sequential","Parallel","Cause","causeDecode","causePretty","cause","causeParse","isCause","causeEncode","CauseFromSelf","die","interrupt","sequential","parallel","CauseDefectUnknown","err","stack","error_","exitFailureEncoded","exitSuccessEncoded","exitEncoded","exitDecode","failCause","exitArbitrary","exitPretty","exit","exitParse","decodeUnknownValue","decodeUnknownCause","isExit","ExitFromSelf","failure","success","Exit","success_","failure_","hashSetArbitrary","hashSetPretty","hashSetEquivalence","hashSetParse","isHashSet","HashSetFromSelf","HashSet","hashMapArbitrary","hashMapPretty","hashMapEquivalence","hashMapParse","isHashMap","HashMapFromSelf","HashMap","listArbitrary","listPretty","listEquivalence","listParse","isList","ListFromSelf","List","sortedSetArbitrary","ord","sortedSetPretty","sortedSetParse","isSortedSet","SortedSetFromSelf","ordA","ordI","SortedSet","BooleanFromUnknown","isTruthy","Config","decodeEither_","string","mapOrFail","InvalidData","formatErrorSync"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 8532, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/internal/util.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/internal/util.ts"],"sourcesContent":["import * as Predicate from \"effect/Predicate\"\nimport type * as AST from \"../AST.js\"\n\n/** @internal */\nexport const getKeysForIndexSignature = (\n  input: { readonly [x: PropertyKey]: unknown },\n  parameter: AST.Parameter\n): ReadonlyArray<string> | ReadonlyArray<symbol> => {\n  switch (parameter._tag) {\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n      return Object.keys(input)\n    case \"SymbolKeyword\":\n      return Object.getOwnPropertySymbols(input)\n    case \"Refinement\":\n      return getKeysForIndexSignature(input, parameter.from)\n  }\n}\n\n/** @internal */\nexport const ownKeys = (o: object): Array<PropertyKey> =>\n  (Object.keys(o) as Array<PropertyKey>).concat(Object.getOwnPropertySymbols(o))\n\n/** @internal */\nexport const memoizeThunk = <A>(f: () => A): () => A => {\n  let done = false\n  let a: A\n  return () => {\n    if (done) {\n      return a\n    }\n    a = f()\n    done = true\n    return a\n  }\n}\n\n/** @internal */\nexport const formatUnknown = (u: unknown): string => {\n  if (Predicate.isString(u)) {\n    return JSON.stringify(u)\n  } else if (\n    Predicate.isNumber(u)\n    || u == null\n    || Predicate.isBoolean(u)\n    || Predicate.isSymbol(u)\n    || Predicate.isDate(u)\n  ) {\n    return String(u)\n  } else if (Predicate.isBigInt(u)) {\n    return String(u) + \"n\"\n  } else if (\n    !Array.isArray(u)\n    && Predicate.hasProperty(u, \"toString\")\n    && Predicate.isFunction(u[\"toString\"])\n    && u[\"toString\"] !== Object.prototype.toString\n  ) {\n    return u[\"toString\"]()\n  }\n  try {\n    JSON.stringify(u)\n    if (Array.isArray(u)) {\n      return `[${u.map(formatUnknown).join(\",\")}]`\n    } else {\n      return `{${\n        ownKeys(u).map((k) =>\n          `${Predicate.isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown((u as any)[k])}`\n        ).join(\",\")\n      }}`\n    }\n  } catch (e) {\n    return String(u)\n  }\n}\n\n/** @internal */\nexport const formatPropertyKey = (name: PropertyKey): string =>\n  typeof name === \"string\" ? JSON.stringify(name) : String(name)\n"],"names":["Predicate","getKeysForIndexSignature","input","parameter","_tag","Object","keys","getOwnPropertySymbols","from","ownKeys","o","concat","memoizeThunk","f","done","a","formatUnknown","u","isString","JSON","stringify","isNumber","isBoolean","isSymbol","isDate","String","isBigInt","Array","isArray","hasProperty","isFunction","prototype","toString","map","join","k","e","formatPropertyKey","name"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 8596, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/internal/errors.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/internal/errors.ts"],"sourcesContent":["import * as util_ from \"./util.js\"\n\n/** @internal */\nexport const getDuplicatePropertySignatureErrorMessage = (name: PropertyKey): string =>\n  `Duplicate property signature ${util_.formatUnknown(name)}`\n\n/** @internal */\nexport const getDuplicateIndexSignatureErrorMessage = (name: \"string\" | \"symbol\"): string =>\n  `Duplicate index signature for type \\`${name}\\``\n\n/** @internal */\nexport const getIndexSignatureParameterErrorMessage =\n  \"An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types\"\n\n/** @internal */\nexport const getRequiredElementFollowinAnOptionalElementErrorMessage =\n  \"A required element cannot follow an optional element. ts(1257)\"\n\n/** @internal */\nexport const getDuplicatePropertySignatureTransformationErrorMessage = (name: PropertyKey): string =>\n  `Duplicate property signature transformation ${util_.formatUnknown(name)}`\n\n/** @internal */\nexport const getArbitraryErrorMessage = (message: string) => `cannot build an Arbitrary for ${message}`\n\n/** @internal */\nexport const getPrettyErrorMessage = (message: string) => `cannot build a Pretty for ${message}`\n\n/** @internal */\nexport const getEquivalenceErrorMessage = (message: string) => `cannot build an Equivalence for ${message}`\n\n/** @internal */\nexport const getAPIErrorMessage = (api: string, message: string) => `${api}: ${message}`\n"],"names":["util_","getDuplicatePropertySignatureErrorMessage","name","formatUnknown","getDuplicateIndexSignatureErrorMessage","getIndexSignatureParameterErrorMessage","getRequiredElementFollowinAnOptionalElementErrorMessage","getDuplicatePropertySignatureTransformationErrorMessage","getArbitraryErrorMessage","message","getPrettyErrorMessage","getEquivalenceErrorMessage","getAPIErrorMessage","api"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAKA,KAAK,MAAM,WAAW;;AAG3B,MAAMC,yCAAyC,IAAIC,IAAiB,GACzE,CAAA,6BAAA,EAAgCF,KAAK,CAACG,mLAAa,CAACD,IAAI,CAAC,EAAE;AAGtD,MAAME,sCAAsC,IAAIF,IAAyB,GAC9E,CAAA,qCAAA,EAAwCA,IAAI,CAAA,EAAA,CAAI;AAG3C,MAAMG,sCAAsC,GACjD,6HAA6H;AAGxH,MAAMC,uDAAuD,GAClE,gEAAgE;AAG3D,MAAMC,uDAAuD,IAAIL,IAAiB,GACvF,CAAA,4CAAA,EAA+CF,KAAK,CAACG,mLAAa,CAACD,IAAI,CAAC,EAAE;AAGrE,MAAMM,wBAAwB,IAAIC,OAAe,GAAK,CAAA,8BAAA,EAAiCA,OAAO,EAAE;AAGhG,MAAMC,qBAAqB,IAAID,OAAe,GAAK,CAAA,0BAAA,EAA6BA,OAAO,EAAE;AAGzF,MAAME,0BAA0B,IAAIF,OAAe,GAAK,CAAA,gCAAA,EAAmCA,OAAO,EAAE;AAGpG,MAAMG,kBAAkB,GAAGA,CAACC,GAAW,EAAEJ,OAAe,GAAK,GAAGI,GAAG,CAAA,EAAA,EAAKJ,OAAO,EAAE","ignoreList":[]}},
    {"offset": {"line": 8631, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/AST.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/AST.ts"],"sourcesContent":["/**\n * @since 1.0.0\n */\n\nimport * as Arr from \"effect/Array\"\nimport type { Effect } from \"effect/Effect\"\nimport { dual, identity } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Hash from \"effect/Hash\"\nimport * as Number from \"effect/Number\"\nimport * as Option from \"effect/Option\"\nimport * as Order from \"effect/Order\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as regexp from \"effect/RegExp\"\nimport type { Concurrency } from \"effect/Types\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as util_ from \"./internal/util.js\"\nimport type { ParseIssue } from \"./ParseResult.js\"\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport type AST =\n  | Declaration\n  | Literal\n  | UniqueSymbol\n  | UndefinedKeyword\n  | VoidKeyword\n  | NeverKeyword\n  | UnknownKeyword\n  | AnyKeyword\n  | StringKeyword\n  | NumberKeyword\n  | BooleanKeyword\n  | BigIntKeyword\n  | SymbolKeyword\n  | ObjectKeyword\n  | Enums\n  | TemplateLiteral\n  // possible transformations\n  | Refinement\n  | TupleType\n  | TypeLiteral\n  | Union\n  | Suspend\n  // transformations\n  | Transformation\n\n// -------------------------------------------------------------------------------------\n// annotations\n// -------------------------------------------------------------------------------------\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type BrandAnnotation = Arr.NonEmptyReadonlyArray<string | symbol>\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const BrandAnnotationId = Symbol.for(\"@effect/schema/annotation/Brand\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type TypeAnnotation = symbol\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const TypeAnnotationId = Symbol.for(\"@effect/schema/annotation/Type\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type MessageAnnotation = (issue: ParseIssue) => string | Effect<string>\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const MessageAnnotationId = Symbol.for(\"@effect/schema/annotation/Message\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type IdentifierAnnotation = string\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const IdentifierAnnotationId = Symbol.for(\"@effect/schema/annotation/Identifier\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type TitleAnnotation = string\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const TitleAnnotationId = Symbol.for(\"@effect/schema/annotation/Title\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type DescriptionAnnotation = string\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const DescriptionAnnotationId = Symbol.for(\"@effect/schema/annotation/Description\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type ExamplesAnnotation<A> = Arr.NonEmptyReadonlyArray<A>\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const ExamplesAnnotationId = Symbol.for(\"@effect/schema/annotation/Examples\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type DefaultAnnotation<A> = A\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const DefaultAnnotationId = Symbol.for(\"@effect/schema/annotation/Default\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type JSONSchemaAnnotation = object\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const JSONSchemaAnnotationId = Symbol.for(\"@effect/schema/annotation/JSONSchema\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type DocumentationAnnotation = string\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const DocumentationAnnotationId = Symbol.for(\"@effect/schema/annotation/Documentation\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type ConcurrencyAnnotation = Concurrency | undefined\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const ConcurrencyAnnotationId = Symbol.for(\"@effect/schema/annotation/Concurrency\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type BatchingAnnotation = boolean | \"inherit\" | undefined\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const BatchingAnnotationId = Symbol.for(\"@effect/schema/annotation/Batching\")\n\n/** @internal */\nexport const SurrogateAnnotationId = Symbol.for(\"@effect/schema/annotation/Surrogate\")\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport type ParseIssueTitleAnnotation = (issue: ParseIssue) => string | undefined\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const ParseIssueTitleAnnotationId = Symbol.for(\"@effect/schema/annotation/ParseIssueTitle\")\n\n/**\n * Used by:\n *\n * - AST.keyof\n * - AST.getPropertyKeyIndexedAccess\n * - AST.getPropertyKeys\n * - AST.getPropertySignatures\n * - AST.getWeight\n * - Parser.getLiterals\n *\n * @internal\n */\nexport type SurrogateAnnotation = AST\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport interface Annotations {\n  readonly [_: symbol]: unknown\n}\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport interface Annotated {\n  readonly annotations: Annotations\n}\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getAnnotation: {\n  <A>(key: symbol): (annotated: Annotated) => Option.Option<A>\n  <A>(annotated: Annotated, key: symbol): Option.Option<A>\n} = dual(\n  2,\n  <A>(annotated: Annotated, key: symbol): Option.Option<A> =>\n    Object.prototype.hasOwnProperty.call(annotated.annotations, key) ?\n      Option.some(annotated.annotations[key] as any) :\n      Option.none()\n)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getBrandAnnotation = getAnnotation<BrandAnnotation>(BrandAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getMessageAnnotation = getAnnotation<MessageAnnotation>(MessageAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getTitleAnnotation = getAnnotation<TitleAnnotation>(TitleAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getIdentifierAnnotation = getAnnotation<IdentifierAnnotation>(IdentifierAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getDescriptionAnnotation = getAnnotation<DescriptionAnnotation>(DescriptionAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getExamplesAnnotation = getAnnotation<ExamplesAnnotation<unknown>>(ExamplesAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getDefaultAnnotation = getAnnotation<DefaultAnnotation<unknown>>(DefaultAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getJSONSchemaAnnotation = getAnnotation<JSONSchemaAnnotation>(JSONSchemaAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getDocumentationAnnotation = getAnnotation<DocumentationAnnotation>(DocumentationAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getConcurrencyAnnotation = getAnnotation<ConcurrencyAnnotation>(ConcurrencyAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getBatchingAnnotation = getAnnotation<BatchingAnnotation>(BatchingAnnotationId)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const getParseIssueTitleAnnotation = getAnnotation<ParseIssueTitleAnnotation>(ParseIssueTitleAnnotationId)\n\n/** @internal */\nexport const getSurrogateAnnotation = getAnnotation<SurrogateAnnotation>(SurrogateAnnotationId)\n\nconst JSONIdentifierAnnotationId = Symbol.for(\"@effect/schema/annotation/JSONIdentifier\")\n\n/** @internal */\nexport const getJSONIdentifierAnnotation = getAnnotation<IdentifierAnnotation>(JSONIdentifierAnnotationId)\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class Declaration implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Declaration\"\n  constructor(\n    readonly typeParameters: ReadonlyArray<AST>,\n    readonly decodeUnknown: (\n      ...typeParameters: ReadonlyArray<AST>\n    ) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>,\n    readonly encodeUnknown: (\n      ...typeParameters: ReadonlyArray<AST>\n    ) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(getExpected(this, verbose), () => \"<declaration schema>\")\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\nconst createASTGuard = <T extends AST[\"_tag\"]>(tag: T) => (ast: AST): ast is Extract<AST, { _tag: T }> =>\n  ast._tag === tag\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isDeclaration: (ast: AST) => ast is Declaration = createASTGuard(\"Declaration\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport type LiteralValue = string | number | boolean | null | bigint\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class Literal implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Literal\"\n  constructor(readonly literal: LiteralValue, readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(getExpected(this, verbose), () => util_.formatUnknown(this.literal))\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      literal: Predicate.isBigInt(this.literal) ? String(this.literal) : this.literal,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isLiteral: (ast: AST) => ast is Literal = createASTGuard(\"Literal\")\n\nconst $null = new Literal(null, {\n  [IdentifierAnnotationId]: \"null\"\n})\n\nexport {\n  /**\n   * @category constructors\n   * @since 1.0.0\n   */\n  $null as null\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class UniqueSymbol implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"UniqueSymbol\"\n  constructor(readonly symbol: symbol, readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(getExpected(this, verbose), () => util_.formatUnknown(this.symbol))\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      symbol: String(this.symbol),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isUniqueSymbol: (ast: AST) => ast is UniqueSymbol = createASTGuard(\"UniqueSymbol\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class UndefinedKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"UndefinedKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const undefinedKeyword: UndefinedKeyword = new UndefinedKeyword({\n  [TitleAnnotationId]: \"undefined\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isUndefinedKeyword: (ast: AST) => ast is UndefinedKeyword = createASTGuard(\"UndefinedKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class VoidKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"VoidKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const voidKeyword: VoidKeyword = new VoidKeyword({\n  [TitleAnnotationId]: \"void\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isVoidKeyword: (ast: AST) => ast is VoidKeyword = createASTGuard(\"VoidKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class NeverKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"NeverKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const neverKeyword: NeverKeyword = new NeverKeyword({\n  [TitleAnnotationId]: \"never\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isNeverKeyword: (ast: AST) => ast is NeverKeyword = createASTGuard(\"NeverKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class UnknownKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"UnknownKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const unknownKeyword: UnknownKeyword = new UnknownKeyword({\n  [TitleAnnotationId]: \"unknown\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isUnknownKeyword: (ast: AST) => ast is UnknownKeyword = createASTGuard(\"UnknownKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class AnyKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"AnyKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const anyKeyword: AnyKeyword = new AnyKeyword({\n  [TitleAnnotationId]: \"any\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isAnyKeyword: (ast: AST) => ast is AnyKeyword = createASTGuard(\"AnyKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class StringKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"StringKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const stringKeyword: StringKeyword = new StringKeyword({\n  [TitleAnnotationId]: \"string\",\n  [DescriptionAnnotationId]: \"a string\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isStringKeyword: (ast: AST) => ast is StringKeyword = createASTGuard(\"StringKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class NumberKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"NumberKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const numberKeyword: NumberKeyword = new NumberKeyword({\n  [TitleAnnotationId]: \"number\",\n  [DescriptionAnnotationId]: \"a number\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isNumberKeyword: (ast: AST) => ast is NumberKeyword = createASTGuard(\"NumberKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class BooleanKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"BooleanKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const booleanKeyword: BooleanKeyword = new BooleanKeyword({\n  [TitleAnnotationId]: \"boolean\",\n  [DescriptionAnnotationId]: \"a boolean\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isBooleanKeyword: (ast: AST) => ast is BooleanKeyword = createASTGuard(\"BooleanKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class BigIntKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"BigIntKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const bigIntKeyword: BigIntKeyword = new BigIntKeyword({\n  [TitleAnnotationId]: \"bigint\",\n  [DescriptionAnnotationId]: \"a bigint\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isBigIntKeyword: (ast: AST) => ast is BigIntKeyword = createASTGuard(\"BigIntKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class SymbolKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"SymbolKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const symbolKeyword: SymbolKeyword = new SymbolKeyword({\n  [TitleAnnotationId]: \"symbol\",\n  [DescriptionAnnotationId]: \"a symbol\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isSymbolKeyword: (ast: AST) => ast is SymbolKeyword = createASTGuard(\"SymbolKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class ObjectKeyword implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"ObjectKeyword\"\n  constructor(readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return formatKeyword(this, verbose)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const objectKeyword: ObjectKeyword = new ObjectKeyword({\n  [IdentifierAnnotationId]: \"object\",\n  [TitleAnnotationId]: \"object\",\n  [DescriptionAnnotationId]: \"an object in the TypeScript meaning, i.e. the `object` type\"\n})\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isObjectKeyword: (ast: AST) => ast is ObjectKeyword = createASTGuard(\"ObjectKeyword\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class Enums implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Enums\"\n  constructor(\n    readonly enums: ReadonlyArray<readonly [string, string | number]>,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(\n      getExpected(this, verbose),\n      () => `<enum ${this.enums.length} value(s): ${this.enums.map((_, value) => JSON.stringify(value)).join(\" | \")}>`\n    )\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      enums: this.enums,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isEnums: (ast: AST) => ast is Enums = createASTGuard(\"Enums\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class TemplateLiteralSpan {\n  constructor(readonly type: StringKeyword | NumberKeyword, readonly literal: string) {}\n  /**\n   * @since 1.0.0\n   */\n  toString() {\n    switch (this.type._tag) {\n      case \"StringKeyword\":\n        return \"${string}\"\n      case \"NumberKeyword\":\n        return \"${number}\"\n    }\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      type: this.type.toJSON(),\n      literal: this.literal\n    }\n  }\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class TemplateLiteral implements Annotated {\n  static make = (\n    head: string,\n    spans: ReadonlyArray<TemplateLiteralSpan>,\n    annotations: Annotations = {}\n  ): TemplateLiteral | Literal =>\n    Arr.isNonEmptyReadonlyArray(spans) ?\n      new TemplateLiteral(head, spans, annotations) :\n      new Literal(head)\n\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"TemplateLiteral\"\n  private constructor(\n    readonly head: string,\n    readonly spans: Arr.NonEmptyReadonlyArray<TemplateLiteralSpan>,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(getExpected(this, verbose), () => formatTemplateLiteral(this))\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      head: this.head,\n      spans: this.spans.map((span) => span.toJSON()),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\nconst formatTemplateLiteral = (ast: TemplateLiteral): string =>\n  \"`\" + ast.head + ast.spans.map((span) => String(span) + span.literal).join(\"\") +\n  \"`\"\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isTemplateLiteral: (ast: AST) => ast is TemplateLiteral = createASTGuard(\"TemplateLiteral\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class Element {\n  constructor(readonly type: AST, readonly isOptional: boolean) {}\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      type: this.type.toJSON(),\n      isOptional: this.isOptional\n    }\n  }\n  /**\n   * @since 1.0.0\n   */\n  toString() {\n    return String(this.type) + (this.isOptional ? \"?\" : \"\")\n  }\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class TupleType implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"TupleType\"\n  constructor(\n    readonly elements: ReadonlyArray<Element>,\n    readonly rest: ReadonlyArray<AST>,\n    readonly isReadonly: boolean,\n    readonly annotations: Annotations = {}\n  ) {\n    let hasOptionalElement = false\n    let hasIllegalRequiredElement = false\n    for (const e of elements) {\n      if (e.isOptional) {\n        hasOptionalElement = true\n      } else if (hasOptionalElement) {\n        hasIllegalRequiredElement = true\n        break\n      }\n    }\n    if (hasIllegalRequiredElement || (hasOptionalElement && rest.length > 1)) {\n      throw new Error(errors_.getRequiredElementFollowinAnOptionalElementErrorMessage)\n    }\n  }\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(getExpected(this, verbose), () => formatTuple(this))\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      elements: this.elements.map((e) => e.toJSON()),\n      rest: this.rest.map((ast) => ast.toJSON()),\n      isReadonly: this.isReadonly,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\nconst formatTuple = (ast: TupleType): string => {\n  const formattedElements = ast.elements.map(String)\n    .join(\", \")\n  return Arr.matchLeft(ast.rest, {\n    onEmpty: () => `readonly [${formattedElements}]`,\n    onNonEmpty: (head, tail) => {\n      const formattedHead = String(head)\n      const wrappedHead = formattedHead.includes(\" | \") ? `(${formattedHead})` : formattedHead\n\n      if (tail.length > 0) {\n        const formattedTail = tail.map(String).join(\", \")\n        if (ast.elements.length > 0) {\n          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`\n        } else {\n          return `readonly [...${wrappedHead}[], ${formattedTail}]`\n        }\n      } else {\n        if (ast.elements.length > 0) {\n          return `readonly [${formattedElements}, ...${wrappedHead}[]]`\n        } else {\n          return `ReadonlyArray<${formattedHead}>`\n        }\n      }\n    }\n  })\n}\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isTupleType: (ast: AST) => ast is TupleType = createASTGuard(\"TupleType\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class PropertySignature implements Annotated {\n  constructor(\n    readonly name: PropertyKey,\n    readonly type: AST,\n    readonly isOptional: boolean,\n    readonly isReadonly: boolean,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      name: String(this.name),\n      type: this.type.toJSON(),\n      isOptional: this.isOptional,\n      isReadonly: this.isReadonly,\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n */\nexport type Parameter = StringKeyword | SymbolKeyword | TemplateLiteral | Refinement<Parameter>\n\n/**\n * @since 1.0.0\n */\nexport const isParameter = (ast: AST): ast is Parameter => {\n  switch (ast._tag) {\n    case \"StringKeyword\":\n    case \"SymbolKeyword\":\n    case \"TemplateLiteral\":\n      return true\n    case \"Refinement\":\n      return isParameter(ast.from)\n  }\n  return false\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class IndexSignature {\n  /**\n   * @since 1.0.0\n   */\n  readonly parameter: Parameter\n  constructor(\n    parameter: AST,\n    readonly type: AST,\n    readonly isReadonly: boolean\n  ) {\n    if (isParameter(parameter)) {\n      this.parameter = parameter\n    } else {\n      throw new Error(errors_.getIndexSignatureParameterErrorMessage)\n    }\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      parameter: this.parameter.toJSON(),\n      type: this.type.toJSON(),\n      isReadonly: this.isReadonly\n    }\n  }\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class TypeLiteral implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"TypeLiteral\"\n  /**\n   * @since 1.0.0\n   */\n  readonly propertySignatures: ReadonlyArray<PropertySignature>\n  /**\n   * @since 1.0.0\n   */\n  readonly indexSignatures: ReadonlyArray<IndexSignature>\n  constructor(\n    propertySignatures: ReadonlyArray<PropertySignature>,\n    indexSignatures: ReadonlyArray<IndexSignature>,\n    readonly annotations: Annotations = {}\n  ) {\n    // check for duplicate property signatures\n    const keys: Record<PropertyKey, null> = {}\n    for (let i = 0; i < propertySignatures.length; i++) {\n      const name = propertySignatures[i].name\n      if (Object.prototype.hasOwnProperty.call(keys, name)) {\n        throw new Error(errors_.getDuplicatePropertySignatureErrorMessage(name))\n      }\n      keys[name] = null\n    }\n    // check for duplicate index signatures\n    const parameters = {\n      string: false,\n      symbol: false\n    }\n    for (let i = 0; i < indexSignatures.length; i++) {\n      const parameter = getParameterBase(indexSignatures[i].parameter)\n      if (isStringKeyword(parameter)) {\n        if (parameters.string) {\n          throw new Error(errors_.getDuplicateIndexSignatureErrorMessage(\"string\"))\n        }\n        parameters.string = true\n      } else if (isSymbolKeyword(parameter)) {\n        if (parameters.symbol) {\n          throw new Error(errors_.getDuplicateIndexSignatureErrorMessage(\"symbol\"))\n        }\n        parameters.symbol = true\n      }\n    }\n\n    this.propertySignatures = sortPropertySignatures(propertySignatures)\n    this.indexSignatures = sortIndexSignatures(indexSignatures)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(getExpected(this, verbose), () => formatTypeLiteral(this))\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),\n      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\nconst formatTypeLiteral = (ast: TypeLiteral): string => {\n  const formattedPropertySignatures = ast.propertySignatures.map((ps) =>\n    String(ps.name) + (ps.isOptional ? \"?\" : \"\") + \": \" + ps.type\n  ).join(\"; \")\n  if (ast.indexSignatures.length > 0) {\n    const formattedIndexSignatures = ast.indexSignatures.map((is) =>\n      `[x: ${getParameterBase(is.parameter)}]: ${is.type}`\n    ).join(\"; \")\n    if (ast.propertySignatures.length > 0) {\n      return `{ ${formattedPropertySignatures}; ${formattedIndexSignatures} }`\n    } else {\n      return `{ ${formattedIndexSignatures} }`\n    }\n  } else {\n    if (ast.propertySignatures.length > 0) {\n      return `{ ${formattedPropertySignatures} }`\n    } else {\n      return \"{}\"\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isTypeLiteral: (ast: AST) => ast is TypeLiteral = createASTGuard(\"TypeLiteral\")\n\n/**\n * @since 1.0.0\n */\nexport type Members<A> = readonly [A, A, ...Array<A>]\n\nconst removeNevers = (candidates: ReadonlyArray<AST>): Array<AST> => candidates.filter((ast) => !(ast === neverKeyword))\n\nconst sortCandidates = Arr.sort(\n  Order.mapInput(Number.Order, (ast: AST) => {\n    switch (ast._tag) {\n      case \"AnyKeyword\":\n        return 0\n      case \"UnknownKeyword\":\n        return 1\n      case \"ObjectKeyword\":\n        return 2\n      case \"StringKeyword\":\n      case \"NumberKeyword\":\n      case \"BooleanKeyword\":\n      case \"BigIntKeyword\":\n      case \"SymbolKeyword\":\n        return 3\n    }\n    return 4\n  })\n)\n\nconst literalMap = {\n  string: \"StringKeyword\",\n  number: \"NumberKeyword\",\n  boolean: \"BooleanKeyword\",\n  bigint: \"BigIntKeyword\"\n} as const\n\n/** @internal */\nexport const flatten = (candidates: ReadonlyArray<AST>): Array<AST> =>\n  Arr.flatMap(candidates, (ast) => isUnion(ast) ? flatten(ast.types) : [ast])\n\n/** @internal */\nexport const unify = (candidates: ReadonlyArray<AST>): Array<AST> => {\n  const cs = sortCandidates(candidates)\n  const out: Array<AST> = []\n  const uniques: { [K in AST[\"_tag\"] | \"{}\"]?: AST } = {}\n  const literals: Array<LiteralValue | symbol> = []\n  for (const ast of cs) {\n    switch (ast._tag) {\n      case \"NeverKeyword\":\n        break\n      case \"AnyKeyword\":\n        return [anyKeyword]\n      case \"UnknownKeyword\":\n        return [unknownKeyword]\n      // uniques\n      case \"ObjectKeyword\":\n      case \"UndefinedKeyword\":\n      case \"VoidKeyword\":\n      case \"StringKeyword\":\n      case \"NumberKeyword\":\n      case \"BooleanKeyword\":\n      case \"BigIntKeyword\":\n      case \"SymbolKeyword\": {\n        if (!uniques[ast._tag]) {\n          uniques[ast._tag] = ast\n          out.push(ast)\n        }\n        break\n      }\n      case \"Literal\": {\n        const type = typeof ast.literal\n        switch (type) {\n          case \"string\":\n          case \"number\":\n          case \"bigint\":\n          case \"boolean\": {\n            const _tag = literalMap[type]\n            if (!uniques[_tag] && !literals.includes(ast.literal)) {\n              literals.push(ast.literal)\n              out.push(ast)\n            }\n            break\n          }\n          // null\n          case \"object\": {\n            if (!literals.includes(ast.literal)) {\n              literals.push(ast.literal)\n              out.push(ast)\n            }\n            break\n          }\n        }\n        break\n      }\n      case \"UniqueSymbol\": {\n        if (!uniques[\"SymbolKeyword\"] && !literals.includes(ast.symbol)) {\n          literals.push(ast.symbol)\n          out.push(ast)\n        }\n        break\n      }\n      case \"TupleType\": {\n        if (!uniques[\"ObjectKeyword\"]) {\n          out.push(ast)\n        }\n        break\n      }\n      case \"TypeLiteral\": {\n        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n          if (!uniques[\"{}\"]) {\n            uniques[\"{}\"] = ast\n            out.push(ast)\n          }\n        } else if (!uniques[\"ObjectKeyword\"]) {\n          out.push(ast)\n        }\n        break\n      }\n      default:\n        out.push(ast)\n    }\n  }\n  return out\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class Union implements Annotated {\n  static make = (candidates: ReadonlyArray<AST>, annotations?: Annotations): AST => {\n    const types = []\n    const memo = new Set<AST>()\n    for (let i = 0; i < candidates.length; i++) {\n      const ast = candidates[i]\n      if (ast === neverKeyword || memo.has(ast)) {\n        continue\n      }\n      memo.add(ast)\n      types.push(ast)\n    }\n    return Union.union(types, annotations)\n  }\n  /** @internal */\n  static members = (candidates: ReadonlyArray<AST>, annotations?: Annotations): AST => {\n    return Union.union(removeNevers(candidates), annotations)\n  }\n  /** @internal */\n  static unify = (candidates: ReadonlyArray<AST>, annotations?: Annotations): AST => {\n    return Union.union(unify(flatten(candidates)), annotations)\n  }\n  /** @internal */\n  static union = (types: ReadonlyArray<AST>, annotations?: Annotations): AST => {\n    return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword\n  }\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Union\"\n  private constructor(readonly types: Members<AST>, readonly annotations: Annotations = {}) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(\n      getExpected(this, verbose),\n      () => this.types.map(String).join(\" | \")\n    )\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      types: this.types.map((ast) => ast.toJSON()),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/** @internal */\nexport const mapMembers = <A, B>(members: Members<A>, f: (a: A) => B): Members<B> => members.map(f) as any\n\n/** @internal */\nexport const isMembers = <A>(as: ReadonlyArray<A>): as is readonly [A, A, ...Array<A>] => as.length > 1\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isUnion: (ast: AST) => ast is Union = createASTGuard(\"Union\")\n\nconst toJSONMemoMap = globalValue(\n  Symbol.for(\"@effect/schema/AST/toJSONMemoMap\"),\n  () => new WeakMap<AST, object>()\n)\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class Suspend implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Suspend\"\n  constructor(readonly f: () => AST, readonly annotations: Annotations = {}) {\n    this.f = util_.memoizeThunk(f)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return getExpected(this, verbose).pipe(\n      Option.orElse(() =>\n        Option.flatMap(\n          Option.liftThrowable(this.f)(),\n          (ast) => getExpected(ast, verbose)\n        )\n      ),\n      Option.getOrElse(() => \"<suspended schema>\")\n    )\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    const ast = this.f()\n    let out = toJSONMemoMap.get(ast)\n    if (out) {\n      return out\n    }\n    toJSONMemoMap.set(ast, { _tag: this._tag })\n    out = {\n      _tag: this._tag,\n      ast: ast.toJSON(),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n    toJSONMemoMap.set(ast, out)\n    return out\n  }\n}\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isSuspend: (ast: AST) => ast is Suspend = createASTGuard(\"Suspend\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class Refinement<From extends AST = AST> implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Refinement\"\n  constructor(\n    readonly from: From,\n    readonly filter: (\n      input: any,\n      options: ParseOptions,\n      self: Refinement\n    ) => Option.Option<ParseIssue>,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(getExpected(this, verbose), () => \"<refinement schema>\")\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      from: this.from.toJSON(),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isRefinement: (ast: AST) => ast is Refinement<AST> = createASTGuard(\"Refinement\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface ParseOptions {\n  /** default \"first\" */\n  readonly errors?: \"first\" | \"all\" | undefined\n  /** default \"ignore\" */\n  readonly onExcessProperty?: \"ignore\" | \"error\" | \"preserve\" | undefined\n}\n\n/**\n * @since 1.0.0\n */\nexport const defaultParseOption: ParseOptions = {}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class Transformation implements Annotated {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Transformation\"\n  constructor(\n    readonly from: AST,\n    readonly to: AST,\n    readonly transformation: TransformationKind,\n    readonly annotations: Annotations = {}\n  ) {}\n  /**\n   * @since 1.0.0\n   */\n  toString(verbose: boolean = false) {\n    return Option.getOrElse(\n      getExpected(this, verbose),\n      () => `(${String(this.from)} <-> ${String(this.to)})`\n    )\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON(): object {\n    return {\n      _tag: this._tag,\n      from: this.from.toJSON(),\n      to: this.to.toJSON(),\n      annotations: toJSONAnnotations(this.annotations)\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isTransformation: (ast: AST) => ast is Transformation = createASTGuard(\"Transformation\")\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport type TransformationKind =\n  | FinalTransformation\n  | ComposeTransformation\n  | TypeLiteralTransformation\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class FinalTransformation {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"FinalTransformation\"\n  constructor(\n    readonly decode: (input: any, options: ParseOptions, self: Transformation) => Effect<any, ParseIssue, any>,\n    readonly encode: (input: any, options: ParseOptions, self: Transformation) => Effect<any, ParseIssue, any>\n  ) {}\n}\n\nconst createTransformationGuard =\n  <T extends TransformationKind[\"_tag\"]>(tag: T) =>\n  (ast: TransformationKind): ast is Extract<TransformationKind, { _tag: T }> => ast._tag === tag\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isFinalTransformation: (ast: TransformationKind) => ast is FinalTransformation = createTransformationGuard(\n  \"FinalTransformation\"\n)\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class ComposeTransformation {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"ComposeTransformation\"\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const composeTransformation: ComposeTransformation = new ComposeTransformation()\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isComposeTransformation: (ast: TransformationKind) => ast is ComposeTransformation =\n  createTransformationGuard(\n    \"ComposeTransformation\"\n  )\n\n/**\n * Represents a `PropertySignature -> PropertySignature` transformation\n *\n * The semantic of `decode` is:\n * - `none()` represents the absence of the key/value pair\n * - `some(value)` represents the presence of the key/value pair\n *\n * The semantic of `encode` is:\n * - `none()` you don't want to output the key/value pair\n * - `some(value)` you want to output the key/value pair\n *\n * @category model\n * @since 1.0.0\n */\nexport class PropertySignatureTransformation {\n  constructor(\n    readonly from: PropertyKey,\n    readonly to: PropertyKey,\n    readonly decode: (o: Option.Option<any>) => Option.Option<any>,\n    readonly encode: (o: Option.Option<any>) => Option.Option<any>\n  ) {}\n}\n\nconst isRenamingPropertySignatureTransformation = (t: PropertySignatureTransformation) =>\n  t.decode === identity && t.encode === identity\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport class TypeLiteralTransformation {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"TypeLiteralTransformation\"\n  constructor(\n    readonly propertySignatureTransformations: ReadonlyArray<\n      PropertySignatureTransformation\n    >\n  ) {\n    // check for duplicate property signature transformations\n    const fromKeys: Record<PropertyKey, true> = {}\n    const toKeys: Record<PropertyKey, true> = {}\n    for (const pst of propertySignatureTransformations) {\n      const from = pst.from\n      if (fromKeys[from]) {\n        throw new Error(errors_.getDuplicatePropertySignatureTransformationErrorMessage(from))\n      }\n      fromKeys[from] = true\n      const to = pst.to\n      if (toKeys[to]) {\n        throw new Error(errors_.getDuplicatePropertySignatureTransformationErrorMessage(to))\n      }\n      toKeys[to] = true\n    }\n  }\n}\n\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isTypeLiteralTransformation: (ast: TransformationKind) => ast is TypeLiteralTransformation =\n  createTransformationGuard(\"TypeLiteralTransformation\")\n\n// -------------------------------------------------------------------------------------\n// API\n// -------------------------------------------------------------------------------------\n\n/**\n * Adds a group of annotations, potentially overwriting existing annotations.\n *\n * @since 1.0.0\n */\nexport const annotations = (ast: AST, annotations: Annotations): AST => {\n  const d = Object.getOwnPropertyDescriptors(ast)\n  d.annotations.value = { ...ast.annotations, ...annotations }\n  return Object.create(Object.getPrototypeOf(ast), d)\n}\n\n/**\n * Equivalent at runtime to the TypeScript type-level `keyof` operator.\n *\n * @since 1.0.0\n */\nexport const keyof = (ast: AST): AST => Union.unify(_keyof(ast))\n\nconst STRING_KEYWORD_PATTERN = \".*\"\nconst NUMBER_KEYWORD_PATTERN = \"[+-]?\\\\d*\\\\.?\\\\d+(?:[Ee][+-]?\\\\d+)?\"\n\n/**\n * @since 1.0.0\n */\nexport const getTemplateLiteralRegExp = (ast: TemplateLiteral): RegExp => {\n  let pattern = `^${regexp.escape(ast.head)}`\n\n  for (const span of ast.spans) {\n    if (isStringKeyword(span.type)) {\n      pattern += STRING_KEYWORD_PATTERN\n    } else if (isNumberKeyword(span.type)) {\n      pattern += NUMBER_KEYWORD_PATTERN\n    }\n    pattern += regexp.escape(span.literal)\n  }\n\n  pattern += \"$\"\n  return new RegExp(pattern)\n}\n\n/**\n * @since 1.0.0\n */\nexport const getPropertySignatures = (ast: AST): Array<PropertySignature> => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return getPropertySignatures(annotation.value)\n      }\n      break\n    }\n    case \"TypeLiteral\":\n      return ast.propertySignatures.slice()\n    case \"Suspend\":\n      return getPropertySignatures(ast.f())\n  }\n  return getPropertyKeys(ast).map((name) => getPropertyKeyIndexedAccess(ast, name))\n}\n\n/** @internal */\nexport const getNumberIndexedAccess = (ast: AST): AST => {\n  switch (ast._tag) {\n    case \"TupleType\": {\n      let hasOptional = false\n      let out: Array<AST> = []\n      for (const e of ast.elements) {\n        if (e.isOptional) {\n          hasOptional = true\n        }\n        out.push(e.type)\n      }\n      if (hasOptional) {\n        out.push(undefinedKeyword)\n      }\n      out = out.concat(ast.rest)\n      return Union.make(out)\n    }\n    case \"Refinement\":\n      return getNumberIndexedAccess(ast.from)\n    case \"Union\":\n      return Union.make(ast.types.map(getNumberIndexedAccess))\n    case \"Suspend\":\n      return getNumberIndexedAccess(ast.f())\n  }\n  throw new Error(errors_.getAPIErrorMessage(\"NumberIndexedAccess\", `unsupported schema (${ast})`))\n}\n\n/** @internal */\nexport const getPropertyKeyIndexedAccess = (ast: AST, name: PropertyKey): PropertySignature => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return getPropertyKeyIndexedAccess(annotation.value, name)\n      }\n      break\n    }\n    case \"TypeLiteral\": {\n      const ops = Arr.findFirst(ast.propertySignatures, (ps) => ps.name === name)\n      if (Option.isSome(ops)) {\n        return ops.value\n      } else {\n        if (Predicate.isString(name)) {\n          for (const is of ast.indexSignatures) {\n            const parameterBase = getParameterBase(is.parameter)\n            switch (parameterBase._tag) {\n              case \"TemplateLiteral\": {\n                const regex = getTemplateLiteralRegExp(parameterBase)\n                if (regex.test(name)) {\n                  return new PropertySignature(name, is.type, false, false)\n                }\n                break\n              }\n              case \"StringKeyword\":\n                return new PropertySignature(name, is.type, false, false)\n            }\n          }\n        } else if (Predicate.isSymbol(name)) {\n          for (const is of ast.indexSignatures) {\n            const parameterBase = getParameterBase(is.parameter)\n            if (isSymbolKeyword(parameterBase)) {\n              return new PropertySignature(name, is.type, false, false)\n            }\n          }\n        }\n      }\n      break\n    }\n    case \"Union\":\n      return new PropertySignature(\n        name,\n        Union.make(ast.types.map((ast) => getPropertyKeyIndexedAccess(ast, name).type)),\n        false,\n        true\n      )\n    case \"Suspend\":\n      return getPropertyKeyIndexedAccess(ast.f(), name)\n  }\n  return new PropertySignature(name, neverKeyword, false, true)\n}\n\nconst getPropertyKeys = (ast: AST): Array<PropertyKey> => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return getPropertyKeys(annotation.value)\n      }\n      break\n    }\n    case \"TypeLiteral\":\n      return ast.propertySignatures.map((ps) => ps.name)\n    case \"Suspend\":\n      return getPropertyKeys(ast.f())\n    case \"Union\":\n      return ast.types.slice(1).reduce(\n        (out: Array<PropertyKey>, ast) => Arr.intersection(out, getPropertyKeys(ast)),\n        getPropertyKeys(ast.types[0])\n      )\n    case \"Transformation\":\n      return getPropertyKeys(ast.to)\n  }\n  return []\n}\n\n/** @internal */\nexport const record = (key: AST, value: AST): {\n  propertySignatures: Array<PropertySignature>\n  indexSignatures: Array<IndexSignature>\n} => {\n  const propertySignatures: Array<PropertySignature> = []\n  const indexSignatures: Array<IndexSignature> = []\n  const go = (key: AST): void => {\n    switch (key._tag) {\n      case \"NeverKeyword\":\n        break\n      case \"StringKeyword\":\n      case \"SymbolKeyword\":\n      case \"TemplateLiteral\":\n      case \"Refinement\":\n        indexSignatures.push(new IndexSignature(key, value, true))\n        break\n      case \"Literal\":\n        if (Predicate.isString(key.literal) || Predicate.isNumber(key.literal)) {\n          propertySignatures.push(new PropertySignature(key.literal, value, false, true))\n        } else {\n          throw new Error(\n            errors_.getAPIErrorMessage(\"Record\", `unsupported literal (${util_.formatUnknown(key.literal)})`)\n          )\n        }\n        break\n      case \"UniqueSymbol\":\n        propertySignatures.push(new PropertySignature(key.symbol, value, false, true))\n        break\n      case \"Union\":\n        key.types.forEach(go)\n        break\n      default:\n        throw new Error(errors_.getAPIErrorMessage(\"Record\", `unsupported key schema (${key})`))\n    }\n  }\n  go(key)\n  return { propertySignatures, indexSignatures }\n}\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Pick`.\n *\n * @since 1.0.0\n */\nexport const pick = (ast: AST, keys: ReadonlyArray<PropertyKey>): TypeLiteral | Transformation => {\n  if (isTransformation(ast)) {\n    switch (ast.transformation._tag) {\n      case \"ComposeTransformation\":\n        return new Transformation(\n          pick(ast.from, keys),\n          pick(ast.to, keys),\n          composeTransformation\n        )\n      case \"TypeLiteralTransformation\": {\n        const ts: Array<PropertySignatureTransformation> = []\n        const fromKeys: Array<PropertyKey> = []\n        for (const k of keys) {\n          const t = ast.transformation.propertySignatureTransformations.find((t) => t.to === k)\n          if (t) {\n            ts.push(t)\n            fromKeys.push(t.from)\n          } else {\n            fromKeys.push(k)\n          }\n        }\n        return new Transformation(\n          pick(ast.from, fromKeys),\n          pick(ast.to, keys),\n          Arr.isNonEmptyReadonlyArray(ts) ?\n            new TypeLiteralTransformation(ts)\n            : composeTransformation\n        )\n      }\n      case \"FinalTransformation\": {\n        const annotation = getSurrogateAnnotation(ast)\n        if (Option.isSome(annotation)) {\n          return pick(annotation.value, keys)\n        }\n        throw new Error(errors_.getAPIErrorMessage(\"Pick\", \"cannot handle this kind of transformation\"))\n      }\n    }\n  }\n  return new TypeLiteral(keys.map((key) => getPropertyKeyIndexedAccess(ast, key)), [])\n}\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Omit`.\n *\n * @since 1.0.0\n */\nexport const omit = (ast: AST, keys: ReadonlyArray<PropertyKey>): TypeLiteral | Transformation =>\n  pick(ast, getPropertyKeys(ast).filter((name) => !keys.includes(name)))\n\n/** @internal */\nexport const orUndefined = (ast: AST): AST => Union.make([ast, undefinedKeyword])\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Partial`.\n *\n * @since 1.0.0\n */\nexport const partial = (ast: AST, options?: { readonly exact: true }): AST => {\n  const exact = options?.exact === true\n  switch (ast._tag) {\n    case \"TupleType\":\n      return new TupleType(\n        ast.elements.map((e) => new Element(exact ? e.type : orUndefined(e.type), true)),\n        Arr.match(ast.rest, {\n          onEmpty: () => ast.rest,\n          onNonEmpty: (rest) => [Union.make([...rest, undefinedKeyword])]\n        }),\n        ast.isReadonly\n      )\n    case \"TypeLiteral\":\n      return new TypeLiteral(\n        ast.propertySignatures.map((ps) =>\n          new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)\n        ),\n        ast.indexSignatures.map((is) => new IndexSignature(is.parameter, orUndefined(is.type), is.isReadonly))\n      )\n    case \"Union\":\n      return Union.make(ast.types.map((member) => partial(member, options)))\n    case \"Suspend\":\n      return new Suspend(() => partial(ast.f(), options))\n    case \"Declaration\":\n      throw new Error(errors_.getAPIErrorMessage(\"partial\", \"cannot handle declarations\"))\n    case \"Refinement\":\n      throw new Error(errors_.getAPIErrorMessage(\"partial\", \"cannot handle refinements\"))\n    case \"Transformation\": {\n      if (\n        isTypeLiteralTransformation(ast.transformation) &&\n        ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)\n      ) {\n        return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation)\n      }\n      throw new Error(errors_.getAPIErrorMessage(\"partial\", \"cannot handle transformations\"))\n    }\n  }\n  return ast\n}\n\n/**\n * Equivalent at runtime to the built-in TypeScript utility type `Required`.\n *\n * @since 1.0.0\n */\nexport const required = (ast: AST): AST => {\n  switch (ast._tag) {\n    case \"TupleType\":\n      return new TupleType(\n        ast.elements.map((e) => new Element(e.type, false)),\n        ast.rest,\n        ast.isReadonly\n      )\n    case \"TypeLiteral\":\n      return new TypeLiteral(\n        ast.propertySignatures.map((f) => new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)),\n        ast.indexSignatures\n      )\n    case \"Union\":\n      return Union.make(ast.types.map((member) => required(member)))\n    case \"Suspend\":\n      return new Suspend(() => required(ast.f()))\n    case \"Declaration\":\n      throw new Error(errors_.getAPIErrorMessage(\"required\", \"cannot handle declarations\"))\n    case \"Refinement\":\n      throw new Error(errors_.getAPIErrorMessage(\"required\", \"cannot handle refinements\"))\n    case \"Transformation\": {\n      if (\n        isTypeLiteralTransformation(ast.transformation) &&\n        ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)\n      ) {\n        return new Transformation(required(ast.from), required(ast.to), ast.transformation)\n      }\n      throw new Error(errors_.getAPIErrorMessage(\"required\", \"cannot handle transformations\"))\n    }\n  }\n  return ast\n}\n\n/**\n * Creates a new AST with shallow mutability applied to its properties.\n *\n * @param ast - The original AST to make properties mutable (shallowly).\n *\n * @since 1.0.0\n */\nexport const mutable = (ast: AST): AST => {\n  switch (ast._tag) {\n    case \"TupleType\":\n      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations)\n    case \"TypeLiteral\": {\n      const propertySignatures = changeMap(\n        ast.propertySignatures,\n        (ps) =>\n          ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations)\n      )\n      const indexSignatures = changeMap(\n        ast.indexSignatures,\n        (is) => is.isReadonly === false ? is : new IndexSignature(is.parameter, is.type, false)\n      )\n      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ?\n        ast :\n        new TypeLiteral(propertySignatures, indexSignatures, ast.annotations)\n    }\n    case \"Union\": {\n      const types = changeMap(ast.types, mutable)\n      return types === ast.types ? ast : Union.make(types, ast.annotations)\n    }\n    case \"Suspend\":\n      return new Suspend(() => mutable(ast.f()), ast.annotations)\n    case \"Refinement\": {\n      const from = mutable(ast.from)\n      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations)\n    }\n    case \"Transformation\": {\n      const from = mutable(ast.from)\n      const to = mutable(ast.to)\n      return from === ast.from && to === ast.to ?\n        ast :\n        new Transformation(from, to, ast.transformation, ast.annotations)\n    }\n  }\n  return ast\n}\n\n// -------------------------------------------------------------------------------------\n// compiler harness\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n */\nexport type Compiler<A> = (ast: AST) => A\n\n/**\n * @since 1.0.0\n */\nexport type Match<A> = {\n  [K in AST[\"_tag\"]]: (ast: Extract<AST, { _tag: K }>, compile: Compiler<A>) => A\n}\n\n/**\n * @since 1.0.0\n */\nexport const getCompiler = <A>(match: Match<A>): Compiler<A> => {\n  const compile = (ast: AST): A => match[ast._tag](ast as any, compile)\n  return compile\n}\n\n/** @internal */\nexport const getToPropertySignatures = (ps: ReadonlyArray<PropertySignature>): Array<PropertySignature> =>\n  ps.map((p) => new PropertySignature(p.name, typeAST(p.type), p.isOptional, p.isReadonly, p.annotations))\n\n/** @internal */\nexport const getToIndexSignatures = (ps: ReadonlyArray<IndexSignature>): Array<IndexSignature> =>\n  ps.map((is) => new IndexSignature(is.parameter, typeAST(is.type), is.isReadonly))\n\n/**\n * @since 1.0.0\n */\nexport const typeAST = (ast: AST): AST => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const typeParameters = changeMap(ast.typeParameters, typeAST)\n      return typeParameters === ast.typeParameters ?\n        ast :\n        new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations)\n    }\n    case \"TupleType\": {\n      const elements = changeMap(ast.elements, (e) => {\n        const type = typeAST(e.type)\n        return type === e.type ? e : new Element(type, e.isOptional)\n      })\n      const rest = changeMap(ast.rest, typeAST)\n      return elements === ast.elements && rest === ast.rest ?\n        ast :\n        new TupleType(elements, rest, ast.isReadonly, ast.annotations)\n    }\n    case \"TypeLiteral\": {\n      const propertySignatures = changeMap(ast.propertySignatures, (p) => {\n        const type = typeAST(p.type)\n        return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly)\n      })\n      const indexSignatures = changeMap(ast.indexSignatures, (is) => {\n        const type = typeAST(is.type)\n        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly)\n      })\n      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ?\n        ast :\n        new TypeLiteral(propertySignatures, indexSignatures, ast.annotations)\n    }\n    case \"Union\": {\n      const types = changeMap(ast.types, typeAST)\n      return types === ast.types ? ast : Union.make(types, ast.annotations)\n    }\n    case \"Suspend\":\n      return new Suspend(() => typeAST(ast.f()), ast.annotations)\n    case \"Refinement\": {\n      const from = typeAST(ast.from)\n      return from === ast.from ?\n        ast :\n        new Refinement(from, ast.filter, ast.annotations)\n    }\n    case \"Transformation\":\n      return typeAST(ast.to)\n  }\n  return ast\n}\n\n/** @internal */\nexport const getJSONIdentifier = (annotated: Annotated) =>\n  Option.orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated))\n\nconst createJSONIdentifierAnnotation = (annotated: Annotated): Annotations | undefined =>\n  Option.match(getJSONIdentifier(annotated), {\n    onNone: () => undefined,\n    onSome: (identifier) => ({ [JSONIdentifierAnnotationId]: identifier })\n  })\n\nfunction changeMap<A>(\n  as: Arr.NonEmptyReadonlyArray<A>,\n  f: (a: A) => A\n): Arr.NonEmptyReadonlyArray<A>\nfunction changeMap<A>(as: ReadonlyArray<A>, f: (a: A) => A): ReadonlyArray<A>\nfunction changeMap<A>(as: ReadonlyArray<A>, f: (a: A) => A): ReadonlyArray<A> {\n  let changed = false\n  const out = Arr.allocate(as.length) as Array<A>\n  for (let i = 0; i < as.length; i++) {\n    const a = as[i]\n    const fa = f(a)\n    if (fa !== a) {\n      changed = true\n    }\n    out[i] = fa\n  }\n  return changed ? out : as\n}\n\n/**\n * @since 1.0.0\n */\nexport const encodedAST = (ast: AST): AST => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const typeParameters = changeMap(ast.typeParameters, encodedAST)\n      return typeParameters === ast.typeParameters ?\n        ast :\n        new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations)\n    }\n    case \"TupleType\": {\n      const elements = changeMap(ast.elements, (e) => {\n        const type = encodedAST(e.type)\n        return type === e.type ? e : new Element(type, e.isOptional)\n      })\n      const rest = changeMap(ast.rest, encodedAST)\n      return elements === ast.elements && rest === ast.rest ?\n        ast :\n        new TupleType(elements, rest, ast.isReadonly, createJSONIdentifierAnnotation(ast))\n    }\n    case \"TypeLiteral\": {\n      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {\n        const type = encodedAST(ps.type)\n        return type === ps.type\n          ? ps\n          : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly)\n      })\n      const indexSignatures = changeMap(ast.indexSignatures, (is) => {\n        const type = encodedAST(is.type)\n        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly)\n      })\n      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ?\n        ast :\n        new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast))\n    }\n    case \"Union\": {\n      const types = changeMap(ast.types, encodedAST)\n      return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast))\n    }\n    case \"Suspend\":\n      return new Suspend(() => encodedAST(ast.f()), createJSONIdentifierAnnotation(ast))\n    case \"Refinement\":\n    case \"Transformation\":\n      return encodedAST(ast.from)\n  }\n  return ast\n}\n\nconst toJSONAnnotations = (annotations: Annotations): object => {\n  const out: Record<string, unknown> = {}\n  for (const k of Object.getOwnPropertySymbols(annotations)) {\n    out[String(k)] = annotations[k]\n  }\n  return out\n}\n\n/**\n * @since 1.0.0\n */\nexport const hash = (ast: AST): number => Hash.string(JSON.stringify(ast, null, 2))\n\n/** @internal */\nexport const getCardinality = (ast: AST): number => {\n  switch (ast._tag) {\n    case \"NeverKeyword\":\n      return 0\n    case \"Literal\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"UniqueSymbol\":\n      return 1\n    case \"BooleanKeyword\":\n      return 2\n    case \"StringKeyword\":\n    case \"NumberKeyword\":\n    case \"BigIntKeyword\":\n    case \"SymbolKeyword\":\n      return 3\n    case \"ObjectKeyword\":\n      return 5\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return 6\n    default:\n      return 4\n  }\n}\n\nconst sortPropertySignatures = Arr.sort(\n  Order.mapInput(Number.Order, (ps: PropertySignature) => getCardinality(ps.type))\n)\n\nconst sortIndexSignatures = Arr.sort(\n  Order.mapInput(Number.Order, (is: IndexSignature) => {\n    switch (getParameterBase(is.parameter)._tag) {\n      case \"StringKeyword\":\n        return 2\n      case \"SymbolKeyword\":\n        return 3\n      case \"TemplateLiteral\":\n        return 1\n    }\n  })\n)\n\ntype Weight = readonly [number, number, number]\n\nconst WeightOrder: Order.Order<Weight> = Order.tuple<\n  readonly [Order.Order<number>, Order.Order<number>, Order.Order<number>]\n>(Number.Order, Number.Order, Number.Order)\n\nconst maxWeight = Order.max<Weight>(WeightOrder)\n\nconst emptyWeight: Weight = [0, 0, 0]\n\nconst maxWeightAll = (weights: ReadonlyArray<Weight>): Weight => weights.reduce(maxWeight, emptyWeight)\n\n/** @internal */\nexport const getWeight = (ast: AST): Weight => {\n  switch (ast._tag) {\n    case \"TupleType\": {\n      return [2, ast.elements.length, ast.rest.length]\n    }\n    case \"TypeLiteral\": {\n      const y = ast.propertySignatures.length\n      const z = ast.indexSignatures.length\n      return y + z === 0 ?\n        [-4, 0, 0] :\n        [4, y, z]\n    }\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        const [_, y, z] = getWeight(annotation.value)\n        return [6, y, z]\n      }\n      return [6, 0, 0]\n    }\n    case \"Suspend\":\n      return [8, 0, 0]\n    case \"Union\":\n      return maxWeightAll(ast.types.map(getWeight))\n    case \"Refinement\": {\n      const [x, y, z] = getWeight(ast.from)\n      return [x + 1, y, z]\n    }\n    case \"Transformation\":\n      return getWeight(ast.from)\n    case \"ObjectKeyword\":\n      return [-2, 0, 0]\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return [-4, 0, 0]\n    default:\n      return emptyWeight\n  }\n}\n\n/** @internal */\nexport const getParameterBase = (\n  ast: Parameter\n): StringKeyword | SymbolKeyword | TemplateLiteral => {\n  switch (ast._tag) {\n    case \"StringKeyword\":\n    case \"SymbolKeyword\":\n    case \"TemplateLiteral\":\n      return ast\n    case \"Refinement\":\n      return getParameterBase(ast.from)\n  }\n}\n\nconst equalsTemplateLiteralSpan = Arr.getEquivalence<TemplateLiteralSpan>((self, that) =>\n  self.type._tag === that.type._tag && self.literal === that.literal\n)\n\nconst equalsEnums = Arr.getEquivalence<readonly [string, string | number]>((self, that) =>\n  that[0] === self[0] && that[1] === self[1]\n)\n\nconst equals = (self: AST, that: AST) => {\n  switch (self._tag) {\n    case \"Literal\":\n      return isLiteral(that) && that.literal === self.literal\n    case \"UniqueSymbol\":\n      return isUniqueSymbol(that) && that.symbol === self.symbol\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"NeverKeyword\":\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n    case \"StringKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"SymbolKeyword\":\n    case \"ObjectKeyword\":\n      return that._tag === self._tag\n    case \"TemplateLiteral\":\n      return isTemplateLiteral(that) && that.head === self.head && equalsTemplateLiteralSpan(that.spans, self.spans)\n    case \"Enums\":\n      return isEnums(that) && equalsEnums(that.enums, self.enums)\n    case \"Refinement\":\n    case \"TupleType\":\n    case \"TypeLiteral\":\n    case \"Union\":\n    case \"Suspend\":\n    case \"Transformation\":\n    case \"Declaration\":\n      return self === that\n  }\n}\n\nconst intersection = Arr.intersectionWith(equals)\n\nconst _keyof = (ast: AST): Array<AST> => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return _keyof(annotation.value)\n      }\n      break\n    }\n    case \"TypeLiteral\":\n      return ast.propertySignatures.map((p): AST =>\n        Predicate.isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)\n      ).concat(ast.indexSignatures.map((is) => getParameterBase(is.parameter)))\n    case \"Suspend\":\n      return _keyof(ast.f())\n    case \"Union\":\n      return ast.types.slice(1).reduce(\n        (out: Array<AST>, ast) => intersection(out, _keyof(ast)),\n        _keyof(ast.types[0])\n      )\n    case \"Transformation\":\n      return _keyof(ast.to)\n  }\n  throw new Error(errors_.getAPIErrorMessage(\"KeyOf\", `unsupported schema (${ast})`))\n}\n\n/** @internal */\nexport const compose = (ab: AST, cd: AST): AST => new Transformation(ab, cd, composeTransformation)\n\n/** @internal */\nexport const rename = (ast: AST, mapping: { readonly [K in PropertyKey]?: PropertyKey }): AST => {\n  switch (ast._tag) {\n    case \"TypeLiteral\": {\n      const propertySignatureTransformations: Array<PropertySignatureTransformation> = []\n      for (const key of util_.ownKeys(mapping)) {\n        const name = mapping[key]\n        if (name !== undefined) {\n          propertySignatureTransformations.push(\n            new PropertySignatureTransformation(\n              key,\n              name,\n              identity,\n              identity\n            )\n          )\n        }\n      }\n      if (propertySignatureTransformations.length === 0) {\n        return ast\n      }\n      return new Transformation(\n        ast,\n        new TypeLiteral(\n          ast.propertySignatures.map((ps) => {\n            const name = mapping[ps.name]\n            return new PropertySignature(\n              name === undefined ? ps.name : name,\n              typeAST(ps.type),\n              ps.isOptional,\n              ps.isReadonly,\n              ps.annotations\n            )\n          }),\n          ast.indexSignatures\n        ),\n        new TypeLiteralTransformation(propertySignatureTransformations)\n      )\n    }\n    case \"Suspend\":\n      return new Suspend(() => rename(ast.f(), mapping))\n    case \"Transformation\":\n      return compose(ast, rename(typeAST(ast), mapping))\n  }\n  throw new Error(`rename: cannot rename (${ast})`)\n}\n\nconst formatKeyword = (ast: AST, verbose: boolean = false): string =>\n  Option.getOrElse(getExpected(ast, verbose), () => ast._tag)\n\nconst getExpected = (ast: AST, verbose: boolean): Option.Option<string> => {\n  if (verbose) {\n    const description = getDescriptionAnnotation(ast).pipe(\n      Option.orElse(() => getTitleAnnotation(ast))\n    )\n    return Option.match(getIdentifierAnnotation(ast), {\n      onNone: () => description,\n      onSome: (identifier) =>\n        Option.match(description, {\n          onNone: () => Option.some(identifier),\n          onSome: (description) => Option.some(`${identifier} (${description})`)\n        })\n    })\n  } else {\n    return getIdentifierAnnotation(ast).pipe(\n      Option.orElse(() => getTitleAnnotation(ast)),\n      Option.orElse(() => getDescriptionAnnotation(ast))\n    )\n  }\n}\n"],"names":["Arr","dual","identity","globalValue","Hash","Number","Option","Order","Predicate","regexp","errors_","util_","BrandAnnotationId","Symbol","for","TypeAnnotationId","MessageAnnotationId","IdentifierAnnotationId","TitleAnnotationId","DescriptionAnnotationId","ExamplesAnnotationId","DefaultAnnotationId","JSONSchemaAnnotationId","DocumentationAnnotationId","ConcurrencyAnnotationId","BatchingAnnotationId","SurrogateAnnotationId","ParseIssueTitleAnnotationId","getAnnotation","annotated","key","Object","prototype","hasOwnProperty","call","annotations","some","none","getBrandAnnotation","getMessageAnnotation","getTitleAnnotation","getIdentifierAnnotation","getDescriptionAnnotation","getExamplesAnnotation","getDefaultAnnotation","getJSONSchemaAnnotation","getDocumentationAnnotation","getConcurrencyAnnotation","getBatchingAnnotation","getParseIssueTitleAnnotation","getSurrogateAnnotation","JSONIdentifierAnnotationId","getJSONIdentifierAnnotation","Declaration","typeParameters","decodeUnknown","encodeUnknown","_tag","constructor","toString","verbose","getOrElse","getExpected","toJSON","map","ast","toJSONAnnotations","createASTGuard","tag","isDeclaration","Literal","literal","formatUnknown","isBigInt","String","isLiteral","$null","null","UniqueSymbol","symbol","isUniqueSymbol","UndefinedKeyword","formatKeyword","undefinedKeyword","isUndefinedKeyword","VoidKeyword","voidKeyword","isVoidKeyword","NeverKeyword","neverKeyword","isNeverKeyword","UnknownKeyword","unknownKeyword","isUnknownKeyword","AnyKeyword","anyKeyword","isAnyKeyword","StringKeyword","stringKeyword","isStringKeyword","NumberKeyword","numberKeyword","isNumberKeyword","BooleanKeyword","booleanKeyword","isBooleanKeyword","BigIntKeyword","bigIntKeyword","isBigIntKeyword","SymbolKeyword","symbolKeyword","isSymbolKeyword","ObjectKeyword","objectKeyword","isObjectKeyword","Enums","enums","length","_","value","JSON","stringify","join","isEnums","TemplateLiteralSpan","type","TemplateLiteral","head","spans","make","isNonEmptyReadonlyArray","formatTemplateLiteral","span","isTemplateLiteral","Element","isOptional","TupleType","elements","rest","isReadonly","hasOptionalElement","hasIllegalRequiredElement","e","Error","getRequiredElementFollowinAnOptionalElementErrorMessage","formatTuple","formattedElements","matchLeft","onEmpty","onNonEmpty","tail","formattedHead","wrappedHead","includes","formattedTail","isTupleType","PropertySignature","name","isParameter","from","IndexSignature","parameter","getIndexSignatureParameterErrorMessage","TypeLiteral","propertySignatures","indexSignatures","keys","i","getDuplicatePropertySignatureErrorMessage","parameters","string","getParameterBase","getDuplicateIndexSignatureErrorMessage","sortPropertySignatures","sortIndexSignatures","formatTypeLiteral","ps","formattedPropertySignatures","formattedIndexSignatures","is","isTypeLiteral","removeNevers","candidates","filter","sortCandidates","sort","mapInput","literalMap","number","boolean","bigint","flatten","flatMap","isUnion","types","unify","cs","out","uniques","literals","push","Union","memo","Set","has","add","union","members","isMembers","mapMembers","f","as","toJSONMemoMap","WeakMap","Suspend","memoizeThunk","pipe","orElse","liftThrowable","get","set","isSuspend","Refinement","isRefinement","defaultParseOption","Transformation","to","transformation","isTransformation","FinalTransformation","decode","encode","createTransformationGuard","isFinalTransformation","ComposeTransformation","composeTransformation","isComposeTransformation","PropertySignatureTransformation","isRenamingPropertySignatureTransformation","t","TypeLiteralTransformation","propertySignatureTransformations","fromKeys","toKeys","pst","getDuplicatePropertySignatureTransformationErrorMessage","isTypeLiteralTransformation","d","getOwnPropertyDescriptors","create","getPrototypeOf","keyof","_keyof","STRING_KEYWORD_PATTERN","NUMBER_KEYWORD_PATTERN","getTemplateLiteralRegExp","pattern","escape","RegExp","getPropertySignatures","annotation","isSome","slice","getPropertyKeys","getPropertyKeyIndexedAccess","getNumberIndexedAccess","hasOptional","concat","getAPIErrorMessage","ops","findFirst","isString","parameterBase","regex","test","isSymbol","reduce","intersection","record","go","isNumber","forEach","pick","ts","k","find","omit","orUndefined","partial","options","exact","match","member","every","required","mutable","changeMap","getCompiler","compile","getToPropertySignatures","p","typeAST","getToIndexSignatures","getJSONIdentifier","createJSONIdentifierAnnotation","onNone","undefined","onSome","identifier","changed","allocate","a","fa","encodedAST","getOwnPropertySymbols","hash","getCardinality","WeightOrder","tuple","maxWeight","max","emptyWeight","maxWeightAll","weights","getWeight","y","z","x","equalsTemplateLiteralSpan","getEquivalence","self","that","equalsEnums","equals","intersectionWith","compose","ab","cd","rename","mapping","ownKeys","description"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 10615, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/FastCheck.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/FastCheck.ts"],"sourcesContent":["/**\n * @since 1.0.0\n */\n\n/**\n * @category re-exports\n * @since 1.0.0\n */\nexport * from \"fast-check\"\n"],"names":[],"mappings":"AAAA;;IAIA;;;;AAIA,cAAc,YAAY","ignoreList":[]}},
    {"offset": {"line": 10891, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/internal/filters.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/internal/filters.ts"],"sourcesContent":["import type * as Schema from \"../Schema.js\"\n\n/** @internal */\nexport const GreaterThanTypeId: Schema.GreaterThanTypeId = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThan\"\n) as Schema.GreaterThanTypeId\n\n/** @internal */\nexport const GreaterThanOrEqualToTypeId: Schema.GreaterThanOrEqualToTypeId = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanOrEqualTo\"\n) as Schema.GreaterThanOrEqualToTypeId\n\n/** @internal */\nexport const LessThanTypeId: Schema.LessThanTypeId = Symbol.for(\n  \"@effect/schema/TypeId/LessThan\"\n) as Schema.LessThanTypeId\n\n/** @internal */\nexport const LessThanOrEqualToTypeId: Schema.LessThanOrEqualToTypeId = Symbol.for(\n  \"@effect/schema/TypeId/LessThanOrEqualTo\"\n) as Schema.LessThanOrEqualToTypeId\n\n/** @internal */\nexport const IntTypeId: Schema.IntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/Int\"\n) as Schema.IntTypeId\n\n/** @internal */\nexport const BetweenTypeId: Schema.BetweenTypeId = Symbol.for(\n  \"@effect/schema/TypeId/Between\"\n) as Schema.BetweenTypeId\n\n/** @internal */\nexport const GreaterThanBigintTypeId: Schema.GreaterThanBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanBigint\"\n) as Schema.GreaterThanBigIntTypeId\n\n/** @internal */\nexport const GreaterThanOrEqualToBigIntTypeId: Schema.GreaterThanOrEqualToBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanOrEqualToBigint\"\n) as Schema.GreaterThanOrEqualToBigIntTypeId\n\n/** @internal */\nexport const LessThanBigIntTypeId: Schema.LessThanBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/LessThanBigint\"\n) as Schema.LessThanBigIntTypeId\n\n/** @internal */\nexport const LessThanOrEqualToBigIntTypeId: Schema.LessThanOrEqualToBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/LessThanOrEqualToBigint\"\n) as Schema.LessThanOrEqualToBigIntTypeId\n\n/** @internal */\nexport const BetweenBigintTypeId: Schema.BetweenBigIntTypeId = Symbol.for(\n  \"@effect/schema/TypeId/BetweenBigint\"\n) as Schema.BetweenBigIntTypeId\n\n/** @internal */\nexport const MinLengthTypeId: Schema.MinLengthTypeId = Symbol.for(\n  \"@effect/schema/TypeId/MinLength\"\n) as Schema.MinLengthTypeId\n\n/** @internal */\nexport const MaxLengthTypeId: Schema.MaxLengthTypeId = Symbol.for(\n  \"@effect/schema/TypeId/MaxLength\"\n) as Schema.MaxLengthTypeId\n\n/** @internal */\nexport const LengthTypeId: Schema.LengthTypeId = Symbol.for(\n  \"@effect/schema/TypeId/Length\"\n) as Schema.LengthTypeId\n\n/** @internal */\nexport const MinItemsTypeId: Schema.MinItemsTypeId = Symbol.for(\n  \"@effect/schema/TypeId/MinItems\"\n) as Schema.MinItemsTypeId\n\n/** @internal */\nexport const MaxItemsTypeId: Schema.MaxItemsTypeId = Symbol.for(\n  \"@effect/schema/TypeId/MaxItems\"\n) as Schema.MaxItemsTypeId\n\n/** @internal */\nexport const ItemsCountTypeId: Schema.ItemsCountTypeId = Symbol.for(\n  \"@effect/schema/TypeId/ItemsCount\"\n) as Schema.ItemsCountTypeId\n"],"names":["GreaterThanTypeId","Symbol","for","GreaterThanOrEqualToTypeId","LessThanTypeId","LessThanOrEqualToTypeId","IntTypeId","BetweenTypeId","GreaterThanBigintTypeId","GreaterThanOrEqualToBigIntTypeId","LessThanBigIntTypeId","LessThanOrEqualToBigIntTypeId","BetweenBigintTypeId","MinLengthTypeId","MaxLengthTypeId","LengthTypeId","MinItemsTypeId","MaxItemsTypeId","ItemsCountTypeId"],"mappings":"AAEA,cAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACO,MAAMA,iBAAiB,GAAA,WAAA,GAA6BC,MAAM,CAACC,GAAG,CACnE,mCAAmC,CACR;AAGtB,MAAMC,0BAA0B,GAAA,WAAA,GAAsCF,MAAM,CAACC,GAAG,CACrF,4CAA4C,CACR;AAG/B,MAAME,cAAc,GAAA,WAAA,GAA0BH,MAAM,CAACC,GAAG,CAC7D,gCAAgC,CACR;AAGnB,MAAMG,uBAAuB,GAAA,WAAA,GAAmCJ,MAAM,CAACC,GAAG,CAC/E,yCAAyC,CACR;AAG5B,MAAMI,SAAS,GAAA,WAAA,GAAqBL,MAAM,CAACC,GAAG,CACnD,2BAA2B,CACR;AAGd,MAAMK,aAAa,GAAA,WAAA,GAAyBN,MAAM,CAACC,GAAG,CAC3D,+BAA+B,CACR;AAGlB,MAAMM,uBAAuB,GAAA,WAAA,GAAmCP,MAAM,CAACC,GAAG,CAC/E,yCAAyC,CACR;AAG5B,MAAMO,gCAAgC,GAAA,WAAA,GAA4CR,MAAM,CAACC,GAAG,CACjG,kDAAkD,CACR;AAGrC,MAAMQ,oBAAoB,GAAA,WAAA,GAAgCT,MAAM,CAACC,GAAG,CACzE,sCAAsC,CACR;AAGzB,MAAMS,6BAA6B,GAAA,WAAA,GAAyCV,MAAM,CAACC,GAAG,CAC3F,+CAA+C,CACR;AAGlC,MAAMU,mBAAmB,GAAA,WAAA,GAA+BX,MAAM,CAACC,GAAG,CACvE,qCAAqC,CACR;AAGxB,MAAMW,eAAe,GAAA,WAAA,GAA2BZ,MAAM,CAACC,GAAG,CAC/D,iCAAiC,CACR;AAGpB,MAAMY,eAAe,GAAA,WAAA,GAA2Bb,MAAM,CAACC,GAAG,CAC/D,iCAAiC,CACR;AAGpB,MAAMa,YAAY,GAAA,WAAA,GAAwBd,MAAM,CAACC,GAAG,CACzD,8BAA8B,CACR;AAGjB,MAAMc,cAAc,GAAA,WAAA,GAA0Bf,MAAM,CAACC,GAAG,CAC7D,gCAAgC,CACR;AAGnB,MAAMe,cAAc,GAAA,WAAA,GAA0BhB,MAAM,CAACC,GAAG,CAC7D,gCAAgC,CACR;AAGnB,MAAMgB,gBAAgB,GAAA,WAAA,GAA4BjB,MAAM,CAACC,GAAG,CACjE,kCAAkC,CACR","ignoreList":[]}},
    {"offset": {"line": 10948, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/Arbitrary.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/Arbitrary.ts"],"sourcesContent":["/**\n * @since 1.0.0\n */\n\nimport * as Arr from \"effect/Array\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as AST from \"./AST.js\"\nimport * as FastCheck from \"./FastCheck.js\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as filters_ from \"./internal/filters.js\"\nimport * as util_ from \"./internal/util.js\"\nimport type * as Schema from \"./Schema.js\"\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface LazyArbitrary<A> {\n  (fc: typeof FastCheck): FastCheck.Arbitrary<A>\n}\n\n/**\n * @category hooks\n * @since 1.0.0\n */\nexport const ArbitraryHookId: unique symbol = Symbol.for(\"@effect/schema/ArbitraryHookId\")\n\n/**\n * @category hooks\n * @since 1.0.0\n */\nexport type ArbitraryHookId = typeof ArbitraryHookId\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const arbitrary =\n  <A>(handler: (...args: ReadonlyArray<LazyArbitrary<any>>) => LazyArbitrary<A>) =>\n  <I, R>(self: Schema.Schema<A, I, R>): Schema.Schema<A, I, R> => self.annotations({ [ArbitraryHookId]: handler })\n\n/**\n * Returns a LazyArbitrary for the `A` type of the provided schema.\n *\n * @category arbitrary\n * @since 1.0.0\n */\nexport const makeLazy = <A, I, R>(schema: Schema.Schema<A, I, R>): LazyArbitrary<A> => go(schema.ast, {})\n\n/**\n * Returns a fast-check Arbitrary for the `A` type of the provided schema.\n *\n * @category arbitrary\n * @since 1.0.0\n */\nexport const make = <A, I, R>(schema: Schema.Schema<A, I, R>): FastCheck.Arbitrary<A> => makeLazy(schema)(FastCheck)\n\nconst depthSize = 1\n\nconst record = <K extends PropertyKey, V>(\n  fc: typeof FastCheck,\n  key: FastCheck.Arbitrary<K>,\n  value: FastCheck.Arbitrary<V>,\n  options: Options\n): FastCheck.Arbitrary<{ readonly [k in K]: V }> => {\n  return (options.isSuspend ?\n    fc.oneof(\n      { depthSize },\n      fc.constant([]),\n      fc.array(fc.tuple(key, value), { minLength: 1, maxLength: 2 })\n    ) :\n    fc.array(fc.tuple(key, value))).map((tuples) => {\n      const out: { [k in K]: V } = {} as any\n      for (const [k, v] of tuples) {\n        out[k] = v\n      }\n      return out\n    })\n}\n\nconst getHook = AST.getAnnotation<\n  (...args: ReadonlyArray<LazyArbitrary<any>>) => LazyArbitrary<any>\n>(ArbitraryHookId)\n\ntype Options = {\n  readonly constraints?: Constraints\n  readonly isSuspend?: boolean\n}\n\nconst getRefinementFromArbitrary = (ast: AST.Refinement, options: Options) => {\n  const constraints = combineConstraints(options.constraints, getConstraints(ast))\n  return go(ast.from, constraints ? { ...options, constraints } : options)\n}\n\nconst go = (ast: AST.AST, options: Options): LazyArbitrary<any> => {\n  const hook = getHook(ast)\n  if (Option.isSome(hook)) {\n    switch (ast._tag) {\n      case \"Declaration\":\n        return hook.value(...ast.typeParameters.map((p) => go(p, options)))\n      case \"Refinement\":\n        return hook.value(getRefinementFromArbitrary(ast, options))\n      default:\n        return hook.value()\n    }\n  }\n  switch (ast._tag) {\n    case \"Declaration\": {\n      throw new Error(errors_.getArbitraryErrorMessage(`a declaration without annotations (${ast})`))\n    }\n    case \"Literal\":\n      return (fc) => fc.constant(ast.literal)\n    case \"UniqueSymbol\":\n      return (fc) => fc.constant(ast.symbol)\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n      return (fc) => fc.constant(undefined)\n    case \"NeverKeyword\":\n      return () => {\n        throw new Error(errors_.getArbitraryErrorMessage(\"`never`\"))\n      }\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return (fc) => fc.anything()\n    case \"StringKeyword\":\n      return (fc) => {\n        if (options.constraints) {\n          switch (options.constraints._tag) {\n            case \"StringConstraints\":\n              return fc.string(options.constraints.constraints)\n          }\n        }\n        return fc.string()\n      }\n    case \"NumberKeyword\":\n      return (fc) => {\n        if (options.constraints) {\n          switch (options.constraints._tag) {\n            case \"NumberConstraints\":\n              return fc.float(options.constraints.constraints)\n            case \"IntegerConstraints\":\n              return fc.integer(options.constraints.constraints)\n          }\n        }\n        return fc.float()\n      }\n    case \"BooleanKeyword\":\n      return (fc) => fc.boolean()\n    case \"BigIntKeyword\":\n      return (fc) => {\n        if (options.constraints) {\n          switch (options.constraints._tag) {\n            case \"BigIntConstraints\":\n              return fc.bigInt(options.constraints.constraints)\n          }\n        }\n        return fc.bigInt()\n      }\n    case \"SymbolKeyword\":\n      return (fc) => fc.string().map((s) => Symbol.for(s))\n    case \"ObjectKeyword\":\n      return (fc) => fc.oneof(fc.object(), fc.array(fc.anything()))\n    case \"TemplateLiteral\": {\n      return (fc) => {\n        const string = fc.string({ maxLength: 5 })\n        const number = fc.float({ noDefaultInfinity: true }).filter((n) => !Number.isNaN(n))\n        const components: Array<FastCheck.Arbitrary<string | number>> = [fc.constant(ast.head)]\n        for (const span of ast.spans) {\n          if (AST.isStringKeyword(span.type)) {\n            components.push(string)\n          } else {\n            components.push(number)\n          }\n          components.push(fc.constant(span.literal))\n        }\n        return fc.tuple(...components).map((spans) => spans.join(\"\"))\n      }\n    }\n    case \"TupleType\": {\n      const elements: Array<LazyArbitrary<any>> = []\n      let hasOptionals = false\n      for (const element of ast.elements) {\n        elements.push(go(element.type, options))\n        if (element.isOptional) {\n          hasOptionals = true\n        }\n      }\n      const rest = ast.rest.map((e) => go(e, options))\n      return (fc) => {\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        let output = fc.tuple(...elements.map((arb) => arb(fc)))\n        if (hasOptionals) {\n          const indexes = fc.tuple(\n            ...ast.elements.map((element) => element.isOptional ? fc.boolean() : fc.constant(true))\n          )\n          output = output.chain((tuple) =>\n            indexes.map((booleans) => {\n              for (const [i, b] of booleans.reverse().entries()) {\n                if (!b) {\n                  tuple.splice(booleans.length - i, 1)\n                }\n              }\n              return tuple\n            })\n          )\n        }\n\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (Arr.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          const arb = head(fc)\n          const constraints = options.constraints\n          output = output.chain((as) => {\n            let out = fc.array(arb)\n            if (options.isSuspend) {\n              out = fc.oneof(\n                { depthSize },\n                fc.constant([]),\n                fc.array(arb, { minLength: 1, maxLength: 2 })\n              )\n            } else if (constraints && constraints._tag === \"ArrayConstraints\") {\n              out = fc.array(arb, constraints.constraints)\n            }\n            return out.map((rest) => [...as, ...rest])\n          })\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            output = output.chain((as) => tail[j](fc).map((a) => [...as, a]))\n          }\n        }\n\n        return output\n      }\n    }\n    case \"TypeLiteral\": {\n      const propertySignaturesTypes = ast.propertySignatures.map((f) => go(f.type, options))\n      const indexSignatures = ast.indexSignatures.map((is) =>\n        [go(is.parameter, options), go(is.type, options)] as const\n      )\n      return (fc) => {\n        const arbs: any = {}\n        const requiredKeys: Array<PropertyKey> = []\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < propertySignaturesTypes.length; i++) {\n          const ps = ast.propertySignatures[i]\n          const name = ps.name\n          if (!ps.isOptional) {\n            requiredKeys.push(name)\n          }\n          arbs[name] = propertySignaturesTypes[i](fc)\n        }\n        let output = fc.record<any, any>(arbs, { requiredKeys })\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const parameter = indexSignatures[i][0](fc)\n          const type = indexSignatures[i][1](fc)\n          output = output.chain((o) => {\n            return record(fc, parameter, type, options).map((d) => ({ ...d, ...o }))\n          })\n        }\n\n        return output\n      }\n    }\n    case \"Union\": {\n      const types = ast.types.map((t) => go(t, options))\n      return (fc) => fc.oneof({ depthSize }, ...types.map((arb) => arb(fc)))\n    }\n    case \"Enums\": {\n      if (ast.enums.length === 0) {\n        throw new Error(errors_.getArbitraryErrorMessage(\"an empty enum\"))\n      }\n      return (fc) => fc.oneof(...ast.enums.map(([_, value]) => fc.constant(value)))\n    }\n    case \"Refinement\": {\n      const from = getRefinementFromArbitrary(ast, options)\n      return (fc) => from(fc).filter((a) => Option.isNone(ast.filter(a, AST.defaultParseOption, ast)))\n    }\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => go(ast.f(), { ...options, isSuspend: true }))\n      return (fc) => fc.constant(null).chain(() => get()(fc))\n    }\n    case \"Transformation\":\n      return go(ast.to, options)\n  }\n}\n\n/** @internal */\nexport class NumberConstraints {\n  readonly _tag = \"NumberConstraints\"\n  readonly constraints: FastCheck.FloatConstraints\n  constructor(options: {\n    readonly min?: number | undefined\n    readonly max?: number | undefined\n    readonly noNaN?: boolean | undefined\n    readonly noDefaultInfinity?: boolean | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isNumber(options.min)) {\n      this.constraints.min = Math.fround(options.min)\n    }\n    if (Predicate.isNumber(options.max)) {\n      this.constraints.max = Math.fround(options.max)\n    }\n    if (Predicate.isBoolean(options.noNaN)) {\n      this.constraints.noNaN = options.noNaN\n    }\n    if (Predicate.isBoolean(options.noDefaultInfinity)) {\n      this.constraints.noDefaultInfinity = options.noDefaultInfinity\n    }\n  }\n}\n\n/** @internal */\nexport class StringConstraints {\n  readonly _tag = \"StringConstraints\"\n  readonly constraints: FastCheck.StringSharedConstraints\n  constructor(options: {\n    readonly minLength?: number | undefined\n    readonly maxLength?: number | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isNumber(options.minLength)) {\n      this.constraints.minLength = options.minLength\n    }\n    if (Predicate.isNumber(options.maxLength)) {\n      this.constraints.maxLength = options.maxLength\n    }\n  }\n}\n\n/** @internal */\nexport class IntegerConstraints {\n  readonly _tag = \"IntegerConstraints\"\n  readonly constraints: FastCheck.IntegerConstraints\n  constructor(options: {\n    readonly min?: number | undefined\n    readonly max?: number | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isNumber(options.min)) {\n      this.constraints.min = options.min\n    }\n    if (Predicate.isNumber(options.max)) {\n      this.constraints.max = options.max\n    }\n  }\n}\n\n/** @internal */\nexport class ArrayConstraints {\n  readonly _tag = \"ArrayConstraints\"\n  readonly constraints: FastCheck.ArrayConstraints\n  constructor(options: {\n    readonly minLength?: number | undefined\n    readonly maxLength?: number | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isNumber(options.minLength)) {\n      this.constraints.minLength = options.minLength\n    }\n    if (Predicate.isNumber(options.maxLength)) {\n      this.constraints.maxLength = options.maxLength\n    }\n  }\n}\n\n/** @internal */\nexport class BigIntConstraints {\n  readonly _tag = \"BigIntConstraints\"\n  readonly constraints: FastCheck.BigIntConstraints\n  constructor(options: {\n    readonly min?: bigint | undefined\n    readonly max?: bigint | undefined\n  }) {\n    this.constraints = {}\n    if (Predicate.isBigInt(options.min)) {\n      this.constraints.min = options.min\n    }\n    if (Predicate.isBigInt(options.max)) {\n      this.constraints.max = options.max\n    }\n  }\n}\n\n/** @internal */\nexport type Constraints =\n  | NumberConstraints\n  | StringConstraints\n  | IntegerConstraints\n  | ArrayConstraints\n  | BigIntConstraints\n\n/** @internal */\nexport const getConstraints = (ast: AST.Refinement): Constraints | undefined => {\n  const TypeAnnotationId = ast.annotations[AST.TypeAnnotationId]\n  const jsonSchema: any = ast.annotations[AST.JSONSchemaAnnotationId]\n  switch (TypeAnnotationId) {\n    // int\n    case filters_.IntTypeId:\n      return new IntegerConstraints({})\n    // number\n    case filters_.GreaterThanTypeId:\n    case filters_.GreaterThanOrEqualToTypeId:\n    case filters_.LessThanTypeId:\n    case filters_.LessThanOrEqualToTypeId:\n    case filters_.BetweenTypeId:\n      return new NumberConstraints({\n        min: jsonSchema.exclusiveMinimum ?? jsonSchema.minimum,\n        max: jsonSchema.exclusiveMaximum ?? jsonSchema.maximum\n      })\n    // bigint\n    case filters_.GreaterThanBigintTypeId:\n    case filters_.GreaterThanOrEqualToBigIntTypeId:\n    case filters_.LessThanBigIntTypeId:\n    case filters_.LessThanOrEqualToBigIntTypeId:\n    case filters_.BetweenBigintTypeId: {\n      const constraints: any = ast.annotations[TypeAnnotationId]\n      return new BigIntConstraints(constraints)\n    }\n    // string\n    case filters_.MinLengthTypeId:\n    case filters_.MaxLengthTypeId:\n    case filters_.LengthTypeId:\n      return new StringConstraints(jsonSchema)\n    // array\n    case filters_.MinItemsTypeId:\n    case filters_.MaxItemsTypeId:\n    case filters_.ItemsCountTypeId:\n      return new ArrayConstraints({\n        minLength: jsonSchema.minItems,\n        maxLength: jsonSchema.maxItems\n      })\n  }\n}\n\n/** @internal */\nexport const combineConstraints = (\n  c1: Constraints | undefined,\n  c2: Constraints | undefined\n): Constraints | undefined => {\n  if (c1 === undefined) {\n    return c2\n  }\n  if (c2 === undefined) {\n    return c1\n  }\n  switch (c1._tag) {\n    case \"ArrayConstraints\": {\n      switch (c2._tag) {\n        case \"ArrayConstraints\":\n          return new ArrayConstraints({\n            minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),\n            maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength)\n          })\n      }\n      break\n    }\n    case \"NumberConstraints\": {\n      switch (c2._tag) {\n        case \"NumberConstraints\":\n          return new NumberConstraints({\n            min: getMax(c1.constraints.min, c2.constraints.min),\n            max: getMin(c1.constraints.max, c2.constraints.max),\n            noNaN: getOr(c1.constraints.noNaN, c2.constraints.noNaN),\n            noDefaultInfinity: getOr(c1.constraints.noDefaultInfinity, c2.constraints.noDefaultInfinity)\n          })\n        case \"IntegerConstraints\":\n          return new IntegerConstraints({\n            min: getMax(c1.constraints.min, c2.constraints.min),\n            max: getMin(c1.constraints.max, c2.constraints.max)\n          })\n      }\n      break\n    }\n    case \"BigIntConstraints\": {\n      switch (c2._tag) {\n        case \"BigIntConstraints\":\n          return new BigIntConstraints({\n            min: getMax(c1.constraints.min, c2.constraints.min),\n            max: getMin(c1.constraints.max, c2.constraints.max)\n          })\n      }\n      break\n    }\n    case \"StringConstraints\": {\n      switch (c2._tag) {\n        case \"StringConstraints\":\n          return new StringConstraints({\n            minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),\n            maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength)\n          })\n      }\n      break\n    }\n    case \"IntegerConstraints\": {\n      switch (c2._tag) {\n        case \"NumberConstraints\":\n        case \"IntegerConstraints\": {\n          return new IntegerConstraints({\n            min: getMax(c1.constraints.min, c2.constraints.min),\n            max: getMin(c1.constraints.max, c2.constraints.max)\n          })\n        }\n      }\n      break\n    }\n  }\n}\n\nconst getOr = (a: boolean | undefined, b: boolean | undefined): boolean | undefined => {\n  return a === undefined ? b : b === undefined ? a : a || b\n}\n\nfunction getMax(n1: bigint | undefined, n2: bigint | undefined): bigint | undefined\nfunction getMax(n1: number | undefined, n2: number | undefined): number | undefined\nfunction getMax(\n  n1: bigint | number | undefined,\n  n2: bigint | number | undefined\n): bigint | number | undefined {\n  return n1 === undefined ? n2 : n2 === undefined ? n1 : n1 <= n2 ? n2 : n1\n}\n\nfunction getMin(n1: bigint | undefined, n2: bigint | undefined): bigint | undefined\nfunction getMin(n1: number | undefined, n2: number | undefined): number | undefined\nfunction getMin(\n  n1: bigint | number | undefined,\n  n2: bigint | number | undefined\n): bigint | number | undefined {\n  return n1 === undefined ? n2 : n2 === undefined ? n1 : n1 <= n2 ? n1 : n2\n}\n"],"names":["Arr","Option","Predicate","AST","FastCheck","errors_","filters_","util_","ArbitraryHookId","Symbol","for","arbitrary","handler","self","annotations","makeLazy","schema","go","ast","make","depthSize","record","fc","key","value","options","isSuspend","oneof","constant","array","tuple","minLength","maxLength","map","tuples","out","k","v","getHook","getAnnotation","getRefinementFromArbitrary","constraints","combineConstraints","getConstraints","from","hook","isSome","_tag","typeParameters","p","Error","getArbitraryErrorMessage","literal","symbol","undefined","anything","string","float","integer","boolean","bigInt","s","object","number","noDefaultInfinity","filter","n","Number","isNaN","components","head","span","spans","isStringKeyword","type","push","join","elements","hasOptionals","element","isOptional","rest","e","output","arb","indexes","chain","booleans","i","b","reverse","entries","splice","length","isNonEmptyReadonlyArray","tail","as","j","a","propertySignaturesTypes","propertySignatures","f","indexSignatures","is","parameter","arbs","requiredKeys","ps","name","o","d","types","t","enums","_","isNone","defaultParseOption","get","memoizeThunk","to","NumberConstraints","constructor","isNumber","min","Math","fround","max","isBoolean","noNaN","StringConstraints","IntegerConstraints","ArrayConstraints","BigIntConstraints","isBigInt","TypeAnnotationId","jsonSchema","JSONSchemaAnnotationId","IntTypeId","GreaterThanTypeId","GreaterThanOrEqualToTypeId","LessThanTypeId","LessThanOrEqualToTypeId","BetweenTypeId","exclusiveMinimum","minimum","exclusiveMaximum","maximum","GreaterThanBigintTypeId","GreaterThanOrEqualToBigIntTypeId","LessThanBigIntTypeId","LessThanOrEqualToBigIntTypeId","BetweenBigintTypeId","MinLengthTypeId","MaxLengthTypeId","LengthTypeId","MinItemsTypeId","MaxItemsTypeId","ItemsCountTypeId","minItems","maxItems","c1","c2","getMax","getMin","getOr","n1","n2"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 11447, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/TreeFormatter.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/TreeFormatter.ts"],"sourcesContent":["/**\n * @since 1.0.0\n */\n\nimport type * as Cause from \"effect/Cause\"\nimport * as Effect from \"effect/Effect\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as AST from \"./AST.js\"\nimport * as util_ from \"./internal/util.js\"\nimport type * as ParseResult from \"./ParseResult.js\"\n\ninterface Forest<A> extends ReadonlyArray<Tree<A>> {}\n\ninterface Tree<A> {\n  readonly value: A\n  readonly forest: Forest<A>\n}\n\nconst make = <A>(value: A, forest: Forest<A> = []): Tree<A> => ({\n  value,\n  forest\n})\n\n/**\n * @category formatting\n * @since 1.0.0\n */\nexport const formatIssue = (issue: ParseResult.ParseIssue): Effect.Effect<string> =>\n  Effect.map(go(issue), (tree) => drawTree(tree))\n\n/**\n * @category formatting\n * @since 1.0.0\n */\nexport const formatIssueSync = (issue: ParseResult.ParseIssue): string => Effect.runSync(formatIssue(issue))\n\n/**\n * @category formatting\n * @since 1.0.0\n */\nexport const formatError = (error: ParseResult.ParseError): Effect.Effect<string> => formatIssue(error.error)\n\n/**\n * @category formatting\n * @since 1.0.0\n */\nexport const formatErrorSync = (error: ParseResult.ParseError): string => formatIssueSync(error.error)\n\nconst drawTree = (tree: Tree<string>): string => tree.value + draw(\"\\n\", tree.forest)\n\nconst draw = (indentation: string, forest: Forest<string>): string => {\n  let r = \"\"\n  const len = forest.length\n  let tree: Tree<string>\n  for (let i = 0; i < len; i++) {\n    tree = forest[i]\n    const isLast = i === len - 1\n    r += indentation + (isLast ? \"\" : \"\") + \" \" + tree.value\n    r += draw(indentation + (len > 1 && !isLast ? \"  \" : \"   \"), tree.forest)\n  }\n  return r\n}\n\nconst formatTransformationKind = (kind: ParseResult.Transformation[\"kind\"]): string => {\n  switch (kind) {\n    case \"Encoded\":\n      return \"Encoded side transformation failure\"\n    case \"Transformation\":\n      return \"Transformation process failure\"\n    case \"Type\":\n      return \"Type side transformation failure\"\n  }\n}\n\nconst formatRefinementKind = (kind: ParseResult.Refinement[\"kind\"]): string => {\n  switch (kind) {\n    case \"From\":\n      return \"From side refinement failure\"\n    case \"Predicate\":\n      return \"Predicate refinement failure\"\n  }\n}\n\nconst getPrevMessage = (\n  issue: ParseResult.ParseIssue\n): Effect.Effect<string, Cause.NoSuchElementException> => {\n  switch (issue._tag) {\n    case \"Refinement\": {\n      if (issue.kind === \"From\") {\n        return getMessage(issue.error)\n      }\n      break\n    }\n    case \"Transformation\":\n      return getMessage(issue.error)\n  }\n  return Option.none()\n}\n\nconst getCurrentMessage: (\n  issue: ParseResult.ParseIssue\n) => Effect.Effect<string, Cause.NoSuchElementException> = (issue: ParseResult.ParseIssue) =>\n  AST.getMessageAnnotation(issue.ast).pipe(Effect.flatMap((annotation) => {\n    const out = annotation(issue)\n    return Predicate.isString(out) ? Effect.succeed(out) : out\n  }))\n\n/** @internal */\nexport const getMessage: (\n  issue: ParseResult.ParseIssue\n) => Effect.Effect<string, Cause.NoSuchElementException> = (issue: ParseResult.ParseIssue) =>\n  Effect.catchAll(getPrevMessage(issue), () => getCurrentMessage(issue))\n\nconst getParseIssueTitleAnnotation = (issue: ParseResult.ParseIssue): Option.Option<string> =>\n  Option.filterMap(\n    AST.getParseIssueTitleAnnotation(issue.ast),\n    (annotation) => Option.fromNullable(annotation(issue))\n  )\n\n/** @internal */\nexport const formatTypeMessage = (e: ParseResult.Type): Effect.Effect<string> =>\n  getMessage(e).pipe(\n    Effect.orElse(() => getParseIssueTitleAnnotation(e)),\n    Effect.orElse(() => e.message),\n    Effect.catchAll(() => Effect.succeed(`Expected ${e.ast.toString(true)}, actual ${util_.formatUnknown(e.actual)}`))\n  )\n\nconst getParseIssueTitle = (issue: ParseResult.ParseIssue): string =>\n  Option.getOrElse(getParseIssueTitleAnnotation(issue), () => String(issue.ast))\n\n/** @internal */\nexport const formatForbiddenMessage = (e: ParseResult.Forbidden): string =>\n  Option.getOrElse(e.message, () => \"is forbidden\")\n\nconst getTree = (issue: ParseResult.ParseIssue, onFailure: () => Effect.Effect<Tree<string>>) =>\n  Effect.matchEffect(getMessage(issue), {\n    onFailure,\n    onSuccess: (message) => Effect.succeed(make(message))\n  })\n\nconst go = (e: ParseResult.ParseIssue | ParseResult.Missing | ParseResult.Unexpected): Effect.Effect<Tree<string>> => {\n  switch (e._tag) {\n    case \"Type\":\n      return Effect.map(formatTypeMessage(e), make)\n    case \"Forbidden\":\n      return Effect.succeed(make(getParseIssueTitle(e), [make(formatForbiddenMessage(e))]))\n    case \"Unexpected\":\n      return Effect.succeed(make(`is unexpected, expected ${e.ast.toString(true)}`))\n    case \"Missing\":\n      return Effect.succeed(make(\"is missing\"))\n    case \"Union\":\n      return getTree(e, () =>\n        Effect.map(\n          Effect.forEach(e.errors, (e) => {\n            switch (e._tag) {\n              case \"Member\":\n                return Effect.map(go(e.error), (tree) => make(`Union member`, [tree]))\n              default:\n                return go(e)\n            }\n          }),\n          (forest) => make(getParseIssueTitle(e), forest)\n        ))\n    case \"TupleType\":\n      return getTree(e, () =>\n        Effect.map(\n          Effect.forEach(\n            e.errors,\n            (index) => Effect.map(go(index.error), (tree) => make(`[${index.index}]`, [tree]))\n          ),\n          (forest) => make(getParseIssueTitle(e), forest)\n        ))\n    case \"TypeLiteral\":\n      return getTree(e, () =>\n        Effect.map(\n          Effect.forEach(e.errors, (key) =>\n            Effect.map(go(key.error), (tree) => make(`[${util_.formatUnknown(key.key)}]`, [tree]))),\n          (forest) =>\n            make(getParseIssueTitle(e), forest)\n        ))\n    case \"Transformation\":\n      return getTree(e, () =>\n        Effect.map(\n          go(e.error),\n          (tree) => make(getParseIssueTitle(e), [make(formatTransformationKind(e.kind), [tree])])\n        ))\n    case \"Refinement\":\n      return getTree(\n        e,\n        () =>\n          Effect.map(go(e.error), (tree) => make(getParseIssueTitle(e), [make(formatRefinementKind(e.kind), [tree])]))\n      )\n    case \"Declaration\":\n      return getTree(e, () => {\n        const error = e.error\n        const shouldSkipDefaultMessage = error._tag === \"Type\" && error.ast === e.ast\n        return shouldSkipDefaultMessage\n          ? go(error)\n          : Effect.map(go(error), (tree) => make(getParseIssueTitle(e), [tree]))\n      })\n  }\n}\n"],"names":["Effect","Option","Predicate","AST","util_","make","value","forest","formatIssue","issue","map","go","tree","drawTree","formatIssueSync","runSync","formatError","error","formatErrorSync","draw","indentation","r","len","length","i","isLast","formatTransformationKind","kind","formatRefinementKind","getPrevMessage","_tag","getMessage","none","getCurrentMessage","getMessageAnnotation","ast","pipe","flatMap","annotation","out","isString","succeed","catchAll","getParseIssueTitleAnnotation","filterMap","fromNullable","formatTypeMessage","e","orElse","message","toString","formatUnknown","actual","getParseIssueTitle","getOrElse","String","formatForbiddenMessage","getTree","onFailure","matchEffect","onSuccess","forEach","errors","index","key","shouldSkipDefaultMessage"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 11598, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/ParseResult.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/ParseResult.ts"],"sourcesContent":["/**\n * @since 1.0.0\n */\n\nimport * as Arr from \"effect/Array\"\nimport { TaggedError } from \"effect/Data\"\nimport * as Effect from \"effect/Effect\"\nimport * as Either from \"effect/Either\"\nimport type { LazyArg } from \"effect/Function\"\nimport { dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport type { Concurrency, Mutable } from \"effect/Types\"\nimport * as AST from \"./AST.js\"\nimport * as util_ from \"./internal/util.js\"\nimport type * as Schema from \"./Schema.js\"\nimport * as TreeFormatter from \"./TreeFormatter.js\"\n\n/**\n * `ParseIssue` is a type that represents the different types of errors that can occur when decoding/encoding a value.\n *\n * @category model\n * @since 1.0.0\n */\nexport type ParseIssue =\n  | Declaration\n  | Refinement\n  | TupleType\n  | TypeLiteral\n  | Union\n  | Transformation\n  | Type\n  | Forbidden\n\n/**\n * Error that occurs when a declaration has an error.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Declaration {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Declaration\"\n  constructor(readonly ast: AST.Declaration, readonly actual: unknown, readonly error: ParseIssue) {}\n}\n\n/**\n * Error that occurs when a refinement has an error.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Refinement {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Refinement\"\n  constructor(\n    readonly ast: AST.Refinement<AST.AST>,\n    readonly actual: unknown,\n    readonly kind: \"From\" | \"Predicate\",\n    readonly error: ParseIssue\n  ) {}\n}\n\n/**\n * Error that occurs when an array or tuple has an error.\n *\n * @category model\n * @since 1.0.0\n */\nexport class TupleType {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"TupleType\"\n  constructor(\n    readonly ast: AST.TupleType,\n    readonly actual: unknown,\n    readonly errors: Arr.NonEmptyReadonlyArray<Index>,\n    readonly output: ReadonlyArray<unknown> = []\n  ) {}\n}\n\n/**\n * The `Index` error indicates that there was an error at a specific index in an array or tuple.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Index {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Index\"\n  constructor(readonly index: number, readonly error: ParseIssue | Missing | Unexpected) {}\n}\n\n/**\n * Error that occurs when a type literal or record has an error.\n *\n * @category model\n * @since 1.0.0\n */\nexport class TypeLiteral {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"TypeLiteral\"\n  constructor(\n    readonly ast: AST.TypeLiteral,\n    readonly actual: unknown,\n    readonly errors: Arr.NonEmptyReadonlyArray<Key>,\n    readonly output: { readonly [x: string]: unknown } = {}\n  ) {}\n}\n\n/**\n * The `Key` variant of the `ParseIssue` type represents an error that occurs when a key in a type literal or record is invalid.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Key {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Key\"\n  constructor(readonly key: PropertyKey, readonly error: ParseIssue | Missing | Unexpected) {}\n}\n\n/**\n * Error that occurs when an unexpected key or index is present.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Unexpected {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Unexpected\"\n  constructor(readonly ast: AST.AST) {}\n}\n\n/**\n * Error that occurs when a transformation has an error.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Transformation {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Transformation\"\n  constructor(\n    readonly ast: AST.Transformation,\n    readonly actual: unknown,\n    readonly kind: \"Encoded\" | \"Transformation\" | \"Type\",\n    readonly error: ParseIssue\n  ) {}\n}\n\n/**\n * The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.\n * The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Type {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Type\"\n  /**\n   * @since 1.0.0\n   */\n  readonly message: Option.Option<string>\n  constructor(readonly ast: AST.AST, readonly actual: unknown, message?: string) {\n    this.message = Option.fromNullable(message)\n  }\n}\n\n/**\n * The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).\n *\n * @category model\n * @since 1.0.0\n */\nexport class Forbidden {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Forbidden\"\n  /**\n   * @since 1.0.0\n   */\n  readonly message: Option.Option<string>\n  constructor(readonly ast: AST.AST, readonly actual: unknown, message?: string) {\n    this.message = Option.fromNullable(message)\n  }\n}\n\n/**\n * Error that occurs when a required key or index is missing.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Missing {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Missing\"\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const missing: Missing = new Missing()\n\n/**\n * Error that occurs when a member in a union has an error.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Member {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Member\"\n  constructor(readonly ast: AST.AST, readonly error: ParseIssue) {}\n}\n\n/**\n * Error that occurs when a union has an error.\n *\n * @category model\n * @since 1.0.0\n */\nexport class Union {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"Union\"\n  constructor(\n    readonly ast: AST.Union,\n    readonly actual: unknown,\n    readonly errors: Arr.NonEmptyReadonlyArray<Type | TypeLiteral | Member>\n  ) {}\n}\n\n/**\n * @since 1.0.0\n */\nexport class ParseError extends TaggedError(\"ParseError\")<{ readonly error: ParseIssue }> {\n  get message() {\n    return this.toString()\n  }\n  /**\n   * @since 1.0.0\n   */\n  toString() {\n    return TreeFormatter.formatIssueSync(this.error)\n  }\n  /**\n   * @since 1.0.0\n   */\n  toJSON() {\n    return {\n      _id: \"ParseError\",\n      message: this.toString()\n    }\n  }\n  /**\n   * @since 1.0.0\n   */\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const parseError = (issue: ParseIssue): ParseError => new ParseError({ error: issue })\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const succeed: <A>(a: A) => Either.Either<A, ParseIssue> = Either.right\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const fail: (issue: ParseIssue) => Either.Either<never, ParseIssue> = Either.left\n\nconst _try: <A>(options: {\n  try: LazyArg<A>\n  catch: (e: unknown) => ParseIssue\n}) => Either.Either<A, ParseIssue> = Either.try\n\nexport {\n  /**\n   * @category constructors\n   * @since 1.0.0\n   */\n  _try as try\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const fromOption: {\n  (onNone: () => ParseIssue): <A>(self: Option.Option<A>) => Either.Either<A, ParseIssue>\n  <A>(self: Option.Option<A>, onNone: () => ParseIssue): Either.Either<A, ParseIssue>\n} = Either.fromOption\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nexport const flatMap: {\n  <A, B, E1, R1>(\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>\n  <A, E, R, B, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ): Effect.Effect<B, E | E1, R | R1>\n} = dual(2, <A, E, R, B, E1, R1>(\n  self: Effect.Effect<A, E, R>,\n  f: (a: A) => Effect.Effect<B, E1, R1>\n): Effect.Effect<B, E | E1, R | R1> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return s\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return f(s.right)\n  }\n  return Effect.flatMap(self, f)\n})\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nexport const map: {\n  <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>\n} = dual(2, <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return s\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return Either.right(f(s.right))\n  }\n  return Effect.map(self, f)\n})\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nexport const mapError: {\n  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>\n} = dual(2, <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return Either.left(f(s.left))\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return s\n  }\n  return Effect.mapError(self, f)\n})\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nexport const eitherOrUndefined = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Either.Either<A, E> | undefined => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\" || s[\"_tag\"] === \"Right\") {\n    return s\n  }\n}\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nexport const mapBoth: {\n  <E, E2, A, A2>(\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>\n  <A, E, R, E2, A2>(\n    self: Effect.Effect<A, E, R>,\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): Effect.Effect<A2, E2, R>\n} = dual(2, <A, E, R, E2, A2>(\n  self: Effect.Effect<A, E, R>,\n  options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n): Effect.Effect<A2, E2, R> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return Either.left(options.onFailure(s.left))\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return Either.right(options.onSuccess(s.right))\n  }\n  return Effect.mapBoth(self, options)\n})\n\n/**\n * @category optimisation\n * @since 1.0.0\n */\nexport const orElse: {\n  <E, A2, E2, R2>(\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (e: E) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A2 | A, E2, R2 | R> => {\n  const s: any = self\n  if (s[\"_tag\"] === \"Left\") {\n    return f(s.left)\n  }\n  if (s[\"_tag\"] === \"Right\") {\n    return s\n  }\n  return Effect.catchAll(self, f)\n})\n\n/**\n * @since 1.0.0\n */\nexport type DecodeUnknown<Out, R> = (u: unknown, options?: AST.ParseOptions) => Effect.Effect<Out, ParseIssue, R>\n\n/**\n * @since 1.0.0\n */\nexport type DeclarationDecodeUnknown<Out, R> = (\n  u: unknown,\n  options: AST.ParseOptions,\n  ast: AST.Declaration\n) => Effect.Effect<Out, ParseIssue, R>\n\n/** @internal */\nexport const mergeParseOptions = (\n  a: AST.ParseOptions | undefined,\n  b: AST.ParseOptions | undefined\n): AST.ParseOptions | undefined => {\n  if (a === undefined) {\n    return b\n  }\n  if (b === undefined) {\n    return a\n  }\n  const out: Mutable<AST.ParseOptions> = {}\n  out.errors = b.errors ?? a.errors\n  out.onExcessProperty = b.onExcessProperty ?? a.onExcessProperty\n  return out\n}\n\nconst getEither = (ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {\n  const parser = goMemo(ast, isDecoding)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): Either.Either<any, ParseIssue> =>\n    parser(u, mergeParseOptions(options, overrideOptions)) as any\n}\n\nconst getSync = (ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {\n  const parser = getEither(ast, isDecoding, options)\n  return (input: unknown, overrideOptions?: AST.ParseOptions) =>\n    Either.getOrThrowWith(parser(input, overrideOptions), (e) => new Error(TreeFormatter.formatIssueSync(e)))\n}\n\nconst getOption = (ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {\n  const parser = getEither(ast, isDecoding, options)\n  return (input: unknown, overrideOptions?: AST.ParseOptions): Option.Option<any> =>\n    Option.getRight(parser(input, overrideOptions))\n}\n\nconst getEffect = <R>(ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {\n  const parser = goMemo(ast, isDecoding)\n  return (input: unknown, overrideOptions?: AST.ParseOptions): Effect.Effect<any, ParseIssue, R> =>\n    parser(input, { ...mergeParseOptions(options, overrideOptions), isEffectAllowed: true })\n}\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeUnknownSync = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => A => getSync(schema.ast, true, options)\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeUnknownOption = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A> => getOption(schema.ast, true, options)\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeUnknownEither = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue> =>\n  getEither(schema.ast, true, options)\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeUnknownPromise = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => {\n  const parser = decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeUnknown = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R> =>\n  getEffect(schema.ast, true, options)\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeUnknownSync = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => I => getSync(schema.ast, false, options)\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeUnknownOption = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<I> => getOption(schema.ast, false, options)\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeUnknownEither = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue> =>\n  getEither(schema.ast, false, options)\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeUnknownPromise = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => {\n  const parser = encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeUnknown = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R> =>\n  getEffect(schema.ast, false, options)\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeSync: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => A = decodeUnknownSync\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeOption: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => Option.Option<A> = decodeUnknownOption\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeEither: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue> = decodeUnknownEither\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodePromise: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => Promise<A> = decodeUnknownPromise\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decode: <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n) => (i: I, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R> = decodeUnknown\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const validateSync = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => A => getSync(AST.typeAST(schema.ast), true, options)\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const validateOption = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A> =>\n  getOption(AST.typeAST(schema.ast), true, options)\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const validateEither = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue> =>\n  getEither(AST.typeAST(schema.ast), true, options)\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const validatePromise = <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => {\n  const parser = validate(schema, options)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const validate = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n): (a: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R> =>\n  getEffect(AST.typeAST(schema.ast), true, options)\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const is = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => {\n  const parser = goMemo(AST.typeAST(schema.ast), true)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): u is A =>\n    Either.isRight(parser(u, { ...mergeParseOptions(options, overrideOptions), isExact: true }) as any)\n}\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const asserts = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => {\n  const parser = goMemo(AST.typeAST(schema.ast), true)\n  return (u: unknown, overrideOptions?: AST.ParseOptions): asserts u is A => {\n    const result: Either.Either<any, ParseIssue> = parser(u, {\n      ...mergeParseOptions(options, overrideOptions),\n      isExact: true\n    }) as any\n    if (Either.isLeft(result)) {\n      throw new Error(TreeFormatter.formatIssueSync(result.left))\n    }\n  }\n}\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeSync: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (a: A, overrideOptions?: AST.ParseOptions) => I = encodeUnknownSync\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeOption: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (input: A, overrideOptions?: AST.ParseOptions) => Option.Option<I> = encodeUnknownOption\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeEither: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (a: A, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue> = encodeUnknownEither\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodePromise: <A, I>(\n  schema: Schema.Schema<A, I, never>,\n  options?: AST.ParseOptions\n) => (a: A, overrideOptions?: AST.ParseOptions) => Promise<I> = encodeUnknownPromise\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encode: <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: AST.ParseOptions\n) => (a: A, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R> = encodeUnknown\n\ninterface InternalOptions extends AST.ParseOptions {\n  readonly isEffectAllowed?: boolean\n  // `isExact = false` means that missing keys are treated as undefined values (`{ key: undefined }`)\n  readonly isExact?: boolean\n}\n\ninterface Parser {\n  (i: any, options?: InternalOptions): Effect.Effect<any, ParseIssue, any>\n}\n\nconst decodeMemoMap = globalValue(\n  Symbol.for(\"@effect/schema/Parser/decodeMemoMap\"),\n  () => new WeakMap<AST.AST, Parser>()\n)\nconst encodeMemoMap = globalValue(\n  Symbol.for(\"@effect/schema/Parser/encodeMemoMap\"),\n  () => new WeakMap<AST.AST, Parser>()\n)\n\nconst goMemo = (ast: AST.AST, isDecoding: boolean): Parser => {\n  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap\n  const memo = memoMap.get(ast)\n  if (memo) {\n    return memo\n  }\n  const parser = go(ast, isDecoding)\n  memoMap.set(ast, parser)\n  return parser\n}\n\nconst getConcurrency = (ast: AST.AST): Concurrency | undefined =>\n  Option.getOrUndefined(AST.getConcurrencyAnnotation(ast))\n\nconst getBatching = (ast: AST.AST): boolean | \"inherit\" | undefined =>\n  Option.getOrUndefined(AST.getBatchingAnnotation(ast))\n\nconst go = (ast: AST.AST, isDecoding: boolean): Parser => {\n  switch (ast._tag) {\n    case \"Refinement\": {\n      if (isDecoding) {\n        const from = goMemo(ast.from, true)\n        return (i, options) =>\n          handleForbidden(\n            flatMap(\n              mapError(from(i, options), (e) => new Refinement(ast, i, \"From\", e)),\n              (a) =>\n                Option.match(\n                  ast.filter(a, options ?? AST.defaultParseOption, ast),\n                  {\n                    onNone: () => Either.right(a),\n                    onSome: (e) => Either.left(new Refinement(ast, i, \"Predicate\", e))\n                  }\n                )\n            ),\n            ast,\n            i,\n            options\n          )\n      } else {\n        const from = goMemo(AST.typeAST(ast), true)\n        const to = goMemo(dropRightRefinement(ast.from), false)\n        return (i, options) => handleForbidden(flatMap(from(i, options), (a) => to(a, options)), ast, i, options)\n      }\n    }\n    case \"Transformation\": {\n      const transform = getFinalTransformation(ast.transformation, isDecoding)\n      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false)\n      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false)\n      return (i1, options) =>\n        handleForbidden(\n          flatMap(\n            mapError(\n              from(i1, options),\n              (e) => new Transformation(ast, i1, isDecoding ? \"Encoded\" : \"Type\", e)\n            ),\n            (a) =>\n              flatMap(\n                mapError(\n                  transform(a, options ?? AST.defaultParseOption, ast),\n                  (e) => new Transformation(ast, i1, \"Transformation\", e)\n                ),\n                (i2) =>\n                  mapError(\n                    to(i2, options),\n                    (e) => new Transformation(ast, i1, isDecoding ? \"Type\" : \"Encoded\", e)\n                  )\n              )\n          ),\n          ast,\n          i1,\n          options\n        )\n    }\n    case \"Declaration\": {\n      const parse = isDecoding\n        ? ast.decodeUnknown(...ast.typeParameters)\n        : ast.encodeUnknown(...ast.typeParameters)\n      return (i, options) =>\n        handleForbidden(\n          mapError(parse(i, options ?? AST.defaultParseOption, ast), (e) => new Declaration(ast, i, e)),\n          ast,\n          i,\n          options\n        )\n    }\n    case \"Literal\":\n      return fromRefinement(ast, (u): u is typeof ast.literal => u === ast.literal)\n    case \"UniqueSymbol\":\n      return fromRefinement(ast, (u): u is typeof ast.symbol => u === ast.symbol)\n    case \"UndefinedKeyword\":\n      return fromRefinement(ast, Predicate.isUndefined)\n    case \"VoidKeyword\":\n      return fromRefinement(ast, Predicate.isUndefined)\n    case \"NeverKeyword\":\n      return fromRefinement(ast, Predicate.isNever)\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n      return Either.right\n    case \"StringKeyword\":\n      return fromRefinement(ast, Predicate.isString)\n    case \"NumberKeyword\":\n      return fromRefinement(ast, Predicate.isNumber)\n    case \"BooleanKeyword\":\n      return fromRefinement(ast, Predicate.isBoolean)\n    case \"BigIntKeyword\":\n      return fromRefinement(ast, Predicate.isBigInt)\n    case \"SymbolKeyword\":\n      return fromRefinement(ast, Predicate.isSymbol)\n    case \"ObjectKeyword\":\n      return fromRefinement(ast, Predicate.isObject)\n    case \"Enums\":\n      return fromRefinement(ast, (u): u is any => ast.enums.some(([_, value]) => value === u))\n    case \"TemplateLiteral\": {\n      const regex = AST.getTemplateLiteralRegExp(ast)\n      return fromRefinement(ast, (u): u is any => Predicate.isString(u) && regex.test(u))\n    }\n    case \"TupleType\": {\n      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding))\n      const rest = ast.rest.map((ast) => goMemo(ast, isDecoding))\n      let requiredLen = ast.elements.filter((e) => !e.isOptional).length\n      if (ast.rest.length > 0) {\n        requiredLen += ast.rest.length - 1\n      }\n      const expectedAST = AST.Union.make(ast.elements.map((_, i) => new AST.Literal(i)))\n      const concurrency = getConcurrency(ast)\n      const batching = getBatching(ast)\n      return (input: unknown, options) => {\n        if (!Arr.isArray(input)) {\n          return Either.left(new Type(ast, input))\n        }\n        const allErrors = options?.errors === \"all\"\n        const es: Array<[number, Index]> = []\n        let stepKey = 0\n        // ---------------------------------------------\n        // handle missing indexes\n        // ---------------------------------------------\n        const len = input.length\n        for (let i = len; i <= requiredLen - 1; i++) {\n          const e = new Index(i, missing)\n          if (allErrors) {\n            es.push([stepKey++, e])\n            continue\n          } else {\n            return Either.left(new TupleType(ast, input, [e]))\n          }\n        }\n\n        // ---------------------------------------------\n        // handle excess indexes\n        // ---------------------------------------------\n        if (ast.rest.length === 0) {\n          for (let i = ast.elements.length; i <= len - 1; i++) {\n            const e = new Index(i, new Unexpected(expectedAST))\n            if (allErrors) {\n              es.push([stepKey++, e])\n              continue\n            } else {\n              return Either.left(new TupleType(ast, input, [e]))\n            }\n          }\n        }\n\n        const output: Array<[number, any]> = []\n        let i = 0\n        type State = {\n          es: typeof es\n          output: typeof output\n        }\n        let queue:\n          | Array<(_: State) => Effect.Effect<void, ParseIssue, any>>\n          | undefined = undefined\n\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        for (; i < elements.length; i++) {\n          if (len < i + 1) {\n            if (ast.elements[i].isOptional) {\n              // the input element is missing\n              continue\n            }\n          } else {\n            const parser = elements[i]\n            const te = parser(input[i], options)\n            const eu = eitherOrUndefined(te)\n            if (eu) {\n              if (Either.isLeft(eu)) {\n                // the input element is present but is not valid\n                const e = new Index(i, eu.left)\n                if (allErrors) {\n                  es.push([stepKey++, e])\n                  continue\n                } else {\n                  return Either.left(new TupleType(ast, input, [e], sortByIndex(output)))\n                }\n              }\n              output.push([stepKey++, eu.right])\n            } else {\n              const nk = stepKey++\n              const index = i\n              if (!queue) {\n                queue = []\n              }\n              queue.push(({ es, output }: State) =>\n                Effect.flatMap(Effect.either(te), (t) => {\n                  if (Either.isLeft(t)) {\n                    // the input element is present but is not valid\n                    const e = new Index(index, t.left)\n                    if (allErrors) {\n                      es.push([nk, e])\n                      return Effect.void\n                    } else {\n                      return Either.left(new TupleType(ast, input, [e], sortByIndex(output)))\n                    }\n                  }\n                  output.push([nk, t.right])\n                  return Effect.void\n                })\n              )\n            }\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (Arr.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          for (; i < len - tail.length; i++) {\n            const te = head(input[i], options)\n            const eu = eitherOrUndefined(te)\n            if (eu) {\n              if (Either.isLeft(eu)) {\n                const e = new Index(i, eu.left)\n                if (allErrors) {\n                  es.push([stepKey++, e])\n                  continue\n                } else {\n                  return Either.left(new TupleType(ast, input, [e], sortByIndex(output)))\n                }\n              } else {\n                output.push([stepKey++, eu.right])\n              }\n            } else {\n              const nk = stepKey++\n              const index = i\n              if (!queue) {\n                queue = []\n              }\n              queue.push(\n                ({ es, output }: State) =>\n                  Effect.flatMap(Effect.either(te), (t) => {\n                    if (Either.isLeft(t)) {\n                      const e = new Index(index, t.left)\n                      if (allErrors) {\n                        es.push([nk, e])\n                        return Effect.void\n                      } else {\n                        return Either.left(new TupleType(ast, input, [e], sortByIndex(output)))\n                      }\n                    } else {\n                      output.push([nk, t.right])\n                      return Effect.void\n                    }\n                  })\n              )\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            i += j\n            if (len < i + 1) {\n              continue\n            } else {\n              const te = tail[j](input[i], options)\n              const eu = eitherOrUndefined(te)\n              if (eu) {\n                if (Either.isLeft(eu)) {\n                  // the input element is present but is not valid\n                  const e = new Index(i, eu.left)\n                  if (allErrors) {\n                    es.push([stepKey++, e])\n                    continue\n                  } else {\n                    return Either.left(new TupleType(ast, input, [e], sortByIndex(output)))\n                  }\n                }\n                output.push([stepKey++, eu.right])\n              } else {\n                const nk = stepKey++\n                const index = i\n                if (!queue) {\n                  queue = []\n                }\n                queue.push(\n                  ({ es, output }: State) =>\n                    Effect.flatMap(Effect.either(te), (t) => {\n                      if (Either.isLeft(t)) {\n                        // the input element is present but is not valid\n                        const e = new Index(index, t.left)\n                        if (allErrors) {\n                          es.push([nk, e])\n                          return Effect.void\n                        } else {\n                          return Either.left(new TupleType(ast, input, [e], sortByIndex(output)))\n                        }\n                      }\n                      output.push([nk, t.right])\n                      return Effect.void\n                    })\n                )\n              }\n            }\n          }\n        }\n\n        // ---------------------------------------------\n        // compute result\n        // ---------------------------------------------\n        const computeResult = ({ es, output }: State) =>\n          Arr.isNonEmptyArray(es) ?\n            Either.left(new TupleType(ast, input, sortByIndex(es), sortByIndex(output))) :\n            Either.right(sortByIndex(output))\n        if (queue && queue.length > 0) {\n          const cqueue = queue\n          return Effect.suspend(() => {\n            const state: State = {\n              es: Arr.copy(es),\n              output: Arr.copy(output)\n            }\n            return Effect.flatMap(\n              Effect.forEach(cqueue, (f) => f(state), { concurrency, batching, discard: true }),\n              () => computeResult(state)\n            )\n          })\n        }\n        return computeResult({ output, es })\n      }\n    }\n    case \"TypeLiteral\": {\n      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n        return fromRefinement(ast, Predicate.isNotNullable)\n      }\n\n      const propertySignatures: Array<readonly [Parser, AST.PropertySignature]> = []\n      const expectedKeys: Record<PropertyKey, null> = {}\n      for (const ps of ast.propertySignatures) {\n        propertySignatures.push([goMemo(ps.type, isDecoding), ps])\n        expectedKeys[ps.name] = null\n      }\n\n      const indexSignatures = ast.indexSignatures.map((is) =>\n        [\n          goMemo(is.parameter, isDecoding),\n          goMemo(is.type, isDecoding),\n          is.parameter\n        ] as const\n      )\n      const expectedAST = AST.Union.make(\n        ast.indexSignatures.map((is): AST.AST => is.parameter).concat(\n          util_.ownKeys(expectedKeys).map((key) =>\n            Predicate.isSymbol(key) ? new AST.UniqueSymbol(key) : new AST.Literal(key)\n          )\n        )\n      )\n      const expected = goMemo(expectedAST, isDecoding)\n      const concurrency = getConcurrency(ast)\n      const batching = getBatching(ast)\n      return (input: unknown, options) => {\n        if (!Predicate.isRecord(input)) {\n          return Either.left(new Type(ast, input))\n        }\n        const allErrors = options?.errors === \"all\"\n        const es: Array<[number, Key]> = []\n        let stepKey = 0\n\n        // ---------------------------------------------\n        // handle excess properties\n        // ---------------------------------------------\n        const onExcessPropertyError = options?.onExcessProperty === \"error\"\n        const onExcessPropertyPreserve = options?.onExcessProperty === \"preserve\"\n        const output: any = {}\n        if (onExcessPropertyError || onExcessPropertyPreserve) {\n          for (const key of util_.ownKeys(input)) {\n            const eu = eitherOrUndefined(expected(key, options))!\n            if (Either.isLeft(eu)) {\n              // key is unexpected\n              if (onExcessPropertyError) {\n                const e = new Key(key, new Unexpected(expectedAST))\n                if (allErrors) {\n                  es.push([stepKey++, e])\n                  continue\n                } else {\n                  return Either.left(new TypeLiteral(ast, input, [e], output))\n                }\n              } else {\n                // preserve key\n                output[key] = input[key]\n              }\n            }\n          }\n        }\n\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        type State = {\n          es: typeof es\n          output: typeof output\n        }\n        let queue:\n          | Array<(state: State) => Effect.Effect<void, ParseIssue, any>>\n          | undefined = undefined\n\n        const isExact = options?.isExact === true\n        for (let i = 0; i < propertySignatures.length; i++) {\n          const ps = propertySignatures[i][1]\n          const name = ps.name\n          const hasKey = Object.prototype.hasOwnProperty.call(input, name)\n          if (!hasKey) {\n            if (ps.isOptional) {\n              continue\n            } else if (isExact) {\n              const e = new Key(name, missing)\n              if (allErrors) {\n                es.push([stepKey++, e])\n                continue\n              } else {\n                return Either.left(new TypeLiteral(ast, input, [e], output))\n              }\n            }\n          }\n          const parser = propertySignatures[i][0]\n          const te = parser(input[name], options)\n          const eu = eitherOrUndefined(te)\n          if (eu) {\n            if (Either.isLeft(eu)) {\n              const e = new Key(name, hasKey ? eu.left : missing)\n              if (allErrors) {\n                es.push([stepKey++, e])\n                continue\n              } else {\n                return Either.left(new TypeLiteral(ast, input, [e], output))\n              }\n            }\n            output[name] = eu.right\n          } else {\n            const nk = stepKey++\n            const index = name\n            if (!queue) {\n              queue = []\n            }\n            queue.push(\n              ({ es, output }: State) =>\n                Effect.flatMap(Effect.either(te), (t) => {\n                  if (Either.isLeft(t)) {\n                    const e = new Key(index, hasKey ? t.left : missing)\n                    if (allErrors) {\n                      es.push([nk, e])\n                      return Effect.void\n                    } else {\n                      return Either.left(new TypeLiteral(ast, input, [e], output))\n                    }\n                  }\n                  output[index] = t.right\n                  return Effect.void\n                })\n            )\n          }\n        }\n\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const indexSignature = indexSignatures[i]\n          const parameter = indexSignature[0]\n          const type = indexSignature[1]\n          const keys = util_.getKeysForIndexSignature(input, indexSignature[2])\n          for (const key of keys) {\n            // ---------------------------------------------\n            // handle keys\n            // ---------------------------------------------\n            const keu = eitherOrUndefined(parameter(key, options))\n            if (keu && Either.isRight(keu)) {\n              // ---------------------------------------------\n              // handle values\n              // ---------------------------------------------\n              const vpr = type(input[key], options)\n              const veu = eitherOrUndefined(vpr)\n              if (veu) {\n                if (Either.isLeft(veu)) {\n                  const e = new Key(key, veu.left)\n                  if (allErrors) {\n                    es.push([stepKey++, e])\n                    continue\n                  } else {\n                    return Either.left(new TypeLiteral(ast, input, [e], output))\n                  }\n                } else {\n                  if (!Object.prototype.hasOwnProperty.call(expectedKeys, key)) {\n                    output[key] = veu.right\n                  }\n                }\n              } else {\n                const nk = stepKey++\n                const index = key\n                if (!queue) {\n                  queue = []\n                }\n                queue.push(\n                  ({ es, output }: State) =>\n                    Effect.flatMap(\n                      Effect.either(vpr),\n                      (tv) => {\n                        if (Either.isLeft(tv)) {\n                          const e = new Key(index, tv.left)\n                          if (allErrors) {\n                            es.push([nk, e])\n                            return Effect.void\n                          } else {\n                            return Either.left(new TypeLiteral(ast, input, [e], output))\n                          }\n                        } else {\n                          if (!Object.prototype.hasOwnProperty.call(expectedKeys, key)) {\n                            output[key] = tv.right\n                          }\n                          return Effect.void\n                        }\n                      }\n                    )\n                )\n              }\n            }\n          }\n        }\n        // ---------------------------------------------\n        // compute result\n        // ---------------------------------------------\n        const computeResult = ({ es, output }: State) =>\n          Arr.isNonEmptyArray(es) ?\n            Either.left(new TypeLiteral(ast, input, sortByIndex(es), output)) :\n            Either.right(output)\n        if (queue && queue.length > 0) {\n          const cqueue = queue\n          return Effect.suspend(() => {\n            const state: State = {\n              es: Arr.copy(es),\n              output: Object.assign({}, output)\n            }\n            return Effect.flatMap(\n              Effect.forEach(cqueue, (f) => f(state), { concurrency, batching, discard: true }),\n              () => computeResult(state)\n            )\n          })\n        }\n        return computeResult({ es, output })\n      }\n    }\n    case \"Union\": {\n      const searchTree = getSearchTree(ast.types, isDecoding)\n      const ownKeys = util_.ownKeys(searchTree.keys)\n      const len = ownKeys.length\n      const map = new Map<any, Parser>()\n      for (let i = 0; i < ast.types.length; i++) {\n        map.set(ast.types[i], goMemo(ast.types[i], isDecoding))\n      }\n      const concurrency = getConcurrency(ast) ?? 1\n      const batching = getBatching(ast)\n      return (input, options) => {\n        const es: Array<[number, Type | TypeLiteral | Member]> = []\n        let stepKey = 0\n        let candidates: Array<AST.AST> = []\n        if (len > 0) {\n          // if there is at least one key then input must be an object\n          if (Predicate.isRecord(input)) {\n            for (let i = 0; i < len; i++) {\n              const name = ownKeys[i]\n              const buckets = searchTree.keys[name].buckets\n              // for each property that should contain a literal, check if the input contains that property\n              if (Object.prototype.hasOwnProperty.call(input, name)) {\n                const literal = String(input[name])\n                // check that the value obtained from the input for the property corresponds to an existing bucket\n                if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                  // retrive the minimal set of candidates for decoding\n                  candidates = candidates.concat(buckets[literal])\n                } else {\n                  const literals = AST.Union.make(searchTree.keys[name].literals)\n                  es.push([\n                    stepKey++,\n                    new TypeLiteral(\n                      new AST.TypeLiteral([\n                        new AST.PropertySignature(name, literals, false, true)\n                      ], []),\n                      input,\n                      [new Key(name, new Type(literals, input[name]))]\n                    )\n                  ])\n                }\n              } else {\n                const literals = AST.Union.make(searchTree.keys[name].literals)\n                es.push([\n                  stepKey++,\n                  new TypeLiteral(\n                    new AST.TypeLiteral([\n                      new AST.PropertySignature(name, literals, false, true)\n                    ], []),\n                    input,\n                    [new Key(name, missing)]\n                  )\n                ])\n              }\n            }\n          } else {\n            es.push([stepKey++, new Type(ast, input)])\n          }\n        }\n        if (searchTree.otherwise.length > 0) {\n          candidates = candidates.concat(searchTree.otherwise)\n        }\n\n        let queue:\n          | Array<(state: State) => Effect.Effect<unknown, ParseIssue, any>>\n          | undefined = undefined\n\n        type State = {\n          finalResult?: any\n          es: typeof es\n        }\n\n        for (let i = 0; i < candidates.length; i++) {\n          const candidate = candidates[i]\n          const pr = map.get(candidate)!(input, options)\n          // the members of a union are ordered based on which one should be decoded first,\n          // therefore if one member has added a task, all subsequent members must\n          // also add a task to the queue even if they are synchronous\n          const eu = !queue || queue.length === 0 ? eitherOrUndefined(pr) : undefined\n          if (eu) {\n            if (Either.isRight(eu)) {\n              return Either.right(eu.right)\n            } else {\n              es.push([stepKey++, new Member(candidate, eu.left)])\n            }\n          } else {\n            const nk = stepKey++\n            if (!queue) {\n              queue = []\n            }\n            queue.push(\n              (state) =>\n                Effect.suspend(() => {\n                  if (\"finalResult\" in state) {\n                    return Effect.void\n                  } else {\n                    return Effect.flatMap(Effect.either(pr), (t) => {\n                      if (Either.isRight(t)) {\n                        state.finalResult = Either.right(t.right)\n                      } else {\n                        state.es.push([nk, new Member(candidate, t.left)])\n                      }\n                      return Effect.void\n                    })\n                  }\n                })\n            )\n          }\n        }\n\n        // ---------------------------------------------\n        // compute result\n        // ---------------------------------------------\n        const computeResult = (es: State[\"es\"]) =>\n          Arr.isNonEmptyArray(es) ?\n            es.length === 1 && es[0][1]._tag === \"Type\" ?\n              Either.left(es[0][1]) :\n              Either.left(new Union(ast, input, sortByIndex(es))) :\n            // this should never happen\n            Either.left(new Type(AST.neverKeyword, input))\n\n        if (queue && queue.length > 0) {\n          const cqueue = queue\n          return Effect.suspend(() => {\n            const state: State = { es: Arr.copy(es) }\n            return Effect.flatMap(\n              Effect.forEach(cqueue, (f) => f(state), { concurrency, batching, discard: true }),\n              () => {\n                if (\"finalResult\" in state) {\n                  return state.finalResult\n                }\n                return computeResult(state.es)\n              }\n            )\n          })\n        }\n        return computeResult(es)\n      }\n    }\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => goMemo(AST.annotations(ast.f(), ast.annotations), isDecoding))\n      return (a, options) => get()(a, options)\n    }\n  }\n}\n\nconst fromRefinement = <A>(ast: AST.AST, refinement: (u: unknown) => u is A): Parser => (u) =>\n  refinement(u) ? Either.right(u) : Either.left(new Type(ast, u))\n\n/** @internal */\nexport const getLiterals = (\n  ast: AST.AST,\n  isDecoding: boolean\n): ReadonlyArray<[PropertyKey, AST.Literal]> => {\n  switch (ast._tag) {\n    case \"Declaration\": {\n      const annotation = AST.getSurrogateAnnotation(ast)\n      if (Option.isSome(annotation)) {\n        return getLiterals(annotation.value, isDecoding)\n      }\n      break\n    }\n    case \"TypeLiteral\": {\n      const out: Array<[PropertyKey, AST.Literal]> = []\n      for (let i = 0; i < ast.propertySignatures.length; i++) {\n        const propertySignature = ast.propertySignatures[i]\n        const type = isDecoding ? AST.encodedAST(propertySignature.type) : AST.typeAST(propertySignature.type)\n        if (AST.isLiteral(type) && !propertySignature.isOptional) {\n          out.push([propertySignature.name, type])\n        }\n      }\n      return out\n    }\n    case \"Refinement\":\n      return getLiterals(ast.from, isDecoding)\n    case \"Suspend\":\n      return getLiterals(ast.f(), isDecoding)\n    case \"Transformation\":\n      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding)\n  }\n  return []\n}\n\n/**\n * The purpose of the algorithm is to narrow down the pool of possible candidates for decoding as much as possible.\n *\n * This function separates the schemas into two groups, `keys` and `otherwise`:\n *\n * - `keys`: the schema has at least one property with a literal value\n * - `otherwise`: the schema has no properties with a literal value\n *\n * If a schema has at least one property with a literal value, so it ends up in `keys`, first a namespace is created for\n * the name of the property containing the literal, and then within this namespace a \"bucket\" is created for the literal\n * value in which to store all the schemas that have the same property and literal value.\n *\n * @internal\n */\nexport const getSearchTree = (\n  members: ReadonlyArray<AST.AST>,\n  isDecoding: boolean\n): {\n  keys: {\n    readonly [key: PropertyKey]: {\n      buckets: { [literal: string]: ReadonlyArray<AST.AST> }\n      literals: ReadonlyArray<AST.Literal> // this is for error messages\n    }\n  }\n  otherwise: ReadonlyArray<AST.AST>\n} => {\n  const keys: {\n    [key: PropertyKey]: {\n      buckets: { [literal: string]: Array<AST.AST> }\n      literals: Array<AST.Literal>\n    }\n  } = {}\n  const otherwise: Array<AST.AST> = []\n  for (let i = 0; i < members.length; i++) {\n    const member = members[i]\n    const tags = getLiterals(member, isDecoding)\n    if (tags.length > 0) {\n      for (let j = 0; j < tags.length; j++) {\n        const [key, literal] = tags[j]\n        const hash = String(literal.literal)\n        keys[key] = keys[key] || { buckets: {}, literals: [] }\n        const buckets = keys[key].buckets\n        if (Object.prototype.hasOwnProperty.call(buckets, hash)) {\n          if (j < tags.length - 1) {\n            continue\n          }\n          buckets[hash].push(member)\n          keys[key].literals.push(literal)\n        } else {\n          buckets[hash] = [member]\n          keys[key].literals.push(literal)\n          break\n        }\n      }\n    } else {\n      otherwise.push(member)\n    }\n  }\n  return { keys, otherwise }\n}\n\nconst dropRightRefinement = (ast: AST.AST): AST.AST => AST.isRefinement(ast) ? dropRightRefinement(ast.from) : ast\n\nconst handleForbidden = <R, A>(\n  effect: Effect.Effect<A, ParseIssue, R>,\n  ast: AST.AST,\n  actual: unknown,\n  options: InternalOptions | undefined\n): Effect.Effect<A, ParseIssue, R> => {\n  const eu = eitherOrUndefined(effect)\n  if (eu) {\n    return eu\n  }\n  if (options?.isEffectAllowed === true) {\n    return effect\n  }\n  try {\n    return Effect.runSync(Effect.either(effect as Effect.Effect<A, ParseIssue>))\n  } catch (e) {\n    return Either.left(\n      new Forbidden(\n        ast,\n        actual,\n        \"cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work\"\n      )\n    )\n  }\n}\n\nfunction sortByIndex<T>(\n  es: Arr.NonEmptyArray<[number, T]>\n): Arr.NonEmptyArray<T>\nfunction sortByIndex<T>(es: Array<[number, T]>): Array<T>\nfunction sortByIndex(es: Array<[number, any]>): any {\n  return es.sort(([a], [b]) => a > b ? 1 : a < b ? -1 : 0).map(([_, a]) => a)\n}\n\n// -------------------------------------------------------------------------------------\n// transformations interpreter\n// -------------------------------------------------------------------------------------\n\n/** @internal */\nexport const getFinalTransformation = (\n  transformation: AST.TransformationKind,\n  isDecoding: boolean\n): (\n  input: any,\n  options: AST.ParseOptions,\n  self: AST.Transformation\n) => Effect.Effect<any, ParseIssue, any> => {\n  switch (transformation._tag) {\n    case \"FinalTransformation\":\n      return isDecoding ? transformation.decode : transformation.encode\n    case \"ComposeTransformation\":\n      return Either.right\n    case \"TypeLiteralTransformation\":\n      return (input) => {\n        let out: Effect.Effect<any, ParseIssue, any> = Either.right(input)\n\n        // ---------------------------------------------\n        // handle property signature transformations\n        // ---------------------------------------------\n        for (const pst of transformation.propertySignatureTransformations) {\n          const [from, to] = isDecoding ?\n            [pst.from, pst.to] :\n            [pst.to, pst.from]\n          const transformation = isDecoding ? pst.decode : pst.encode\n          const f = (input: any) => {\n            const o = transformation(\n              Object.prototype.hasOwnProperty.call(input, from) ?\n                Option.some(input[from]) :\n                Option.none()\n            )\n            delete input[from]\n            if (Option.isSome(o)) {\n              input[to] = o.value\n            }\n            return input\n          }\n          out = map(out, f)\n        }\n        return out\n      }\n  }\n}\n"],"names":["Arr","TaggedError","Effect","Either","dual","globalValue","Inspectable","Option","Predicate","AST","util_","TreeFormatter","Declaration","ast","actual","error","_tag","constructor","Refinement","kind","TupleType","errors","output","Index","index","TypeLiteral","Key","key","Unexpected","Transformation","Type","message","fromNullable","Forbidden","Missing","missing","Member","Union","ParseError","toString","formatIssueSync","toJSON","_id","NodeInspectSymbol","parseError","issue","succeed","right","fail","left","_try","try","fromOption","flatMap","self","f","s","map","mapError","eitherOrUndefined","mapBoth","options","onFailure","onSuccess","orElse","catchAll","mergeParseOptions","a","b","undefined","out","onExcessProperty","getEither","isDecoding","parser","goMemo","u","overrideOptions","getSync","input","getOrThrowWith","e","Error","getOption","getRight","getEffect","isEffectAllowed","decodeUnknownSync","schema","decodeUnknownOption","decodeUnknownEither","decodeUnknownPromise","decodeUnknown","runPromise","encodeUnknownSync","encodeUnknownOption","encodeUnknownEither","encodeUnknownPromise","encodeUnknown","decodeSync","decodeOption","decodeEither","decodePromise","decode","validateSync","typeAST","validateOption","validateEither","validatePromise","validate","is","isRight","isExact","asserts","result","isLeft","encodeSync","encodeOption","encodeEither","encodePromise","encode","decodeMemoMap","Symbol","for","WeakMap","encodeMemoMap","memoMap","memo","get","go","set","getConcurrency","getOrUndefined","getConcurrencyAnnotation","getBatching","getBatchingAnnotation","from","i","handleForbidden","match","filter","defaultParseOption","onNone","onSome","to","dropRightRefinement","transform","getFinalTransformation","transformation","i1","i2","parse","typeParameters","fromRefinement","literal","symbol","isUndefined","isNever","isString","isNumber","isBoolean","isBigInt","isSymbol","isObject","enums","some","_","value","regex","getTemplateLiteralRegExp","test","elements","type","rest","requiredLen","isOptional","length","expectedAST","make","Literal","concurrency","batching","isArray","allErrors","es","stepKey","len","push","queue","te","eu","sortByIndex","nk","either","t","void","isNonEmptyReadonlyArray","head","tail","j","computeResult","isNonEmptyArray","cqueue","suspend","state","copy","forEach","discard","propertySignatures","indexSignatures","isNotNullable","expectedKeys","ps","name","parameter","concat","ownKeys","UniqueSymbol","expected","isRecord","onExcessPropertyError","onExcessPropertyPreserve","hasKey","Object","prototype","hasOwnProperty","call","indexSignature","keys","getKeysForIndexSignature","keu","vpr","veu","tv","assign","searchTree","getSearchTree","types","Map","candidates","buckets","String","literals","PropertySignature","otherwise","candidate","pr","finalResult","neverKeyword","memoizeThunk","annotations","refinement","getLiterals","annotation","getSurrogateAnnotation","isSome","propertySignature","encodedAST","isLiteral","members","member","tags","hash","isRefinement","effect","runSync","sort","pst","propertySignatureTransformations","o","none"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 12902, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/Equivalence.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/Equivalence.ts"],"sourcesContent":["/**\n * @since 1.0.0\n */\n\nimport * as Arr from \"effect/Array\"\nimport * as Equal from \"effect/Equal\"\nimport * as Equivalence from \"effect/Equivalence\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as AST from \"./AST.js\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as util_ from \"./internal/util.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type * as Schema from \"./Schema.js\"\n\n/**\n * @category hooks\n * @since 1.0.0\n */\nexport const EquivalenceHookId: unique symbol = Symbol.for(\"@effect/schema/EquivalenceHookId\")\n\n/**\n * @category hooks\n * @since 1.0.0\n */\nexport type EquivalenceHookId = typeof EquivalenceHookId\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const equivalence =\n  <A>(handler: (...args: ReadonlyArray<Equivalence.Equivalence<any>>) => Equivalence.Equivalence<A>) =>\n  <I, R>(self: Schema.Schema<A, I, R>): Schema.Schema<A, I, R> => self.annotations({ [EquivalenceHookId]: handler })\n\n/**\n * @category Equivalence\n * @since 1.0.0\n */\nexport const make = <A, I, R>(schema: Schema.Schema<A, I, R>): Equivalence.Equivalence<A> => go(schema.ast)\n\nconst getHook = AST.getAnnotation<\n  (...args: ReadonlyArray<Equivalence.Equivalence<any>>) => Equivalence.Equivalence<any>\n>(\n  EquivalenceHookId\n)\n\nconst go = (ast: AST.AST): Equivalence.Equivalence<any> => {\n  const hook = getHook(ast)\n  if (Option.isSome(hook)) {\n    switch (ast._tag) {\n      case \"Declaration\":\n        return hook.value(...ast.typeParameters.map(go))\n      case \"Refinement\":\n        return hook.value(go(ast.from))\n      default:\n        return hook.value()\n    }\n  }\n  switch (ast._tag) {\n    case \"NeverKeyword\":\n      throw new Error(errors_.getEquivalenceErrorMessage(\"`never`\"))\n    case \"Transformation\":\n      return go(ast.to)\n    case \"Declaration\":\n    case \"Literal\":\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n    case \"UniqueSymbol\":\n    case \"SymbolKeyword\":\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"Enums\":\n    case \"ObjectKeyword\":\n      return Equal.equals\n    case \"Refinement\":\n      return go(ast.from)\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => go(ast.f()))\n      return (a, b) => get()(a, b)\n    }\n    case \"TupleType\": {\n      const elements = ast.elements.map((element) => go(element.type))\n      const rest = ast.rest.map(go)\n      return Equivalence.make((a, b) => {\n        const len = a.length\n        if (len !== b.length) {\n          return false\n        }\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        let i = 0\n        for (; i < Math.min(len, ast.elements.length); i++) {\n          if (!elements[i](a[i], b[i])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (Arr.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          for (; i < len - tail.length; i++) {\n            if (!head(a[i], b[i])) {\n              return false\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            i += j\n            if (!tail[j](a[i], b[i])) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"TypeLiteral\": {\n      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n        return Equal.equals\n      }\n      const propertySignatures = ast.propertySignatures.map((ps) => go(ps.type))\n      const indexSignatures = ast.indexSignatures.map((is) => go(is.type))\n      return Equivalence.make((a, b) => {\n        const aStringKeys = Object.keys(a)\n        const aSymbolKeys = Object.getOwnPropertySymbols(a)\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < propertySignatures.length; i++) {\n          const ps = ast.propertySignatures[i]\n          const name = ps.name\n          const aHas = Object.prototype.hasOwnProperty.call(a, name)\n          const bHas = Object.prototype.hasOwnProperty.call(b, name)\n          if (ps.isOptional) {\n            if (aHas !== bHas) {\n              return false\n            }\n          }\n          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        let bSymbolKeys: Array<symbol> | undefined\n        let bStringKeys: Array<string> | undefined\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const is = ast.indexSignatures[i]\n          const base = AST.getParameterBase(is.parameter)\n          const isSymbol = AST.isSymbolKeyword(base)\n          if (isSymbol) {\n            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b)\n            if (aSymbolKeys.length !== bSymbolKeys.length) {\n              return false\n            }\n          } else {\n            bStringKeys = bStringKeys || Object.keys(b)\n            if (aStringKeys.length !== bStringKeys.length) {\n              return false\n            }\n          }\n          const aKeys = isSymbol ? aSymbolKeys : aStringKeys\n          for (let j = 0; j < aKeys.length; j++) {\n            const key = aKeys[j]\n            if (\n              !Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])\n            ) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"Union\": {\n      const searchTree = ParseResult.getSearchTree(ast.types, true)\n      const ownKeys = util_.ownKeys(searchTree.keys)\n      const len = ownKeys.length\n      return Equivalence.make((a, b) => {\n        let candidates: Array<AST.AST> = []\n        if (len > 0 && Predicate.isRecord(a)) {\n          for (let i = 0; i < len; i++) {\n            const name = ownKeys[i]\n            const buckets = searchTree.keys[name].buckets\n            if (Object.prototype.hasOwnProperty.call(a, name)) {\n              const literal = String(a[name])\n              if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                candidates = candidates.concat(buckets[literal])\n              }\n            }\n          }\n        }\n        if (searchTree.otherwise.length > 0) {\n          candidates = candidates.concat(searchTree.otherwise)\n        }\n        const tuples = candidates.map((ast) => [go(ast), ParseResult.is({ ast } as any)] as const)\n        for (let i = 0; i < tuples.length; i++) {\n          const [equivalence, is] = tuples[i]\n          if (is(a) && is(b)) {\n            if (equivalence(a, b)) {\n              return true\n            }\n          }\n        }\n        return false\n      })\n    }\n  }\n}\n"],"names":["Arr","Equal","Equivalence","Option","Predicate","AST","errors_","util_","ParseResult","EquivalenceHookId","Symbol","for","equivalence","handler","self","annotations","make","schema","go","ast","getHook","getAnnotation","hook","isSome","_tag","value","typeParameters","map","from","Error","getEquivalenceErrorMessage","to","equals","get","memoizeThunk","f","a","b","elements","element","type","rest","len","length","i","Math","min","isNonEmptyReadonlyArray","head","tail","j","propertySignatures","indexSignatures","ps","is","aStringKeys","Object","keys","aSymbolKeys","getOwnPropertySymbols","name","aHas","prototype","hasOwnProperty","call","bHas","isOptional","bSymbolKeys","bStringKeys","base","getParameterBase","parameter","isSymbol","isSymbolKeyword","aKeys","key","searchTree","getSearchTree","types","ownKeys","candidates","isRecord","buckets","literal","String","concat","otherwise","tuples"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 13120, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/internal/serializable.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/internal/serializable.ts"],"sourcesContent":["/** @internal */\nexport const symbol: unique symbol = Symbol.for(\n  \"@effect/schema/Serializable/symbol\"\n)\n\n/** @internal */\nexport const symbolResult: unique symbol = Symbol.for(\n  \"@effect/schema/Serializable/symbolResult\"\n)\n"],"names":["symbol","Symbol","for","symbolResult"],"mappings":"AAAA,cAAA;;;;;;AACO,MAAMA,MAAM,GAAA,WAAA,GAAkBC,MAAM,CAACC,GAAG,CAC7C,oCAAoC,CACrC;AAGM,MAAMC,YAAY,GAAA,WAAA,GAAkBF,MAAM,CAACC,GAAG,CACnD,0CAA0C,CAC3C","ignoreList":[]}},
    {"offset": {"line": 13132, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/Pretty.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/Pretty.ts"],"sourcesContent":["/**\n * @since 1.0.0\n */\nimport * as Arr from \"effect/Array\"\nimport * as Option from \"effect/Option\"\nimport * as AST from \"./AST.js\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as util_ from \"./internal/util.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type * as Schema from \"./Schema.js\"\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Pretty<To> {\n  (a: To): string\n}\n\n/**\n * @category hooks\n * @since 1.0.0\n */\nexport const PrettyHookId: unique symbol = Symbol.for(\"@effect/schema/PrettyHookId\")\n\n/**\n * @category hooks\n * @since 1.0.0\n */\nexport type PrettyHookId = typeof PrettyHookId\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const pretty =\n  <A>(handler: (...args: ReadonlyArray<Pretty<any>>) => Pretty<A>) =>\n  <I, R>(self: Schema.Schema<A, I, R>): Schema.Schema<A, I, R> => self.annotations({ [PrettyHookId]: handler })\n\n/**\n * @category prettify\n * @since 1.0.0\n */\nexport const make = <A, I, R>(schema: Schema.Schema<A, I, R>): (a: A) => string => compile(schema.ast)\n\nconst getHook = AST.getAnnotation<(...args: ReadonlyArray<Pretty<any>>) => Pretty<any>>(\n  PrettyHookId\n)\n\nconst getMatcher = (defaultPretty: Pretty<any>) => (ast: AST.AST): Pretty<any> =>\n  Option.match(getHook(ast), {\n    onNone: () => defaultPretty,\n    onSome: (handler) => handler()\n  })\n\nconst toString = getMatcher((a) => String(a))\n\nconst stringify = getMatcher((a) => JSON.stringify(a))\n\nconst formatUnknown = getMatcher(util_.formatUnknown)\n\n/**\n * @since 1.0.0\n */\nexport const match: AST.Match<Pretty<any>> = {\n  \"Declaration\": (ast, go) => {\n    const hook = getHook(ast)\n    if (Option.isSome(hook)) {\n      return hook.value(...ast.typeParameters.map(go))\n    }\n    throw new Error(errors_.getPrettyErrorMessage(`a declaration without annotations (${ast})`))\n  },\n  \"VoidKeyword\": getMatcher(() => \"void(0)\"),\n  \"NeverKeyword\": getMatcher(() => {\n    throw new Error(\"cannot pretty print a `never` value\")\n  }),\n  \"Literal\": getMatcher((literal: AST.LiteralValue): string =>\n    typeof literal === \"bigint\" ?\n      `${String(literal)}n` :\n      JSON.stringify(literal)\n  ),\n  \"SymbolKeyword\": toString,\n  \"UniqueSymbol\": toString,\n  \"TemplateLiteral\": stringify,\n  \"UndefinedKeyword\": toString,\n  \"UnknownKeyword\": formatUnknown,\n  \"AnyKeyword\": formatUnknown,\n  \"ObjectKeyword\": formatUnknown,\n  \"StringKeyword\": stringify,\n  \"NumberKeyword\": toString,\n  \"BooleanKeyword\": toString,\n  \"BigIntKeyword\": getMatcher((a) => `${String(a)}n`),\n  \"Enums\": stringify,\n  \"TupleType\": (ast, go) => {\n    const hook = getHook(ast)\n    if (Option.isSome(hook)) {\n      return hook.value()\n    }\n    const elements = ast.elements.map((e) => go(e.type))\n    const rest = ast.rest.map(go)\n    return (input: ReadonlyArray<unknown>) => {\n      const output: Array<string> = []\n      let i = 0\n      // ---------------------------------------------\n      // handle elements\n      // ---------------------------------------------\n      for (; i < elements.length; i++) {\n        if (input.length < i + 1) {\n          if (ast.elements[i].isOptional) {\n            continue\n          }\n        } else {\n          output.push(elements[i](input[i]))\n        }\n      }\n      // ---------------------------------------------\n      // handle rest element\n      // ---------------------------------------------\n      if (Arr.isNonEmptyReadonlyArray(rest)) {\n        const [head, ...tail] = rest\n        for (; i < input.length - tail.length; i++) {\n          output.push(head(input[i]))\n        }\n        // ---------------------------------------------\n        // handle post rest elements\n        // ---------------------------------------------\n        for (let j = 0; j < tail.length; j++) {\n          i += j\n          output.push(tail[j](input[i]))\n        }\n      }\n\n      return \"[\" + output.join(\", \") + \"]\"\n    }\n  },\n  \"TypeLiteral\": (ast, go) => {\n    const hook = getHook(ast)\n    if (Option.isSome(hook)) {\n      return hook.value()\n    }\n    const propertySignaturesTypes = ast.propertySignatures.map((f) => go(f.type))\n    const indexSignatureTypes = ast.indexSignatures.map((is) => go(is.type))\n    const expectedKeys: any = {}\n    for (let i = 0; i < propertySignaturesTypes.length; i++) {\n      expectedKeys[ast.propertySignatures[i].name] = null\n    }\n    return (input: { readonly [x: PropertyKey]: unknown }) => {\n      const output: Array<string> = []\n      // ---------------------------------------------\n      // handle property signatures\n      // ---------------------------------------------\n      for (let i = 0; i < propertySignaturesTypes.length; i++) {\n        const ps = ast.propertySignatures[i]\n        const name = ps.name\n        if (ps.isOptional && !Object.prototype.hasOwnProperty.call(input, name)) {\n          continue\n        }\n        output.push(\n          `${util_.formatPropertyKey(name)}: ${propertySignaturesTypes[i](input[name])}`\n        )\n      }\n      // ---------------------------------------------\n      // handle index signatures\n      // ---------------------------------------------\n      if (indexSignatureTypes.length > 0) {\n        for (let i = 0; i < indexSignatureTypes.length; i++) {\n          const type = indexSignatureTypes[i]\n          const keys = util_.getKeysForIndexSignature(input, ast.indexSignatures[i].parameter)\n          for (const key of keys) {\n            if (Object.prototype.hasOwnProperty.call(expectedKeys, key)) {\n              continue\n            }\n            output.push(`${util_.formatPropertyKey(key)}: ${type(input[key])}`)\n          }\n        }\n      }\n\n      return Arr.isNonEmptyReadonlyArray(output) ? \"{ \" + output.join(\", \") + \" }\" : \"{}\"\n    }\n  },\n  \"Union\": (ast, go) => {\n    const hook = getHook(ast)\n    if (Option.isSome(hook)) {\n      return hook.value()\n    }\n    const types = ast.types.map((ast) => [ParseResult.is({ ast } as any), go(ast)] as const)\n    return (a) => {\n      const index = types.findIndex(([is]) => is(a))\n      return types[index][1](a)\n    }\n  },\n  \"Suspend\": (ast, go) => {\n    return Option.match(getHook(ast), {\n      onNone: () => {\n        const get = util_.memoizeThunk(() => go(ast.f()))\n        return (a) => get()(a)\n      },\n      onSome: (handler) => handler()\n    })\n  },\n  \"Refinement\": (ast, go) => {\n    return Option.match(getHook(ast), {\n      onNone: () => go(ast.from),\n      onSome: (handler) => handler()\n    })\n  },\n  \"Transformation\": (ast, go) => {\n    return Option.match(getHook(ast), {\n      onNone: () => go(ast.to),\n      onSome: (handler) => handler()\n    })\n  }\n}\n\nconst compile = AST.getCompiler(match)\n"],"names":["Arr","Option","AST","errors_","util_","ParseResult","PrettyHookId","Symbol","for","pretty","handler","self","annotations","make","schema","compile","ast","getHook","getAnnotation","getMatcher","defaultPretty","match","onNone","onSome","toString","a","String","stringify","JSON","formatUnknown","Declaration","go","hook","isSome","value","typeParameters","map","Error","getPrettyErrorMessage","literal","TupleType","elements","e","type","rest","input","output","i","length","isOptional","push","isNonEmptyReadonlyArray","head","tail","j","join","TypeLiteral","propertySignaturesTypes","propertySignatures","f","indexSignatureTypes","indexSignatures","is","expectedKeys","name","ps","Object","prototype","hasOwnProperty","call","formatPropertyKey","keys","getKeysForIndexSignature","parameter","key","Union","types","index","findIndex","Suspend","get","memoizeThunk","Refinement","from","Transformation","to","getCompiler"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 13320, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@effect/schema/dist/esm/Schema.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/%40effect/schema/src/Schema.ts"],"sourcesContent":["/**\n * @since 1.0.0\n */\n\nimport * as array_ from \"effect/Array\"\nimport * as bigDecimal_ from \"effect/BigDecimal\"\nimport * as bigInt_ from \"effect/BigInt\"\nimport * as boolean_ from \"effect/Boolean\"\nimport * as brand_ from \"effect/Brand\"\nimport * as cause_ from \"effect/Cause\"\nimport * as chunk_ from \"effect/Chunk\"\nimport * as data_ from \"effect/Data\"\nimport * as duration_ from \"effect/Duration\"\nimport * as Effect from \"effect/Effect\"\nimport * as either_ from \"effect/Either\"\nimport * as Encoding from \"effect/Encoding\"\nimport * as Equal from \"effect/Equal\"\nimport * as Equivalence from \"effect/Equivalence\"\nimport * as exit_ from \"effect/Exit\"\nimport * as fiberId_ from \"effect/FiberId\"\nimport type { LazyArg } from \"effect/Function\"\nimport { dual, identity } from \"effect/Function\"\nimport * as hashMap_ from \"effect/HashMap\"\nimport * as hashSet_ from \"effect/HashSet\"\nimport * as list_ from \"effect/List\"\nimport * as number_ from \"effect/Number\"\nimport * as option_ from \"effect/Option\"\nimport type * as Order from \"effect/Order\"\nimport type { Pipeable } from \"effect/Pipeable\"\nimport { pipeArguments } from \"effect/Pipeable\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Request from \"effect/Request\"\nimport * as secret_ from \"effect/Secret\"\nimport * as sortedSet_ from \"effect/SortedSet\"\nimport * as string_ from \"effect/String\"\nimport type * as Types from \"effect/Types\"\nimport type { LazyArbitrary } from \"./Arbitrary.js\"\nimport * as arbitrary_ from \"./Arbitrary.js\"\nimport type { ParseOptions } from \"./AST.js\"\nimport * as AST from \"./AST.js\"\nimport * as equivalence_ from \"./Equivalence.js\"\nimport type * as fastCheck_ from \"./FastCheck.js\"\nimport * as errors_ from \"./internal/errors.js\"\nimport * as filters_ from \"./internal/filters.js\"\nimport * as serializable_ from \"./internal/serializable.js\"\nimport * as util_ from \"./internal/util.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport * as pretty_ from \"./Pretty.js\"\nimport type * as Serializable from \"./Serializable.js\"\nimport * as TreeFormatter from \"./TreeFormatter.js\"\n\n/**\n * @since 1.0.0\n */\nexport type SimplifyMutable<A> = {\n  -readonly [K in keyof A]: A[K]\n} extends infer B ? B : never\n\n/**\n * @since 1.0.0\n * @category symbol\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/schema/Schema\")\n\n/**\n * @since 1.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {\n  readonly ast: AST.AST\n  annotations(annotations: Annotations.Schema<A>): Schema<A, I, R>\n}\n\nconst variance = {\n  /* c8 ignore next */\n  _A: (_: any) => _,\n  /* c8 ignore next */\n  _I: (_: any) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\nconst toASTAnnotations = (\n  annotations?: Record<string | symbol, any> | undefined\n): AST.Annotations => {\n  if (!annotations) {\n    return {}\n  }\n  const out: Types.Mutable<AST.Annotations> = {}\n\n  // symbols are reserved for custom annotations\n  const custom = Object.getOwnPropertySymbols(annotations)\n  for (const sym of custom) {\n    out[sym] = annotations[sym]\n  }\n\n  // string keys are reserved as /schema namespace\n  if (annotations.typeId !== undefined) {\n    const typeId = annotations.typeId\n    if (typeof typeId === \"object\") {\n      out[AST.TypeAnnotationId] = typeId.id\n      out[typeId.id] = typeId.annotation\n    } else {\n      out[AST.TypeAnnotationId] = typeId\n    }\n  }\n  const move = (from: keyof typeof annotations, to: symbol) => {\n    if (annotations[from] !== undefined) {\n      out[to] = annotations[from]\n    }\n  }\n  move(\"message\", AST.MessageAnnotationId)\n  move(\"identifier\", AST.IdentifierAnnotationId)\n  move(\"title\", AST.TitleAnnotationId)\n  move(\"description\", AST.DescriptionAnnotationId)\n  move(\"examples\", AST.ExamplesAnnotationId)\n  move(\"default\", AST.DefaultAnnotationId)\n  move(\"documentation\", AST.DocumentationAnnotationId)\n  move(\"jsonSchema\", AST.JSONSchemaAnnotationId)\n  move(\"arbitrary\", arbitrary_.ArbitraryHookId)\n  move(\"pretty\", pretty_.PrettyHookId)\n  move(\"equivalence\", equivalence_.EquivalenceHookId)\n  move(\"concurrency\", AST.ConcurrencyAnnotationId)\n  move(\"batching\", AST.BatchingAnnotationId)\n  move(\"parseIssueTitle\", AST.ParseIssueTitleAnnotationId)\n\n  return out\n}\n\nclass SchemaImpl<in out A, in out I = A, out R = never> implements Schema.Variance<A, I, R>, Pipeable {\n  readonly [TypeId] = variance\n  constructor(readonly ast: AST.AST) {}\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  annotations(annotations: Annotations.Schema<A>): Schema<A, I, R> {\n    return new SchemaImpl(AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n  toString() {\n    return String(this.ast)\n  }\n}\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport declare namespace Annotable {\n  /**\n   * @since 1.0.0\n   */\n  export type Self<S extends All> = ReturnType<S[\"annotations\"]>\n\n  /**\n   * @since 1.0.0\n   */\n  export type Any = Annotable<any, any, any, unknown>\n\n  /**\n   * @since 1.0.0\n   */\n  export type All =\n    | Any\n    | Annotable<any, any, never, unknown>\n    | Annotable<any, never, any, unknown>\n    | Annotable<any, never, never, unknown>\n}\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.Schema<A>): Self\n}\n\n/**\n * @since 1.0.0\n */\nexport const asSchema = <S extends Schema.All>(\n  schema: S\n): Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>> => schema as any\n\n/**\n * @category hashing\n * @since 1.0.0\n */\nexport const hash = <A, I, R>(schema: Schema<A, I, R>): number => AST.hash(schema.ast)\n\n/**\n * @category formatting\n * @since 1.0.0\n */\nexport const format = <A, I, R>(schema: Schema<A, I, R>): string => String(schema.ast)\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Schema {\n  /**\n   * @since 1.0.0\n   */\n  export interface Variance<A, I, R> {\n    readonly [TypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _I: Types.Invariant<I>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type ToAsserts<S extends AnyNoContext> = (\n    input: unknown,\n    options?: AST.ParseOptions\n  ) => asserts input is Schema.Type<S>\n\n  /**\n   * Any schema, except for `never`.\n   *\n   * @since 1.0.0\n   */\n  export type Any = Schema<any, any, unknown>\n\n  /**\n   * Any schema with `Context = never`, except for `never`.\n   *\n   * @since 1.0.0\n   */\n  export type AnyNoContext = Schema<any, any, never>\n\n  /**\n   * Any schema, including `never`.\n   *\n   * @since 1.0.0\n   */\n  export type All =\n    | Any\n    | Schema<any, never, unknown>\n    | Schema<never, any, unknown>\n    | Schema<never, never, unknown>\n}\n\n/**\n * @since 1.0.0\n */\nexport const encodedSchema = <A, I, R>(schema: Schema<A, I, R>): Schema<I> => make(AST.encodedAST(schema.ast))\n\n/**\n * @since 1.0.0\n */\nexport const typeSchema = <A, I, R>(schema: Schema<A, I, R>): Schema<A> => make(AST.typeAST(schema.ast))\n\n/* c8 ignore start */\nexport {\n  /**\n   * @category validation\n   * @since 1.0.0\n   */\n  asserts,\n  /**\n   * @category decoding\n   * @since 1.0.0\n   */\n  decodeOption,\n  /**\n   * @category decoding\n   * @since 1.0.0\n   */\n  decodeSync,\n  /**\n   * @category decoding\n   * @since 1.0.0\n   */\n  decodeUnknownOption,\n  /**\n   * @category decoding\n   * @since 1.0.0\n   */\n  decodeUnknownSync,\n  /**\n   * @category encoding\n   * @since 1.0.0\n   */\n  encodeOption,\n  /**\n   * @category encoding\n   * @since 1.0.0\n   */\n  encodeSync,\n  /**\n   * @category encoding\n   * @since 1.0.0\n   */\n  encodeUnknownOption,\n  /**\n   * @category encoding\n   * @since 1.0.0\n   */\n  encodeUnknownSync,\n  /**\n   * @category validation\n   * @since 1.0.0\n   */\n  is,\n  /**\n   * @category validation\n   * @since 1.0.0\n   */\n  validateOption,\n  /**\n   * @category validation\n   * @since 1.0.0\n   */\n  validateSync\n} from \"./ParseResult.js\"\n/* c8 ignore end */\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const encodeUnknown = ParseResult.encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<I, ParseResult.ParseError, R> =>\n    ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<I, ParseResult.ParseError> =>\n    either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R> = encodeUnknown\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError> = encodeUnknownEither\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const encodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Promise<I> = encodeUnknownPromise\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const decodeUnknown = ParseResult.decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R> = decodeUnknown\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError> = decodeUnknownEither\n\n/**\n * @category decoding\n * @since 1.0.0\n */\nexport const decodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Promise<A> = decodeUnknownPromise\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const validate = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validate = ParseResult.validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const validateEither = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validateEither = ParseResult.validateEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 1.0.0\n */\nexport const validatePromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * Tests if a value is a `Schema`.\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isSchema = (u: unknown): u is Schema.Any =>\n  Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId])\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const make = <A, I = A, R = never>(ast: AST.AST): Schema<A, I, R> => new SchemaImpl(ast)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>\n  extends Annotable<Literal<Literals>, Literals[number]>\n{\n  readonly literals: Readonly<Literals>\n}\n\nclass LiteralImpl<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>> extends SchemaImpl<Literals[number]>\n  implements Literal<Literals>\n{\n  static ast = <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n    literals: Literals\n  ): AST.AST => {\n    return AST.isMembers(literals)\n      ? AST.Union.make(AST.mapMembers(literals, (literal) => new AST.Literal(literal)))\n      : new AST.Literal(literals[0])\n  }\n  readonly literals: Literals\n  constructor(literals: Literals, ast: AST.AST = LiteralImpl.ast(literals)) {\n    super(ast)\n    this.literals = [...literals]\n  }\n  annotations(annotations: Annotations.Schema<Literals[number]>) {\n    return new LiteralImpl(this.literals, AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Literal<Literals>\nexport function Literal(): Never\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]>\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]> | Never {\n  return array_.isNonEmptyReadonlyArray(literals) ? new LiteralImpl(literals) : Never\n}\n\n/**\n * Creates a new `Schema` from a literal schema.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n * import { Either } from \"effect\"\n *\n * const schema = S.Literal(\"a\", \"b\", \"c\").pipe(S.pickLiteral(\"a\", \"b\"))\n *\n * assert.deepStrictEqual(S.decodeSync(schema)(\"a\"), \"a\")\n * assert.deepStrictEqual(S.decodeSync(schema)(\"b\"), \"b\")\n * assert.strictEqual(Either.isLeft(S.decodeUnknownEither(schema)(\"c\")), true)\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const pickLiteral =\n  <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) =>\n  <I, R>(_schema: Schema<A, I, R>): Literal<[...L]> => Literal(...literals)\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const UniqueSymbolFromSelf = <S extends symbol>(symbol: S): Schema<S> => make(new AST.UniqueSymbol(symbol))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Enums<A extends { [x: string]: string | number }> extends Annotable<Enums<A>, A[keyof A]> {\n  readonly enums: A\n}\n\nclass EnumsImpl<A extends { [x: string]: string | number }> extends SchemaImpl<A[keyof A]> implements Enums<A> {\n  static ast = <A extends { [x: string]: string | number }>(enums: A): AST.AST => {\n    return new AST.Enums(\n      Object.keys(enums).filter(\n        (key) => typeof enums[enums[key]] !== \"number\"\n      ).map((key) => [key, enums[key]])\n    )\n  }\n  constructor(readonly enums: A, ast: AST.AST = EnumsImpl.ast(enums)) {\n    super(ast)\n  }\n  annotations(annotations: Annotations.Schema<A[keyof A]>) {\n    return new EnumsImpl(this.enums, AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const Enums = <A extends { [x: string]: string | number }>(enums: A): Enums<A> => new EnumsImpl(enums)\n\ntype Join<T> = T extends [infer Head, ...infer Tail]\n  ? `${Head & (string | number | bigint | boolean | null | undefined)}${Tail extends [] ? \"\"\n    : Join<Tail>}`\n  : never\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const TemplateLiteral = <T extends [Schema.AnyNoContext, ...Array<Schema.AnyNoContext>]>(\n  ...[head, ...tail]: T\n): Schema<Join<{ [K in keyof T]: Schema.Type<T[K]> }>> => {\n  let types: ReadonlyArray<AST.TemplateLiteral | AST.Literal> = getTemplateLiterals(head.ast)\n  for (const span of tail) {\n    types = array_.flatMap(\n      types,\n      (a) => getTemplateLiterals(span.ast).map((b) => combineTemplateLiterals(a, b))\n    )\n  }\n  return make(AST.Union.make(types))\n}\n\nconst combineTemplateLiterals = (\n  a: AST.TemplateLiteral | AST.Literal,\n  b: AST.TemplateLiteral | AST.Literal\n): AST.TemplateLiteral | AST.Literal => {\n  if (AST.isLiteral(a)) {\n    return AST.isLiteral(b) ?\n      new AST.Literal(String(a.literal) + String(b.literal)) :\n      AST.TemplateLiteral.make(String(a.literal) + b.head, b.spans)\n  }\n  if (AST.isLiteral(b)) {\n    return AST.TemplateLiteral.make(\n      a.head,\n      array_.modifyNonEmptyLast(\n        a.spans,\n        (span) => new AST.TemplateLiteralSpan(span.type, span.literal + String(b.literal))\n      )\n    )\n  }\n  return AST.TemplateLiteral.make(\n    a.head,\n    array_.appendAll(\n      array_.modifyNonEmptyLast(\n        a.spans,\n        (span) => new AST.TemplateLiteralSpan(span.type, span.literal + String(b.head))\n      ),\n      b.spans\n    )\n  )\n}\n\nconst getTemplateLiterals = (\n  ast: AST.AST\n): ReadonlyArray<AST.TemplateLiteral | AST.Literal> => {\n  switch (ast._tag) {\n    case \"Literal\":\n      return [ast]\n    case \"NumberKeyword\":\n    case \"StringKeyword\":\n      return [AST.TemplateLiteral.make(\"\", [new AST.TemplateLiteralSpan(ast, \"\")])]\n    case \"Union\":\n      return array_.flatMap(ast.types, getTemplateLiterals)\n    default:\n      throw new Error(`unsupported template literal span (${ast})`)\n  }\n}\n\nconst declareConstructor = <\n  const TypeParameters extends ReadonlyArray<Schema.Any>,\n  I,\n  A\n>(\n  typeParameters: TypeParameters,\n  options: {\n    readonly decode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n    readonly encode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n  },\n  annotations?: Annotations.Schema<A, TypeParameters>\n): Schema<A, I, Schema.Context<TypeParameters[number]>> =>\n  make(\n    new AST.Declaration(\n      typeParameters.map((tp) => tp.ast),\n      (...typeParameters) => options.decode(...typeParameters.map(make) as any),\n      (...typeParameters) => options.encode(...typeParameters.map(make) as any),\n      toASTAnnotations(annotations)\n    )\n  )\n\nconst declarePrimitive = <A>(\n  is: (input: unknown) => input is A,\n  annotations?: Annotations.Schema<A>\n): Schema<A> => {\n  const decodeUnknown = () => (input: unknown, _: ParseOptions, ast: AST.Declaration) =>\n    is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input))\n  const encodeUnknown = decodeUnknown\n  return make(new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)))\n}\n\n/**\n * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const declare: {\n  <A>(\n    is: (input: unknown) => input is A,\n    annotations?: Annotations.Schema<A>\n  ): Schema<A>\n  <const P extends ReadonlyArray<Schema.Any>, I, A>(\n    typeParameters: P,\n    options: {\n      readonly decode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n      readonly encode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n    },\n    annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]> }>\n  ): Schema<A, I, Schema.Context<P[number]>>\n} = function() {\n  if (Array.isArray(arguments[0])) {\n    const typeParameters = arguments[0]\n    const options = arguments[1]\n    const annotations = arguments[2]\n    return declareConstructor(typeParameters, options, annotations)\n  }\n  const is = arguments[0]\n  const annotations = arguments[1]\n  return declarePrimitive(is, annotations)\n} as any\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const BrandTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Brand\")\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const fromBrand = <C extends brand_.Brand<string | symbol>>(\n  constructor: brand_.Brand.Constructor<C>,\n  annotations?: Annotations.Filter<brand_.Brand.Unbranded<C>>\n) =>\n<R, I, A extends brand_.Brand.Unbranded<C>>(self: Schema<A, I, R>): Schema<A & C, I, R> =>\n  make(\n    new AST.Refinement(\n      self.ast,\n      (a: A, _: ParseOptions, ast: AST.AST): option_.Option<ParseResult.ParseIssue> => {\n        const either = constructor.either(a)\n        return either_.isLeft(either) ?\n          option_.some(new ParseResult.Type(ast, a, either.left.map((v) => v.message).join(\", \"))) :\n          option_.none()\n      },\n      toASTAnnotations({ typeId: { id: BrandTypeId, annotation: { constructor } }, ...annotations })\n    )\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const InstanceOfTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/InstanceOf\")\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface instanceOf<A> extends Annotable<instanceOf<A>, A> {}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const instanceOf = <A extends abstract new(...args: any) => any>(\n  constructor: A,\n  annotations?: Annotations.Schema<InstanceType<A>>\n): instanceOf<InstanceType<A>> =>\n  declare(\n    (u): u is InstanceType<A> => u instanceof constructor,\n    {\n      title: constructor.name,\n      description: `an instance of ${constructor.name}`,\n      pretty: (): pretty_.Pretty<InstanceType<A>> => String,\n      typeId: { id: InstanceOfTypeId, annotation: { constructor } },\n      ...annotations\n    }\n  )\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Undefined extends Annotable<Undefined, undefined> {}\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport const Undefined: Undefined = make(AST.undefinedKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Void extends Annotable<Void, void> {}\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport const Void: Void = make(AST.voidKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Null extends Annotable<Null, null> {}\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport const Null: Null = make(AST.null)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Never extends Annotable<Never, never> {}\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport const Never: Never = make(AST.neverKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Unknown extends Annotable<Unknown, unknown> {}\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport const Unknown: Unknown = make(AST.unknownKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Any extends Annotable<Any, any> {}\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport const Any: Any = make(AST.anyKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $String extends Annotable<$String, string> {}\n\nconst $String: $String = make(AST.stringKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $Number extends Annotable<$Number, number> {}\n\nconst $Number: $Number = make(AST.numberKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $Boolean extends Annotable<$Boolean, boolean> {}\n\nconst $Boolean: $Boolean = make(AST.booleanKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface BigIntFromSelf extends Annotable<BigIntFromSelf, bigint> {}\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport const BigIntFromSelf: BigIntFromSelf = make(AST.bigIntKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface SymbolFromSelf extends Annotable<SymbolFromSelf, symbol> {}\n\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport const SymbolFromSelf: SymbolFromSelf = make(AST.symbolKeyword)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $Object extends Annotable<$Object, object> {}\n\nconst $Object: $Object = make(AST.objectKeyword)\n\nexport {\n  /**\n   * @category primitives\n   * @since 1.0.0\n   */\n  $Boolean as Boolean,\n  /**\n   * @category primitives\n   * @since 1.0.0\n   */\n  $Number as Number,\n  /**\n   * @category primitives\n   * @since 1.0.0\n   */\n  $Object as Object,\n  /**\n   * @category primitives\n   * @since 1.0.0\n   */\n  $String as String\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Union<Members extends ReadonlyArray<Schema.Any>> extends\n  Schema<\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >\n{\n  readonly members: Readonly<Members>\n  annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members>\n}\n\nclass UnionImpl<Members extends ReadonlyArray<Schema.Any>>\n  extends SchemaImpl<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>\n  implements Union<Members>\n{\n  static ast = <Members extends ReadonlyArray<Schema.Any>>(members: Members): AST.AST => {\n    return AST.Union.members(members.map((m) => m.ast))\n  }\n  readonly members: Readonly<Members>\n  constructor(members: Members, ast: AST.AST = UnionImpl.ast(members)) {\n    super(ast)\n    this.members = [...members] as any as Members\n  }\n  annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>) {\n    return new UnionImpl(this.members, AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n}\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function Union<Members extends AST.Members<Schema.Any>>(...members: Members): Union<Members>\nexport function Union<Member extends Schema.Any>(member: Member): Member\nexport function Union(): Never\nexport function Union<Members extends ReadonlyArray<Schema.Any>>(\n  ...members: Members\n): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>\nexport function Union<Members extends ReadonlyArray<Schema.Any>>(\n  ...members: Members\n): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>> | Never {\n  return AST.isMembers(members)\n    ? new UnionImpl(members)\n    : array_.isNonEmptyReadonlyArray(members)\n    ? members[0] as any\n    : Never\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface NullOr<S extends Schema.Any> extends Union<[S, Null]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>\n}\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const NullOr = <S extends Schema.Any>(self: S): NullOr<S> => Union(self, Null)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface UndefinedOr<S extends Schema.Any> extends Union<[S, Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>\n}\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const UndefinedOr = <S extends Schema.Any>(self: S): UndefinedOr<S> => Union(self, Undefined)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface NullishOr<S extends Schema.Any> extends Union<[S, Null, Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>\n}\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const NullishOr = <S extends Schema.Any>(self: S): NullishOr<S> => Union(self, Null, Undefined)\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const keyof = <A, I, R>(self: Schema<A, I, R>): Schema<keyof A> => make<keyof A>(AST.keyof(self.ast))\n\n/**\n * @since 1.0.0\n */\nexport interface OptionalElement<E extends Schema.Any>\n  extends Schema.Variance<Schema.Type<E>, Schema.Encoded<E>, Schema.Context<E>>\n{\n  readonly optionalElement: E\n}\n\n/**\n * @since 1.0.0\n */\nexport const optionalElement = <E extends Schema.Any>(self: E): OptionalElement<E> => new OptionalElementImpl(self)\n\nclass OptionalElementImpl<E extends Schema.Any> implements OptionalElement<E> {\n  readonly [TypeId]!: Schema.Variance<Schema.Type<E>, Schema.Encoded<E>, Schema.Context<E>>[TypeId]\n  constructor(readonly optionalElement: E) {}\n  toString() {\n    return `${this.optionalElement.ast}?`\n  }\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace TupleType {\n  type ElementsType<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends OptionalElement<infer T> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]>\n    : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]>\n    : Out\n\n  type ElementsEncoded<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends OptionalElement<infer T> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]>\n    : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]>\n    : Out\n\n  /**\n   * @since 1.0.0\n   */\n  export type Element = Schema.Any | OptionalElement<Schema.Any>\n\n  /**\n   * @since 1.0.0\n   */\n  export type Elements = ReadonlyArray<Element>\n\n  /**\n   * @since 1.0.0\n   */\n  export type Type<\n    Elements extends TupleType.Elements,\n    Rest extends ReadonlyArray<Schema.Any>\n  > = Rest extends [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsType<Elements>,\n      ...ReadonlyArray<Schema.Type<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Type<Tail[K]> }\n    ]> :\n    ElementsType<Elements>\n\n  /**\n   * @since 1.0.0\n   */\n  export type Encoded<\n    Elements extends TupleType.Elements,\n    Rest extends ReadonlyArray<Schema.Any>\n  > = Rest extends [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsEncoded<Elements>,\n      ...ReadonlyArray<Schema.Encoded<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Encoded<Tail[K]> }\n    ]> :\n    ElementsEncoded<Elements>\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface TupleType<\n  Elements extends TupleType.Elements,\n  Rest extends ReadonlyArray<Schema.Any>\n> extends\n  Schema<\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >\n{\n  readonly elements: Readonly<Elements>\n  readonly rest: Readonly<Rest>\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>): TupleType<Elements, Rest>\n}\n\nclass TupleTypeImpl<\n  Elements extends TupleType.Elements,\n  Rest extends ReadonlyArray<Schema.Any>\n> extends SchemaImpl<\n  TupleType.Type<Elements, Rest>,\n  TupleType.Encoded<Elements, Rest>,\n  Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n> implements TupleType<Elements, Rest> {\n  static ast = <\n    Elements extends TupleType.Elements,\n    Rest extends ReadonlyArray<Schema.Any>\n  >(\n    elements: Elements,\n    rest: Rest\n  ): AST.AST => {\n    return new AST.TupleType(\n      elements.map((schema) =>\n        isSchema(schema) ? new AST.Element(schema.ast, false) : new AST.Element(schema.optionalElement.ast, true)\n      ),\n      rest.map((e) => e.ast),\n      true\n    )\n  }\n  constructor(\n    readonly elements: Elements,\n    readonly rest: Rest,\n    ast: AST.AST = TupleTypeImpl.ast(elements, rest)\n  ) {\n    super(ast)\n  }\n  annotations(\n    annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>\n  ): TupleType<Elements, Rest> {\n    return new TupleTypeImpl(this.elements, this.rest, AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function Tuple<\n  const Elements extends TupleType.Elements,\n  Rest extends array_.NonEmptyReadonlyArray<Schema.Any>\n>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>\nexport function Tuple<Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>\nexport function Tuple(...args: ReadonlyArray<any>): any {\n  return Array.isArray(args[0])\n    ? new TupleTypeImpl(args[0], args.slice(1))\n    : new TupleTypeImpl(args, [])\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $Array<Value extends Schema.Any> extends TupleType<[], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): $Array<Value>\n}\n\nclass $ArrayImpl<Value extends Schema.Any> extends TupleTypeImpl<[], [Value]> implements $Array<Value> {\n  constructor(readonly value: Value, ast?: AST.AST) {\n    super([], [value], ast)\n  }\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>) {\n    return new $ArrayImpl(this.value, AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n}\n\nconst $Array = <Value extends Schema.Any>(value: Value): $Array<Value> => new $ArrayImpl(value)\n\nexport {\n  /**\n   * @category constructors\n   * @since 1.0.0\n   */\n  $Array as Array\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface NonEmptyArray<Value extends Schema.Any> extends TupleType<[Value], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>): NonEmptyArray<Value>\n}\n\nclass NonEmptyArrayImpl<Value extends Schema.Any> extends TupleTypeImpl<[Value], [Value]>\n  implements NonEmptyArray<Value>\n{\n  constructor(readonly value: Value, ast?: AST.AST) {\n    super([value], [value], ast)\n  }\n  annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>) {\n    return new NonEmptyArrayImpl(this.value, AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const NonEmptyArray = <Value extends Schema.Any>(value: Value): NonEmptyArray<Value> =>\n  new NonEmptyArrayImpl(value)\n\n/**\n * @since 1.0.0\n */\nexport declare namespace PropertySignature {\n  /**\n   * @since 1.0.0\n   */\n  export type Token = \"?:\" | \":\"\n\n  /**\n   * @since 1.0.0\n   */\n  export type GetToken<B extends boolean> = B extends true ? \"?:\" : \":\"\n\n  /**\n   * @since 1.0.0\n   */\n  export type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<Token, any, Key, Token, any, unknown>\n\n  /**\n   * @since 1.0.0\n   */\n  export type All<Key extends PropertyKey = PropertyKey> =\n    | Any<Key>\n    | PropertySignature<Token, never, Key, Token, any, unknown>\n    | PropertySignature<Token, any, Key, Token, never, unknown>\n    | PropertySignature<Token, never, Key, Token, never, unknown>\n\n  /**\n   * @since 1.0.0\n   */\n  export type AST =\n    | PropertySignatureDeclaration\n    | PropertySignatureTransformation\n\n  /**\n   * @since 1.0.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {}\n}\n\nconst formatToken = (isOptional: boolean): string => isOptional ? \"\\\"?:\\\"\" : \"\\\":\\\"\"\n\n/**\n * @category PropertySignature\n * @since 1.0.0\n */\nexport class PropertySignatureDeclaration {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"PropertySignatureDeclaration\"\n  constructor(\n    readonly type: AST.AST,\n    readonly isOptional: boolean,\n    readonly isReadonly: boolean,\n    readonly annotations: AST.Annotations\n  ) {}\n  /**\n   * @since 1.0.0\n   */\n  toString() {\n    const token = formatToken(this.isOptional)\n    const type = String(this.type)\n    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 1.0.0\n */\nexport class FromPropertySignature implements AST.Annotated {\n  constructor(\n    readonly type: AST.AST,\n    readonly isOptional: boolean,\n    readonly isReadonly: boolean,\n    readonly annotations: AST.Annotations,\n    readonly fromKey?: PropertyKey | undefined\n  ) {}\n}\n\n/**\n * @category PropertySignature\n * @since 1.0.0\n */\nexport class ToPropertySignature implements AST.Annotated {\n  constructor(\n    readonly type: AST.AST,\n    readonly isOptional: boolean,\n    readonly isReadonly: boolean,\n    readonly annotations: AST.Annotations\n  ) {}\n}\n\nconst formatPropertyKey = (p: PropertyKey | undefined): string => {\n  if (p === undefined) {\n    return \"never\"\n  }\n  if (Predicate.isString(p)) {\n    return JSON.stringify(p)\n  }\n  return String(p)\n}\n\n/**\n * @category PropertySignature\n * @since 1.0.0\n */\nexport class PropertySignatureTransformation {\n  /**\n   * @since 1.0.0\n   */\n  readonly _tag = \"PropertySignatureTransformation\"\n  constructor(\n    readonly from: FromPropertySignature,\n    readonly to: ToPropertySignature,\n    readonly decode: AST.PropertySignatureTransformation[\"decode\"],\n    readonly encode: AST.PropertySignatureTransformation[\"encode\"]\n  ) {}\n  /**\n   * @since 1.0.0\n   */\n  toString() {\n    return `PropertySignature<${formatToken(this.to.isOptional)}, ${this.to.type}, ${\n      formatPropertyKey(this.from.fromKey)\n    }, ${formatToken(this.from.isOptional)}, ${this.from.type}>`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category symbol\n */\nexport const PropertySignatureTypeId: unique symbol = Symbol.for(\"@effect/schema/PropertySignature\")\n\n/**\n * @since 1.0.0\n * @category symbol\n */\nexport type PropertySignatureTypeId = typeof PropertySignatureTypeId\n\nconst propertySignatureAnnotations_ = (\n  ast: PropertySignature.AST,\n  annotations: AST.Annotations\n): PropertySignature.AST => {\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return new PropertySignatureDeclaration(\n        ast.type,\n        ast.isOptional,\n        ast.isReadonly,\n        { ...ast.annotations, ...annotations }\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      return new PropertySignatureTransformation(\n        new FromPropertySignature(\n          ast.from.type,\n          ast.from.isOptional,\n          ast.from.isReadonly,\n          ast.from.annotations\n        ),\n        new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {\n          ...ast.to.annotations,\n          ...annotations\n        }),\n        ast.decode,\n        ast.encode\n      )\n    }\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 1.0.0\n */\nexport interface PropertySignature<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  R = never\n> extends Schema.Variance<Type, Encoded, R>, Pipeable {\n  readonly [PropertySignatureTypeId]: null\n  readonly _EncodedToken: EncodedToken\n  readonly _TypeToken: TypeToken\n  readonly _Key: Key\n  readonly ast: PropertySignature.AST\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, R>\n}\n\n/** @internal */\nexport class PropertySignatureImpl<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  R = never\n> implements PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, R> {\n  readonly [TypeId]!: Schema.Variance<Type, Encoded, R>[TypeId]\n  readonly [PropertySignatureTypeId] = null\n  readonly _Key!: Key\n  readonly _EncodedToken!: EncodedToken\n  readonly _TypeToken!: TypeToken\n\n  constructor(\n    readonly ast: PropertySignature.AST\n  ) {}\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, R> {\n    return new PropertySignatureImpl(propertySignatureAnnotations_(this.ast, toASTAnnotations(annotations)))\n  }\n\n  toString() {\n    return String(this.ast)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 1.0.0\n */\nexport const propertySignature = <A, I, R>(\n  self: Schema<A, I, R>\n): PropertySignature<PropertySignature.GetToken<false>, A, never, PropertySignature.GetToken<false>, I, R> =>\n  new PropertySignatureImpl(new PropertySignatureDeclaration(self.ast, false, true, {}))\n\n/**\n * @category PropertySignature\n * @since 1.0.0\n */\nexport const fromKey: {\n  <Key extends PropertyKey>(key: Key): <\n    Type,\n    TypeToken extends PropertySignature.Token,\n    Encoded,\n    EncodedToken extends PropertySignature.Token,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, R>\n  <\n    Type,\n    TypeToken extends PropertySignature.Token,\n    Encoded,\n    EncodedToken extends PropertySignature.Token,\n    R,\n    Key extends PropertyKey\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, R>,\n    key: Key\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, R>\n} = dual(2, <\n  Type,\n  TypeToken extends PropertySignature.Token,\n  Encoded,\n  EncodedToken extends PropertySignature.Token,\n  R,\n  Key extends PropertyKey\n>(\n  self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, R>,\n  key: Key\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return new PropertySignatureImpl(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.type,\n            ast.isOptional,\n            ast.isReadonly,\n            ast.annotations,\n            key\n          ),\n          new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}),\n          identity,\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\":\n      return new PropertySignatureImpl(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.from.type,\n            ast.from.isOptional,\n            ast.from.isReadonly,\n            ast.from.annotations,\n            key\n          ),\n          ast.to,\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * - `decode`: `none` as argument means: the value is missing in the input\n * - `encode`: `none` as return value means: the value will be missing in the output\n *\n * @category PropertySignature\n * @since 1.0.0\n */\nexport const optionalToRequired = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => TI\n    readonly encode: (ti: TI) => option_.Option<FA>\n  }\n): PropertySignature<\":\", TA, never, \"?:\", FI, FR | TR> =>\n  new PropertySignatureImpl(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, false, true, {}),\n      (o) => option_.some(options.decode(o)),\n      option_.flatMap(options.encode)\n    )\n  )\n\n/**\n * - `decode`:\n *   - `none` as argument means: the value is missing in the input\n *   - `none` as return value means: the value will be missing in the output\n * - `encode`:\n *   - `none` as argument means: the value is missing in the input\n *   - `none` as return value means: the value will be missing in the output\n *\n * @category PropertySignature\n * @since 1.0.0\n */\nexport const optionalToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>\n  }\n): PropertySignature<\"?:\", TA, never, \"?:\", FI, FR | TR> =>\n  new PropertySignatureImpl(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}),\n      options.decode,\n      options.encode\n    )\n  )\n\n/**\n * @category PropertySignature\n * @since 1.0.0\n */\nexport const optional: {\n  <\n    A,\n    const Options extends {\n      readonly default?: never\n      readonly as?: never\n      readonly exact?: true\n      readonly nullable?: true\n    } | {\n      readonly default: () => A\n      readonly as?: never\n      readonly exact?: true\n      readonly nullable?: true\n    } | {\n      readonly as: \"Option\"\n      readonly default?: never\n      readonly exact?: true\n      readonly nullable?: true\n    } | undefined\n  >(\n    options?: Options\n  ): <I, R>(schema: Schema<A, I, R>) => [undefined] extends [Options] ? PropertySignature<\n      \"?:\",\n      A | undefined,\n      never,\n      \"?:\",\n      I | undefined,\n      R\n    > :\n    PropertySignature<\n      Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<A> : A)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n      never,\n      \"?:\",\n      | I\n      | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n      | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n      R\n    >\n  <\n    A,\n    I,\n    R,\n    const Options extends {\n      readonly default?: never\n      readonly as?: never\n      readonly exact?: true\n      readonly nullable?: true\n    } | {\n      readonly default: () => A\n      readonly as?: never\n      readonly exact?: true\n      readonly nullable?: true\n    } | {\n      readonly as: \"Option\"\n      readonly default?: never\n      readonly exact?: true\n      readonly nullable?: true\n    } | undefined\n  >(\n    schema: Schema<A, I, R>,\n    options?: Options\n  ): [undefined] extends [Options] ? PropertySignature<\n      \"?:\",\n      A | undefined,\n      never,\n      \"?:\",\n      I | undefined,\n      R\n    > :\n    PropertySignature<\n      Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<A> : A)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n      never,\n      \"?:\",\n      | I\n      | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n      | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n      R\n    >\n} = dual((args) => isSchema(args[0]), <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: {\n    readonly exact?: true\n    readonly default?: () => A\n    readonly nullable?: true\n    readonly as?: \"Option\"\n  }\n): PropertySignature<any, any, never, any, any, any> => {\n  const isExact = options?.exact\n  const defaultValue = options?.default\n  const isNullable = options?.nullable\n  const asOption = options?.as == \"Option\"\n\n  if (isExact) {\n    if (defaultValue) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullOr(schema),\n          typeSchema(schema),\n          {\n            decode: option_.match({ onNone: defaultValue, onSome: (a) => a === null ? defaultValue() : a }),\n            encode: option_.some\n          }\n        )\n      } else {\n        return optionalToRequired(\n          schema,\n          typeSchema(schema),\n          { decode: option_.match({ onNone: defaultValue, onSome: identity }), encode: option_.some }\n        )\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullOr(schema),\n          OptionFromSelf(typeSchema(schema)),\n          { decode: option_.filter(Predicate.isNotNull<A | null>), encode: identity }\n        )\n      } else {\n        return optionalToRequired(\n          schema,\n          OptionFromSelf(typeSchema(schema)),\n          { decode: identity, encode: identity }\n        )\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullOr(schema),\n          typeSchema(schema),\n          { decode: option_.filter(Predicate.isNotNull<A | null>), encode: identity }\n        )\n      } else {\n        return new PropertySignatureImpl(new PropertySignatureDeclaration(schema.ast, true, true, {}))\n      }\n    }\n  } else {\n    if (defaultValue) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullishOr(schema),\n          typeSchema(schema),\n          {\n            decode: option_.match({ onNone: defaultValue, onSome: (a) => (a == null ? defaultValue() : a) }),\n            encode: option_.some\n          }\n        )\n      } else {\n        return optionalToRequired(\n          UndefinedOr(schema),\n          typeSchema(schema),\n          {\n            decode: option_.match({ onNone: defaultValue, onSome: (a) => (a === undefined ? defaultValue() : a) }),\n            encode: option_.some\n          }\n        )\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullishOr(schema),\n          OptionFromSelf(typeSchema(schema)),\n          { decode: option_.filter<A | null | undefined, A>((a): a is A => a != null), encode: identity }\n        )\n      } else {\n        return optionalToRequired(\n          UndefinedOr(schema),\n          OptionFromSelf(typeSchema(schema)),\n          { decode: option_.filter(Predicate.isNotUndefined<A | undefined>), encode: identity }\n        )\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullishOr(schema),\n          UndefinedOr(typeSchema(schema)),\n          { decode: option_.filter(Predicate.isNotNull<A | null | undefined>), encode: identity }\n        )\n      } else {\n        return new PropertySignatureImpl(\n          new PropertySignatureDeclaration(UndefinedOr(schema).ast, true, true, {})\n        )\n      }\n    }\n  }\n})\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Struct {\n  /**\n   * @since 1.0.0\n   */\n  export type Fields = {\n    readonly [x: PropertyKey]:\n      | Schema.All\n      | PropertySignature.All\n  }\n\n  type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never :\n    F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key :\n    K\n\n  type EncodedTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", any, unknown>\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", never, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", any, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", never, unknown> ? K\n      : never\n  }[keyof Fields]\n\n  type TypeTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends OptionalPropertySignature ? K : never\n  }[keyof Fields]\n\n  type OptionalPropertySignature =\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, any, unknown>\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, never, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, any, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, never, unknown>\n\n  /**\n   * @since 1.0.0\n   */\n  export type Type<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalPropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type Encoded<F extends Fields> =\n    & { readonly [K in Exclude<keyof F, EncodedTokenKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]> }\n    & { readonly [K in EncodedTokenKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]> }\n\n  /**\n   * @since 1.0.0\n   */\n  export type Context<F extends Fields> = Schema.Context<F[keyof F]>\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace IndexSignature {\n  /**\n   * @since 1.0.0\n   */\n  export type Record = { readonly key: Schema.All; readonly value: Schema.All }\n\n  /**\n   * @since 1.0.0\n   */\n  export type Records = ReadonlyArray<Record>\n\n  /**\n   * @since 1.0.0\n   */\n  export type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>\n\n  /**\n   * @since 1.0.0\n   */\n  export type Type<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Type<Records[K][\"key\"]>]: Schema.Type<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 1.0.0\n   */\n  export type Encoded<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Encoded<Records[K][\"key\"]>]: Schema.Encoded<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 1.0.0\n   */\n  export type Context<Records extends IndexSignature.Records> = {\n    [K in keyof Records]: Schema.Context<Records[K][\"key\"]> | Schema.Context<Records[K][\"value\"]>\n  }[number]\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace TypeLiteral {\n  /**\n   * @since 1.0.0\n   */\n  export type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Type<Fields>\n    & IndexSignature.Type<Records>\n\n  /**\n   * @since 1.0.0\n   */\n  export type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Encoded<Fields>\n    & IndexSignature.Encoded<Records>\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface TypeLiteral<\n  Fields extends Struct.Fields,\n  Records extends IndexSignature.Records\n> extends\n  Schema<\n    Types.Simplify<TypeLiteral.Type<Fields, Records>>,\n    Types.Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >\n{\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n  readonly records: Readonly<Records>\n  annotations(\n    annotations: Annotations.Schema<Types.Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records>\n}\n\nconst isPropertySignature = (u: unknown): u is PropertySignature.All =>\n  Predicate.hasProperty(u, PropertySignatureTypeId)\n\nclass TypeLiteralImpl<\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n> extends SchemaImpl<\n  Types.Simplify<TypeLiteral.Type<Fields, Records>>,\n  Types.Simplify<TypeLiteral.Encoded<Fields, Records>>,\n  | Struct.Context<Fields>\n  | IndexSignature.Context<Records>\n> implements TypeLiteral<Fields, Records> {\n  static ast = <\n    Fields extends Struct.Fields,\n    const Records extends IndexSignature.Records\n  >(fields: Fields, records: Records): AST.AST => {\n    const ownKeys = util_.ownKeys(fields)\n    const pss: Array<AST.PropertySignature> = []\n    if (ownKeys.length > 0) {\n      const from: Array<AST.PropertySignature> = []\n      const to: Array<AST.PropertySignature> = []\n      const transformations: Array<AST.PropertySignatureTransformation> = []\n      for (let i = 0; i < ownKeys.length; i++) {\n        const key = ownKeys[i]\n        const field = fields[key]\n        if (isPropertySignature(field)) {\n          const ast: PropertySignature.AST = field.ast\n          switch (ast._tag) {\n            case \"PropertySignatureDeclaration\": {\n              const type = ast.type\n              const isOptional = ast.isOptional\n              const toAnnotations = ast.annotations\n              from.push(new AST.PropertySignature(key, type, isOptional, true))\n              to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations))\n              pss.push(\n                new AST.PropertySignature(key, type, isOptional, true, toAnnotations)\n              )\n              break\n            }\n            case \"PropertySignatureTransformation\": {\n              const fromKey = ast.from.fromKey ?? key\n              from.push(\n                new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations)\n              )\n              to.push(\n                new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations)\n              )\n              transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode))\n              break\n            }\n          }\n        } else {\n          from.push(new AST.PropertySignature(key, field.ast, false, true))\n          to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true))\n          pss.push(new AST.PropertySignature(key, field.ast, false, true))\n        }\n      }\n      if (array_.isNonEmptyReadonlyArray(transformations)) {\n        const issFrom: Array<AST.IndexSignature> = []\n        const issTo: Array<AST.IndexSignature> = []\n        for (const r of records) {\n          const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n          propertySignatures.forEach((ps) => {\n            from.push(ps)\n            to.push(\n              new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations)\n            )\n          })\n          indexSignatures.forEach((is) => {\n            issFrom.push(is)\n            issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly))\n          })\n        }\n        return new AST.Transformation(\n          new AST.TypeLiteral(from, issFrom, { [AST.TitleAnnotationId]: \"Struct (Encoded side)\" }),\n          new AST.TypeLiteral(to, issTo, { [AST.TitleAnnotationId]: \"Struct (Type side)\" }),\n          new AST.TypeLiteralTransformation(transformations)\n        )\n      }\n    }\n    const iss: Array<AST.IndexSignature> = []\n    for (const r of records) {\n      const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n      propertySignatures.forEach((ps) => pss.push(ps))\n      indexSignatures.forEach((is) => iss.push(is))\n    }\n    return new AST.TypeLiteral(pss, iss)\n  }\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n  readonly records: Readonly<Records>\n  constructor(\n    fields: Fields,\n    records: Records,\n    ast: AST.AST = TypeLiteralImpl.ast(fields, records)\n  ) {\n    super(ast)\n    this.fields = { ...fields }\n    this.records = [...records] as Records\n  }\n  annotations(\n    annotations: Annotations.Schema<Types.Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records> {\n    return new TypeLiteralImpl(this.fields, this.records, AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Struct<Fields extends Struct.Fields> extends TypeLiteral<Fields, []> {\n  annotations(annotations: Annotations.Schema<Types.Simplify<Struct.Type<Fields>>>): Struct<Fields>\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records>\nexport function Struct<Fields extends Struct.Fields>(fields: Fields): Struct<Fields>\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records> {\n  return new TypeLiteralImpl(fields, records)\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $Record<K extends Schema.All, V extends Schema.All> extends TypeLiteral<{}, [{ key: K; value: V }]> {\n  readonly key: K\n  readonly value: V\n  annotations(\n    annotations: Annotations.Schema<Types.Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n  ): $Record<K, V>\n}\n\nclass $RecordImpl<K extends Schema.All, V extends Schema.All> extends TypeLiteralImpl<\n  {},\n  [{ key: K; value: V }]\n> implements $Record<K, V> {\n  constructor(readonly key: K, readonly value: V, ast?: AST.AST) {\n    super({}, [{ key, value }], ast)\n  }\n  annotations(annotations: Annotations.Schema<Types.Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>) {\n    return new $RecordImpl(this.key, this.value, AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const Record = <K extends Schema.All, V extends Schema.All>(key: K, value: V): $Record<K, V> =>\n  new $RecordImpl(key, value)\n\n/**\n * @category struct transformations\n * @since 1.0.0\n */\nexport const pick = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): Schema<Types.Simplify<Pick<A, Keys[number]>>, Types.Simplify<Pick<I, Keys[number]>>, R> =>\n  make(AST.pick(self.ast, keys))\n\n/**\n * @category struct transformations\n * @since 1.0.0\n */\nexport const omit = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): Schema<Types.Simplify<Omit<A, Keys[number]>>, Types.Simplify<Omit<I, Keys[number]>>, R> =>\n  make(AST.omit(self.ast, keys))\n\n/**\n * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * // ---------------------------------------------\n * // use case: pull out a single field from a\n * // struct through a transformation\n * // ---------------------------------------------\n *\n * const mytable = S.Struct({\n *   column1: S.NumberFromString,\n *   column2: S.Number\n * })\n *\n * // const pullOutColumn: S.Schema<number, {\n * //     readonly column1: string;\n * // }, never>\n * const pullOutColumn = mytable.pipe(S.pluck(\"column1\"))\n *\n * console.log(S.decodeUnknownEither(S.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n *\n * @category struct transformations\n * @since 1.0.0\n */\nexport const pluck: {\n  <A, I, K extends keyof A & keyof I>(\n    key: K\n  ): <R>(schema: Schema<A, I, R>) => Schema<A[K], { readonly [P in K]: I[P] }, R>\n  <A, I, R, K extends keyof A & keyof I>(\n    schema: Schema<A, I, R>,\n    key: K\n  ): Schema<A[K], { readonly [P in K]: I[P] }, R>\n} = dual(\n  2,\n  <A, I, R, K extends keyof A & keyof I>(\n    schema: Schema<A, I, R>,\n    key: K\n  ): Schema<A[K], Types.Simplify<Pick<I, K>>, R> => {\n    const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key)\n    const value = make<A[K], A[K], R>(ps.isOptional ? AST.orUndefined(ps.type) : ps.type)\n    return transform(\n      schema.pipe(pick(key)),\n      value,\n      {\n        decode: (a: any) => a[key],\n        encode: (ak) => ps.isOptional && ak === undefined ? {} : { [key]: ak } as any\n      }\n    )\n  }\n)\n\nconst makeBrandSchema = <S extends Schema.AnyNoContext, B extends string | symbol>(\n  self: AST.AST,\n  annotations: Annotations.Schema<Schema.Type<S> & brand_.Brand<B>>\n): brand<S, B> => {\n  const ast = AST.annotations(self, toASTAnnotations(annotations))\n  const schema = make(ast)\n  const validateEither_ = validateEither(schema)\n\n  //     v-- function\n  const out: any = brand_.refined((unbranded) =>\n    either_.match(validateEither_(unbranded), {\n      onLeft: (e) => option_.some(brand_.error(TreeFormatter.formatErrorSync(e), e)),\n      onRight: () => option_.none()\n    })\n  )\n  // ----------------\n  // Schema interface\n  // ----------------\n  Object.setPrototypeOf(\n    Object.assign(out, schema, {\n      annotations: (a: typeof annotations) => makeBrandSchema(ast, a)\n    }),\n    Object.getPrototypeOf(schema)\n  )\n  return out\n}\n\n/**\n * @category branding\n * @since 1.0.0\n */\nexport interface BrandSchema<A extends brand_.Brand<any>, I>\n  extends Annotable<BrandSchema<A, I>, A, I>, brand_.Brand.Constructor<A>\n{}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface brand<S extends Schema.AnyNoContext, B extends string | symbol>\n  extends BrandSchema<Schema.Type<S> & brand_.Brand<B>, Schema.Encoded<S>>\n{\n  annotations(annotations: Annotations.Schema<Schema.Type<S> & brand_.Brand<B>>): brand<S, B>\n}\n\n/**\n * @category branding\n * @since 1.0.0\n */\nexport const asBrandSchema = <A extends brand_.Brand<any>, I>(schema: BrandSchema<A, I>): BrandSchema<A, I> => schema\n\n/**\n * Returns a nominal branded schema by applying a brand to a given schema.\n *\n * ```\n * Schema<A> + B -> Schema<A & Brand<B>>\n * ```\n *\n * @param self - The input schema to be combined with the brand.\n * @param brand - The brand to apply.\n *\n * @example\n * import * as Schema from \"@effect/schema/Schema\"\n *\n * const Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\n * type Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">\n *\n * @category branding\n * @since 1.0.0\n */\nexport const brand = <S extends Schema.AnyNoContext, B extends string | symbol>(\n  brand: B,\n  annotations?: Annotations.Schema<Schema.Type<S> & brand_.Brand<B>>\n) =>\n(self: S): brand<S, B> => {\n  const brandAnnotation: AST.BrandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {\n    onNone: () => [brand],\n    onSome: (brands) => [...brands, brand]\n  })\n  return makeBrandSchema(self.ast, {\n    // add a default title annotation containing the brand\n    title: String(self.ast) + ` & Brand<${util_.formatUnknown(brand)}>`,\n    ...annotations,\n    [AST.BrandAnnotationId]: brandAnnotation\n  })\n}\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const partial: {\n  <const Options extends { readonly exact: true } | undefined>(\n    options?: Options\n  ): <A, I, R>(\n    self: Schema<A, I, R>\n  ) => Schema<\n    { [K in keyof A]?: A[K] | ([undefined] extends [Options] ? undefined : never) },\n    { [K in keyof I]?: I[K] | ([undefined] extends [Options] ? undefined : never) },\n    R\n  >\n  <A, I, R, const Options extends { readonly exact: true } | undefined>(\n    self: Schema<A, I, R>,\n    options?: Options\n  ): Schema<\n    { [K in keyof A]?: A[K] | ([undefined] extends [Options] ? undefined : never) },\n    { [K in keyof I]?: I[K] | ([undefined] extends [Options] ? undefined : never) },\n    R\n  >\n} = dual((args) => isSchema(args[0]), <A, I, R>(\n  self: Schema<A, I, R>,\n  options?: { readonly exact: true }\n): Schema<Partial<A>, Partial<I>, R> => make(AST.partial(self.ast, options)))\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const required = <A, I, R>(\n  self: Schema<A, I, R>\n): Schema<{ [K in keyof A]-?: A[K] }, { [K in keyof I]-?: I[K] }, R> => make(AST.required(self.ast))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface mutable<S extends Schema.Any> extends\n  Annotable<\n    mutable<S>,\n    SimplifyMutable<Schema.Type<S>>,\n    SimplifyMutable<Schema.Encoded<S>>,\n    Schema.Context<S>\n  >\n{}\n\n/**\n * Creates a new schema with shallow mutability applied to its properties.\n *\n * @param schema - The original schema to make properties mutable (shallowly).\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const mutable = <S extends Schema.Any>(schema: S): mutable<S> => make(AST.mutable(schema.ast))\n\nconst getExtendErrorMessage = (x: AST.AST, y: AST.AST, path: ReadonlyArray<string>) =>\n  errors_.getAPIErrorMessage(\"Extend\", `cannot extend \\`${x}\\` with \\`${y}\\` (path [${path?.join(\", \")}])`)\n\nconst intersectTypeLiterals = (x: AST.AST, y: AST.AST, path: ReadonlyArray<string>): AST.TypeLiteral => {\n  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {\n    const propertySignatures = [...x.propertySignatures]\n    for (const ps of y.propertySignatures) {\n      const name = ps.name\n      const i = propertySignatures.findIndex((ps) => ps.name === name)\n      if (i === -1) {\n        propertySignatures.push(ps)\n      } else {\n        const { isOptional, type } = propertySignatures[i]\n        path = [...path, util_.formatUnknown(name)]\n        propertySignatures[i] = new AST.PropertySignature(name, extendAST(type, ps.type, path), isOptional, true)\n      }\n    }\n    return new AST.TypeLiteral(\n      propertySignatures,\n      x.indexSignatures.concat(y.indexSignatures)\n    )\n  }\n  throw new Error(getExtendErrorMessage(x, y, path))\n}\n\nconst extendAST = (x: AST.AST, y: AST.AST, path: ReadonlyArray<string>): AST.AST =>\n  AST.Union.make(intersectUnionMembers([x], [y], path))\n\nconst intersectUnionMembers = (\n  xs: ReadonlyArray<AST.AST>,\n  ys: ReadonlyArray<AST.AST>,\n  path: ReadonlyArray<string>\n): Array<AST.AST> =>\n  array_.flatMap(xs, (x) =>\n    array_.flatMap(ys, (y) => {\n      if (AST.isUnion(x)) {\n        return intersectUnionMembers(x.types, AST.isUnion(y) ? y.types : [y], path)\n      } else if (AST.isUnion(y)) {\n        return intersectUnionMembers([x], y.types, path)\n      }\n\n      if (AST.isTypeLiteral(x)) {\n        if (AST.isTypeLiteral(y)) {\n          return [intersectTypeLiterals(x, y, path)]\n        } else if (\n          AST.isTransformation(y) && AST.isTypeLiteralTransformation(y.transformation)\n        ) {\n          return [\n            new AST.Transformation(\n              intersectTypeLiterals(x, y.from, path),\n              intersectTypeLiterals(AST.typeAST(x), y.to, path),\n              new AST.TypeLiteralTransformation(\n                y.transformation.propertySignatureTransformations\n              )\n            )\n          ]\n        }\n      } else if (\n        AST.isTransformation(x) && AST.isTypeLiteralTransformation(x.transformation)\n      ) {\n        if (AST.isTypeLiteral(y)) {\n          return [\n            new AST.Transformation(\n              intersectTypeLiterals(x.from, y, path),\n              intersectTypeLiterals(x.to, AST.typeAST(y), path),\n              new AST.TypeLiteralTransformation(\n                x.transformation.propertySignatureTransformations\n              )\n            )\n          ]\n        } else if (\n          AST.isTransformation(y) && AST.isTypeLiteralTransformation(y.transformation)\n        ) {\n          return [\n            new AST.Transformation(\n              intersectTypeLiterals(x.from, y.from, path),\n              intersectTypeLiterals(x.to, y.to, path),\n              new AST.TypeLiteralTransformation(\n                x.transformation.propertySignatureTransformations.concat(\n                  y.transformation.propertySignatureTransformations\n                )\n              )\n            )\n          ]\n        }\n      }\n      throw new Error(getExtendErrorMessage(x, y, path))\n    }))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface extend<Self extends Schema.Any, That extends Schema.Any> extends\n  Schema<\n    Types.Simplify<Schema.Type<Self> & Schema.Type<That>>,\n    Types.Simplify<Schema.Encoded<Self> & Schema.Encoded<That>>,\n    Schema.Context<Self> | Schema.Context<That>\n  >\n{}\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const extend: {\n  <That extends Schema.Any>(\n    that: That\n  ): <Self extends Schema.Any>(self: Self) => extend<Self, That>\n  <Self extends Schema.Any, That extends Schema.Any>(\n    self: Self,\n    that: That\n  ): extend<Self, That>\n} = dual(\n  2,\n  <Self extends Schema.Any, That extends Schema.Any>(\n    self: Self,\n    that: That\n  ) => make(extendAST(self.ast, that.ast, []))\n)\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const compose: {\n  <D, C extends B, R2, B>(\n    to: Schema<D, C, R2>\n  ): <A, R1>(from: Schema<B, A, R1>) => Schema<D, A, R1 | R2>\n  <D, C, R2>(\n    to: Schema<D, C, R2>\n  ): <B extends C, A, R1>(from: Schema<B, A, R1>) => Schema<D, A, R1 | R2>\n  <C, B, R2>(\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): <A, R1>(from: Schema<B, A, R1>) => Schema<C, A, R1 | R2>\n  <D, C, R2>(\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): <B, A, R1>(from: Schema<B, A, R1>) => Schema<D, A, R1 | R2>\n\n  <B, A, R1, D, C extends B, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<D, C, R2>\n  ): Schema<D, A, R1 | R2>\n  <B extends C, A, R1, D, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<D, C, R2>\n  ): Schema<D, A, R1 | R2>\n  <B, A, R1, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): Schema<C, A, R1 | R2>\n  <B, A, R1, D, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): Schema<D, A, R1 | R2>\n} = dual(\n  (args) => isSchema(args[1]),\n  <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): Schema<D, A, R1 | R2> =>\n    make(AST.compose(from.ast, to.ast))\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface suspend<A, I, R> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.Schema<A>): suspend<A, I, R>\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const suspend = <A, I, R>(f: () => Schema<A, I, R>): suspend<A, I, R> => make(new AST.Suspend(() => f().ast))\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function filter<A>(\n  f: (a: A, options: ParseOptions, self: AST.Refinement) => option_.Option<ParseResult.ParseIssue>,\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>\nexport function filter<C extends A, B extends A, A = C>(\n  refinement: Predicate.Refinement<A, B>,\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<C, I, R>) => Schema<C & B, I, R>\nexport function filter<A>(\n  predicate: Predicate.Predicate<Types.NoInfer<A>>,\n  annotations?: Annotations.Filter<Types.NoInfer<A>>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>\nexport function filter<A>(\n  predicate: Predicate.Predicate<A> | AST.Refinement[\"filter\"],\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> {\n  return (self) =>\n    make(\n      new AST.Refinement(\n        self.ast,\n        (a, options, ast) => {\n          const out = predicate(a, options, ast)\n          if (Predicate.isBoolean(out)) {\n            return out\n              ? option_.none()\n              : option_.some(new ParseResult.Type(ast, a))\n          }\n          return out\n        },\n        toASTAnnotations(annotations)\n      )\n    )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface transformOrFail<From extends Schema.Any, To extends Schema.Any, R> extends\n  Annotable<\n    transformOrFail<From, To, R>,\n    Schema.Type<To>,\n    Schema.Encoded<From>,\n    Schema.Context<From> | Schema.Context<To> | R\n  >\n{\n  readonly from: From\n  readonly to: To\n}\n\nclass transformOrFailImpl<From extends Schema.Any, To extends Schema.Any, R>\n  extends SchemaImpl<Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R>\n  implements transformOrFail<From, To, R>\n{\n  constructor(readonly from: From, readonly to: To, ast: AST.AST) {\n    super(ast)\n  }\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>) {\n    return new transformOrFailImpl(this.from, this.to, AST.annotations(this.ast, toASTAnnotations(annotations)))\n  }\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided decoding functions.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const transformOrFail: {\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): (from: From) => transformOrFail<From, To, RD | RE>\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): transformOrFail<From, To, RD | RE>\n} = dual((args) => isSchema(args[0]) && isSchema(args[1]), <FromA, FromI, FromR, ToA, ToI, ToR, RD, RE>(\n  from: Schema<FromA, FromI, FromR>,\n  to: Schema<ToA, ToI, ToR>,\n  options: {\n    readonly decode: (\n      fromA: FromA,\n      options: ParseOptions,\n      ast: AST.Transformation\n    ) => Effect.Effect<ToI, ParseResult.ParseIssue, RD>\n    readonly encode: (\n      toI: ToI,\n      options: ParseOptions,\n      ast: AST.Transformation\n    ) => Effect.Effect<FromA, ParseResult.ParseIssue, RE>\n  }\n): Schema<ToA, FromI, FromR | ToR | RD | RE> =>\n  new transformOrFailImpl(\n    from,\n    to,\n    new AST.Transformation(\n      from.ast,\n      to.ast,\n      new AST.FinalTransformation(options.decode, options.encode)\n    )\n  ))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface transform<From extends Schema.Any, To extends Schema.Any> extends transformOrFail<From, To, never> {\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided mapping functions.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const transform: {\n  <To extends Schema.Any, From extends Schema.Any>(\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>) => unknown\n      readonly strict: false\n    }\n  ): (from: From) => transform<From, To>\n  <To extends Schema.Any, From extends Schema.Any>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>) => unknown\n      readonly strict: false\n    }\n  ): transform<From, To>\n} = dual(\n  (args) => isSchema(args[0]) && isSchema(args[1]),\n  <FromA, FromI, FromR, ToA, ToI, ToR>(\n    from: Schema<FromA, FromI, FromR>,\n    to: Schema<ToA, ToI, ToR>,\n    options: {\n      readonly decode: (fromA: FromA) => ToI\n      readonly encode: (toI: ToI) => FromA\n    }\n  ): Schema<ToA, FromI, FromR | ToR> =>\n    transformOrFail(\n      from,\n      to,\n      {\n        decode: (fromA) => ParseResult.succeed(options.decode(fromA)),\n        encode: (toI) => ParseResult.succeed(options.encode(toI))\n      }\n    )\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface transformLiteral<Type, Encoded> extends Annotable<transformLiteral<Type, Encoded>, Type, Encoded> {}\n\n/**\n * Creates a new `Schema` which transforms literal values.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * const schema = S.transformLiteral(0, \"a\")\n *\n * assert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const transformLiteral = <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  from: Encoded,\n  to: Type\n): transformLiteral<Type, Encoded> => transform(Literal(from), Literal(to), { decode: () => to, encode: () => from })\n\n/**\n * Creates a new `Schema` which maps between corresponding literal values.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * const Animal = S.transformLiterals(\n *   [0, \"cat\"],\n *   [1, \"dog\"],\n *   [2, \"cow\"]\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Animal)(1), \"dog\")\n *\n * @category constructors\n * @since 1.0.0\n */\nexport function transformLiterals<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(\n  ...pairs: A\n): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]> }>\nexport function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  pairs: [Encoded, Type]\n): transformLiteral<Type, Encoded>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]> {\n  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)))\n}\n\n/**\n * Attaches a property signature with the specified key and value to the schema.\n * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n *\n * @param self - The input schema.\n * @param key - The name of the property to add to the schema.\n * @param value - The value of the property to add to the schema.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n * import { pipe } from \"effect/Function\"\n *\n * const Circle = S.Struct({ radius: S.Number })\n * const Square = S.Struct({ sideLength: S.Number })\n * const Shape = S.Union(\n *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n *   kind: \"circle\",\n *   radius: 10\n * })\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const attachPropertySignature: {\n  <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Types.Simplify<A & { readonly [k in K]: V }>>\n  ): <I, R>(\n    schema: Schema<A, I, R>\n  ) => Schema<Types.Simplify<A & { readonly [k in K]: V }>, I, R>\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Types.Simplify<A & { readonly [k in K]: V }>>\n  ): Schema<Types.Simplify<A & { readonly [k in K]: V }>, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Types.Simplify<A & { readonly [k in K]: V }>>\n  ): Schema<Types.Simplify<A & { readonly [k in K]: V }>, I, R> => {\n    const attached = extend(\n      typeSchema(schema),\n      Struct({ [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value) })\n    ).ast\n    return make(\n      new AST.Transformation(\n        schema.ast,\n        annotations ? AST.annotations(attached, toASTAnnotations(annotations)) : attached,\n        new AST.TypeLiteralTransformation(\n          [\n            new AST.PropertySignatureTransformation(\n              key,\n              key,\n              () => option_.some(value),\n              () => option_.none()\n            )\n          ]\n        )\n      )\n    )\n  }\n)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport declare namespace Annotations {\n  /**\n   * @category annotations\n   * @since 1.0.0\n   */\n  export interface Doc<A> extends AST.Annotations {\n    readonly title?: AST.TitleAnnotation\n    readonly description?: AST.DescriptionAnnotation\n    readonly documentation?: AST.DocumentationAnnotation\n    readonly examples?: AST.ExamplesAnnotation<A>\n    readonly default?: AST.DefaultAnnotation<A>\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {\n    readonly identifier?: AST.IdentifierAnnotation\n    readonly message?: AST.MessageAnnotation\n    readonly typeId?: AST.TypeAnnotation | { id: AST.TypeAnnotation; annotation: unknown }\n    readonly jsonSchema?: AST.JSONSchemaAnnotation\n    readonly arbitrary?: (\n      ...arbitraries: { readonly [K in keyof TypeParameters]: LazyArbitrary<TypeParameters[K]> }\n    ) => LazyArbitrary<A>\n    readonly pretty?: (\n      ...pretties: { readonly [K in keyof TypeParameters]: pretty_.Pretty<TypeParameters[K]> }\n    ) => pretty_.Pretty<A>\n    readonly equivalence?: (\n      ...equivalences: { readonly [K in keyof TypeParameters]: Equivalence.Equivalence<TypeParameters[K]> }\n    ) => Equivalence.Equivalence<A>\n    readonly concurrency?: AST.ConcurrencyAnnotation\n    readonly batching?: AST.BatchingAnnotation\n    readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export interface Filter<A> extends Schema<A, readonly [A]> {}\n}\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const annotations: {\n  <S extends Annotable.All>(annotations: Annotations.Schema<Schema.Type<S>>): (self: S) => Annotable.Self<S>\n  <S extends Annotable.All>(self: S, annotations: Annotations.Schema<Schema.Type<S>>): Annotable.Self<S>\n} = dual(\n  2,\n  <A, I, R>(self: Schema<A, I, R>, annotations: Annotations.Schema<A>): Schema<A, I, R> => self.annotations(annotations)\n)\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const message = (message: AST.MessageAnnotation) => <S extends Annotable.All>(self: S): Annotable.Self<S> =>\n  self.annotations({ [AST.MessageAnnotationId]: message })\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const identifier =\n  (identifier: AST.IdentifierAnnotation) => <S extends Annotable.All>(self: S): Annotable.Self<S> =>\n    self.annotations({ [AST.IdentifierAnnotationId]: identifier })\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const title = (title: AST.TitleAnnotation) => <S extends Annotable.All>(self: S): Annotable.Self<S> =>\n  self.annotations({ [AST.TitleAnnotationId]: title })\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const description =\n  (description: AST.DescriptionAnnotation) => <S extends Annotable.All>(self: S): Annotable.Self<S> =>\n    self.annotations({ [AST.DescriptionAnnotationId]: description })\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const examples =\n  <S extends Annotable.All>(examples: AST.ExamplesAnnotation<Schema.Type<S>>) => (self: S): Annotable.Self<S> =>\n    self.annotations({ [AST.ExamplesAnnotationId]: examples })\n\nconst $default = <S extends Annotable.All>(value: Schema.Type<S>) => (self: S): Annotable.Self<S> =>\n  self.annotations({ [AST.DefaultAnnotationId]: value })\n\nexport {\n  /**\n   * @category annotations\n   * @since 1.0.0\n   */\n  $default as default\n}\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const documentation =\n  (documentation: AST.DocumentationAnnotation) => <S extends Annotable.All>(self: S): Annotable.Self<S> =>\n    self.annotations({ [AST.DocumentationAnnotationId]: documentation })\n\n/**\n * Attaches a JSON Schema annotation to a schema that represents a refinement.\n *\n * If the schema is composed of more than one refinement, the corresponding annotations will be merged.\n *\n * @category annotations\n * @since 1.0.0\n */\nexport const jsonSchema =\n  (jsonSchema: AST.JSONSchemaAnnotation) => <S extends Annotable.All>(self: S): Annotable.Self<S> =>\n    self.annotations({ [AST.JSONSchemaAnnotationId]: jsonSchema })\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const equivalence =\n  <S extends Annotable.All>(equivalence: Equivalence.Equivalence<Schema.Type<S>>) => (self: S): Annotable.Self<S> =>\n    self.annotations({ [equivalence_.EquivalenceHookId]: () => equivalence })\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const concurrency =\n  (concurrency: AST.ConcurrencyAnnotation) => <S extends Annotable.All>(self: S): Annotable.Self<S> =>\n    self.annotations({ [AST.ConcurrencyAnnotationId]: concurrency })\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const batching = (batching: AST.BatchingAnnotation) => <S extends Annotable.All>(self: S): Annotable.Self<S> =>\n  self.annotations({ [AST.BatchingAnnotationId]: batching })\n\n/**\n * @category annotations\n * @since 1.0.0\n */\nexport const parseIssueTitle =\n  (f: AST.ParseIssueTitleAnnotation) => <S extends Annotable.All>(self: S): Annotable.Self<S> =>\n    self.annotations({ [AST.ParseIssueTitleAnnotationId]: f })\n\ntype Rename<A, M> = {\n  [\n    K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K]\n      : never\n      : K\n  ]: A[K]\n}\n\n/**\n * @category renaming\n * @since 1.0.0\n */\nexport const rename: {\n  <\n    A,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    mapping: M\n  ): <I, R>(self: Schema<A, I, R>) => Schema<Types.Simplify<Rename<A, M>>, I, R>\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    self: Schema<A, I, R>,\n    mapping: M\n  ): Schema<Types.Simplify<Rename<A, M>>, I, R>\n} = dual(\n  2,\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    self: Schema<A, I, R>,\n    mapping: M\n  ): Schema<Types.Simplify<Rename<A, M>>, I, R> => {\n    return make(AST.rename(self.ast, mapping))\n  }\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const TrimmedTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Trimmed\")\n\n/**\n * Verifies that a string contains no leading or trailing whitespaces.\n *\n * Note. This combinator does not make any transformations, it only validates.\n * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.\n *\n * @category string filters\n * @since 1.0.0\n */\nexport const trimmed =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    self.pipe(\n      filter((a): a is A => a === a.trim(), {\n        typeId: TrimmedTypeId,\n        description: \"a string with no leading or trailing whitespace\",\n        ...annotations\n      })\n    )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const MaxLengthTypeId: unique symbol = filters_.MaxLengthTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type MaxLengthTypeId = typeof MaxLengthTypeId\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nexport const maxLength = <A extends string>(\n  maxLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter(\n      (a): a is A => a.length <= maxLength,\n      {\n        typeId: MaxLengthTypeId,\n        description: `a string at most ${maxLength} character(s) long`,\n        jsonSchema: { maxLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const MinLengthTypeId: unique symbol = filters_.MinLengthTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type MinLengthTypeId = typeof MinLengthTypeId\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nexport const minLength = <A extends string>(\n  minLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter(\n      (a): a is A => a.length >= minLength,\n      {\n        typeId: MinLengthTypeId,\n        description: `a string at least ${minLength} character(s) long`,\n        jsonSchema: { minLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const PatternTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Pattern\")\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nexport const pattern = <A extends string>(\n  regex: RegExp,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> => {\n  const pattern = regex.source\n  return self.pipe(\n    filter(\n      (a): a is A => {\n        // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag\n        regex.lastIndex = 0\n        return regex.test(a)\n      },\n      {\n        typeId: { id: PatternTypeId, annotation: { regex } },\n        description: `a string matching the pattern ${pattern}`,\n        jsonSchema: { pattern },\n        arbitrary: () => (fc) => fc.stringMatching(regex) as any,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const StartsWithTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/StartsWith\")\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nexport const startsWith = <A extends string>(\n  startsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter(\n      (a): a is A => a.startsWith(startsWith),\n      {\n        typeId: { id: StartsWithTypeId, annotation: { startsWith } },\n        description: `a string starting with ${JSON.stringify(startsWith)}`,\n        jsonSchema: { pattern: `^${startsWith}` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const EndsWithTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/EndsWith\")\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nexport const endsWith = <A extends string>(\n  endsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter(\n      (a): a is A => a.endsWith(endsWith),\n      {\n        typeId: { id: EndsWithTypeId, annotation: { endsWith } },\n        description: `a string ending with ${JSON.stringify(endsWith)}`,\n        jsonSchema: { pattern: `^.*${endsWith}$` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const IncludesTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Includes\")\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nexport const includes = <A extends string>(\n  searchString: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter(\n      (a): a is A => a.includes(searchString),\n      {\n        typeId: { id: IncludesTypeId, annotation: { includes: searchString } },\n        description: `a string including ${JSON.stringify(searchString)}`,\n        jsonSchema: { pattern: `.*${searchString}.*` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LowercasedTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Lowercased\")\n\n/**\n * Verifies that a string is lowercased.\n *\n * @category string filters\n * @since 1.0.0\n */\nexport const lowercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    self.pipe(\n      filter((a): a is A => a === a.toLowerCase(), {\n        typeId: LowercasedTypeId,\n        description: \"a lowercase string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 1.0.0\n */\nexport const Lowercased: $String = $String.pipe(\n  lowercased({ identifier: \"Lowercased\", title: \"Lowercased\" })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const UppercasedTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Uppercased\")\n\n/**\n * Verifies that a string is uppercased.\n *\n * @category string filters\n * @since 1.0.0\n */\nexport const uppercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    self.pipe(\n      filter((a): a is A => a === a.toUpperCase(), {\n        typeId: UppercasedTypeId,\n        description: \"an uppercase string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 1.0.0\n */\nexport const Uppercased: $String = $String.pipe(\n  uppercased({ identifier: \"Uppercased\", title: \"Uppercased\" })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LengthTypeId: unique symbol = filters_.LengthTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type LengthTypeId = typeof LengthTypeId\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nexport const length = <A extends string>(\n  length: number | { readonly min: number; readonly max: number },\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> => {\n  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length))\n  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength\n  if (minLength !== maxLength) {\n    return self.pipe(\n      filter((a): a is A => a.length >= minLength && a.length <= maxLength, {\n        typeId: LengthTypeId,\n        description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,\n        jsonSchema: { minLength, maxLength },\n        ...annotations\n      })\n    )\n  }\n  return self.pipe(\n    filter((a): a is A => a.length === minLength, {\n      typeId: LengthTypeId,\n      description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,\n      jsonSchema: { minLength, maxLength: minLength },\n      ...annotations\n    })\n  )\n}\n\n/**\n * A schema representing a single character.\n *\n * @category string constructors\n * @since 1.0.0\n */\nexport const Char = $String.pipe(length(1, { identifier: \"Char\" }))\n\n/**\n * @category string filters\n * @since 1.0.0\n */\nexport const nonEmpty = <A extends string>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> =>\n  minLength(1, {\n    description: \"a non empty string\",\n    ...annotations\n  })\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Lowercase extends Annotable<Lowercase, string> {}\n\n/**\n * This schema converts a string to lowercase.\n *\n * @category string transformations\n * @since 1.0.0\n */\nexport const Lowercase: Lowercase = transform(\n  $String,\n  Lowercased,\n  { decode: (s) => s.toLowerCase(), encode: identity }\n).annotations({ identifier: \"Lowercase\" })\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Uppercase extends Annotable<Uppercase, string> {}\n\n/**\n * This schema converts a string to uppercase.\n *\n * @category string transformations\n * @since 1.0.0\n */\nexport const Uppercase: Uppercase = transform(\n  $String,\n  Uppercased,\n  { decode: (s) => s.toUpperCase(), encode: identity }\n).annotations({ identifier: \"Uppercase\" })\n\n/**\n * @category string constructors\n * @since 1.0.0\n */\nexport const Trimmed: $String = $String.pipe(\n  trimmed({ identifier: \"Trimmed\", title: \"Trimmed\" })\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Trim extends Annotable<Trim, string> {}\n\n/**\n * This schema allows removing whitespaces from the beginning and end of a string.\n *\n * @category string transformations\n * @since 1.0.0\n */\nexport const Trim: Trim = transform(\n  $String,\n  Trimmed,\n  { decode: (s) => s.trim(), encode: identity }\n).annotations({ identifier: \"Trim\" })\n\n/**\n * Returns a schema that allows splitting a string into an array of strings.\n *\n * @category string transformations\n * @since 1.0.0\n */\nexport const split = (separator: string): Schema<ReadonlyArray<string>, string> =>\n  transform(\n    $String,\n    $Array($String),\n    { decode: string_.split(separator), encode: array_.join(separator) }\n  )\n\n/**\n * @since 1.0.0\n */\nexport type ParseJsonOptions = {\n  readonly reviver?: Parameters<typeof JSON.parse>[1]\n  readonly replacer?: Parameters<typeof JSON.stringify>[1]\n  readonly space?: Parameters<typeof JSON.stringify>[2]\n}\n\nconst JsonString = $String.annotations({\n  [AST.IdentifierAnnotationId]: \"JsonString\",\n  [AST.TitleAnnotationId]: \"JsonString\",\n  [AST.DescriptionAnnotationId]: \"a JSON string\"\n})\n\n/**\n * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n *\n * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n *\n * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson(S.Struct({ a: S.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n *\n * @category string transformations\n * @since 1.0.0\n */\nexport const parseJson: {\n  <A, I, R>(schema: Schema<A, I, R>, options?: ParseJsonOptions): Schema<A, string, R>\n  (options?: ParseJsonOptions): Schema<unknown, string>\n} = <A, I, R>(schema?: Schema<A, I, R> | ParseJsonOptions, o?: ParseJsonOptions) => {\n  if (isSchema(schema)) {\n    return compose(parseJson(o), schema as any) as any\n  }\n  const options: ParseJsonOptions | undefined = schema as any\n  return transformOrFail(\n    JsonString,\n    Unknown,\n    {\n      decode: (s, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.parse(s, options?.reviver),\n          catch: (e: any) => new ParseResult.Type(ast, s, e.message)\n        }),\n      encode: (u, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.stringify(u, options?.replacer, options?.space),\n          catch: (e: any) => new ParseResult.Type(ast, u, e.message)\n        })\n    }\n  )\n}\n\n/**\n * @category string constructors\n * @since 1.0.0\n */\nexport const NonEmpty: $String = $String.pipe(\n  nonEmpty({ identifier: \"NonEmpty\", title: \"NonEmpty\" })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const UUIDTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/UUID\")\n\nconst uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i\n\n/**\n * Represents a Universally Unique Identifier (UUID).\n *\n * This schema ensures that the provided string adheres to the standard UUID format.\n *\n * @category string constructors\n * @since 1.0.0\n */\nexport const UUID: $String = $String.pipe(\n  pattern(uuidRegex, {\n    typeId: UUIDTypeId,\n    identifier: \"UUID\",\n    title: \"UUID\",\n    description: \"a Universally Unique Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.uuid()\n  })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const ULIDTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/ULID\")\n\nconst ulidRegex = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i\n\n/**\n * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).\n *\n * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.\n * This schema ensures that the provided string adheres to the standard ULID format.\n *\n * @category string constructors\n * @since 1.0.0\n */\nexport const ULID: $String = $String.pipe(\n  pattern(ulidRegex, {\n    typeId: ULIDTypeId,\n    identifier: \"ULID\",\n    title: \"ULID\",\n    description: \"a Universally Unique Lexicographically Sortable Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.ulid()\n  })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const FiniteTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/Finite\")\n\n/**\n * Ensures that the provided value is a finite number.\n *\n * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.\n *\n * @category number filters\n * @since 1.0.0\n */\nexport const finite =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    self.pipe(\n      filter((a): a is A => Number.isFinite(a), {\n        typeId: FiniteTypeId,\n        description: \"a finite number\",\n        ...annotations\n      })\n    )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const GreaterThanTypeId: unique symbol = filters_.GreaterThanTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type GreaterThanTypeId = typeof GreaterThanTypeId\n\n/**\n * This filter checks whether the provided number is greater than the specified minimum.\n *\n * @category number filters\n * @since 1.0.0\n */\nexport const greaterThan = <A extends number>(\n  min: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a > min, {\n      typeId: GreaterThanTypeId,\n      description: min === 0 ? \"a positive number\" : `a number greater than ${min}`,\n      jsonSchema: { exclusiveMinimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const GreaterThanOrEqualToTypeId: unique symbol = filters_.GreaterThanOrEqualToTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type GreaterThanOrEqualToTypeId = typeof GreaterThanOrEqualToTypeId\n\n/**\n * This filter checks whether the provided number is greater than or equal to the specified minimum.\n *\n * @category number filters\n * @since 1.0.0\n */\nexport const greaterThanOrEqualTo = <A extends number>(\n  min: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a >= min, {\n      typeId: GreaterThanOrEqualToTypeId,\n      description: min === 0 ? \"a non-negative number\" : `a number greater than or equal to ${min}`,\n      jsonSchema: { minimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const MultipleOfTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/MultipleOf\")\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nexport const multipleOf = <A extends number>(\n  divisor: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => number_.remainder(a, divisor) === 0, {\n      typeId: MultipleOfTypeId,\n      description: `a number divisible by ${divisor}`,\n      jsonSchema: { multipleOf: Math.abs(divisor) }, // spec requires positive divisor\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const IntTypeId: unique symbol = filters_.IntTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type IntTypeId = typeof IntTypeId\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nexport const int =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    self.pipe(\n      filter((a): a is A => Number.isSafeInteger(a), {\n        typeId: IntTypeId,\n        title: \"integer\",\n        description: \"an integer\",\n        jsonSchema: { type: \"integer\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LessThanTypeId: unique symbol = filters_.LessThanTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type LessThanTypeId = typeof LessThanTypeId\n\n/**\n * This filter checks whether the provided number is less than the specified maximum.\n *\n * @category number filters\n * @since 1.0.0\n */\nexport const lessThan =\n  <A extends number>(max: number, annotations?: Annotations.Filter<A>) =>\n  <I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    self.pipe(\n      filter((a): a is A => a < max, {\n        typeId: LessThanTypeId,\n        description: max === 0 ? \"a negative number\" : `a number less than ${max}`,\n        jsonSchema: { exclusiveMaximum: max },\n        ...annotations\n      })\n    )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LessThanOrEqualToTypeId: unique symbol = filters_.LessThanOrEqualToTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type LessThanOrEqualToTypeId = typeof LessThanOrEqualToTypeId\n\n/**\n * This schema checks whether the provided number is less than or equal to the specified maximum.\n *\n * @category number filters\n * @since 1.0.0\n */\nexport const lessThanOrEqualTo = <A extends number>(\n  max: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a <= max, {\n      typeId: LessThanOrEqualToTypeId,\n      description: max === 0 ? \"a non-positive number\" : `a number less than or equal to ${max}`,\n      jsonSchema: { maximum: max },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const BetweenTypeId: unique symbol = filters_.BetweenTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type BetweenTypeId = typeof BetweenTypeId\n\n/**\n * This filter checks whether the provided number falls within the specified minimum and maximum values.\n *\n * @category number filters\n * @since 1.0.0\n */\nexport const between = <A extends number>(\n  min: number,\n  max: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a >= min && a <= max, {\n      typeId: BetweenTypeId,\n      description: `a number between ${min} and ${max}`,\n      jsonSchema: { maximum: max, minimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const NonNaNTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/NonNaN\")\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nexport const nonNaN =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    self.pipe(\n      filter((a): a is A => !Number.isNaN(a), {\n        typeId: NonNaNTypeId,\n        description: \"a number excluding NaN\",\n        ...annotations\n      })\n    )\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nexport const positive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> => greaterThan(0, annotations)\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nexport const negative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> => lessThan(0, annotations)\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nexport const nonPositive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> => lessThanOrEqualTo(0, annotations)\n\n/**\n * @category number filters\n * @since 1.0.0\n */\nexport const nonNegative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> => greaterThanOrEqualTo(0, annotations)\n\n/**\n * Clamps a number between a minimum and a maximum value.\n *\n * @category number transformations\n * @since 1.0.0\n */\nexport const clamp =\n  (minimum: number, maximum: number) => <R, I, A extends number>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    transform(\n      self,\n      self.pipe(typeSchema, between(minimum, maximum)),\n      { strict: false, decode: (self) => number_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface NumberFromString extends Annotable<NumberFromString, number, string> {}\n\n/**\n * This schema transforms a `string` into a `number` by parsing the string using the `Number` function.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number constructors\n * @since 1.0.0\n */\nexport const NumberFromString: NumberFromString = transformOrFail(\n  $String,\n  $Number,\n  {\n    decode: (s, _, ast) => ParseResult.fromOption(number_.parse(s), () => new ParseResult.Type(ast, s)),\n    encode: (n) => ParseResult.succeed(String(n))\n  }\n).annotations({ identifier: \"NumberFromString\" })\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nexport const Finite: $Number = $Number.pipe(finite({ identifier: \"Finite\", title: \"Finite\" }))\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nexport const Int: $Number = $Number.pipe(int({ identifier: \"Int\", title: \"Int\" }))\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nexport const NonNaN: $Number = $Number.pipe(nonNaN({ identifier: \"NonNaN\", title: \"NonNaN\" }))\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nexport const Positive: $Number = $Number.pipe(\n  positive({ identifier: \"Positive\", title: \"Positive\" })\n)\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nexport const Negative: $Number = $Number.pipe(\n  negative({ identifier: \"Negative\", title: \"Negative\" })\n)\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nexport const NonPositive: $Number = $Number.pipe(\n  nonPositive({ identifier: \"NonPositive\", title: \"NonPositive\" })\n)\n\n/**\n * @category number constructors\n * @since 1.0.0\n */\nexport const NonNegative: $Number = $Number.pipe(\n  nonNegative({ identifier: \"NonNegative\", title: \"NonNegative\" })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const JsonNumberTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/JsonNumber\")\n\n/**\n * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\n * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\n * format.\n *\n * @example\n * import * as S from \"@effect/schema/Schema\"\n *\n * const is = S.is(S.JsonNumber)\n *\n * assert.deepStrictEqual(is(42), true)\n * assert.deepStrictEqual(is(Number.NaN), false)\n * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\n * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n *\n * @category number constructors\n * @since 1.0.0\n */\nexport const JsonNumber: $Number = $Number.pipe(\n  filter((n) => !Number.isNaN(n) && Number.isFinite(n), {\n    typeId: JsonNumberTypeId,\n    identifier: \"JsonNumber\",\n    title: \"JSON-compatible number\",\n    description: \"a JSON-compatible number, excluding NaN, +Infinity, and -Infinity\",\n    jsonSchema: { type: \"number\" }\n  })\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Not extends Annotable<Not, boolean> {}\n\n/**\n * @category boolean transformations\n * @since 1.0.0\n */\nexport const Not: Not = transform($Boolean, $Boolean, { decode: boolean_.not, encode: boolean_.not })\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $Symbol extends Annotable<$Symbol, symbol, string> {}\n\nconst $Symbol: $Symbol = transform(\n  $String,\n  SymbolFromSelf,\n  { strict: false, decode: (s) => Symbol.for(s), encode: (sym) => sym.description }\n).annotations({ identifier: \"symbol\" })\n\nexport {\n  /**\n   * This schema transforms a `string` into a `symbol`.\n   *\n   * @category symbol transformations\n   * @since 1.0.0\n   */\n  $Symbol as Symbol\n}\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const GreaterThanBigIntTypeId: unique symbol = filters_.GreaterThanBigintTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type GreaterThanBigIntTypeId = typeof GreaterThanBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nexport const greaterThanBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a > min, {\n      typeId: { id: GreaterThanBigIntTypeId, annotation: { min } },\n      description: min === 0n ? \"a positive bigint\" : `a bigint greater than ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const GreaterThanOrEqualToBigIntTypeId: unique symbol = filters_.GreaterThanOrEqualToBigIntTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type GreaterThanOrEqualToBigIntTypeId = typeof GreaterThanOrEqualToBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nexport const greaterThanOrEqualToBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a >= min, {\n      typeId: { id: GreaterThanOrEqualToBigIntTypeId, annotation: { min } },\n      description: min === 0n\n        ? \"a non-negative bigint\"\n        : `a bigint greater than or equal to ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LessThanBigIntTypeId: unique symbol = filters_.LessThanBigIntTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type LessThanBigIntTypeId = typeof LessThanBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nexport const lessThanBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a < max, {\n      typeId: { id: LessThanBigIntTypeId, annotation: { max } },\n      description: max === 0n ? \"a negative bigint\" : `a bigint less than ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LessThanOrEqualToBigIntTypeId: unique symbol = filters_.LessThanOrEqualToBigIntTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type LessThanOrEqualToBigIntTypeId = typeof LessThanOrEqualToBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nexport const lessThanOrEqualToBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a <= max, {\n      typeId: { id: LessThanOrEqualToBigIntTypeId, annotation: { max } },\n      description: max === 0n ? \"a non-positive bigint\" : `a bigint less than or equal to ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const BetweenBigIntTypeId: unique symbol = filters_.BetweenBigintTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type BetweenBigIntTypeId = typeof BetweenBigIntTypeId\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nexport const betweenBigInt = <A extends bigint>(\n  min: bigint,\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a >= min && a <= max, {\n      typeId: { id: BetweenBigIntTypeId, annotation: { max, min } },\n      description: `a bigint between ${min}n and ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nexport const positiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> => greaterThanBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nexport const negativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> => lessThanBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nexport const nonNegativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> => greaterThanOrEqualToBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 1.0.0\n */\nexport const nonPositiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R> => lessThanOrEqualToBigInt(0n, annotations)\n\n/**\n * Clamps a bigint between a minimum and a maximum value.\n *\n * @category bigint transformations\n * @since 1.0.0\n */\nexport const clampBigInt =\n  (minimum: bigint, maximum: bigint) => <R, I, A extends bigint>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigInt(minimum, maximum)),\n      { strict: false, decode: (self) => bigInt_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $BigInt extends Annotable<$BigInt, bigint, string> {}\n\nconst bigint: $BigInt = transformOrFail(\n  $String,\n  BigIntFromSelf,\n  {\n    decode: (s, _, ast) => ParseResult.fromOption(bigInt_.fromString(s), () => new ParseResult.Type(ast, s)),\n    encode: (n) => ParseResult.succeed(String(n))\n  }\n).annotations({ identifier: \"bigint\" })\n\nexport {\n  /**\n   * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n   *\n   * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n   *\n   * @category bigint transformations\n   * @since 1.0.0\n   */\n  bigint as BigInt\n}\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nexport const PositiveBigIntFromSelf: Schema<bigint> = BigIntFromSelf.pipe(\n  positiveBigInt({ identifier: \"PositiveBigintFromSelf\", title: \"PositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nexport const PositiveBigInt: Schema<bigint, string> = bigint.pipe(\n  positiveBigInt({ identifier: \"PositiveBigint\", title: \"PositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nexport const NegativeBigIntFromSelf: Schema<bigint> = BigIntFromSelf.pipe(\n  negativeBigInt({ identifier: \"NegativeBigintFromSelf\", title: \"NegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nexport const NegativeBigInt: Schema<bigint, string> = bigint.pipe(\n  negativeBigInt({ identifier: \"NegativeBigint\", title: \"NegativeBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nexport const NonPositiveBigIntFromSelf: Schema<bigint> = BigIntFromSelf.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigintFromSelf\", title: \"NonPositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nexport const NonPositiveBigInt: Schema<bigint, string> = bigint.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigint\", title: \"NonPositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nexport const NonNegativeBigIntFromSelf: Schema<bigint> = BigIntFromSelf.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigintFromSelf\", title: \"NonNegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 1.0.0\n */\nexport const NonNegativeBigInt: Schema<bigint, string> = bigint.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigint\", title: \"NonNegativeBigint\" })\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface BigIntFromNumber extends Annotable<BigIntFromNumber, bigint, number> {}\n\n/**\n * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n *\n * It returns an error if the value can't be safely encoded as a `number` due to being out of range.\n *\n * @category bigint transformations\n * @since 1.0.0\n */\nexport const BigIntFromNumber: BigIntFromNumber = transformOrFail(\n  $Number,\n  BigIntFromSelf,\n  {\n    decode: (n, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.fromNumber(n),\n        () => new ParseResult.Type(ast, n)\n      ),\n    encode: (b, _, ast) => ParseResult.fromOption(bigInt_.toNumber(b), () => new ParseResult.Type(ast, b))\n  }\n).annotations({ identifier: \"BigintFromNumber\" })\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface SecretFromSelf extends Annotable<SecretFromSelf, secret_.Secret> {}\n\n/**\n * @category Secret constructors\n * @since 1.0.0\n */\nexport const SecretFromSelf: SecretFromSelf = declare(\n  secret_.isSecret,\n  {\n    identifier: \"SecretFromSelf\",\n    pretty: (): pretty_.Pretty<secret_.Secret> => (secret) => String(secret),\n    arbitrary: (): LazyArbitrary<secret_.Secret> => (fc) => fc.string().map((_) => secret_.fromString(_))\n  }\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Secret extends Annotable<Secret, secret_.Secret, string> {}\n\n/**\n * A schema that transforms a `string` into a `Secret`.\n *\n * @category Secret transformations\n * @since 1.0.0\n */\nexport const Secret: Secret = transform(\n  $String,\n  SecretFromSelf,\n  { strict: false, decode: (str) => secret_.fromString(str), encode: (secret) => secret_.value(secret) }\n).annotations({ identifier: \"Secret\" })\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface DurationFromSelf extends Annotable<DurationFromSelf, duration_.Duration> {}\n\n/**\n * @category Duration constructors\n * @since 1.0.0\n */\nexport const DurationFromSelf: DurationFromSelf = declare(\n  duration_.isDuration,\n  {\n    identifier: \"DurationFromSelf\",\n    pretty: (): pretty_.Pretty<duration_.Duration> => String,\n    arbitrary: (): LazyArbitrary<duration_.Duration> => (fc) =>\n      fc.oneof(\n        fc.constant(duration_.infinity),\n        fc.bigUint().map((_) => duration_.nanos(_)),\n        fc.bigUint().map((_) => duration_.micros(_)),\n        fc.maxSafeNat().map((_) => duration_.millis(_)),\n        fc.maxSafeNat().map((_) => duration_.seconds(_)),\n        fc.maxSafeNat().map((_) => duration_.minutes(_)),\n        fc.maxSafeNat().map((_) => duration_.hours(_)),\n        fc.maxSafeNat().map((_) => duration_.days(_)),\n        fc.maxSafeNat().map((_) => duration_.weeks(_))\n      ),\n    equivalence: (): Equivalence.Equivalence<duration_.Duration> => duration_.Equivalence\n  }\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface DurationFromNanos extends Annotable<DurationFromNanos, duration_.Duration, bigint> {}\n\n/**\n * A schema that transforms a `bigint` tuple into a `Duration`.\n * Treats the value as the number of nanoseconds.\n *\n * @category Duration transformations\n * @since 1.0.0\n */\nexport const DurationFromNanos: DurationFromNanos = transformOrFail(\n  BigIntFromSelf,\n  DurationFromSelf,\n  {\n    decode: (nanos) => ParseResult.succeed(duration_.nanos(nanos)),\n    encode: (duration, _, ast) =>\n      option_.match(duration_.toNanos(duration), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, duration)),\n        onSome: (val) => ParseResult.succeed(val)\n      })\n  }\n).annotations({ identifier: \"DurationFromNanos\" })\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface DurationFromMillis extends Annotable<DurationFromMillis, duration_.Duration, number> {}\n\n/**\n * A schema that transforms a `number` tuple into a `Duration`.\n * Treats the value as the number of milliseconds.\n *\n * @category Duration transformations\n * @since 1.0.0\n */\nexport const DurationFromMillis: DurationFromMillis = transform(\n  $Number,\n  DurationFromSelf,\n  { decode: (ms) => duration_.millis(ms), encode: (n) => duration_.toMillis(n) }\n).annotations({ identifier: \"DurationFromMillis\" })\n\nconst hrTime: Schema<readonly [seconds: number, nanos: number]> = Tuple(\n  NonNegative.pipe(\n    finite({\n      [AST.TitleAnnotationId]: \"seconds\",\n      [AST.DescriptionAnnotationId]: \"seconds\"\n    })\n  ),\n  NonNegative.pipe(\n    finite({\n      [AST.TitleAnnotationId]: \"nanos\",\n      [AST.DescriptionAnnotationId]: \"nanos\"\n    })\n  )\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Duration extends Annotable<Duration, duration_.Duration, readonly [seconds: number, nanos: number]> {}\n\n/**\n * A schema that transforms a `[number, number]` tuple into a `Duration`.\n *\n * @category Duration transformations\n * @since 1.0.0\n */\nexport const Duration: Duration = transform(\n  hrTime,\n  DurationFromSelf,\n  {\n    decode: ([seconds, nanos]) => duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos)),\n    encode: (duration) => duration_.toHrTime(duration)\n  }\n).annotations({ identifier: \"Duration\" })\n\n/**\n * Clamps a `Duration` between a minimum and a maximum value.\n *\n * @category Duration transformations\n * @since 1.0.0\n */\nexport const clampDuration =\n  (minimum: duration_.DurationInput, maximum: duration_.DurationInput) =>\n  <R, I, A extends duration_.Duration>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenDuration(minimum, maximum)),\n      { strict: false, decode: (self) => duration_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LessThanDurationTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/LessThanDuration\")\n\n/**\n * @category Duration filters\n * @since 1.0.0\n */\nexport const lessThanDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => duration_.lessThan(a, max), {\n      typeId: { id: LessThanDurationTypeId, annotation: { max } },\n      description: `a Duration less than ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LessThanOrEqualToDurationTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/LessThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 1.0.0\n */\nexport const lessThanOrEqualToDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => duration_.lessThanOrEqualTo(a, max), {\n      typeId: { id: LessThanDurationTypeId, annotation: { max } },\n      description: `a Duration less than or equal to ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const GreaterThanDurationTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/GreaterThanDuration\")\n\n/**\n * @category Duration filters\n * @since 1.0.0\n */\nexport const greaterThanDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => duration_.greaterThan(a, min), {\n      typeId: { id: GreaterThanDurationTypeId, annotation: { min } },\n      description: `a Duration greater than ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const GreaterThanOrEqualToDurationTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 1.0.0\n */\nexport const greaterThanOrEqualToDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => duration_.greaterThanOrEqualTo(a, min), {\n      typeId: { id: GreaterThanOrEqualToDurationTypeId, annotation: { min } },\n      description: `a Duration greater than or equal to ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const BetweenDurationTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/BetweenDuration\")\n\n/**\n * @category Duration filters\n * @since 1.0.0\n */\nexport const betweenDuration = <A extends duration_.Duration>(\n  minimum: duration_.DurationInput,\n  maximum: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => duration_.between(a, { minimum, maximum }), {\n      typeId: { id: BetweenDurationTypeId, annotation: { maximum, minimum } },\n      description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category Uint8Array constructors\n * @since 1.0.0\n */\nexport const Uint8ArrayFromSelf: Schema<Uint8Array> = declare(\n  Predicate.isUint8Array,\n  {\n    identifier: \"Uint8ArrayFromSelf\",\n    pretty: (): pretty_.Pretty<Uint8Array> => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,\n    arbitrary: (): LazyArbitrary<Uint8Array> => (fc) => fc.uint8Array(),\n    equivalence: (): Equivalence.Equivalence<Uint8Array> => array_.getEquivalence(Equal.equals) as any\n  }\n)\n\nconst $Uint8Array: Schema<Uint8Array, ReadonlyArray<number>> = transform(\n  $Array($Number.pipe(\n    between(0, 255, {\n      title: \"8-bit unsigned integer\",\n      description: \"a 8-bit unsigned integer\"\n    })\n  )).annotations({ description: \"an array of 8-bit unsigned integers\" }),\n  Uint8ArrayFromSelf,\n  { decode: (numbers) => Uint8Array.from(numbers), encode: (uint8Array) => Array.from(uint8Array) }\n).annotations({ identifier: \"Uint8Array\" })\n\nexport {\n  /**\n   * A schema that transforms a `number` array into a `Uint8Array`.\n   *\n   * @category Uint8Array transformations\n   * @since 1.0.0\n   */\n  $Uint8Array as Uint8Array\n}\n\nconst makeEncodingTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<Uint8Array, Encoding.DecodeException>,\n  encode: (u: Uint8Array) => string\n): Schema<Uint8Array, string> =>\n  transformOrFail(\n    $String,\n    Uint8ArrayFromSelf,\n    {\n      strict: false,\n      decode: (s, _, ast) =>\n        either_.mapLeft(\n          decode(s),\n          (decodeException) => new ParseResult.Type(ast, s, decodeException.message)\n        ),\n      encode: (u) => ParseResult.succeed(encode(u))\n    }\n  ).annotations({ identifier: id })\n\n/**\n * @category Encoding transformations\n * @since 1.0.0\n */\nexport const Base64: Schema<Uint8Array, string> = makeEncodingTransformation(\n  \"Base64\",\n  Encoding.decodeBase64,\n  Encoding.encodeBase64\n)\n\n/**\n * @category Encoding transformations\n * @since 1.0.0\n */\nexport const Base64Url: Schema<Uint8Array, string> = makeEncodingTransformation(\n  \"Base64Url\",\n  Encoding.decodeBase64Url,\n  Encoding.encodeBase64Url\n)\n\n/**\n * @category Encoding transformations\n * @since 1.0.0\n */\nexport const Hex: Schema<Uint8Array, string> = makeEncodingTransformation(\n  \"Hex\",\n  Encoding.decodeHex,\n  Encoding.encodeHex\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const MinItemsTypeId: unique symbol = filters_.MinItemsTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type MinItemsTypeId = typeof MinItemsTypeId\n\n/**\n * @category ReadonlyArray filters\n * @since 1.0.0\n */\nexport const minItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): Schema<ReadonlyArray<A>, I, R> =>\n  self.pipe(\n    filter((a): a is ReadonlyArray<A> => a.length >= n, {\n      typeId: MinItemsTypeId,\n      description: `an array of at least ${n} items`,\n      jsonSchema: { minItems: n },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const MaxItemsTypeId: unique symbol = filters_.MaxItemsTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type MaxItemsTypeId = typeof MaxItemsTypeId\n\n/**\n * @category ReadonlyArray filters\n * @since 1.0.0\n */\nexport const maxItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): Schema<ReadonlyArray<A>, I, R> =>\n  self.pipe(\n    filter((a): a is ReadonlyArray<A> => a.length <= n, {\n      typeId: MaxItemsTypeId,\n      description: `an array of at most ${n} items`,\n      jsonSchema: { maxItems: n },\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const ItemsCountTypeId: unique symbol = filters_.ItemsCountTypeId\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport type ItemsCountTypeId = typeof ItemsCountTypeId\n\n/**\n * @category ReadonlyArray filters\n * @since 1.0.0\n */\nexport const itemsCount = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): Schema<ReadonlyArray<A>, I, R> =>\n  self.pipe(\n    filter((a): a is ReadonlyArray<A> => a.length === n, {\n      typeId: ItemsCountTypeId,\n      description: `an array of exactly ${n} item(s)`,\n      jsonSchema: { minItems: n, maxItems: n },\n      ...annotations\n    })\n  )\n\n/**\n * @category ReadonlyArray transformations\n * @since 1.0.0\n */\nexport const getNumberIndexedAccess = <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(\n  self: Schema<A, I, R>\n): Schema<A[number], I[number], R> => make(AST.getNumberIndexedAccess(self.ast))\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.\n *\n * @category ReadonlyArray transformations\n * @since 1.0.0\n */\nexport const head = <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>): Schema<option_.Option<A>, I, R> =>\n  transform(\n    self,\n    OptionFromSelf(getNumberIndexedAccess(typeSchema(self))),\n    { decode: array_.head, encode: option_.match({ onNone: () => [], onSome: array_.of }) }\n  )\n\n/**\n * Retrieves the first element of a `ReadonlyArray`.\n *\n * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n *\n * @category ReadonlyArray transformations\n * @since 1.0.0\n */\nexport const headOrElse: {\n  <A>(fallback?: LazyArg<A>): <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => Schema<A, I, R>\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): Schema<A, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): Schema<A, I, R> =>\n    transformOrFail(\n      self,\n      getNumberIndexedAccess(typeSchema(self)),\n      {\n        decode: (as, _, ast) =>\n          as.length > 0\n            ? ParseResult.succeed(as[0])\n            : fallback\n            ? ParseResult.succeed(fallback())\n            : ParseResult.fail(new ParseResult.Type(ast, as)),\n        encode: (a) => ParseResult.succeed(array_.of(a))\n      }\n    )\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const ValidDateTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/ValidDate\")\n\n/**\n * A filter that **excludes invalid** dates (e.g., `new Date(\"Invalid Date\")` is rejected).\n *\n * @category Date filters\n * @since 1.0.0\n */\nexport const validDate =\n  (annotations?: Annotations.Filter<Date>) => <I, R>(self: Schema<Date, I, R>): Schema<Date, I, R> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a.getTime()), {\n        typeId: ValidDateTypeId,\n        description: \"a valid Date\",\n        ...annotations\n      })\n    )\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface DateFromSelf extends Annotable<DateFromSelf, Date> {}\n\n/**\n * Represents a schema for handling potentially **invalid** `Date` instances (e.g., `new Date(\"Invalid Date\")` is not rejected).\n *\n * @category Date constructors\n * @since 1.0.0\n */\nexport const DateFromSelf: DateFromSelf = declare(\n  Predicate.isDate,\n  {\n    identifier: \"DateFromSelf\",\n    description: \"a potentially invalid Date instance\",\n    pretty: (): pretty_.Pretty<Date> => (date) => `new Date(${JSON.stringify(date)})`,\n    arbitrary: (): LazyArbitrary<Date> => (fc) => fc.date({ noInvalidDate: false }),\n    equivalence: () => Equivalence.Date\n  }\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface ValidDateFromSelf extends Annotable<ValidDateFromSelf, Date> {}\n\n/**\n * Represents a schema for handling only **valid** dates. For example, `new Date(\"Invalid Date\")` is rejected, even though it is an instance of `Date`.\n *\n * @category Date constructors\n * @since 1.0.0\n */\nexport const ValidDateFromSelf: ValidDateFromSelf = DateFromSelf.pipe(\n  validDate({\n    identifier: \"ValidDateFromSelf\",\n    description: \"a valid Date instance\"\n  })\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface DateFromString extends Annotable<DateFromString, Date, string> {}\n\n/**\n * Represents a schema that converts a `string` into a (potentially invalid) `Date` (e.g., `new Date(\"Invalid Date\")` is not rejected).\n *\n * @category Date transformations\n * @since 1.0.0\n */\nexport const DateFromString: DateFromString = transform(\n  $String,\n  DateFromSelf,\n  { decode: (s) => new Date(s), encode: (n) => n.toISOString() }\n).annotations({ identifier: \"DateFromString\" })\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $Date extends Annotable<$Date, Date, string> {}\n\nconst $Date: $Date = DateFromString.pipe(\n  validDate({ identifier: \"Date\" })\n)\n\nexport {\n  /**\n   * A schema that transforms a `string` into a **valid** `Date`, ensuring that invalid dates, such as `new Date(\"Invalid Date\")`, are rejected.\n   *\n   * @category Date transformations\n   * @since 1.0.0\n   */\n  $Date as Date\n}\n\n/**\n * @category Option utils\n * @since 1.0.0\n */\nexport type OptionEncoded<I> =\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Some\"\n    readonly value: I\n  }\n\nconst OptionNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ description: \"NoneEncoded\" })\n\nconst optionSomeEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Struct({\n    _tag: Literal(\"Some\"),\n    value\n  }).annotations({ description: `SomeEncoded<${format(value)}>` })\n\nconst optionEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Union(\n    OptionNoneEncoded,\n    optionSomeEncoded(value)\n  ).annotations({\n    description: `OptionEncoded<${format(value)}>`\n  })\n\nconst optionDecode = <A>(input: OptionEncoded<A>): option_.Option<A> =>\n  input._tag === \"None\" ? option_.none() : option_.some(input.value)\n\nconst optionArbitrary = <A>(value: LazyArbitrary<A>): LazyArbitrary<option_.Option<A>> => (fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"None\" as const) }),\n    fc.record({ _tag: fc.constant(\"Some\" as const), value: value(fc) })\n  ).map(optionDecode)\n\nconst optionPretty = <A>(value: pretty_.Pretty<A>): pretty_.Pretty<option_.Option<A>> =>\n  option_.match({\n    onNone: () => \"none()\",\n    onSome: (a) => `some(${value(a)})`\n  })\n\nconst optionParse =\n  <R, A>(decodeUnknown: ParseResult.DecodeUnknown<A, R>): ParseResult.DeclarationDecodeUnknown<option_.Option<A>, R> =>\n  (u, options, ast) =>\n    option_.isOption(u) ?\n      option_.isNone(u) ?\n        ParseResult.succeed(option_.none())\n        : ParseResult.map(decodeUnknown(u.value, options), option_.some)\n      : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface OptionFromSelf<Value extends Schema.Any> extends\n  Annotable<\n    OptionFromSelf<Value>,\n    option_.Option<Schema.Type<Value>>,\n    option_.Option<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 1.0.0\n */\nexport const OptionFromSelf = <Value extends Schema.Any>(\n  value: Value\n): OptionFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (value) => optionParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => optionParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: `Option<${format(value)}>`,\n      pretty: optionPretty,\n      arbitrary: optionArbitrary,\n      equivalence: option_.getEquivalence\n    }\n  )\n}\n\nconst makeNoneEncoded = {\n  _tag: \"None\"\n} as const\nconst makeSomeEncoded = <A>(value: A) => ({\n  _tag: \"Some\",\n  value\n} as const)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Option<Value extends Schema.Any> extends\n  Annotable<\n    Option<Value>,\n    option_.Option<Schema.Type<Value>>,\n    OptionEncoded<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 1.0.0\n */\nexport const Option = <Value extends Schema.Any>(value: Value): Option<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    optionEncoded(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      decode: optionDecode,\n      encode: option_.match({\n        onNone: () => makeNoneEncoded,\n        onSome: makeSomeEncoded\n      })\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface OptionFromNullOr<Value extends Schema.Any> extends\n  Annotable<\n    OptionFromNullOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 1.0.0\n */\nexport const OptionFromNullOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromNullOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(NullOr(value_), OptionFromSelf(typeSchema(value_)), {\n    decode: option_.fromNullable,\n    encode: option_.getOrNull\n  })\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface OptionFromNullishOr<Value extends Schema.Any> extends\n  Annotable<\n    OptionFromNullishOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 1.0.0\n */\nexport const OptionFromNullishOr = <Value extends Schema.Any>(\n  value: Value,\n  onNoneEncoding: null | undefined\n): OptionFromNullishOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    NullishOr(value_),\n    OptionFromSelf(typeSchema(value_)),\n    { decode: option_.fromNullable, encode: onNoneEncoding === null ? option_.getOrNull : option_.getOrUndefined }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface OptionFromUndefinedOr<Value extends Schema.Any> extends\n  Annotable<\n    OptionFromUndefinedOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 1.0.0\n */\nexport const OptionFromUndefinedOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromUndefinedOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(UndefinedOr(value_), OptionFromSelf(typeSchema(value_)), {\n    decode: option_.fromNullable,\n    encode: option_.getOrUndefined\n  })\n}\n\n/**\n * @category Either utils\n * @since 1.0.0\n */\nexport type RightEncoded<IA> = {\n  readonly _tag: \"Right\"\n  readonly right: IA\n}\n\n/**\n * @category Either utils\n * @since 1.0.0\n */\nexport type LeftEncoded<IE> = {\n  readonly _tag: \"Left\"\n  readonly left: IE\n}\n\n/**\n * @category Either utils\n * @since 1.0.0\n */\nexport type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>\n\nconst rightEncoded = <RA, RI, RR>(right: Schema<RA, RI, RR>): Schema<RightEncoded<RA>, RightEncoded<RI>, RR> =>\n  Struct({\n    _tag: Literal(\"Right\"),\n    right\n  }).annotations({ description: `RightEncoded<${format(right)}>` })\n\nconst leftEncoded = <LA, LI, LR>(left: Schema<LA, LI, LR>): Schema<LeftEncoded<LA>, LeftEncoded<LI>, LR> =>\n  Struct({\n    _tag: Literal(\"Left\"),\n    left\n  }).annotations({ description: `LeftEncoded<${format(left)}>` })\n\nconst eitherEncoded = <RA, RI, RR, LA, LI, LR>(\n  right: Schema<RA, RI, RR>,\n  left: Schema<LA, LI, LR>\n) =>\n  Union(rightEncoded(right), leftEncoded(left)).annotations({\n    description: `EitherEncoded<${format(left)}, ${format(right)}>`\n  })\n\nconst eitherDecode = <R, L>(input: EitherEncoded<R, L>): either_.Either<R, L> =>\n  input._tag === \"Left\" ? either_.left(input.left) : either_.right(input.right)\n\nconst eitherArbitrary = <R, L>(\n  right: LazyArbitrary<R>,\n  left: LazyArbitrary<L>\n): LazyArbitrary<either_.Either<R, L>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Left\" as const), left: left(fc) }),\n    fc.record({ _tag: fc.constant(\"Right\" as const), right: right(fc) })\n  ).map(eitherDecode)\n\nconst eitherPretty = <R, L>(\n  right: pretty_.Pretty<R>,\n  left: pretty_.Pretty<L>\n): pretty_.Pretty<either_.Either<R, L>> =>\n  either_.match({\n    onLeft: (e) => `left(${left(e)})`,\n    onRight: (a) => `right(${right(a)})`\n  })\n\nconst eitherParse = <RR, R, LR, L>(\n  parseRight: ParseResult.DecodeUnknown<R, RR>,\n  decodeUnknownLeft: ParseResult.DecodeUnknown<L, LR>\n): ParseResult.DeclarationDecodeUnknown<either_.Either<R, L>, LR | RR> =>\n(u, options, ast) =>\n  either_.isEither(u) ?\n    either_.match(u, {\n      onLeft: (left) => ParseResult.map(decodeUnknownLeft(left, options), either_.left),\n      onRight: (right) => ParseResult.map(parseRight(right, options), either_.right)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface EitherFromSelf<R extends Schema.Any, L extends Schema.Any> extends\n  Annotable<\n    EitherFromSelf<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 1.0.0\n */\nexport const EitherFromSelf = <R extends Schema.Any, L extends Schema.Any>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromSelf<R, L> => {\n  return declare(\n    [right, left],\n    {\n      decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),\n      encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))\n    },\n    {\n      description: `Either<${format(right)}, ${format(left)}>`,\n      pretty: eitherPretty,\n      arbitrary: eitherArbitrary,\n      equivalence: (right, left) => either_.getEquivalence({ left, right })\n    }\n  )\n}\n\nconst makeLeftEncoded = <E>(left: E) => (({\n  _tag: \"Left\",\n  left\n}) as const)\nconst makeRightEncoded = <A>(right: A) => (({\n  _tag: \"Right\",\n  right\n}) as const)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Either<R extends Schema.Any, L extends Schema.Any> extends\n  Annotable<\n    Either<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    EitherEncoded<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 1.0.0\n */\nexport const Either = <R extends Schema.Any, L extends Schema.Any>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): Either<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  return transform(\n    eitherEncoded(right_, left_),\n    EitherFromSelf({ left: typeSchema(left_), right: typeSchema(right_) }),\n    { decode: eitherDecode, encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded }) }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface EitherFromUnion<R extends Schema.Any, L extends Schema.Any> extends\n  Annotable<\n    EitherFromUnion<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    Schema.Encoded<R> | Schema.Encoded<L>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @example\n * import * as Schema from \"@effect/schema/Schema\"\n *\n * // Schema<string | number, Either<string, number>>\n * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })\n *\n * @category Either transformations\n * @since 1.0.0\n */\nexport const EitherFromUnion = <R extends Schema.Any, L extends Schema.Any>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromUnion<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  const toright = typeSchema(right_)\n  const toleft = typeSchema(left_)\n  const fromRight = transform(right_, rightEncoded(toright), { decode: makeRightEncoded, encode: (r) => r.right })\n  const fromLeft = transform(left_, leftEncoded(toleft), { decode: makeLeftEncoded, encode: (l) => l.left })\n  return transform(\n    Union(fromRight, fromLeft),\n    EitherFromSelf({ left: toleft, right: toright }),\n    {\n      decode: (from) => from._tag === \"Left\" ? either_.left(from.left) : either_.right(from.right),\n      encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded })\n    }\n  )\n}\n\nconst mapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>\n): LazyArbitrary<Map<K, V>> =>\n(fc) => fc.array(fc.tuple(key(fc), value(fc))).map((as) => new Map(as))\n\nconst readonlyMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<ReadonlyMap<K, V>> =>\n(map) =>\n  `new Map([${\n    Array.from(map.entries())\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst readonlyMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<ReadonlyMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())))\n}\n\nconst readonlyMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlyMap<K, V>, R> =>\n(u, options, ast) =>\n  Predicate.isMap(u) ?\n    ParseResult.map(decodeUnknown(Array.from(u.entries()), options), (as): ReadonlyMap<K, V> => new Map(as))\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  Annotable<\n    ReadonlyMapFromSelf<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst mapFromSelf_ = <K extends Schema.Any, V extends Schema.Any>(\n  key: K,\n  value: V,\n  description: string\n): ReadonlyMapFromSelf<K, V> =>\n  declare(\n    [key, value],\n    {\n      decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown($Array(Tuple(Key, Value)))),\n      encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown($Array(Tuple(Key, Value))))\n    },\n    {\n      description,\n      pretty: readonlyMapPretty,\n      arbitrary: mapArbitrary,\n      equivalence: readonlyMapEquivalence\n    }\n  )\n\n/**\n * @category ReadonlyMap\n * @since 1.0.0\n */\nexport const ReadonlyMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMapFromSelf<K, V> => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  Annotable<\n    MapFromSelf<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category Map\n * @since 1.0.0\n */\nexport const MapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): MapFromSelf<K, V> => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $ReadonlyMap<K extends Schema.Any, V extends Schema.Any> extends\n  Annotable<\n    $ReadonlyMap<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category ReadonlyMap transformations\n * @since 1.0.0\n */\nexport const ReadonlyMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): $ReadonlyMap<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    $Array(Tuple(key_, value_)),\n    ReadonlyMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $Map<K extends Schema.Any, V extends Schema.Any> extends\n  Annotable<\n    $Map<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst map = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): $Map<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    $Array(Tuple(key_, value_)),\n    MapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\nexport {\n  /**\n   * @category Map transformations\n   * @since 1.0.0\n   */\n  map as Map\n}\n\nconst setArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<ReadonlySet<A>> => (fc) =>\n  fc.array(item(fc)).map((as) => new Set(as))\n\nconst readonlySetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<ReadonlySet<A>> => (set) =>\n  `new Set([${Array.from(set.values()).map((a) => item(a)).join(\", \")}])`\n\nconst readonlySetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<ReadonlySet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())))\n}\n\nconst readonlySetParse = <R, A>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlySet<A>, R> =>\n(u, options, ast) =>\n  Predicate.isSet(u) ?\n    ParseResult.map(decodeUnknown(Array.from(u.values()), options), (as): ReadonlySet<A> => new Set(as))\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface ReadonlySetFromSelf<Value extends Schema.Any> extends\n  Annotable<\n    ReadonlySetFromSelf<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst setFromSelf_ = <Value extends Schema.Any>(value: Value, description: string): ReadonlySetFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (item) => readonlySetParse(ParseResult.decodeUnknown($Array(item))),\n      encode: (item) => readonlySetParse(ParseResult.encodeUnknown($Array(item)))\n    },\n    {\n      description,\n      pretty: readonlySetPretty,\n      arbitrary: setArbitrary,\n      equivalence: readonlySetEquivalence\n    }\n  )\n\n/**\n * @category ReadonlySet\n * @since 1.0.0\n */\nexport const ReadonlySetFromSelf = <Value extends Schema.Any>(value: Value): ReadonlySetFromSelf<Value> =>\n  setFromSelf_(value, `ReadonlySet<${format(value)}>`)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface SetFromSelf<Value extends Schema.Any> extends\n  Annotable<\n    SetFromSelf<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Set\n * @since 1.0.0\n */\nexport const SetFromSelf = <Value extends Schema.Any>(value: Value): SetFromSelf<Value> =>\n  setFromSelf_(value, `Set<${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $ReadonlySet<Value extends Schema.Any> extends\n  Annotable<\n    $ReadonlySet<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category ReadonlySet transformations\n * @since 1.0.0\n */\nexport const ReadonlySet = <Value extends Schema.Any>(value: Value): $ReadonlySet<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    $Array(value_),\n    ReadonlySetFromSelf(typeSchema(value_)),\n    { decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface $Set<Value extends Schema.Any> extends\n  Annotable<\n    $Set<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst set = <Value extends Schema.Any>(value: Value): $Set<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    $Array(value_),\n    SetFromSelf(typeSchema(value_)),\n    { decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\nexport {\n  /**\n   * @category Set transformations\n   * @since 1.0.0\n   */\n  set as Set\n}\n\nconst bigDecimalPretty = (): pretty_.Pretty<bigDecimal_.BigDecimal> => (val) =>\n  `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`\n\nconst bigDecimalArbitrary = (): LazyArbitrary<bigDecimal_.BigDecimal> => (fc) =>\n  fc.tuple(fc.bigInt(), fc.integer()).map(([value, scale]) => bigDecimal_.make(value, scale))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface BigDecimalFromSelf extends Annotable<BigDecimalFromSelf, bigDecimal_.BigDecimal> {}\n\n/**\n * @category BigDecimal constructors\n * @since 1.0.0\n */\nexport const BigDecimalFromSelf: BigDecimalFromSelf = declare(\n  bigDecimal_.isBigDecimal,\n  {\n    identifier: \"BigDecimalFromSelf\",\n    pretty: bigDecimalPretty,\n    arbitrary: bigDecimalArbitrary,\n    equivalence: () => bigDecimal_.Equivalence\n  }\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface BigDecimal extends Annotable<BigDecimal, bigDecimal_.BigDecimal, string> {}\n\n/**\n * @category BigDecimal transformations\n * @since 1.0.0\n */\nexport const BigDecimal: BigDecimal = transformOrFail(\n  $String,\n  BigDecimalFromSelf,\n  {\n    decode: (num, _, ast) =>\n      bigDecimal_.fromString(num).pipe(option_.match({\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, num)),\n        onSome: (val) => ParseResult.succeed(bigDecimal_.normalize(val))\n      })),\n    encode: (val) => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(val)))\n  }\n).annotations({ identifier: \"BigDecimal\" })\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface BigDecimalFromNumber extends Annotable<BigDecimalFromNumber, bigDecimal_.BigDecimal, number> {}\n\n/**\n * A schema that transforms a `number` into a `BigDecimal`.\n * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.\n *\n * @category BigDecimal transformations\n * @since 1.0.0\n */\nexport const BigDecimalFromNumber: BigDecimalFromNumber = transformOrFail(\n  $Number,\n  BigDecimalFromSelf,\n  {\n    decode: (num) => ParseResult.succeed(bigDecimal_.fromNumber(num)),\n    encode: (val) => ParseResult.succeed(bigDecimal_.unsafeToNumber(val))\n  }\n).annotations({ identifier: \"BigDecimalFromNumber\" })\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const GreaterThanBigDecimalTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/GreaterThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 1.0.0\n */\nexport const greaterThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => bigDecimal_.greaterThan(a, min), {\n      typeId: { id: GreaterThanBigDecimalTypeId, annotation: { min } },\n      description: `a BigDecimal greater than ${bigDecimal_.format(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const GreaterThanOrEqualToBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/GreaterThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 1.0.0\n */\nexport const greaterThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => bigDecimal_.greaterThanOrEqualTo(a, min), {\n      typeId: { id: GreaterThanOrEqualToBigDecimalTypeId, annotation: { min } },\n      description: `a BigDecimal greater than or equal to ${bigDecimal_.format(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LessThanBigDecimalTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/LessThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 1.0.0\n */\nexport const lessThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => bigDecimal_.lessThan(a, max), {\n      typeId: { id: LessThanBigDecimalTypeId, annotation: { max } },\n      description: `a BigDecimal less than ${bigDecimal_.format(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const LessThanOrEqualToBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/LessThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 1.0.0\n */\nexport const lessThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => bigDecimal_.lessThanOrEqualTo(a, max), {\n      typeId: { id: LessThanOrEqualToBigDecimalTypeId, annotation: { max } },\n      description: `a BigDecimal less than or equal to ${bigDecimal_.format(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const PositiveBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/PositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 1.0.0\n */\nexport const positiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => bigDecimal_.isPositive(a), {\n      typeId: { id: PositiveBigDecimalTypeId, annotation: {} },\n      description: `a positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 1.0.0\n */\nexport const PositiveBigDecimalFromSelf = BigDecimalFromSelf.pipe(\n  positiveBigDecimal({\n    identifier: \"PositiveBigDecimalFromSelf\",\n    title: \"PositiveBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const NonNegativeBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/NonNegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 1.0.0\n */\nexport const nonNegativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a.value >= 0n, {\n      typeId: { id: NonNegativeBigDecimalTypeId, annotation: {} },\n      description: `a non-negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 1.0.0\n */\nexport const NonNegativeBigDecimalFromSelf = BigDecimalFromSelf.pipe(\n  nonNegativeBigDecimal({\n    identifier: \"NonNegativeBigDecimalFromSelf\",\n    title: \"NonNegativeBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const NegativeBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/NegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 1.0.0\n */\nexport const negativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => bigDecimal_.isNegative(a), {\n      typeId: { id: NegativeBigDecimalTypeId, annotation: {} },\n      description: `a negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 1.0.0\n */\nexport const NegativeBigDecimalFromSelf = BigDecimalFromSelf.pipe(\n  negativeBigDecimal({\n    identifier: \"NegativeBigDecimalFromSelf\",\n    title: \"NegativeBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const NonPositiveBigDecimalTypeId: unique symbol = Symbol.for(\n  \"@effect/schema/TypeId/NonPositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 1.0.0\n */\nexport const nonPositiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => a.value <= 0n, {\n      typeId: { id: NonPositiveBigDecimalTypeId, annotation: {} },\n      description: `a non-positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 1.0.0\n */\nexport const NonPositiveBigDecimalFromSelf = BigDecimalFromSelf.pipe(\n  nonPositiveBigDecimal({\n    identifier: \"NonPositiveBigDecimalFromSelf\",\n    title: \"NonPositiveBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category type id\n * @since 1.0.0\n */\nexport const BetweenBigDecimalTypeId: unique symbol = Symbol.for(\"@effect/schema/TypeId/BetweenBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 1.0.0\n */\nexport const betweenBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  minimum: bigDecimal_.BigDecimal,\n  maximum: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): Schema<A, I, R> =>\n  self.pipe(\n    filter((a): a is A => bigDecimal_.between(a, { minimum, maximum }), {\n      typeId: { id: BetweenBigDecimalTypeId, annotation: { maximum, minimum } },\n      description: `a BigDecimal between ${bigDecimal_.format(minimum)} and ${bigDecimal_.format(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * Clamps a `BigDecimal` between a minimum and a maximum value.\n *\n * @category BigDecimal transformations\n * @since 1.0.0\n */\nexport const clampBigDecimal =\n  (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) =>\n  <R, I, A extends bigDecimal_.BigDecimal>(self: Schema<A, I, R>): Schema<A, I, R> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)),\n      { strict: false, decode: (self) => bigDecimal_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\nconst chunkArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<chunk_.Chunk<A>> => (fc) =>\n  fc.array(item(fc)).map(chunk_.fromIterable)\n\nconst chunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.Chunk<A>> => (c) =>\n  `Chunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst chunkParse = <R, A>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.Chunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) ?\n    chunk_.isEmpty(u) ?\n      ParseResult.succeed(chunk_.empty())\n      : ParseResult.map(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface ChunkFromSelf<Value extends Schema.Any> extends\n  Annotable<\n    ChunkFromSelf<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    chunk_.Chunk<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 1.0.0\n */\nexport const ChunkFromSelf = <Value extends Schema.Any>(value: Value): ChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => chunkParse(ParseResult.decodeUnknown($Array(item))),\n      encode: (item) => chunkParse(ParseResult.encodeUnknown($Array(item)))\n    },\n    {\n      description: `Chunk<${format(value)}>`,\n      pretty: chunkPretty,\n      arbitrary: chunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Chunk<Value extends Schema.Any> extends\n  Annotable<\n    Chunk<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 1.0.0\n */\nexport const Chunk = <Value extends Schema.Any>(value: Value): Chunk<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    $Array(value_),\n    ChunkFromSelf(typeSchema(value_)),\n    { decode: (as) => as.length === 0 ? chunk_.empty() : chunk_.fromIterable(as), encode: chunk_.toReadonlyArray }\n  )\n}\n\nconst toData = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(a: A): A =>\n  Array.isArray(a) ? data_.array(a) : data_.struct(a)\n\nconst dataArbitrary = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: LazyArbitrary<A>\n): LazyArbitrary<A> =>\n(fc) => item(fc).map(toData)\n\nconst dataPretty = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: pretty_.Pretty<A>\n): pretty_.Pretty<A> =>\n(d) => `Data(${item(d)})`\n\nconst dataParse = <R, A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<A, R> =>\n(u, options, ast) =>\n  Equal.isEqual(u) ?\n    ParseResult.map(decodeUnknown(u, options), toData)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Data transformations\n * @since 1.0.0\n */\nexport const DataFromSelf = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): Schema<A, I, R> => {\n  return declare(\n    [item],\n    {\n      decode: (item) => dataParse(ParseResult.decodeUnknown(item)),\n      encode: (item) => dataParse(ParseResult.encodeUnknown(item))\n    },\n    {\n      description: `Data<${format(item)}>`,\n      pretty: dataPretty,\n      arbitrary: dataArbitrary\n    }\n  )\n}\n\n/**\n * @category Data transformations\n * @since 1.0.0\n */\nexport const Data = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): Schema<A, I, R> =>\n  transform(\n    item,\n    DataFromSelf(typeSchema(item)),\n    { strict: false, decode: toData, encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a) }\n  )\n\ntype MissingSelfGeneric<Usage extends string, Params extends string = \"\"> =\n  `Missing \\`Self\\` generic - use \\`class Self extends ${Usage}<Self>()(${Params}{ ... })\\``\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Class<Self, Fields extends Struct.Fields, A, I, R, C, Inherited, Proto> extends Schema<Self, I, R> {\n  new(\n    props: keyof C extends never ? void | {} : C,\n    disableValidation?: boolean | undefined\n  ): A & Omit<Inherited, keyof A> & Proto\n\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n\n  readonly identifier: string\n\n  readonly extend: <Extended = never>(identifier: string) => <newFields extends Struct.Fields>(\n    fields: newFields,\n    annotations?: Annotations.Schema<Extended>\n  ) => [Extended] extends [never] ? MissingSelfGeneric<\"Base.extend\">\n    : Class<\n      Extended,\n      Fields & newFields,\n      Types.Simplify<A & Struct.Type<newFields>>,\n      Types.Simplify<I & Struct.Encoded<newFields>>,\n      R | Struct.Context<newFields>,\n      Types.Simplify<C & Struct.Type<newFields>>,\n      Self,\n      Proto\n    >\n\n  readonly transformOrFail: <Transformed = never>(identifier: string) => <\n    newFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: newFields,\n    options: {\n      readonly decode: (\n        input: A,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Types.Simplify<A & Struct.Type<newFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Types.Simplify<A & Struct.Type<newFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<A, ParseResult.ParseIssue, R3>\n    },\n    annotations?: Annotations.Schema<Transformed>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transform\">\n    : Class<\n      Transformed,\n      Fields & newFields,\n      Types.Simplify<A & Struct.Type<newFields>>,\n      I,\n      R | Struct.Context<newFields> | R2 | R3,\n      Types.Simplify<C & Struct.Type<newFields>>,\n      Self,\n      Proto\n    >\n\n  readonly transformOrFailFrom: <Transformed = never>(identifier: string) => <\n    newFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: newFields,\n    options: {\n      readonly decode: (\n        input: I,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Types.Simplify<I & Struct.Encoded<newFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Types.Simplify<I & Struct.Encoded<newFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>\n    },\n    annotations?: Annotations.Schema<Transformed>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformFrom\">\n    : Class<\n      Transformed,\n      Fields & newFields,\n      Types.Simplify<A & Struct.Type<newFields>>,\n      I,\n      R | Struct.Context<newFields> | R2 | R3,\n      Types.Simplify<C & Struct.Type<newFields>>,\n      Self,\n      Proto\n    >\n}\n\n/**\n * @category classes\n * @since 1.0.0\n */\nexport const Class = <Self = never>(identifier: string) =>\n<Fields extends Struct.Fields>(\n  fields: Fields,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"Class\">\n  : Class<\n    Self,\n    Fields,\n    Types.Simplify<Struct.Type<Fields>>,\n    Types.Simplify<Struct.Encoded<Fields>>,\n    Struct.Context<Fields>,\n    Types.Simplify<Struct.Type<Fields>>,\n    {},\n    {}\n  > => makeClass({ kind: \"Class\", identifier, fields, Base: data_.Class, annotations })\n\n/**\n * @category classes\n * @since 1.0.0\n */\nexport const TaggedClass = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fields: Fields,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedClass\", `\"Tag\", `>\n  : Class<\n    Self,\n    { readonly _tag: Literal<[Tag]> } & Fields,\n    Types.Simplify<{ readonly _tag: Tag } & Struct.Type<Fields>>,\n    Types.Simplify<{ readonly _tag: Tag } & Struct.Encoded<Fields>>,\n    Struct.Context<Fields>,\n    Types.Simplify<Struct.Type<Fields>>,\n    {},\n    {}\n  > =>\n  makeClass({\n    kind: \"TaggedClass\",\n    identifier: identifier ?? tag,\n    fields: extendFields({ _tag: Literal(tag) }, fields),\n    Base: data_.Class,\n    tag: { _tag: tag },\n    annotations\n  })\n\n/**\n * @category classes\n * @since 1.0.0\n */\nexport const TaggedError = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fields: Fields,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedError\", `\"Tag\", `>\n  : Class<\n    Self,\n    { readonly _tag: Literal<[Tag]> } & Fields,\n    Types.Simplify<{ readonly _tag: Tag } & Struct.Type<Fields>>,\n    Types.Simplify<{ readonly _tag: Tag } & Struct.Encoded<Fields>>,\n    Struct.Context<Fields>,\n    Types.Simplify<Struct.Type<Fields>>,\n    {},\n    cause_.YieldableError\n  > =>\n{\n  class Base extends data_.Error {}\n  ;(Base.prototype as any).name = tag\n  return makeClass({\n    kind: \"TaggedError\",\n    identifier: identifier ?? tag,\n    fields: extendFields({ _tag: Literal(tag) }, fields),\n    Base,\n    tag: { _tag: tag },\n    annotations,\n    toStringOverride(self) {\n      if ((Predicate.isString(self.message) && self.message.length > 0)) {\n        let message = `${self._tag}: ${self.message}`\n        if (Predicate.isString(self.stack)) {\n          message = `${message}\\n${self.stack.split(\"\\n\").slice(1).join(\"\\n\")}`\n        }\n        return message\n      }\n    }\n  })\n}\n\n/**\n * @category classes\n * @since 1.0.0\n */\nexport interface TaggedRequest<Tag extends string, S, SI, SR, A, AI, E, EI, RR>\n  extends Request.Request<A, E>, Serializable.SerializableWithResult<S, SI, SR, A, AI, E, EI, RR>\n{\n  readonly _tag: Tag\n}\n\n/**\n * @category classes\n * @since 1.0.0\n */\nexport declare namespace TaggedRequest {\n  /**\n   * @category classes\n   * @since 1.0.0\n   */\n  export type Any =\n    | TaggedRequest<string, any, any, any, any, any, any, any, any>\n    | TaggedRequest<string, any, any, any, any, any, never, never, any>\n}\n\n/**\n * @category classes\n * @since 1.0.0\n */\nexport const TaggedRequest =\n  <Self = never>(identifier?: string) =>\n  <Tag extends string, Fields extends Struct.Fields, EA, EI, ER, AA, AI, AR>(\n    tag: Tag,\n    Failure: Schema<EA, EI, ER>,\n    Success: Schema<AA, AI, AR>,\n    fields: Fields,\n    annotations?: Annotations.Schema<Self>\n  ): [Self] extends [never] ? MissingSelfGeneric<\"TaggedRequest\", `\"Tag\", SuccessSchema, FailureSchema, `>\n    : Class<\n      Self,\n      { readonly _tag: Literal<[Tag]> } & Fields,\n      Types.Simplify<{ readonly _tag: Tag } & Struct.Type<Fields>>,\n      Types.Simplify<{ readonly _tag: Tag } & Struct.Encoded<Fields>>,\n      Struct.Context<Fields>,\n      Types.Simplify<Struct.Type<Fields>>,\n      TaggedRequest<\n        Tag,\n        Self,\n        { readonly _tag: Tag } & Struct.Encoded<Fields>,\n        Struct.Context<Fields>,\n        AA,\n        AI,\n        EA,\n        EI,\n        ER | AR\n      >,\n      {}\n    > =>\n  {\n    class SerializableRequest extends Request.Class<any, any, { readonly _tag: string }> {\n      get [serializable_.symbol]() {\n        return this.constructor\n      }\n      get [serializable_.symbolResult]() {\n        return { Failure, Success }\n      }\n    }\n    return makeClass({\n      kind: \"TaggedRequest\",\n      identifier: identifier ?? tag,\n      fields: extendFields({ _tag: Literal(tag) }, fields),\n      Base: SerializableRequest,\n      tag: { _tag: tag },\n      annotations\n    })\n  }\n\nconst extendFields = (a: Struct.Fields, b: Struct.Fields): Struct.Fields => {\n  const out = { ...a }\n  for (const name of util_.ownKeys(b)) {\n    if (name in a) {\n      throw new Error(errors_.getDuplicatePropertySignatureErrorMessage(name))\n    }\n    out[name] = b[name]\n  }\n  return out\n}\n\nconst makeClass = ({ Base, annotations, fields, fromSchema, identifier, kind, tag, toStringOverride }: {\n  kind: string\n  identifier: string\n  fields: Struct.Fields\n  Base: new(...args: ReadonlyArray<any>) => any\n  fromSchema?: Schema.Any | undefined\n  tag?: { _tag: AST.LiteralValue } | undefined\n  annotations?: Annotations.Schema<any> | undefined\n  toStringOverride?: (self: any) => string | undefined\n}): any => {\n  const classSymbol = Symbol.for(`@effect/schema/${kind}/${identifier}`)\n  const schema = fromSchema ?? Struct(fields)\n  const from = option_.match(AST.getTitleAnnotation(schema.ast), {\n    onNone: () => schema.annotations({ title: `${identifier} (Encoded side)` }),\n    onSome: () => schema\n  })\n\n  return class extends Base {\n    constructor(\n      props: { [x: string | symbol]: unknown } = {},\n      disableValidation: boolean = false\n    ) {\n      if (tag !== undefined) {\n        props = { ...props, ...tag }\n      }\n      if (disableValidation !== true) {\n        props = ParseResult.validateSync(schema)(props)\n      }\n      super(props, true)\n    }\n\n    // ----------------\n    // Schema interface\n    // ----------------\n\n    static [TypeId] = variance\n\n    static get ast() {\n      const toSchema = typeSchema(schema)\n      const guard = ParseResult.is(toSchema)\n      const fallbackInstanceOf = (u: unknown) => Predicate.hasProperty(u, classSymbol) && guard(u)\n      const encode = ParseResult.encodeUnknown(toSchema)\n      const declaration: Schema.Any = declare(\n        [toSchema],\n        {\n          decode: () => (input, _, ast) =>\n            input instanceof this || fallbackInstanceOf(input)\n              ? ParseResult.succeed(input)\n              : ParseResult.fail(new ParseResult.Type(ast, input)),\n          encode: () => (input, options) =>\n            input instanceof this\n              ? ParseResult.succeed(input)\n              : ParseResult.map(\n                encode(input, options),\n                (props) => new this(props, true)\n              )\n        },\n        {\n          identifier,\n          title: identifier,\n          description: `an instance of ${identifier}`,\n          pretty: (pretty) => (self: any) => `${identifier}(${pretty(self)})`,\n          arbitrary: (arb) => (fc: any) => arb(fc).map((props: any) => new this(props)),\n          equivalence: identity,\n          [AST.SurrogateAnnotationId]: toSchema.ast,\n          ...annotations\n        }\n      )\n      const transformation = transform(\n        from,\n        declaration,\n        { decode: (input) => new this(input, true), encode: identity }\n      ).annotations({ [AST.SurrogateAnnotationId]: schema.ast })\n      return transformation.ast\n    }\n\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n\n    static annotations(annotations: Annotations.Schema<any>) {\n      return make(this.ast).annotations(annotations)\n    }\n\n    static toString() {\n      return `(${String(from)} <-> ${identifier})`\n    }\n\n    // ----------------\n    // Class interface\n    // ----------------\n\n    static fields = { ...fields }\n\n    static identifier = identifier\n\n    static extend<Extended>(identifier: string) {\n      return (newFields: Struct.Fields, annotations?: Annotations.Schema<Extended>) => {\n        const extendedFields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          fields: extendedFields,\n          Base: this,\n          tag,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFail<Transformed>(identifier: string) {\n      return (newFields: Struct.Fields, options: any, annotations?: Annotations.Schema<Transformed>) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          fromSchema: transformOrFail(\n            schema,\n            typeSchema(Struct(transformedFields)),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          tag,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFailFrom<Transformed>(identifier: string) {\n      return (newFields: Struct.Fields, options: any, annotations?: Annotations.Schema<Transformed>) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          fromSchema: transformOrFail(\n            encodedSchema(schema),\n            Struct(transformedFields),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          tag,\n          annotations\n        })\n      }\n    }\n\n    // ----------------\n    // other\n    // ----------------\n\n    get [classSymbol]() {\n      return classSymbol\n    }\n\n    toString() {\n      if (toStringOverride !== undefined) {\n        const out = toStringOverride(this)\n        if (out !== undefined) {\n          return out\n        }\n      }\n      return `${identifier}({ ${\n        util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n          .join(\", \")\n      } })`\n    }\n  }\n}\n\n/**\n * @category FiberId\n * @since 1.0.0\n */\nexport type FiberIdEncoded =\n  | {\n    readonly _tag: \"Composite\"\n    readonly left: FiberIdEncoded\n    readonly right: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Runtime\"\n    readonly id: number\n    readonly startTimeMillis: number\n  }\n\nconst FiberIdNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ identifier: \"FiberIdNoneEncoded\" })\n\nconst FiberIdRuntimeEncoded = Struct({\n  _tag: Literal(\"Runtime\"),\n  id: Int.annotations({\n    title: \"id\",\n    description: \"id\"\n  }),\n  startTimeMillis: Int.annotations({\n    title: \"startTimeMillis\",\n    description: \"startTimeMillis\"\n  })\n}).annotations({ identifier: \"FiberIdRuntimeEncoded\" })\n\nconst FiberIdCompositeEncoded = Struct({\n  _tag: Literal(\"Composite\"),\n  left: suspend(() => FiberIdEncoded),\n  right: suspend(() => FiberIdEncoded)\n}).annotations({ identifier: \"FiberIdCompositeEncoded\" })\n\nconst FiberIdEncoded: Schema<FiberIdEncoded> = Union(\n  FiberIdNoneEncoded,\n  FiberIdRuntimeEncoded,\n  FiberIdCompositeEncoded\n).annotations({ identifier: \"FiberIdEncoded\" })\n\nconst fiberIdArbitrary: LazyArbitrary<fiberId_.FiberId> = (fc) =>\n  fc.letrec((tie) => ({\n    None: fc.record({ _tag: fc.constant(\"None\" as const) }),\n    Runtime: fc.record({ _tag: fc.constant(\"Runtime\" as const), id: fc.integer(), startTimeMillis: fc.integer() }),\n    Composite: fc.record({ _tag: fc.constant(\"Composite\" as const), left: tie(\"FiberId\"), right: tie(\"FiberId\") }),\n    FiberId: fc.oneof(tie(\"None\"), tie(\"Runtime\"), tie(\"Composite\")) as any as fastCheck_.Arbitrary<fiberId_.FiberId>\n  })).FiberId.map(fiberIdDecode)\n\nconst fiberIdPretty: pretty_.Pretty<fiberId_.FiberId> = (fiberId) => {\n  switch (fiberId._tag) {\n    case \"None\":\n      return \"FiberId.none\"\n    case \"Runtime\":\n      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`\n    case \"Composite\":\n      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`\n  }\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface FiberIdFromSelf extends Annotable<FiberIdFromSelf, fiberId_.FiberId> {}\n\n/**\n * @category FiberId constructors\n * @since 1.0.0\n */\nexport const FiberIdFromSelf: FiberIdFromSelf = declare(\n  fiberId_.isFiberId,\n  {\n    identifier: \"FiberIdFromSelf\",\n    pretty: () => fiberIdPretty,\n    arbitrary: () => fiberIdArbitrary\n  }\n)\n\nconst fiberIdDecode = (input: FiberIdEncoded): fiberId_.FiberId => {\n  switch (input._tag) {\n    case \"None\":\n      return fiberId_.none\n    case \"Runtime\":\n      return fiberId_.runtime(input.id, input.startTimeMillis)\n    case \"Composite\":\n      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right))\n  }\n}\n\nconst fiberIdEncode = (input: fiberId_.FiberId): FiberIdEncoded => {\n  switch (input._tag) {\n    case \"None\":\n      return { _tag: \"None\" }\n    case \"Runtime\":\n      return { _tag: \"Runtime\", id: input.id, startTimeMillis: input.startTimeMillis }\n    case \"Composite\":\n      return {\n        _tag: \"Composite\",\n        left: fiberIdEncode(input.left),\n        right: fiberIdEncode(input.right)\n      }\n  }\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface FiberId extends Annotable<FiberId, fiberId_.FiberId, FiberIdEncoded> {}\n\n/**\n * @category FiberId transformations\n * @since 1.0.0\n */\nexport const FiberId: FiberId = transform(\n  FiberIdEncoded,\n  FiberIdFromSelf,\n  { decode: fiberIdDecode, encode: fiberIdEncode }\n).annotations({ identifier: \"FiberId\" })\n\n/**\n * @category Cause utils\n * @since 1.0.0\n */\nexport type CauseEncoded<E> =\n  | {\n    readonly _tag: \"Empty\"\n  }\n  | {\n    readonly _tag: \"Fail\"\n    readonly error: E\n  }\n  | {\n    readonly _tag: \"Die\"\n    readonly defect: unknown\n  }\n  | {\n    readonly _tag: \"Interrupt\"\n    readonly fiberId: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"Sequential\"\n    readonly left: CauseEncoded<E>\n    readonly right: CauseEncoded<E>\n  }\n  | {\n    readonly _tag: \"Parallel\"\n    readonly left: CauseEncoded<E>\n    readonly right: CauseEncoded<E>\n  }\n\nconst causeDieEncoded = <R>(defect: Schema<unknown, unknown, R>) =>\n  Struct({\n    _tag: Literal(\"Die\"),\n    defect\n  })\n\nconst CauseEmptyEncoded = Struct({\n  _tag: Literal(\"Empty\")\n})\n\nconst causeFailEncoded = <E, EI, R>(error: Schema<E, EI, R>) =>\n  Struct({\n    _tag: Literal(\"Fail\"),\n    error\n  })\n\nconst CauseInterruptEncoded = Struct({\n  _tag: Literal(\"Interrupt\"),\n  fiberId: FiberIdEncoded\n})\n\nconst causeParallelEncoded = <E, EI, R>(causeEncoded: Schema<CauseEncoded<E>, CauseEncoded<EI>, R>) =>\n  Struct({\n    _tag: Literal(\"Parallel\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeSequentialEncoded = <E, EI, R>(causeEncoded: Schema<CauseEncoded<E>, CauseEncoded<EI>, R>) =>\n  Struct({\n    _tag: Literal(\"Sequential\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeEncoded = <E, EI, R1, R2>(\n  error: Schema<E, EI, R1>,\n  defect: Schema<unknown, unknown, R2>\n): Schema<CauseEncoded<E>, CauseEncoded<EI>, R1 | R2> => {\n  const recur = suspend(() => out)\n  const out: Schema<CauseEncoded<E>, CauseEncoded<EI>, R1 | R2> = Union(\n    CauseEmptyEncoded,\n    causeFailEncoded(error),\n    causeDieEncoded(defect),\n    CauseInterruptEncoded,\n    causeSequentialEncoded(recur),\n    causeParallelEncoded(recur)\n  ).annotations({ description: `CauseEncoded<${format(error)}>` })\n  return out\n}\n\nconst causeArbitrary = <E>(\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<cause_.Cause<E>> =>\n(fc) =>\n  fc.letrec((tie) => ({\n    Empty: fc.record({ _tag: fc.constant(\"Empty\" as const) }),\n    Fail: fc.record({ _tag: fc.constant(\"Fail\" as const), error: error(fc) }),\n    Die: fc.record({ _tag: fc.constant(\"Die\" as const), defect: defect(fc) }),\n    Interrupt: fc.record({ _tag: fc.constant(\"Interrupt\" as const), fiberId: fiberIdArbitrary(fc) }),\n    Sequential: fc.record({ _tag: fc.constant(\"Sequential\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Parallel: fc.record({ _tag: fc.constant(\"Parallel\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Cause: fc.oneof(\n      tie(\"Empty\"),\n      tie(\"Fail\"),\n      tie(\"Die\"),\n      tie(\"Interrupt\"),\n      tie(\"Sequential\"),\n      tie(\"Parallel\")\n    ) as any as fastCheck_.Arbitrary<cause_.Cause<E>>\n  })).Cause.map(causeDecode)\n\nconst causePretty = <E>(error: pretty_.Pretty<E>): pretty_.Pretty<cause_.Cause<E>> => (cause) => {\n  const f = (cause: cause_.Cause<E>): string => {\n    switch (cause._tag) {\n      case \"Empty\":\n        return \"Cause.empty\"\n      case \"Fail\":\n        return `Cause.fail(${error(cause.error)})`\n      case \"Die\":\n        return `Cause.die(${cause_.pretty(cause)})`\n      case \"Interrupt\":\n        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`\n      case \"Sequential\":\n        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`\n      case \"Parallel\":\n        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`\n    }\n  }\n  return f(cause)\n}\n\nconst causeParse = <R, A>(\n  decodeUnknown: ParseResult.DecodeUnknown<CauseEncoded<A>, R>\n): ParseResult.DeclarationDecodeUnknown<cause_.Cause<A>, R> =>\n(u, options, ast) =>\n  cause_.isCause(u) ?\n    ParseResult.map(decodeUnknown(causeEncode(u), options), causeDecode)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface CauseFromSelf<E extends Schema.Any, DR> extends\n  Annotable<\n    CauseFromSelf<E, DR>,\n    cause_.Cause<Schema.Type<E>>,\n    cause_.Cause<Schema.Encoded<E>>,\n    Schema.Context<E> | DR\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 1.0.0\n */\nexport const CauseFromSelf = <E extends Schema.Any, DR = never>({ defect = Unknown, error }: {\n  readonly error: E\n  readonly defect?: Schema<unknown, unknown, DR> | undefined\n}): CauseFromSelf<E, DR> => {\n  return declare(\n    [error, defect],\n    {\n      decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),\n      encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))\n    },\n    {\n      description: `Cause<${format(error)}>`,\n      pretty: causePretty,\n      arbitrary: causeArbitrary\n    }\n  )\n}\n\nfunction causeDecode<E>(cause: CauseEncoded<E>): cause_.Cause<E> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return cause_.empty\n    case \"Fail\":\n      return cause_.fail(cause.error)\n    case \"Die\":\n      return cause_.die(cause.defect)\n    case \"Interrupt\":\n      return cause_.interrupt(fiberIdDecode(cause.fiberId))\n    case \"Sequential\":\n      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right))\n    case \"Parallel\":\n      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right))\n  }\n}\n\nfunction causeEncode<E>(cause: cause_.Cause<E>): CauseEncoded<E> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return { _tag: \"Empty\" }\n    case \"Fail\":\n      return { _tag: \"Fail\", error: cause.error }\n    case \"Die\":\n      return { _tag: \"Die\", defect: cause.defect }\n    case \"Interrupt\":\n      return { _tag: \"Interrupt\", fiberId: cause.fiberId }\n    case \"Sequential\":\n      return {\n        _tag: \"Sequential\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n    case \"Parallel\":\n      return {\n        _tag: \"Parallel\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n  }\n}\n\n/**\n * @category Cause transformations\n * @since 1.0.0\n */\nexport const CauseDefectUnknown: Unknown = transform(\n  Unknown,\n  Unknown,\n  {\n    decode: (u) => {\n      if (Predicate.isObject(u) && \"message\" in u && typeof u.message === \"string\") {\n        const err = new Error(u.message, { cause: u })\n        if (\"name\" in u && typeof u.name === \"string\") {\n          err.name = u.name\n        }\n        err.stack = \"stack\" in u && typeof u.stack === \"string\" ? u.stack : \"\"\n        return err\n      }\n      return String(u)\n    },\n    encode: (defect) => {\n      if (defect instanceof Error) {\n        return {\n          name: defect.name,\n          message: defect.message\n        }\n      }\n      return String(defect)\n    }\n  }\n)\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Cause<E extends Schema.All, DR> extends\n  Annotable<\n    Cause<E, DR>,\n    cause_.Cause<Schema.Type<E>>,\n    CauseEncoded<Schema.Encoded<E>>,\n    Schema.Context<E> | DR\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 1.0.0\n */\nexport const Cause = <E extends Schema.All, DR = never>({ defect = CauseDefectUnknown, error }: {\n  readonly error: E\n  readonly defect?: Schema<unknown, unknown, DR> | undefined\n}): Cause<E, DR> => {\n  const error_ = asSchema(error)\n  return transform(\n    causeEncoded(error_, defect),\n    CauseFromSelf({ error: typeSchema(error_), defect: typeSchema(defect) }),\n    { decode: causeDecode, encode: causeEncode }\n  )\n}\n\n/**\n * @category Exit utils\n * @since 1.0.0\n */\nexport type ExitEncoded<A, E> =\n  | {\n    readonly _tag: \"Failure\"\n    readonly cause: CauseEncoded<E>\n  }\n  | {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }\n\nconst exitFailureEncoded = <E, EI, ER, DR>(\n  error: Schema<E, EI, ER>,\n  defect: Schema<unknown, unknown, DR>\n) =>\n  Struct({\n    _tag: Literal(\"Failure\"),\n    cause: causeEncoded(error, defect)\n  }).annotations({ description: `FailureEncoded<${format(error)}>` })\n\nconst exitSuccessEncoded = <A, I, R>(\n  value: Schema<A, I, R>\n) =>\n  Struct({\n    _tag: Literal(\"Success\"),\n    value\n  }).annotations({ description: `SuccessEncoded<${format(value)}>` })\n\nconst exitEncoded = <A, I, R, E, EI, ER, DR>(\n  value: Schema<A, I, R>,\n  error: Schema<E, EI, ER>,\n  defect: Schema<unknown, unknown, DR>\n): Schema<ExitEncoded<A, E>, ExitEncoded<I, EI>, ER | R | DR> =>\n  Union(\n    exitFailureEncoded(error, defect),\n    exitSuccessEncoded(value)\n  ).annotations({\n    description: `ExitEncoded<${format(value)}, ${format(error)}>`\n  })\n\nconst exitDecode = <A, E>(input: ExitEncoded<A, E>): exit_.Exit<A, E> => {\n  switch (input._tag) {\n    case \"Failure\":\n      return exit_.failCause(causeDecode(input.cause))\n    case \"Success\":\n      return exit_.succeed(input.value)\n  }\n}\n\nconst exitArbitrary = <A, E>(\n  value: LazyArbitrary<A>,\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<exit_.Exit<A, E>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Failure\" as const), cause: causeArbitrary(error, defect)(fc) }),\n    fc.record({ _tag: fc.constant(\"Success\" as const), value: value(fc) })\n  ).map(exitDecode)\n\nconst exitPretty =\n  <A, E>(value: pretty_.Pretty<A>, error: pretty_.Pretty<E>): pretty_.Pretty<exit_.Exit<A, E>> => (exit) =>\n    exit._tag === \"Failure\"\n      ? `Exit.failCause(${causePretty(error)(exit.cause)})`\n      : `Exit.succeed(${value(exit.value)})`\n\nconst exitParse = <A, R, E, ER>(\n  decodeUnknownValue: ParseResult.DecodeUnknown<A, R>,\n  decodeUnknownCause: ParseResult.DecodeUnknown<cause_.Cause<E>, ER>\n): ParseResult.DeclarationDecodeUnknown<exit_.Exit<A, E>, ER | R> =>\n(u, options, ast) =>\n  exit_.isExit(u) ?\n    exit_.match(u, {\n      onFailure: (cause) => ParseResult.map(decodeUnknownCause(cause, options), exit_.failCause),\n      onSuccess: (value) => ParseResult.map(decodeUnknownValue(value, options), exit_.succeed)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface ExitFromSelf<A extends Schema.Any, E extends Schema.Any, DR> extends\n  Annotable<\n    ExitFromSelf<A, E, DR>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,\n    Schema.Context<A> | Schema.Context<E> | DR\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 1.0.0\n */\nexport const ExitFromSelf = <A extends Schema.Any, E extends Schema.Any, DR = never>(\n  { defect = Unknown, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect?: Schema<unknown, unknown, DR> | undefined\n  }\n): ExitFromSelf<A, E, DR> =>\n  declare(\n    [success, failure, defect],\n    {\n      decode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.decodeUnknown(success),\n          ParseResult.decodeUnknown(CauseFromSelf({ error: failure, defect }))\n        ),\n      encode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.encodeUnknown(success),\n          ParseResult.encodeUnknown(CauseFromSelf({ error: failure, defect }))\n        )\n    },\n    {\n      description: `Exit<${format(success)}, ${format(failure)}>`,\n      pretty: exitPretty,\n      arbitrary: exitArbitrary\n    }\n  )\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface Exit<A extends Schema.All, E extends Schema.All, DR> extends\n  Annotable<\n    Exit<A, E, DR>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    ExitEncoded<Schema.Encoded<A>, Schema.Encoded<E>>,\n    Schema.Context<A> | Schema.Context<E> | DR\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 1.0.0\n */\nexport const Exit = <A extends Schema.All, E extends Schema.All, DR = never>(\n  { defect = CauseDefectUnknown, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect?: Schema<unknown, unknown, DR> | undefined\n  }\n): Exit<A, E, DR> => {\n  const success_ = asSchema(success)\n  const failure_ = asSchema(failure)\n  return transform(\n    exitEncoded(success_, failure_, defect),\n    ExitFromSelf({ failure: typeSchema(failure_), success: typeSchema(success_), defect: typeSchema(defect) }),\n    {\n      decode: exitDecode,\n      encode: (exit) =>\n        exit._tag === \"Failure\"\n          ? { _tag: \"Failure\", cause: exit.cause } as const\n          : { _tag: \"Success\", value: exit.value } as const\n    }\n  )\n}\n\nconst hashSetArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<hashSet_.HashSet<A>> => (fc) =>\n  fc.array(item(fc)).map((as) => hashSet_.fromIterable(as))\n\nconst hashSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<hashSet_.HashSet<A>> => (set) =>\n  `HashSet(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst hashSetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<hashSet_.HashSet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashSetParse = <R, A>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<hashSet_.HashSet<A>, R> =>\n(u, options, ast) =>\n  hashSet_.isHashSet(u) ?\n    ParseResult.map(\n      decodeUnknown(Array.from(u), options),\n      (as): hashSet_.HashSet<A> => hashSet_.fromIterable(as)\n    )\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface HashSetFromSelf<Value extends Schema.Any> extends\n  Annotable<\n    HashSetFromSelf<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    hashSet_.HashSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 1.0.0\n */\nexport const HashSetFromSelf = <Value extends Schema.Any>(\n  value: Value\n): HashSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => hashSetParse(ParseResult.decodeUnknown($Array(item))),\n      encode: (item) => hashSetParse(ParseResult.encodeUnknown($Array(item)))\n    },\n    {\n      description: `HashSet<${format(value)}>`,\n      pretty: hashSetPretty,\n      arbitrary: hashSetArbitrary,\n      equivalence: hashSetEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface HashSet<Value extends Schema.Any> extends\n  Annotable<\n    HashSet<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 1.0.0\n */\nexport const HashSet = <Value extends Schema.Any>(value: Value): HashSet<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    $Array(value_),\n    HashSetFromSelf(typeSchema(value_)),\n    { decode: (as) => hashSet_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst hashMapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>\n): LazyArbitrary<hashMap_.HashMap<K, V>> =>\n(fc) => fc.array(fc.tuple(key(fc), value(fc))).map((as) => hashMap_.fromIterable(as))\n\nconst hashMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<hashMap_.HashMap<K, V>> =>\n(map) =>\n  `HashMap([${\n    Array.from(map)\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst hashMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<hashMap_.HashMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<hashMap_.HashMap<K, V>, R> =>\n(u, options, ast) =>\n  hashMap_.isHashMap(u) ?\n    ParseResult.map(decodeUnknown(Array.from(u), options), (as): hashMap_.HashMap<K, V> => hashMap_.fromIterable(as))\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  Annotable<\n    HashMapFromSelf<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 1.0.0\n */\nexport const HashMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMapFromSelf<K, V> => {\n  return declare(\n    [key, value],\n    {\n      decode: (key, value) => hashMapParse(ParseResult.decodeUnknown($Array(Tuple(key, value)))),\n      encode: (key, value) => hashMapParse(ParseResult.encodeUnknown($Array(Tuple(key, value))))\n    },\n    {\n      description: `HashMap<${format(key)}, ${format(value)}>`,\n      pretty: hashMapPretty,\n      arbitrary: hashMapArbitrary,\n      equivalence: hashMapEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface HashMap<K extends Schema.Any, V extends Schema.Any> extends\n  Annotable<\n    HashMap<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 1.0.0\n */\nexport const HashMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMap<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    $Array(Tuple(key_, value_)),\n    HashMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { decode: (as) => hashMap_.fromIterable(as), encode: (map) => Array.from(map) }\n  )\n}\n\nconst listArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<list_.List<A>> => (fc) =>\n  fc.array(item(fc)).map((as) => list_.fromIterable(as))\n\nconst listPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<list_.List<A>> => (set) =>\n  `List(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst listEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<list_.List<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst listParse = <R, A>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<list_.List<A>, R> =>\n(u, options, ast) =>\n  list_.isList(u) ?\n    ParseResult.map(\n      decodeUnknown(Array.from(u), options),\n      (as): list_.List<A> => list_.fromIterable(as)\n    )\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface ListFromSelf<Value extends Schema.Any> extends\n  Annotable<\n    ListFromSelf<Value>,\n    list_.List<Schema.Type<Value>>,\n    list_.List<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 1.0.0\n */\nexport const ListFromSelf = <Value extends Schema.Any>(\n  value: Value\n): ListFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => listParse(ParseResult.decodeUnknown($Array(item))),\n      encode: (item) => listParse(ParseResult.encodeUnknown($Array(item)))\n    },\n    {\n      description: `List<${format(value)}>`,\n      pretty: listPretty,\n      arbitrary: listArbitrary,\n      equivalence: listEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface List<Value extends Schema.Any> extends\n  Annotable<\n    List<Value>,\n    list_.List<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 1.0.0\n */\nexport const List = <Value extends Schema.Any>(value: Value): List<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    $Array(value_),\n    ListFromSelf(typeSchema(value_)),\n    { decode: (as) => list_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst sortedSetArbitrary =\n  <A>(item: LazyArbitrary<A>, ord: Order.Order<A>): LazyArbitrary<sortedSet_.SortedSet<A>> => (fc) =>\n    fc.array(item(fc)).map((as) => sortedSet_.fromIterable(as, ord))\n\nconst sortedSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<sortedSet_.SortedSet<A>> => (set) =>\n  `new SortedSet([${Array.from(sortedSet_.values(set)).map((a) => item(a)).join(\", \")}])`\n\nconst sortedSetParse = <R, A>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>,\n  ord: Order.Order<A>\n): ParseResult.DeclarationDecodeUnknown<sortedSet_.SortedSet<A>, R> =>\n(u, options, ast) =>\n  sortedSet_.isSortedSet(u) ?\n    ParseResult.map(decodeUnknown(Array.from(sortedSet_.values(u)), options), (as): sortedSet_.SortedSet<A> =>\n      sortedSet_.fromIterable(as, ord))\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface SortedSetFromSelf<Value extends Schema.Any> extends\n  Annotable<\n    SortedSetFromSelf<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    sortedSet_.SortedSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 1.0.0\n */\nexport const SortedSetFromSelf = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>,\n  ordI: Order.Order<Schema.Encoded<Value>>\n): SortedSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => sortedSetParse(ParseResult.decodeUnknown($Array(item)), ordA),\n      encode: (item) => sortedSetParse(ParseResult.encodeUnknown($Array(item)), ordI)\n    },\n    {\n      description: `SortedSet<${format(value)}>`,\n      pretty: sortedSetPretty,\n      arbitrary: (arb) => sortedSetArbitrary(arb, ordA),\n      equivalence: () => sortedSet_.getEquivalence<Schema.Type<Value>>()\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface SortedSet<Value extends Schema.Any> extends\n  Annotable<\n    SortedSet<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 1.0.0\n */\nexport const SortedSet = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>\n): SortedSet<Value> => {\n  const value_ = asSchema(value)\n  const to = typeSchema(value_)\n  return transform(\n    $Array(value_),\n    SortedSetFromSelf<typeof to>(to, ordA, ordA),\n    { decode: (as) => sortedSet_.fromIterable(as, ordA), encode: (set) => Array.from(sortedSet_.values(set)) }\n  )\n}\n\n/**\n * @category api interface\n * @since 1.0.0\n */\nexport interface BooleanFromUnknown extends Annotable<BooleanFromUnknown, boolean, unknown> {}\n\n/**\n * Converts an arbitrary value to a `boolean` by testing whether it is truthy.\n * Uses `!!val` to coerce the value to a `boolean`.\n *\n * @see https://developer.mozilla.org/docs/Glossary/Truthy\n * @category boolean constructors\n * @since 1.0.0\n */\nexport const BooleanFromUnknown: BooleanFromUnknown = transform(\n  Unknown,\n  $Boolean,\n  { decode: Predicate.isTruthy, encode: identity }\n).annotations({ identifier: \"BooleanFromUnknown\" })\n"],"names":["array_","bigDecimal_","bigInt_","boolean_","brand_","cause_","chunk_","data_","duration_","Effect","either_","Encoding","Equal","Equivalence","exit_","fiberId_","dual","identity","hashMap_","hashSet_","list_","number_","option_","pipeArguments","Predicate","Request","secret_","sortedSet_","string_","arbitrary_","AST","equivalence_","errors_","filters_","serializable_","util_","ParseResult","pretty_","TreeFormatter","TypeId","Symbol","for","variance","_A","_","_I","_R","toASTAnnotations","annotations","out","custom","Object","getOwnPropertySymbols","sym","typeId","undefined","TypeAnnotationId","id","annotation","move","from","to","MessageAnnotationId","IdentifierAnnotationId","TitleAnnotationId","DescriptionAnnotationId","ExamplesAnnotationId","DefaultAnnotationId","DocumentationAnnotationId","JSONSchemaAnnotationId","ArbitraryHookId","PrettyHookId","EquivalenceHookId","ConcurrencyAnnotationId","BatchingAnnotationId","ParseIssueTitleAnnotationId","SchemaImpl","ast","constructor","pipe","arguments","toString","String","asSchema","schema","hash","format","encodedSchema","make","encodedAST","typeSchema","typeAST","asserts","decodeOption","decodeSync","decodeUnknownOption","decodeUnknownSync","encodeOption","encodeSync","encodeUnknownOption","encodeUnknownSync","is","validateOption","validateSync","encodeUnknown","options","u","overrideOptions","mapError","parseError","encodeUnknownEither","mapLeft","encodeUnknownPromise","parser","runPromise","encode","encodeEither","encodePromise","decodeUnknown","decodeUnknownEither","decodeUnknownPromise","decode","decodeEither","decodePromise","validate","validateEither","validatePromise","isSchema","hasProperty","isObject","LiteralImpl","literals","isMembers","Union","mapMembers","literal","Literal","isNonEmptyReadonlyArray","Never","pickLiteral","_schema","UniqueSymbolFromSelf","symbol","UniqueSymbol","EnumsImpl","enums","Enums","keys","filter","key","map","TemplateLiteral","head","tail","types","getTemplateLiterals","span","flatMap","a","b","combineTemplateLiterals","isLiteral","spans","modifyNonEmptyLast","TemplateLiteralSpan","type","appendAll","_tag","Error","declareConstructor","typeParameters","Declaration","tp","declarePrimitive","input","succeed","fail","Type","declare","Array","isArray","BrandTypeId","fromBrand","self","Refinement","either","isLeft","some","left","v","message","join","none","InstanceOfTypeId","instanceOf","title","name","description","pretty","Undefined","undefinedKeyword","Void","voidKeyword","Null","null","neverKeyword","Unknown","unknownKeyword","Any","anyKeyword","$String","stringKeyword","$Number","numberKeyword","$Boolean","booleanKeyword","BigIntFromSelf","bigIntKeyword","SymbolFromSelf","symbolKeyword","$Object","objectKeyword","Boolean","Number","UnionImpl","members","m","NullOr","UndefinedOr","NullishOr","keyof","optionalElement","OptionalElementImpl","TupleTypeImpl","elements","rest","TupleType","Element","e","Tuple","args","slice","$ArrayImpl","value","$Array","NonEmptyArrayImpl","NonEmptyArray","formatToken","isOptional","PropertySignatureDeclaration","isReadonly","token","FromPropertySignature","fromKey","ToPropertySignature","formatPropertyKey","p","isString","JSON","stringify","PropertySignatureTransformation","PropertySignatureTypeId","propertySignatureAnnotations_","PropertySignatureImpl","_Key","_EncodedToken","_TypeToken","propertySignature","optionalToRequired","o","optionalToOptional","optional","isExact","exact","defaultValue","default","isNullable","nullable","asOption","as","match","onNone","onSome","OptionFromSelf","isNotNull","isNotUndefined","isPropertySignature","TypeLiteralImpl","fields","records","ownKeys","pss","length","transformations","i","field","toAnnotations","push","PropertySignature","issFrom","issTo","r","indexSignatures","propertySignatures","record","forEach","ps","IndexSignature","parameter","Transformation","TypeLiteral","TypeLiteralTransformation","iss","Struct","$RecordImpl","Record","pick","omit","pluck","getPropertyKeyIndexedAccess","orUndefined","transform","ak","makeBrandSchema","validateEither_","refined","unbranded","onLeft","error","formatErrorSync","onRight","setPrototypeOf","assign","getPrototypeOf","asBrandSchema","brand","brandAnnotation","getBrandAnnotation","brands","formatUnknown","BrandAnnotationId","partial","required","mutable","getExtendErrorMessage","x","y","path","getAPIErrorMessage","intersectTypeLiterals","isTypeLiteral","findIndex","extendAST","concat","intersectUnionMembers","xs","ys","isUnion","isTransformation","isTypeLiteralTransformation","transformation","propertySignatureTransformations","extend","that","compose","suspend","f","Suspend","predicate","isBoolean","transformOrFailImpl","transformOrFail","FinalTransformation","fromA","toI","transformLiteral","transformLiterals","pairs","attachPropertySignature","attached","isSymbol","identifier","examples","$default","documentation","jsonSchema","equivalence","concurrency","batching","parseIssueTitle","rename","mapping","TrimmedTypeId","trimmed","trim","MaxLengthTypeId","maxLength","MinLengthTypeId","minLength","PatternTypeId","pattern","regex","source","lastIndex","test","arbitrary","fc","stringMatching","StartsWithTypeId","startsWith","EndsWithTypeId","endsWith","IncludesTypeId","includes","searchString","LowercasedTypeId","lowercased","toLowerCase","Lowercased","UppercasedTypeId","uppercased","toUpperCase","Uppercased","LengthTypeId","Math","max","floor","min","Char","nonEmpty","Lowercase","s","Uppercase","Trimmed","Trim","split","separator","JsonString","parseJson","try","parse","reviver","catch","replacer","space","NonEmpty","UUIDTypeId","uuidRegex","UUID","uuid","ULIDTypeId","ulidRegex","ULID","ulid","FiniteTypeId","finite","isFinite","GreaterThanTypeId","greaterThan","exclusiveMinimum","GreaterThanOrEqualToTypeId","greaterThanOrEqualTo","minimum","MultipleOfTypeId","multipleOf","divisor","remainder","abs","IntTypeId","int","isSafeInteger","LessThanTypeId","lessThan","exclusiveMaximum","LessThanOrEqualToTypeId","lessThanOrEqualTo","maximum","BetweenTypeId","between","NonNaNTypeId","nonNaN","isNaN","positive","negative","nonPositive","nonNegative","clamp","strict","NumberFromString","fromOption","n","Finite","Int","NonNaN","Positive","Negative","NonPositive","NonNegative","JsonNumberTypeId","JsonNumber","Not","not","$Symbol","GreaterThanBigIntTypeId","GreaterThanBigintTypeId","greaterThanBigInt","GreaterThanOrEqualToBigIntTypeId","greaterThanOrEqualToBigInt","LessThanBigIntTypeId","lessThanBigInt","LessThanOrEqualToBigIntTypeId","lessThanOrEqualToBigInt","BetweenBigIntTypeId","BetweenBigintTypeId","betweenBigInt","positiveBigInt","negativeBigInt","nonNegativeBigInt","nonPositiveBigInt","clampBigInt","bigint","fromString","BigInt","PositiveBigIntFromSelf","PositiveBigInt","NegativeBigIntFromSelf","NegativeBigInt","NonPositiveBigIntFromSelf","NonPositiveBigInt","NonNegativeBigIntFromSelf","NonNegativeBigInt","BigIntFromNumber","fromNumber","toNumber","SecretFromSelf","isSecret","secret","string","Secret","str","DurationFromSelf","isDuration","oneof","constant","infinity","bigUint","nanos","micros","maxSafeNat","millis","seconds","minutes","hours","days","weeks","DurationFromNanos","duration","toNanos","val","DurationFromMillis","ms","toMillis","hrTime","Duration","toHrTime","clampDuration","betweenDuration","LessThanDurationTypeId","lessThanDuration","LessThanOrEqualToDurationTypeId","lessThanOrEqualToDuration","GreaterThanDurationTypeId","greaterThanDuration","GreaterThanOrEqualToDurationTypeId","greaterThanOrEqualToDuration","BetweenDurationTypeId","Uint8ArrayFromSelf","isUint8Array","u8arr","uint8Array","getEquivalence","equals","$Uint8Array","numbers","Uint8Array","makeEncodingTransformation","decodeException","Base64","decodeBase64","encodeBase64","Base64Url","decodeBase64Url","encodeBase64Url","Hex","decodeHex","encodeHex","MinItemsTypeId","minItems","MaxItemsTypeId","maxItems","ItemsCountTypeId","itemsCount","getNumberIndexedAccess","of","headOrElse","fallback","ValidDateTypeId","validDate","getTime","DateFromSelf","isDate","date","noInvalidDate","Date","ValidDateFromSelf","DateFromString","toISOString","$Date","OptionNoneEncoded","optionSomeEncoded","optionEncoded","optionDecode","optionArbitrary","optionPretty","optionParse","isOption","isNone","makeNoneEncoded","makeSomeEncoded","Option","value_","OptionFromNullOr","fromNullable","getOrNull","OptionFromNullishOr","onNoneEncoding","getOrUndefined","OptionFromUndefinedOr","rightEncoded","right","leftEncoded","eitherEncoded","eitherDecode","eitherArbitrary","eitherPretty","eitherParse","parseRight","decodeUnknownLeft","isEither","EitherFromSelf","makeLeftEncoded","makeRightEncoded","Either","right_","left_","EitherFromUnion","toright","toleft","fromRight","fromLeft","l","mapArbitrary","array","tuple","Map","readonlyMapPretty","entries","k","readonlyMapEquivalence","arrayEquivalence","ka","va","kb","vb","readonlyMapParse","isMap","mapFromSelf_","Key","Value","ReadonlyMapFromSelf","MapFromSelf","ReadonlyMap","key_","setArbitrary","item","Set","readonlySetPretty","set","values","readonlySetEquivalence","readonlySetParse","isSet","setFromSelf_","ReadonlySetFromSelf","SetFromSelf","ReadonlySet","bigDecimalPretty","normalize","bigDecimalArbitrary","bigInt","integer","scale","BigDecimalFromSelf","isBigDecimal","BigDecimal","num","BigDecimalFromNumber","unsafeToNumber","GreaterThanBigDecimalTypeId","greaterThanBigDecimal","GreaterThanOrEqualToBigDecimalTypeId","greaterThanOrEqualToBigDecimal","LessThanBigDecimalTypeId","lessThanBigDecimal","LessThanOrEqualToBigDecimalTypeId","lessThanOrEqualToBigDecimal","PositiveBigDecimalTypeId","positiveBigDecimal","isPositive","PositiveBigDecimalFromSelf","NonNegativeBigDecimalTypeId","nonNegativeBigDecimal","NonNegativeBigDecimalFromSelf","NegativeBigDecimalTypeId","negativeBigDecimal","isNegative","NegativeBigDecimalFromSelf","NonPositiveBigDecimalTypeId","nonPositiveBigDecimal","NonPositiveBigDecimalFromSelf","BetweenBigDecimalTypeId","betweenBigDecimal","clampBigDecimal","chunkArbitrary","fromIterable","chunkPretty","c","toReadonlyArray","chunkParse","isChunk","isEmpty","empty","ChunkFromSelf","Chunk","toData","struct","dataArbitrary","dataPretty","d","dataParse","isEqual","DataFromSelf","Data","Class","makeClass","kind","Base","TaggedClass","tag","extendFields","TaggedError","prototype","toStringOverride","stack","TaggedRequest","Failure","Success","SerializableRequest","symbolResult","getDuplicatePropertySignatureErrorMessage","fromSchema","classSymbol","getTitleAnnotation","props","disableValidation","toSchema","guard","fallbackInstanceOf","declaration","arb","SurrogateAnnotationId","newFields","extendedFields","transformedFields","transformOrFailFrom","FiberIdNoneEncoded","FiberIdRuntimeEncoded","startTimeMillis","FiberIdCompositeEncoded","FiberIdEncoded","fiberIdArbitrary","letrec","tie","None","Runtime","Composite","FiberId","fiberIdDecode","fiberIdPretty","fiberId","FiberIdFromSelf","isFiberId","runtime","composite","fiberIdEncode","causeDieEncoded","defect","CauseEmptyEncoded","causeFailEncoded","CauseInterruptEncoded","causeParallelEncoded","causeEncoded","causeSequentialEncoded","recur","causeArbitrary","Empty","Fail","Die","Interrupt","Sequential","Parallel","Cause","causeDecode","causePretty","cause","causeParse","isCause","causeEncode","CauseFromSelf","die","interrupt","sequential","parallel","CauseDefectUnknown","err","error_","exitFailureEncoded","exitSuccessEncoded","exitEncoded","exitDecode","failCause","exitArbitrary","exitPretty","exit","exitParse","decodeUnknownValue","decodeUnknownCause","isExit","onFailure","onSuccess","ExitFromSelf","failure","success","Exit","success_","failure_","hashSetArbitrary","hashSetPretty","hashSetEquivalence","hashSetParse","isHashSet","HashSetFromSelf","HashSet","hashMapArbitrary","hashMapPretty","hashMapEquivalence","hashMapParse","isHashMap","HashMapFromSelf","HashMap","listArbitrary","listPretty","listEquivalence","listParse","isList","ListFromSelf","List","sortedSetArbitrary","ord","sortedSetPretty","sortedSetParse","isSortedSet","SortedSetFromSelf","ordA","ordI","SortedSet","BooleanFromUnknown","isTruthy"],"mappings":"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","ignoreList":[]}}]
}