{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/cbor-x/decode.js"],"sourcesContent":["let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet maxArraySize = 112810000 // This is the maximum array size in V8. We would potentially detect and set it higher\n// for JSC, but this is pretty large and should be sufficient for most use cases\nlet maxMapSize = 16810000 // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,\n// so we don't need to\n\nlet maxObjectSize = 16710000; // This is the maximum number of keys in a Map. It takes over a minute to create this\n// many keys in an object, so also probably a reasonable choice there.\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tif (i >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(key, read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tif (token >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (token >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`)\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tif (!structure) throw new Error('Structure is required in record definition');\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\t// protect against prototype pollution\n\tif (typeof key === 'string') return key === '__proto__' ? '__proto_' : key\n\tif (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString();\n\tif (key == null) return key + '';\n\t// protect against expensive (DoS) string conversions\n\tthrow new Error('Invalid property name type ' + typeof key);\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + (value << BigInt(8))\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length < position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet startingPosition = position\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) {// there is a cycle, so we have to assign properties to original target\n\t\tif (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {\n\t\t\t// this means that the returned target does not match the targetProperties, so we need rerun the read to\n\t\t\t// have the correctly create instance be assigned as a reference, then we do the copy the properties back to the\n\t\t\t// target\n\t\t\t// reset the position so that the read can be repeated\n\t\t\tposition = startingPosition\n\t\t\t// the returned instance is our new target for references\n\t\t\ttarget = targetProperties\n\t\t\treferenceMap.set(id, { target })\n\t\t\ttargetProperties = read()\n\t\t}\n\t\treturn Object.assign(target, targetProperties)\n\t}\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 && !(buffer.byteOffset & 1) ||\n\t\t\t\t\tbytesPerElement === 4 && !(buffer.byteOffset & 3) ||\n\t\t\t\t\tbytesPerElement === 8 && !(buffer.byteOffset & 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport function setSizeLimits(limits) {\n\tif (limits.maxMapSize) maxMapSize = limits.maxMapSize;\n\tif (limits.maxArraySize) maxArraySize = limits.maxArraySize;\n\tif (limits.maxObjectSize) maxObjectSize = limits.maxObjectSize;\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1287, "column": 0}, "map": {"version":3,"sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/cbor-x/encode.js"],"sourcesContent":["import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as a plain object\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value >= BigInt(0))\n\t\t\t\t\t\t\ttarget[position++] = 0xc2 // tag 2\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc3 // tag 2\n\t\t\t\t\t\t\tvalue = BigInt(-1) - value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\twhile (value) {\n\t\t\t\t\t\t\tbytes.push(Number(value & BigInt(0xff)));\n\t\t\t\t\t\t\tvalue >>= BigInt(8);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twriteBuffer(new Uint8Array(bytes.reverse()), makeRoom);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, skipValues) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, true); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator] && !object.buffer) { // iterator, but exclude typed arrays\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2488, "column": 0}, "map": {"version":3,"sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/cbor-x/iterators.js"],"sourcesContent":["import { Encoder } from './encode.js'\nimport { Decoder } from './decode.js'\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - cbor-x Encoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function encodeIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return encodeIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return encodeIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * encodeIterSync (objectIterator, options) {\n  const encoder = new Encoder(options)\n  for (const value of objectIterator) {\n    yield encoder.encode(value)\n  }\n}\n\nasync function * encodeIterAsync (objectIterator, options) {\n  const encoder = new Encoder(options)\n  for await (const value of objectIterator) {\n    yield encoder.encode(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - Decoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function decodeIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const decoder = new Decoder(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = decoder.decodeMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\n"],"names":[],"mappings":";;;;;;AAsDc;AAtDd;AACA;;;AASO,SAAS,WAAY,cAAc,EAAE,UAAU,CAAC,CAAC;IACtD,IAAI,CAAC,kBAAkB,OAAO,mBAAmB,UAAU;QACzD,MAAM,IAAI,MAAM;IAClB,OAAO,IAAI,OAAO,cAAc,CAAC,OAAO,QAAQ,CAAC,KAAK,YAAY;QAChE,OAAO,eAAe,gBAAgB;IACxC,OAAO,IAAI,OAAO,eAAe,IAAI,KAAK,cAAc,OAAO,cAAc,CAAC,OAAO,aAAa,CAAC,KAAK,YAAY;QAClH,OAAO,gBAAgB,gBAAgB;IACzC,OAAO;QACL,MAAM,IAAI,MAAM;IAClB;AACF;AAEA,UAAW,eAAgB,cAAc,EAAE,OAAO;IAChD,MAAM,UAAU,IAAI,iKAAO,CAAC;IAC5B,KAAK,MAAM,SAAS,eAAgB;QAClC,MAAM,QAAQ,MAAM,CAAC;IACvB;AACF;AAEA,gBAAiB,gBAAiB,cAAc,EAAE,OAAO;IACvD,MAAM,UAAU,IAAI,iKAAO,CAAC;IAC5B,WAAW,MAAM,SAAS,eAAgB;QACxC,MAAM,QAAQ,MAAM,CAAC;IACvB;AACF;AASO,SAAS,WAAY,cAAc,EAAE,UAAU,CAAC,CAAC;IACtD,IAAI,CAAC,kBAAkB,OAAO,mBAAmB,UAAU;QACzD,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,UAAU,IAAI,iJAAO,CAAC;IAC5B,IAAI;IACJ,MAAM,SAAS,CAAC;QACd,IAAI;QACJ,4EAA4E;QAC5E,IAAI,YAAY;YACd,QAAQ,wKAAM,CAAC,MAAM,CAAC;gBAAC;gBAAY;aAAM;YACzC,aAAa;QACf;QAEA,IAAI;YACF,SAAS,QAAQ,cAAc,CAAC;QAClC,EAAE,OAAO,KAAK;YACZ,IAAI,IAAI,UAAU,EAAE;gBAClB,aAAa,MAAM,KAAK,CAAC,IAAI,YAAY;gBACzC,SAAS,IAAI,MAAM;YACrB,OAAO;gBACL,MAAM;YACR;QACF;QACA,OAAO;IACT;IAEA,IAAI,OAAO,cAAc,CAAC,OAAO,QAAQ,CAAC,KAAK,YAAY;QACzD,OAAO,AAAC,UAAW;YACjB,KAAK,MAAM,SAAS,eAAgB;gBAClC,OAAQ,OAAO;YACjB;QACF;IACF,OAAO,IAAI,OAAO,cAAc,CAAC,OAAO,aAAa,CAAC,KAAK,YAAY;QACrE,OAAO,AAAC,gBAAiB;YACvB,WAAW,MAAM,SAAS,eAAgB;gBACxC,OAAQ,OAAO;YACjB;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2568, "column": 0}, "map": {"version":3,"sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/cbor-x/index.js"],"sourcesContent":["export { Encoder, addExtension, encode, encodeAsIterable, encodeAsAsyncIterable, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE } from './encode.js'\nexport { Tag, Decoder, decodeMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled, setSizeLimits } from './decode.js'\nexport { decodeIter, encodeIter } from './iterators.js'\n"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0]}}]
}