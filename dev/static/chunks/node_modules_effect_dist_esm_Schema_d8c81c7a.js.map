{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/effect/dist/esm/Schema.js","sources":["file:///Users/vata/HydroX-exchange/frontend/node_modules/effect/src/Schema.ts"],"sourcesContent":["/**\n * @since 3.10.0\n */\n\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport type { ArbitraryAnnotation, ArbitraryGenerationContext, LazyArbitrary } from \"./Arbitrary.js\"\nimport * as array_ from \"./Array.js\"\nimport * as bigDecimal_ from \"./BigDecimal.js\"\nimport * as bigInt_ from \"./BigInt.js\"\nimport * as boolean_ from \"./Boolean.js\"\nimport type { Brand } from \"./Brand.js\"\nimport * as cause_ from \"./Cause.js\"\nimport * as chunk_ from \"./Chunk.js\"\nimport * as config_ from \"./Config.js\"\nimport * as configError_ from \"./ConfigError.js\"\nimport * as data_ from \"./Data.js\"\nimport * as dateTime from \"./DateTime.js\"\nimport * as duration_ from \"./Duration.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as either_ from \"./Either.js\"\nimport * as Encoding from \"./Encoding.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport * as exit_ from \"./Exit.js\"\nimport * as fastCheck_ from \"./FastCheck.js\"\nimport * as fiberId_ from \"./FiberId.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual, identity } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport * as hashMap_ from \"./HashMap.js\"\nimport * as hashSet_ from \"./HashSet.js\"\nimport * as Inspectable from \"./Inspectable.js\"\nimport * as internalCause_ from \"./internal/cause.js\"\nimport * as errors_ from \"./internal/schema/errors.js\"\nimport * as schemaId_ from \"./internal/schema/schemaId.js\"\nimport * as util_ from \"./internal/schema/util.js\"\nimport * as list_ from \"./List.js\"\nimport * as number_ from \"./Number.js\"\nimport * as option_ from \"./Option.js\"\nimport type * as Order from \"./Order.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as pretty_ from \"./Pretty.js\"\nimport * as redacted_ from \"./Redacted.js\"\nimport * as Request from \"./Request.js\"\nimport * as scheduler_ from \"./Scheduler.js\"\nimport type { ParseOptions } from \"./SchemaAST.js\"\nimport * as AST from \"./SchemaAST.js\"\nimport * as sortedSet_ from \"./SortedSet.js\"\nimport * as string_ from \"./String.js\"\nimport * as struct_ from \"./Struct.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 3.10.0\n */\nexport type Simplify<A> = { [K in keyof A]: A[K] } & {}\n\n/**\n * @since 3.10.0\n */\nexport type SimplifyMutable<A> = {\n  -readonly [K in keyof A]: A[K]\n} extends infer B ? B : never\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Schema\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {\n  readonly Type: A\n  readonly Encoded: I\n  readonly Context: R\n  readonly ast: AST.AST\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   */\n  annotations(annotations: Annotations.GenericSchema<A>): Schema<A, I, R>\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.GenericSchema<A>): Self\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {\n  new(_: never): Schema.Variance<A, I, R>\n}\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function make<A, I = A, R = never>(ast: AST.AST): SchemaClass<A, I, R> {\n  return class SchemaClass {\n    [TypeId] = variance\n    static ast = ast\n    static annotations(annotations: Annotations.GenericSchema<A>) {\n      return make<A, I, R>(mergeSchemaAnnotations(this.ast, annotations))\n    }\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n    static toString() {\n      return String(ast)\n    }\n    static Type: A\n    static Encoded: I\n    static Context: R\n    static [TypeId] = variance\n  }\n}\n\nconst variance = {\n  /* c8 ignore next */\n  _A: (_: any) => _,\n  /* c8 ignore next */\n  _I: (_: any) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\nconst makeStandardResult = <A>(exit: exit_.Exit<StandardSchemaV1.Result<A>>): StandardSchemaV1.Result<A> =>\n  exit_.isSuccess(exit) ? exit.value : makeStandardFailureResult(cause_.pretty(exit.cause))\n\nconst makeStandardFailureResult = (message: string): StandardSchemaV1.FailureResult => ({\n  issues: [{ message }]\n})\n\nconst makeStandardFailureFromParseIssue = (\n  issue: ParseResult.ParseIssue\n): Effect.Effect<StandardSchemaV1.FailureResult> =>\n  Effect.map(ParseResult.ArrayFormatter.formatIssue(issue), (issues) => ({\n    issues: issues.map((issue) => ({\n      path: issue.path,\n      message: issue.message\n    }))\n  }))\n\n/**\n * Returns a \"Standard Schema\" object conforming to the [Standard Schema\n * v1](https://standardschema.dev/) specification.\n *\n * This function creates a schema whose `validate` method attempts to decode and\n * validate the provided input synchronously. If the underlying `Schema`\n * includes any asynchronous components (e.g., asynchronous message resolutions\n * or checks), then validation will necessarily return a `Promise` instead.\n *\n * Any detected defects will be reported via a single issue containing no\n * `path`.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * const schema = Schema.Struct({\n *   name: Schema.String\n * })\n *\n * //      ┌─── StandardSchemaV1<{ readonly name: string; }>\n * //      ▼\n * const standardSchema = Schema.standardSchemaV1(schema)\n * ```\n *\n * @category Standard Schema\n * @since 3.13.0\n */\nexport const standardSchemaV1 = <A, I>(\n  schema: Schema<A, I, never>,\n  overrideOptions?: AST.ParseOptions\n): StandardSchemaV1<I, A> & SchemaClass<A, I, never> => {\n  const decodeUnknown = ParseResult.decodeUnknown(schema, { errors: \"all\" })\n  return class StandardSchemaV1Class extends make<A, I, never>(schema.ast) {\n    static \"~standard\" = {\n      version: 1,\n      vendor: \"effect\",\n      validate(value) {\n        const scheduler = new scheduler_.SyncScheduler()\n        const fiber = Effect.runFork(\n          Effect.matchEffect(decodeUnknown(value, overrideOptions), {\n            onFailure: makeStandardFailureFromParseIssue,\n            onSuccess: (value) => Effect.succeed({ value })\n          }),\n          { scheduler }\n        )\n        scheduler.flush()\n        const exit = fiber.unsafePoll()\n        if (exit) {\n          return makeStandardResult(exit)\n        }\n        return new Promise((resolve) => {\n          fiber.addObserver((exit) => {\n            resolve(makeStandardResult(exit))\n          })\n        })\n      }\n    }\n  }\n}\n\ninterface AllAnnotations<A, TypeParameters extends ReadonlyArray<any>>\n  extends Annotations.Schema<A, TypeParameters>, PropertySignature.Annotations<A>\n{}\n\nconst builtInAnnotations = {\n  typeConstructor: AST.TypeConstructorAnnotationId,\n  schemaId: AST.SchemaIdAnnotationId,\n  message: AST.MessageAnnotationId,\n  missingMessage: AST.MissingMessageAnnotationId,\n  identifier: AST.IdentifierAnnotationId,\n  title: AST.TitleAnnotationId,\n  description: AST.DescriptionAnnotationId,\n  examples: AST.ExamplesAnnotationId,\n  default: AST.DefaultAnnotationId,\n  documentation: AST.DocumentationAnnotationId,\n  jsonSchema: AST.JSONSchemaAnnotationId,\n  arbitrary: AST.ArbitraryAnnotationId,\n  pretty: AST.PrettyAnnotationId,\n  equivalence: AST.EquivalenceAnnotationId,\n  concurrency: AST.ConcurrencyAnnotationId,\n  batching: AST.BatchingAnnotationId,\n  parseIssueTitle: AST.ParseIssueTitleAnnotationId,\n  parseOptions: AST.ParseOptionsAnnotationId,\n  decodingFallback: AST.DecodingFallbackAnnotationId\n}\n\nconst toASTAnnotations = <A, TypeParameters extends ReadonlyArray<any>>(\n  annotations?: AllAnnotations<A, TypeParameters>\n): AST.Annotations => {\n  if (!annotations) {\n    return {}\n  }\n  const out: Types.Mutable<AST.Annotations> = { ...annotations }\n\n  for (const key in builtInAnnotations) {\n    if (key in annotations) {\n      const id = builtInAnnotations[key as keyof typeof builtInAnnotations]\n      out[id] = annotations[key as keyof typeof annotations]\n      delete out[key]\n    }\n  }\n\n  return out\n}\n\nconst mergeSchemaAnnotations = <A>(ast: AST.AST, annotations: Annotations.Schema<A>): AST.AST =>\n  AST.annotations(ast, toASTAnnotations(annotations))\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotable {\n  /**\n   * @since 3.10.0\n   */\n  export type Self<S extends All> = ReturnType<S[\"annotations\"]>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Annotable<any, any, any, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Annotable<any, any, never, unknown>\n    | Annotable<any, never, any, unknown>\n    | Annotable<any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport function asSchema<S extends Schema.All>(\n  schema: S\n): Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>> {\n  return schema as any\n}\n\n/**\n * @category formatting\n * @since 3.10.0\n */\nexport const format = <S extends Schema.All>(schema: S): string => String(schema.ast)\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Schema {\n  /**\n   * @since 3.10.0\n   */\n  export interface Variance<A, I, R> {\n    readonly [TypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _I: Types.Invariant<I>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type ToAsserts<S extends AnyNoContext> = (\n    input: unknown,\n    options?: AST.ParseOptions\n  ) => asserts input is Schema.Type<S>\n\n  /**\n   * Any schema, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type Any = Schema<any, any, unknown>\n\n  /**\n   * Any schema with `Context = never`, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type AnyNoContext = Schema<any, any, never>\n\n  /**\n   * Any schema, including `never`.\n   *\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Schema<any, never, unknown>\n    | Schema<never, any, unknown>\n    | Schema<never, never, unknown>\n\n  /**\n   * Type-level counterpart of `Schema.asSchema` function.\n   *\n   * @since 3.10.0\n   */\n  export type AsSchema<S extends All> = Schema<Type<S>, Encoded<S>, Context<S>>\n}\n\n/**\n * The `encodedSchema` function allows you to extract the `Encoded` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without retaining any refinements or transformations that\n * were applied previously.\n *\n * @since 3.10.0\n */\nexport const encodedSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> => make(AST.encodedAST(schema.ast))\n\n/**\n * The `encodedBoundSchema` function is similar to `encodedSchema` but preserves\n * the refinements up to the first transformation point in the original schema.\n *\n * @since 3.10.0\n */\nexport const encodedBoundSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> =>\n  make(AST.encodedBoundAST(schema.ast))\n\n/**\n * The `typeSchema` function allows you to extract the `Type` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without considering the initial encoding or transformation\n * processes.\n *\n * @since 3.10.0\n */\nexport const typeSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<A> => make(AST.typeAST(schema.ast))\n\n/* c8 ignore start */\nexport {\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  asserts,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeSync,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownSync,\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @category validation\n   * @since 3.10.0\n   */\n  is,\n  /**\n   * @category validation\n   * @since 3.10.0\n   */\n  validateOption,\n  /**\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  validateSync\n} from \"./ParseResult.js\"\n/* c8 ignore end */\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const encodeUnknown = ParseResult.encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<I, ParseResult.ParseError, R> =>\n    ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<I, ParseResult.ParseError> =>\n    either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R> = encodeUnknown\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError> = encodeUnknownEither\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Promise<I> = encodeUnknownPromise\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const decodeUnknown = ParseResult.decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R> = decodeUnknown\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError> = decodeUnknownEither\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Promise<A> = decodeUnknownPromise\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validate = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validate = ParseResult.validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validateEither = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validateEither = ParseResult.validateEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validatePromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * Tests if a value is a `Schema`.\n *\n * @category guards\n * @since 3.10.0\n */\nexport const isSchema = (u: unknown): u is Schema.Any =>\n  Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId])\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>\n  extends AnnotableClass<Literal<Literals>, Literals[number]>\n{\n  readonly literals: Readonly<Literals>\n}\n\nfunction getDefaultLiteralAST<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals\n): AST.AST {\n  return AST.isMembers(literals)\n    ? AST.Union.make(AST.mapMembers(literals, (literal) => new AST.Literal(literal)))\n    : new AST.Literal(literals[0])\n}\n\nfunction makeLiteralClass<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals,\n  ast: AST.AST = getDefaultLiteralAST(literals)\n): Literal<Literals> {\n  return class LiteralClass extends make<Literals[number]>(ast) {\n    static override annotations(annotations: Annotations.Schema<Literals[number]>): Literal<Literals> {\n      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations))\n    }\n    static literals = [...literals] as Literals\n  }\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Literal<Literals>\nexport function Literal(): Never\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): SchemaClass<Literals[number]>\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): SchemaClass<Literals[number]> | Never {\n  return array_.isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never\n}\n\n/**\n * Creates a new `Schema` from a literal schema.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Schema } from \"effect\"\n *\n * const schema = Schema.Literal(\"a\", \"b\", \"c\").pipe(Schema.pickLiteral(\"a\", \"b\"))\n *\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"a\"), \"a\")\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"b\"), \"b\")\n * assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)(\"c\")), true)\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const pickLiteral =\n  <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) =>\n  <I, R>(_schema: Schema<A, I, R>): Literal<[...L]> => Literal(...literals)\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const UniqueSymbolFromSelf = <S extends symbol>(symbol: S): SchemaClass<S> => make(new AST.UniqueSymbol(symbol))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {\n  readonly enums: A\n}\n\n/**\n * @since 3.10.0\n */\nexport type EnumsDefinition = { [x: string]: string | number }\n\nconst getDefaultEnumsAST = <A extends EnumsDefinition>(enums: A) =>\n  new AST.Enums(\n    Object.keys(enums).filter(\n      (key) => typeof enums[enums[key]] !== \"number\"\n    ).map((key) => [key, enums[key]])\n  )\n\nconst makeEnumsClass = <A extends EnumsDefinition>(\n  enums: A,\n  ast: AST.AST = getDefaultEnumsAST(enums)\n): Enums<A> => (class EnumsClass extends make<A[keyof A]>(ast) {\n  static override annotations(annotations: Annotations.Schema<A[keyof A]>) {\n    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static enums = { ...enums }\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Enums = <A extends EnumsDefinition>(enums: A): Enums<A> => makeEnumsClass(enums)\n\ntype AppendType<\n  Template extends string,\n  Next\n> = Next extends AST.LiteralValue ? `${Template}${Next}`\n  : Next extends Schema<infer A extends AST.LiteralValue, infer _I, infer _R> ? `${Template}${A}`\n  : never\n\ntype GetTemplateLiteralType<Params> = Params extends [...infer Init, infer Last] ?\n  AppendType<GetTemplateLiteralType<Init>, Last>\n  : ``\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteral<A> extends SchemaClass<A> {}\n\ntype TemplateLiteralParameter = Schema.AnyNoContext | AST.LiteralValue\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteral = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParameter>>(\n  ...[head, ...tail]: Params\n): TemplateLiteral<GetTemplateLiteralType<Params>> => {\n  const spans: Array<AST.TemplateLiteralSpan> = []\n  let h = \"\"\n  let ts = tail\n\n  if (isSchema(head)) {\n    if (AST.isLiteral(head.ast)) {\n      h = String(head.ast.literal)\n    } else {\n      ts = [head, ...ts]\n    }\n  } else {\n    h = String(head)\n  }\n\n  for (let i = 0; i < ts.length; i++) {\n    const item = ts[i]\n    if (isSchema(item)) {\n      if (i < ts.length - 1) {\n        const next = ts[i + 1]\n        if (isSchema(next)) {\n          if (AST.isLiteral(next.ast)) {\n            spans.push(new AST.TemplateLiteralSpan(item.ast, String(next.ast.literal)))\n            i++\n            continue\n          }\n        } else {\n          spans.push(new AST.TemplateLiteralSpan(item.ast, String(next)))\n          i++\n          continue\n        }\n      }\n      spans.push(new AST.TemplateLiteralSpan(item.ast, \"\"))\n    } else {\n      spans.push(new AST.TemplateLiteralSpan(new AST.Literal(item), \"\"))\n    }\n  }\n\n  if (array_.isNonEmptyArray(spans)) {\n    return make(new AST.TemplateLiteral(h, spans))\n  } else {\n    return make(new AST.TemplateLiteral(\"\", [new AST.TemplateLiteralSpan(new AST.Literal(h), \"\")]))\n  }\n}\n\ntype TemplateLiteralParserParameters = Schema.Any | AST.LiteralValue\n\ntype GetTemplateLiteralParserType<Params> = Params extends [infer Head, ...infer Tail] ? readonly [\n    Head extends Schema<infer A, infer _I, infer _R> ? A : Head,\n    ...GetTemplateLiteralParserType<Tail>\n  ]\n  : []\n\ntype AppendEncoded<\n  Template extends string,\n  Next\n> = Next extends AST.LiteralValue ? `${Template}${Next}`\n  : Next extends Schema<infer _A, infer I extends AST.LiteralValue, infer _R> ? `${Template}${I}`\n  : never\n\ntype GetTemplateLiteralParserEncoded<Params> = Params extends [...infer Init, infer Last] ?\n  AppendEncoded<GetTemplateLiteralParserEncoded<Init>, Last>\n  : ``\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteralParser<Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>\n  extends\n    Schema<\n      GetTemplateLiteralParserType<Params>,\n      GetTemplateLiteralParserEncoded<Params>,\n      Schema.Context<Params[number]>\n    >\n{\n  readonly params: Params\n}\n\nfunction getTemplateLiteralParserCoercedElement(encoded: Schema.Any, schema: Schema.Any): Schema.Any | undefined {\n  const ast = encoded.ast\n  switch (ast._tag) {\n    case \"Literal\": {\n      const literal = ast.literal\n      if (!Predicate.isString(literal)) {\n        const s = String(literal)\n        return transform(Literal(s), schema, {\n          strict: true,\n          decode: () => literal,\n          encode: () => s\n        })\n      }\n      break\n    }\n    case \"NumberKeyword\":\n      return compose(NumberFromString, schema)\n    case \"Union\": {\n      const members: Array<Schema.Any> = []\n      let hasCoercions = false\n      for (const member of ast.types) {\n        const schema = make(member)\n        const encoded = encodedSchema(schema)\n        const coerced = getTemplateLiteralParserCoercedElement(encoded, schema)\n        if (coerced) {\n          hasCoercions = true\n        }\n        members.push(coerced ?? schema)\n      }\n      return hasCoercions ? compose(Union(...members), schema) : schema\n    }\n  }\n}\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteralParser = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>(\n  ...params: Params\n): TemplateLiteralParser<Params> => {\n  const encodedSchemas: Array<Schema.Any> = []\n  const elements: Array<Schema.Any> = []\n  const schemas: Array<Schema.Any> = []\n  let coerced = false\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i]\n    const schema = isSchema(param) ? param : Literal(param)\n    schemas.push(schema)\n    const encoded = encodedSchema(schema)\n    encodedSchemas.push(encoded)\n    const element = getTemplateLiteralParserCoercedElement(encoded, schema)\n    if (element) {\n      elements.push(element)\n      coerced = true\n    } else {\n      elements.push(schema)\n    }\n  }\n  const from = TemplateLiteral(...encodedSchemas as any)\n  const re = AST.getTemplateLiteralCapturingRegExp(from.ast as AST.TemplateLiteral)\n  let to = Tuple(...elements)\n  if (coerced) {\n    to = to.annotations({ [AST.AutoTitleAnnotationId]: format(Tuple(...schemas)) })\n  }\n  return class TemplateLiteralParserClass extends transformOrFail(from, to, {\n    strict: false,\n    decode: (i, _, ast) => {\n      const match = re.exec(i)\n      return match\n        ? ParseResult.succeed(match.slice(1, params.length + 1))\n        : ParseResult.fail(new ParseResult.Type(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`))\n    },\n    encode: (tuple) => ParseResult.succeed(tuple.join(\"\"))\n  }) {\n    static params = params.slice()\n  } as any\n}\n\nconst declareConstructor = <\n  const TypeParameters extends ReadonlyArray<Schema.Any>,\n  I,\n  A\n>(\n  typeParameters: TypeParameters,\n  options: {\n    readonly decode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n    readonly encode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n  },\n  annotations?: Annotations.Schema<A, TypeParameters>\n): SchemaClass<A, I, Schema.Context<TypeParameters[number]>> =>\n  makeDeclareClass(\n    typeParameters,\n    new AST.Declaration(\n      typeParameters.map((tp) => tp.ast),\n      (...typeParameters) => options.decode(...typeParameters.map(make) as any),\n      (...typeParameters) => options.encode(...typeParameters.map(make) as any),\n      toASTAnnotations(annotations)\n    )\n  )\n\nconst declarePrimitive = <A>(\n  is: (input: unknown) => input is A,\n  annotations?: Annotations.Schema<A>\n): SchemaClass<A> => {\n  const decodeUnknown = () => (input: unknown, _: ParseOptions, ast: AST.Declaration) =>\n    is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input))\n  const encodeUnknown = decodeUnknown\n  return makeDeclareClass([], new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)))\n}\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface declare<\n  A,\n  I = A,\n  P extends ReadonlyArray<Schema.All> = readonly [],\n  R = Schema.Context<P[number]>\n> extends AnnotableClass<declare<A, I, P, R>, A, I, R> {\n  readonly typeParameters: Readonly<P>\n}\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface AnnotableDeclare<\n  Self extends declare<A, I, P, R>,\n  A,\n  I = A,\n  P extends ReadonlyArray<Schema.All> = readonly [],\n  R = Schema.Context<P[number]>\n> extends declare<A, I, P, R> {\n  annotations(annotations: Annotations.Schema<A>): Self\n}\n\nfunction makeDeclareClass<P extends ReadonlyArray<Schema.All>, A, I, R>(\n  typeParameters: P,\n  ast: AST.AST\n): declare<A, I, P, R> {\n  return class DeclareClass extends make<A, I, R>(ast) {\n    static override annotations(annotations: Annotations.Schema<A>): declare<A, I, P, R> {\n      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations))\n    }\n    static typeParameters = [...typeParameters] as any as P\n  }\n}\n\n/**\n * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const declare: {\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): declare<A>\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <A, I, const P extends ReadonlyArray<Schema.All>>(\n    typeParameters: P,\n    options: {\n      readonly decode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n      readonly encode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n    },\n    annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]> }>\n  ): declare<A, I, P>\n} = function() {\n  if (Array.isArray(arguments[0])) {\n    const typeParameters = arguments[0]\n    const options = arguments[1]\n    const annotations = arguments[2]\n    return declareConstructor(typeParameters, options, annotations)\n  }\n  const is = arguments[0]\n  const annotations = arguments[1]\n  return declarePrimitive(is, annotations)\n} as any\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BrandSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Brand\")\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const fromBrand = <C extends Brand<string | symbol>, A extends Brand.Unbranded<C>>(\n  constructor: Brand.Constructor<C>,\n  annotations?: Annotations.Filter<C, A>\n) =>\n<I, R>(self: Schema<A, I, R>): BrandSchema<A & C, I, R> => {\n  const out = makeBrandClass(\n    self,\n    new AST.Refinement(\n      self.ast,\n      function predicate(a: A, _: ParseOptions, ast: AST.AST): option_.Option<ParseResult.ParseIssue> {\n        const either = constructor.either(a)\n        return either_.isLeft(either) ?\n          option_.some(new ParseResult.Type(ast, a, either.left.map((v) => v.message).join(\", \"))) :\n          option_.none()\n      },\n      toASTAnnotations({\n        schemaId: BrandSchemaId,\n        [BrandSchemaId]: { constructor },\n        ...annotations\n      })\n    )\n  )\n  return out as any\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const InstanceOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/InstanceOf\")\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface instanceOf<A> extends AnnotableDeclare<instanceOf<A>, A> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const instanceOf = <A extends abstract new(...args: any) => any>(\n  constructor: A,\n  annotations?: Annotations.Schema<InstanceType<A>>\n): instanceOf<InstanceType<A>> =>\n  declare(\n    (u): u is InstanceType<A> => u instanceof constructor,\n    {\n      title: constructor.name,\n      description: `an instance of ${constructor.name}`,\n      pretty: (): pretty_.Pretty<InstanceType<A>> => String,\n      schemaId: InstanceOfSchemaId,\n      [InstanceOfSchemaId]: { constructor },\n      ...annotations\n    }\n  )\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Undefined extends make<undefined>(AST.undefinedKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Void extends make<void>(AST.voidKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Null extends make<null>(AST.null) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Never extends make<never>(AST.neverKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Unknown extends make<unknown>(AST.unknownKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Any extends make<any>(AST.anyKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class BigIntFromSelf extends make<bigint>(AST.bigIntKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class SymbolFromSelf extends make<symbol>(AST.symbolKeyword) {}\n\n/** @ignore */\nclass String$ extends make<string>(AST.stringKeyword) {}\n\n/** @ignore */\nclass Number$ extends make<number>(AST.numberKeyword) {}\n\n/** @ignore */\nclass Boolean$ extends make<boolean>(AST.booleanKeyword) {}\n\n/** @ignore */\nclass Object$ extends make<object>(AST.objectKeyword) {}\n\nexport {\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Boolean$ as Boolean,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Number$ as Number,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Object$ as Object,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  String$ as String\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Union<Members extends ReadonlyArray<Schema.All>> extends\n  AnnotableClass<\n    Union<Members>,\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >\n{\n  readonly members: Readonly<Members>\n}\n\nconst getDefaultUnionAST = <Members extends AST.Members<Schema.All>>(members: Members): AST.AST =>\n  AST.Union.make(members.map((m) => m.ast))\n\nfunction makeUnionClass<Members extends AST.Members<Schema.All>>(\n  members: Members,\n  ast: AST.AST = getDefaultUnionAST(members)\n): Union<Members> {\n  return class UnionClass extends make<\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >(ast) {\n    static override annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members> {\n      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static members = [...members]\n  }\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport function Union<Members extends AST.Members<Schema.All>>(...members: Members): Union<Members>\nexport function Union<Member extends Schema.All>(member: Member): Member\nexport function Union(): typeof Never\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n) {\n  return AST.isMembers(members)\n    ? makeUnionClass(members)\n    : array_.isNonEmptyReadonlyArray(members)\n    ? members[0]\n    : Never\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullOr<S extends Schema.All> extends Union<[S, typeof Null]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullOr = <S extends Schema.All>(self: S): NullOr<S> => Union(self, Null)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface UndefinedOr<S extends Schema.All> extends Union<[S, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const UndefinedOr = <S extends Schema.All>(self: S): UndefinedOr<S> => Union(self, Undefined)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullishOr<S extends Schema.All> extends Union<[S, typeof Null, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullishOr = <S extends Schema.All>(self: S): NullishOr<S> => Union(self, Null, Undefined)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const keyof = <A, I, R>(self: Schema<A, I, R>): SchemaClass<keyof A> => make<keyof A>(AST.keyof(self.ast))\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Element {\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"\" | \"?\"\n}\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface Element<S extends Schema.Any, Token extends Element.Token>\n  extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly _Token: Token\n  readonly ast: AST.OptionalType\n  readonly from: S\n  annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>\n}\n\n/**\n * @since 3.10.0\n */\nexport const element = <S extends Schema.Any>(self: S): Element<S, \"\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, false), self)\n\n/**\n * @since 3.10.0\n */\nexport const optionalElement = <S extends Schema.Any>(self: S): Element<S, \"?\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, true), self)\n\nclass ElementImpl<S extends Schema.Any, Token extends Element.Token> implements Element<S, Token> {\n  readonly [TypeId]!: Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>[TypeId]\n  readonly _Token!: Token\n  constructor(\n    readonly ast: AST.OptionalType,\n    readonly from: S\n  ) {}\n  annotations(\n    annotations: Annotations.Schema<Schema.Type<S>>\n  ): ElementImpl<S, Token> {\n    return new ElementImpl(\n      new AST.OptionalType(\n        this.ast.type,\n        this.ast.isOptional,\n        { ...this.ast.annotations, ...toASTAnnotations(annotations) }\n      ),\n      this.from\n    )\n  }\n  toString() {\n    return `${this.ast.type}${this.ast.isOptional ? \"?\" : \"\"}`\n  }\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TupleType {\n  type ElementsType<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]>\n    : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]>\n    : Out\n\n  type ElementsEncoded<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]>\n    : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]>\n    : Out\n\n  /**\n   * @since 3.10.0\n   */\n  export type Elements = ReadonlyArray<Schema.Any | Element<Schema.Any, Element.Token>>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Rest = ReadonlyArray<Schema.Any | Element<Schema.Any, \"\">>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsType<Elements>,\n      ...ReadonlyArray<Schema.Type<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Type<Tail[K]> }\n    ]> :\n    ElementsType<Elements>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsEncoded<Elements>,\n      ...ReadonlyArray<Schema.Encoded<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Encoded<Tail[K]> }\n    ]> :\n    ElementsEncoded<Elements>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends\n  AnnotableClass<\n    TupleType<Elements, Rest>,\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >\n{\n  readonly elements: Readonly<Elements>\n  readonly rest: Readonly<Rest>\n}\n\nconst getDefaultTupleTypeAST = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest\n) =>\n  new AST.TupleType(\n    elements.map((el) => isSchema(el) ? new AST.OptionalType(el.ast, false) : el.ast),\n    rest.map((el) => isSchema(el) ? new AST.Type(el.ast) : el.ast),\n    true\n  )\n\nfunction makeTupleTypeClass<Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest,\n  ast: AST.AST = getDefaultTupleTypeAST(elements, rest)\n) {\n  return class TupleTypeClass extends make<\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >(ast) {\n    static override annotations(\n      annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>\n    ): TupleType<Elements, Rest> {\n      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static elements = [...elements] as any as Elements\n\n    static rest = [...rest] as any as Rest\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>\n}\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface Tuple2<Fst extends Schema.Any, Snd extends Schema.Any> extends\n  AnnotableClass<\n    Tuple2<Fst, Snd>,\n    readonly [Schema.Type<Fst>, Schema.Type<Snd>],\n    readonly [Schema.Encoded<Fst>, Schema.Encoded<Snd>],\n    Schema.Context<Fst> | Schema.Context<Snd>\n  >\n{\n  readonly elements: readonly [Fst, Snd]\n  readonly rest: readonly []\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Tuple<\n  const Elements extends TupleType.Elements,\n  Rest extends array_.NonEmptyReadonlyArray<TupleType.Rest[number]>\n>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>\nexport function Tuple<Fst extends Schema.Any, Snd extends Schema.Any>(fst: Fst, snd: Snd): Tuple2<Fst, Snd>\nexport function Tuple<Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>\nexport function Tuple(...args: ReadonlyArray<any>): any {\n  return Array.isArray(args[0])\n    ? makeTupleTypeClass(args[0], args.slice(1))\n    : makeTupleTypeClass(args, [])\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>\n}\n\nfunction makeArrayClass<Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n): Array$<Value> {\n  return class ArrayClass extends makeTupleTypeClass<[], [Value]>([], [value], ast) {\n    static override annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>) {\n      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static value = value\n  }\n}\n\nconst Array$ = <Value extends Schema.Any>(value: Value): Array$<Value> => makeArrayClass(value)\n\nexport {\n  /**\n   * @category constructors\n   * @since 3.10.0\n   */\n  Array$ as Array\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArray<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyArray<Value>,\n    array_.NonEmptyReadonlyArray<Schema.Type<Value>>,\n    array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{\n  readonly elements: readonly [Value]\n  readonly rest: readonly [Value]\n  readonly value: Value\n}\n\nfunction makeNonEmptyArrayClass<Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n) {\n  return class NonEmptyArrayClass extends makeTupleTypeClass<[Value], [Value]>([value], [value], ast) {\n    static override annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>) {\n      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static value = value\n  }\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const NonEmptyArray = <Value extends Schema.Any>(value: Value): NonEmptyArray<Value> =>\n  makeNonEmptyArrayClass(value) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ArrayEnsure<Value extends Schema.Any>\n  extends transform<Union<[Value, Array$<Value>]>, Array$<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function ArrayEnsure<Value extends Schema.Any>(value: Value): ArrayEnsure<Value> {\n  return transform(Union(value, Array$(value)), Array$(typeSchema(asSchema(value))), {\n    strict: true,\n    decode: (i) => array_.ensure(i),\n    encode: (a) => a.length === 1 ? a[0] : a\n  })\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArrayEnsure<Value extends Schema.Any>\n  extends transform<Union<[Value, NonEmptyArray<Value>]>, NonEmptyArray<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function NonEmptyArrayEnsure<Value extends Schema.Any>(value: Value): NonEmptyArrayEnsure<Value> {\n  return transform(Union(value, NonEmptyArray(value)), NonEmptyArray(typeSchema(asSchema(value))), {\n    strict: true,\n    decode: (i) => array_.isNonEmptyReadonlyArray(i) ? i : array_.of(i),\n    encode: (a) => a.length === 1 ? a[0] : a\n  })\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace PropertySignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"?:\" | \":\"\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<\n    Token,\n    any,\n    Key,\n    Token,\n    any,\n    boolean,\n    unknown\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type All<Key extends PropertyKey = PropertyKey> =\n    | Any<Key>\n    | PropertySignature<Token, never, Key, Token, any, boolean, unknown>\n    | PropertySignature<Token, any, Key, Token, never, boolean, unknown>\n    | PropertySignature<Token, never, Key, Token, never, boolean, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type AST =\n    | PropertySignatureDeclaration\n    | PropertySignatureTransformation\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n}\n\nconst formatPropertySignatureToken = (isOptional: boolean): string => isOptional ? \"\\\"?:\\\"\" : \"\\\":\\\"\"\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureDeclaration extends AST.OptionalType {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureDeclaration\"\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    const token = formatPropertySignatureToken(this.isOptional)\n    const type = String(this.type)\n    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class FromPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly fromKey?: PropertyKey | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class ToPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\nconst formatPropertyKey = (p: PropertyKey | undefined): string => {\n  if (p === undefined) {\n    return \"never\"\n  }\n  if (Predicate.isString(p)) {\n    return JSON.stringify(p)\n  }\n  return String(p)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureTransformation {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureTransformation\"\n  constructor(\n    readonly from: FromPropertySignature,\n    readonly to: ToPropertySignature,\n    readonly decode: AST.PropertySignatureTransformation[\"decode\"],\n    readonly encode: AST.PropertySignatureTransformation[\"encode\"]\n  ) {}\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${\n      formatPropertyKey(this.from.fromKey)\n    }, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`\n  }\n}\n\nconst mergeSignatureAnnotations = (\n  ast: PropertySignature.AST,\n  annotations: AST.Annotations\n): PropertySignature.AST => {\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return new PropertySignatureDeclaration(\n        ast.type,\n        ast.isOptional,\n        ast.isReadonly,\n        { ...ast.annotations, ...annotations },\n        ast.defaultValue\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      return new PropertySignatureTransformation(\n        ast.from,\n        new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {\n          ...ast.to.annotations,\n          ...annotations\n        }, ast.to.defaultValue),\n        ast.decode,\n        ast.encode\n      )\n    }\n  }\n}\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const PropertySignatureTypeId: unique symbol = Symbol.for(\"effect/PropertySignature\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type PropertySignatureTypeId = typeof PropertySignatureTypeId\n\n/**\n * @since 3.10.0\n * @category guards\n */\nexport const isPropertySignature = (u: unknown): u is PropertySignature.All =>\n  Predicate.hasProperty(u, PropertySignatureTypeId)\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport interface PropertySignature<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends Schema.Variance<Type, Encoded, R>, Pipeable {\n  readonly [PropertySignatureTypeId]: null\n  readonly _TypeToken: TypeToken\n  readonly _EncodedToken: EncodedToken\n  readonly _HasDefault: HasDefault\n  readonly _Key: Key\n  readonly ast: PropertySignature.AST\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n}\n\nclass PropertySignatureImpl<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> implements PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  readonly [TypeId]!: Schema.Variance<Type, Encoded, R>[TypeId]\n  readonly [PropertySignatureTypeId] = null\n  readonly _TypeToken!: TypeToken\n  readonly _Key!: Key\n  readonly _EncodedToken!: EncodedToken\n  readonly _HasDefault!: HasDefault\n\n  constructor(\n    readonly ast: PropertySignature.AST\n  ) {}\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)))\n  }\n\n  toString() {\n    return String(this.ast)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const makePropertySignature = <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n>(ast: PropertySignature.AST) =>\n  new PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>(ast)\n\nclass PropertySignatureWithFromImpl<\n  From extends Schema.All,\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  constructor(ast: PropertySignature.AST, readonly from: From) {\n    super(ast)\n  }\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignatureWithFromImpl<From, TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureWithFromImpl(\n      mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)),\n      this.from\n    )\n  }\n}\n\n/**\n * @category API interface\n * @since 1.0.0\n */\nexport interface propertySignature<S extends Schema.All>\n  extends PropertySignature<\":\", Schema.Type<S>, never, \":\", Schema.Encoded<S>, false, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>\n}\n\n/**\n * Lifts a `Schema` into a `PropertySignature`.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const propertySignature = <S extends Schema.All>(\n  self: S\n): propertySignature<S> =>\n  new PropertySignatureWithFromImpl(\n    new PropertySignatureDeclaration(self.ast, false, true, {}, undefined),\n    self\n  )\n\n/**\n * Enhances a property signature with a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withConstructorDefault: {\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Type>): <\n    TypeToken extends PropertySignature.Token,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n    defaultValue: () => Types.NoInfer<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n} = dual(2, <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  R\n>(\n  self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n  defaultValue: () => Types.NoInfer<Type>\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\":\n      return makePropertySignature(\n        new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue)\n      )\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue),\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\nconst applyDefaultValue = <A>(o: option_.Option<A>, defaultValue: () => A) =>\n  option_.match(o, {\n    onNone: () => option_.some(defaultValue()),\n    onSome: (value) => option_.some(value === undefined ? defaultValue() : value)\n  })\n\nconst pruneUndefined = (ast: AST.AST): AST.AST | undefined =>\n  AST.pruneUndefined(ast, pruneUndefined, (ast) => {\n    const pruned = pruneUndefined(ast.to)\n    if (pruned) {\n      return new AST.Transformation(ast.from, pruned, ast.transformation)\n    }\n  })\n\n/**\n * Enhances a property signature with a default decoding value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDecodingDefault: {\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): <\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>,\n    defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>,\n  defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      const to = AST.typeAST(ast.type)\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations),\n          new ToPropertySignature(pruneUndefined(to) ?? to, false, true, {}, ast.defaultValue),\n          (o) => applyDefaultValue(o, defaultValue),\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      const to = ast.to.type\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(\n            pruneUndefined(to) ?? to,\n            false,\n            ast.to.isReadonly,\n            ast.to.annotations,\n            ast.to.defaultValue\n          ),\n          (o) => applyDefaultValue(ast.decode(o), defaultValue),\n          ast.encode\n        )\n      )\n    }\n  }\n})\n\n/**\n * Enhances a property signature with a default decoding value and a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDefaults: {\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Exclude<Type, undefined>>\n    }\n  ): <\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Exclude<Type, undefined>>\n    }\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>,\n  defaults: {\n    constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n    decoding: () => Types.NoInfer<Exclude<Type, undefined>>\n  }\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R> =>\n  self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)))\n\n/**\n * Enhances a property signature by specifying a different key for it in the Encoded type.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const fromKey: {\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Key extends PropertyKey>(key: Key): <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    TypeToken extends PropertySignature.Token,\n    Encoded,\n    EncodedToken extends PropertySignature.Token,\n    HasDefault extends boolean,\n    R,\n    Key extends PropertyKey\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n    key: Key\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n} = dual(2, <\n  Type,\n  TypeToken extends PropertySignature.Token,\n  Encoded,\n  EncodedToken extends PropertySignature.Token,\n  HasDefault extends boolean,\n  R,\n  Key extends PropertyKey\n>(\n  self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n  key: Key\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.type,\n            ast.isOptional,\n            ast.isReadonly,\n            ast.annotations,\n            key\n          ),\n          new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue),\n          identity,\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.from.type,\n            ast.from.isOptional,\n            ast.from.isReadonly,\n            ast.from.annotations,\n            key\n          ),\n          ast.to,\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * Converts an optional property to a required one through a transformation `Option -> Type`.\n *\n * - `decode`: `none` as argument means the value is missing in the input.\n * - `encode`: `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToRequired = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => TI\n    readonly encode: (ti: TI) => option_.Option<FA>\n  }\n): PropertySignature<\":\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, false, true, {}, undefined),\n      (o) => option_.some(options.decode(o)),\n      option_.flatMap(options.encode)\n    )\n  )\n\n/**\n * Converts an optional property to a required one through a transformation `Type -> Option`.\n *\n * - `decode`: `none` as return value means the value will be missing in the output.\n * - `encode`: `none` as argument means the value is missing in the input.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const requiredToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (fa: FA) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => FA\n  }\n): PropertySignature<\"?:\", TA, never, \":\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, false, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      option_.flatMap(options.decode),\n      (o) => option_.some(options.encode(o))\n    )\n  )\n\n/**\n * Converts an optional property to another optional property through a transformation `Option -> Option`.\n *\n * - `decode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n * - `encode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>\n  }\n): PropertySignature<\"?:\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      options.decode,\n      options.encode\n    )\n  )\n\n/**\n * @since 3.10.0\n */\nexport type OptionalOptions<A> = {\n  readonly default?: never\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly default: LazyArg<A>\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable?: never\n  readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable?: never\n  readonly onNoneEncoding?: never\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null>>\n} | undefined\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optional<S extends Schema.All> extends\n  PropertySignature<\n    \"?:\",\n    Schema.Type<S> | undefined,\n    never,\n    \"?:\",\n    Schema.Encoded<S> | undefined,\n    false,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optionalWith<S extends Schema.All, Options> extends\n  PropertySignature<\n    Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n    | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n    | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n    never,\n    \"?:\",\n    | Schema.Encoded<S>\n    | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n    | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n    Types.Has<Options, \"default\">,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(\n    annotations: PropertySignature.Annotations<\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined)\n    >\n  ): optionalWith<S, Options>\n}\n\nconst optionalPropertySignatureAST = <A, I, R>(\n  self: Schema<A, I, R>,\n  options?: {\n    readonly exact?: true\n    readonly default?: () => A\n    readonly nullable?: true\n    readonly as?: \"Option\"\n    readonly onNoneEncoding?: () => option_.Option<never>\n  }\n): PropertySignature.AST => {\n  const isExact = options?.exact\n  const defaultValue = options?.default\n  const isNullable = options?.nullable\n  const asOption = options?.as == \"Option\"\n  const asOptionEncode = options?.onNoneEncoding ? option_.orElse(options.onNoneEncoding) : identity\n\n  if (isExact) {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => a === null ? defaultValue() : a }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            self,\n            typeSchema(self),\n            { decode: option_.match({ onNone: defaultValue, onSome: identity }), encode: option_.some }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      const to = OptionFromSelf_(typeSchema(self))\n      if (isNullable) {\n        return optionalToRequired(\n          NullOr(self),\n          to,\n          {\n            decode: option_.filter(Predicate.isNotNull<A | null>),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          self,\n          to,\n          { decode: identity, encode: identity }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullOr(self),\n          typeSchema(self),\n          { decode: option_.filter(Predicate.isNotNull<A | null>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(self.ast, true, true, {}, undefined)\n      }\n    }\n  } else {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullishOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a == null ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            UndefinedOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a === undefined ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      const to = OptionFromSelf_(typeSchema(self))\n      if (isNullable) {\n        return optionalToRequired(\n          NullishOr(self),\n          to,\n          {\n            decode: option_.filter<A | null | undefined, A>((a): a is A => a != null),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          UndefinedOr(self),\n          to,\n          {\n            decode: option_.filter(Predicate.isNotUndefined<A | undefined>),\n            encode: asOptionEncode\n          }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullishOr(self),\n          UndefinedOr(typeSchema(self)),\n          { decode: option_.filter(Predicate.isNotNull<A | null | undefined>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, undefined)\n      }\n    }\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optional = <S extends Schema.All>(self: S): optional<S> => {\n  const ast = self.ast === AST.undefinedKeyword || self.ast === AST.neverKeyword\n    ? AST.undefinedKeyword\n    : UndefinedOr(self).ast\n  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalWith: {\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(options: Options): (self: S) => optionalWith<S, Options>\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(self: S, options: Options): optionalWith<S, Options>\n} = dual((args) => isSchema(args[0]), (self, options) => {\n  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self)\n})\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Struct {\n  /**\n   * Useful for creating a type that can be used to add custom constraints to the fields of a struct.\n   *\n   * ```ts\n   * import { Schema } from \"effect\"\n   *\n   * const f = <Fields extends Record<\"a\" | \"b\", Schema.Struct.Field>>(\n   *   schema: Schema.Struct<Fields>\n   * ) => {\n   *   return schema.omit(\"a\")\n   * }\n   *\n   * //      ┌─── Schema.Struct<{ b: typeof Schema.Number; }>\n   * //      ▼\n   * const result = f(Schema.Struct({ a: Schema.String, b: Schema.Number }))\n   * ```\n   * @since 3.13.11\n   */\n  export type Field =\n    | Schema.All\n    | PropertySignature.All\n\n  /**\n   * @since 3.10.0\n   */\n  export type Fields = { readonly [x: PropertyKey]: Field }\n\n  type OptionalEncodedPropertySignature =\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", any, boolean, unknown>\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", never, boolean, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", any, boolean, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", never, boolean, unknown>\n\n  type EncodedOptionalKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends OptionalEncodedPropertySignature ? K\n      : never\n  }[keyof Fields]\n\n  type OptionalTypePropertySignature =\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n\n  // type TypeOptionalKeys<Fields extends Struct.Fields> = {\n  //   [K in keyof Fields]: Fields[K] extends OptionalTypePropertySignature ? K : never\n  // }[keyof Fields]\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalTypePropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n\n  type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never :\n    F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key :\n    K\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<F extends Fields> =\n    & { readonly [K in Exclude<keyof F, EncodedOptionalKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]> }\n    & { readonly [K in EncodedOptionalKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]> }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<F extends Fields> = Schema.Context<F[keyof F]>\n\n  type PropertySignatureWithDefault =\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, never, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, never, true, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalTypePropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        F[K] extends PropertySignatureWithDefault ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace IndexSignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Record = { readonly key: Schema.All; readonly value: Schema.All }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Records = ReadonlyArray<Record>\n\n  /**\n   * @since 3.10.0\n   */\n  export type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>\n\n  type MergeTuple<T extends ReadonlyArray<unknown>> = T extends readonly [infer Head, ...infer Tail] ?\n    Head & MergeTuple<Tail>\n    : {}\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Records extends IndexSignature.Records> = MergeTuple<\n    {\n      readonly [K in keyof Records]: {\n        readonly [P in Schema.Type<Records[K][\"key\"]>]: Schema.Type<Records[K][\"value\"]>\n      }\n    }\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Records extends IndexSignature.Records> = MergeTuple<\n    {\n      readonly [K in keyof Records]: {\n        readonly [P in Schema.Encoded<Records[K][\"key\"]>]: Schema.Encoded<Records[K][\"value\"]>\n      }\n    }\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<Records extends IndexSignature.Records> = {\n    [K in keyof Records]: Schema.Context<Records[K][\"key\"]> | Schema.Context<Records[K][\"value\"]>\n  }[number]\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TypeLiteral {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Type<Fields>\n    & IndexSignature.Type<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Encoded<Fields>\n    & IndexSignature.Encoded<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Constructor<Fields>\n    & IndexSignature.Type<Records>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TypeLiteral<\n  Fields extends Struct.Fields,\n  Records extends IndexSignature.Records\n> extends\n  AnnotableClass<\n    TypeLiteral<Fields, Records>,\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >\n{\n  readonly fields: Readonly<Fields>\n  readonly records: Readonly<Records>\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records>\n  make(\n    props: RequiredKeys<TypeLiteral.Constructor<Fields, Records>> extends never\n      ? void | Simplify<TypeLiteral.Constructor<Fields, Records>>\n      : Simplify<TypeLiteral.Constructor<Fields, Records>>,\n    options?: MakeOptions\n  ): Simplify<TypeLiteral.Type<Fields, Records>>\n}\n\nconst preserveMissingMessageAnnotation = AST.pickAnnotations([AST.MissingMessageAnnotationId])\n\nconst getDefaultTypeLiteralAST = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(fields: Fields, records: Records) => {\n  const ownKeys = Reflect.ownKeys(fields)\n  const pss: Array<AST.PropertySignature> = []\n  if (ownKeys.length > 0) {\n    const from: Array<AST.PropertySignature> = []\n    const to: Array<AST.PropertySignature> = []\n    const transformations: Array<AST.PropertySignatureTransformation> = []\n    for (let i = 0; i < ownKeys.length; i++) {\n      const key = ownKeys[i]\n      const field = fields[key]\n      if (isPropertySignature(field)) {\n        const ast: PropertySignature.AST = field.ast\n        switch (ast._tag) {\n          case \"PropertySignatureDeclaration\": {\n            const type = ast.type\n            const isOptional = ast.isOptional\n            const toAnnotations = ast.annotations\n            from.push(new AST.PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)))\n            to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations))\n            pss.push(\n              new AST.PropertySignature(key, type, isOptional, true, toAnnotations)\n            )\n            break\n          }\n          case \"PropertySignatureTransformation\": {\n            const fromKey = ast.from.fromKey ?? key\n            from.push(\n              new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations)\n            )\n            to.push(\n              new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations)\n            )\n            transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode))\n            break\n          }\n        }\n      } else {\n        from.push(new AST.PropertySignature(key, field.ast, false, true))\n        to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true))\n        pss.push(new AST.PropertySignature(key, field.ast, false, true))\n      }\n    }\n    if (array_.isNonEmptyReadonlyArray(transformations)) {\n      const issFrom: Array<AST.IndexSignature> = []\n      const issTo: Array<AST.IndexSignature> = []\n      for (const r of records) {\n        const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n        propertySignatures.forEach((ps) => {\n          from.push(ps)\n          to.push(\n            new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations)\n          )\n        })\n        indexSignatures.forEach((is) => {\n          issFrom.push(is)\n          issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly))\n        })\n      }\n      return new AST.Transformation(\n        new AST.TypeLiteral(from, issFrom, { [AST.AutoTitleAnnotationId]: \"Struct (Encoded side)\" }),\n        new AST.TypeLiteral(to, issTo, { [AST.AutoTitleAnnotationId]: \"Struct (Type side)\" }),\n        new AST.TypeLiteralTransformation(transformations)\n      )\n    }\n  }\n  const iss: Array<AST.IndexSignature> = []\n  for (const r of records) {\n    const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n    propertySignatures.forEach((ps) => pss.push(ps))\n    indexSignatures.forEach((is) => iss.push(is))\n  }\n  return new AST.TypeLiteral(pss, iss)\n}\n\nconst lazilyMergeDefaults = (\n  fields: Struct.Fields,\n  out: Record<PropertyKey, unknown>\n): { [x: string | symbol]: unknown } => {\n  const ownKeys = Reflect.ownKeys(fields)\n  for (const key of ownKeys) {\n    const field = fields[key]\n    if (out[key] === undefined && isPropertySignature(field)) {\n      const ast = field.ast\n      const defaultValue = ast._tag === \"PropertySignatureDeclaration\" ? ast.defaultValue : ast.to.defaultValue\n      if (defaultValue !== undefined) {\n        out[key] = defaultValue()\n      }\n    }\n  }\n  return out\n}\n\nfunction makeTypeLiteralClass<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(\n  fields: Fields,\n  records: Records,\n  ast: AST.AST = getDefaultTypeLiteralAST(fields, records)\n): TypeLiteral<Fields, Records> {\n  return class TypeLiteralClass extends make<\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >(ast) {\n    static override annotations(\n      annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n    ): TypeLiteral<Fields, Records> {\n      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static fields = { ...fields }\n\n    static records = [...records] as Records\n\n    static make = (\n      props: Simplify<TypeLiteral.Constructor<Fields, Records>>,\n      options?: MakeOptions\n    ): Simplify<TypeLiteral.Type<Fields, Records>> => {\n      const propsWithDefaults: any = lazilyMergeDefaults(fields, { ...props as any })\n      return getDisableValidationMakeOption(options)\n        ? propsWithDefaults\n        : ParseResult.validateSync(this)(propsWithDefaults)\n    }\n\n    static pick(...keys: Array<keyof Fields>): Struct<Simplify<Pick<Fields, typeof keys[number]>>> {\n      return Struct(struct_.pick(fields, ...keys) as any)\n    }\n\n    static omit(...keys: Array<keyof Fields>): Struct<Simplify<Omit<Fields, typeof keys[number]>>> {\n      return Struct(struct_.omit(fields, ...keys) as any)\n    }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Struct<Fields extends Struct.Fields> extends\n  AnnotableClass<\n    Struct<Fields>,\n    Simplify<Struct.Type<Fields>>,\n    Simplify<Struct.Encoded<Fields>>,\n    Struct.Context<Fields>\n  >\n{\n  readonly fields: Readonly<Fields>\n  readonly records: readonly []\n  make(\n    props: RequiredKeys<Struct.Constructor<Fields>> extends never ? void | Simplify<Struct.Constructor<Fields>>\n      : Simplify<Struct.Constructor<Fields>>,\n    options?: MakeOptions\n  ): Simplify<Struct.Type<Fields>>\n\n  annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>\n  pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>\n  omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records>\nexport function Struct<Fields extends Struct.Fields>(fields: Fields): Struct<Fields>\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records> {\n  return makeTypeLiteralClass(fields, records)\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface tag<Tag extends AST.LiteralValue> extends PropertySignature<\":\", Tag, never, \":\", Tag, true, never> {}\n\n/**\n * Returns a property signature that represents a tag.\n * A tag is a literal value that is used to distinguish between different types of objects.\n * The tag is optional when using the `make` method.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Schema } from \"effect\"\n *\n * const User = Schema.Struct({\n *   _tag: Schema.tag(\"User\"),\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n * ```\n *\n * @see {@link TaggedStruct}\n *\n * @since 3.10.0\n */\nexport const tag = <Tag extends AST.LiteralValue>(tag: Tag): tag<Tag> =>\n  Literal(tag).pipe(propertySignature, withConstructorDefault(() => tag))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport type TaggedStruct<Tag extends AST.LiteralValue, Fields extends Struct.Fields> = Struct<\n  { _tag: tag<Tag> } & Fields\n>\n\n/**\n * A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.\n *\n * The tag is optional when using the `make` method.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Schema } from \"effect\"\n *\n * const User = Schema.TaggedStruct(\"User\", {\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const TaggedStruct = <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(\n  value: Tag,\n  fields: Fields\n): TaggedStruct<Tag, Fields> => Struct({ _tag: tag(value), ...fields })\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Record$<K extends Schema.All, V extends Schema.All> extends\n  AnnotableClass<\n    Record$<K, V>,\n    { readonly [P in Schema.Type<K>]: Schema.Type<V> },\n    { readonly [P in Schema.Encoded<K>]: Schema.Encoded<V> },\n    | Schema.Context<K>\n    | Schema.Context<V>\n  >\n{\n  readonly fields: {}\n  readonly records: readonly [{ readonly key: K; readonly value: V }]\n  readonly key: K\n  readonly value: V\n  make(\n    props: void | { readonly [P in Schema.Type<K>]: Schema.Type<V> },\n    options?: MakeOptions\n  ): { readonly [P in Schema.Type<K>]: Schema.Type<V> }\n  annotations(annotations: Annotations.Schema<{ readonly [P in Schema.Type<K>]: Schema.Type<V> }>): Record$<K, V>\n}\n\nfunction makeRecordClass<K extends Schema.All, V extends Schema.All>(\n  key: K,\n  value: V,\n  ast?: AST.AST\n): Record$<K, V> {\n  return class RecordClass extends makeTypeLiteralClass({}, [{ key, value }], ast) {\n    static override annotations(\n      annotations: Annotations.Schema<{ readonly [P in Schema.Type<K>]: Schema.Type<V> }>\n    ): Record$<K, V> {\n      return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static key = key\n\n    static value = value\n  }\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Record = <K extends Schema.All, V extends Schema.All>(\n  options: { readonly key: K; readonly value: V }\n): Record$<K, V> => makeRecordClass(options.key, options.value)\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pick = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R> => make(AST.pick(self.ast, keys))\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const omit = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R> => make(AST.omit(self.ast, keys))\n\n/**\n * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * // ---------------------------------------------\n * // use case: pull out a single field from a\n * // struct through a transformation\n * // ---------------------------------------------\n *\n * const mytable = Schema.Struct({\n *   column1: Schema.NumberFromString,\n *   column2: Schema.Number\n * })\n *\n * // const pullOutColumn: S.Schema<number, {\n * //     readonly column1: string;\n * // }, never>\n * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n *\n * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n * ```\n *\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pluck: {\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   * ```\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => SchemaClass<A[K], Simplify<Pick<I, K>>, R>\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   * ```\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): SchemaClass<A[K], Simplify<Pick<I, K>>, R>\n} = dual(\n  2,\n  <A, I, R, K extends keyof A & keyof I>(\n    schema: Schema<A, I, R>,\n    key: K\n  ): Schema<A[K], Pick<I, K>, R> => {\n    const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key)\n    const value = make</**\n     * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n     * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n     *\n     * @example\n     * ```ts\n     * import * as Schema from \"effect/Schema\"\n     *\n     * // ---------------------------------------------\n     * // use case: pull out a single field from a\n     * // struct through a transformation\n     * // ---------------------------------------------\n     *\n     * const mytable = Schema.Struct({\n     *   column1: Schema.NumberFromString,\n     *   column2: Schema.Number\n     * })\n     *\n     * // const pullOutColumn: S.Schema<number, {\n     * //     readonly column1: string;\n     * // }, never>\n     * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n     *\n     * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n     * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n     * ```\n     *\n     * @category struct transformations\n     * @since 3.10.0\n     */\n    A[K], /**\n     * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n     * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n     *\n     * @example\n     * ```ts\n     * import * as Schema from \"effect/Schema\"\n     *\n     * // ---------------------------------------------\n     * // use case: pull out a single field from a\n     * // struct through a transformation\n     * // ---------------------------------------------\n     *\n     * const mytable = Schema.Struct({\n     *   column1: Schema.NumberFromString,\n     *   column2: Schema.Number\n     * })\n     *\n     * // const pullOutColumn: S.Schema<number, {\n     * //     readonly column1: string;\n     * // }, never>\n     * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n     *\n     * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n     * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n     * ```\n     *\n     * @category struct transformations\n     * @since 3.10.0\n     */\n    A[K], /**\n     * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n     * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n     *\n     * @example\n     * ```ts\n     * import * as Schema from \"effect/Schema\"\n     *\n     * // ---------------------------------------------\n     * // use case: pull out a single field from a\n     * // struct through a transformation\n     * // ---------------------------------------------\n     *\n     * const mytable = Schema.Struct({\n     *   column1: Schema.NumberFromString,\n     *   column2: Schema.Number\n     * })\n     *\n     * // const pullOutColumn: S.Schema<number, {\n     * //     readonly column1: string;\n     * // }, never>\n     * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n     *\n     * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n     * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n     * ```\n     *\n     * @category struct transformations\n     * @since 3.10.0\n     */\n    R>(ps.isOptional ? AST.orUndefined(ps.type) : ps.type)\n    const out = transform(\n      schema.pipe(pick(key)),\n      value,\n      {\n        strict: true,\n        decode: (i) => i[key],\n        encode: (a) => ps.isOptional && a === undefined ? {} : { [key]: a } as any\n      }\n    )\n    return out\n  }\n)\n\n/**\n * @category branding\n * @since 3.10.0\n */\nexport interface BrandSchema<A extends Brand<any>, I = A, R = never>\n  extends AnnotableClass<BrandSchema<A, I, R>, A, I, R>\n{\n  make(a: Brand.Unbranded<A>, options?: MakeOptions): A\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface brand<S extends Schema.Any, B extends string | symbol>\n  extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>\n}\n\nfunction makeBrandClass<S extends Schema.Any, B extends string | symbol>(\n  from: S,\n  ast: AST.AST\n): brand<S, B> {\n  return class BrandClass extends make<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>(ast) {\n    static override annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B> {\n      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static make = (a: Brand.Unbranded<Schema.Type<S> & Brand<B>>, options?: MakeOptions): Schema.Type<S> & Brand<B> => {\n      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n    }\n\n    static from = from\n  }\n}\n\n/**\n * Returns a nominal branded schema by applying a brand to a given schema.\n *\n * ```\n * Schema<A> + B -> Schema<A & Brand<B>>\n * ```\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\n * type Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">\n * ```\n *\n * @category branding\n * @since 3.10.0\n */\nexport const brand = <S extends Schema.Any, B extends string | symbol>(\n  brand: B,\n  annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>\n) =>\n(self: S): brand<S, B> => {\n  const annotation: AST.BrandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {\n    onNone: () => [brand],\n    onSome: (brands) => [...brands, brand]\n  })\n  const ast = AST.annotations(\n    self.ast,\n    toASTAnnotations({\n      [AST.BrandAnnotationId]: annotation,\n      ...annotations\n    })\n  )\n  return makeBrandClass(self, ast)\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partial = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]?: A[K] | undefined }, { [K in keyof I]?: I[K] | undefined }, R> =>\n  make(AST.partial(self.ast))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partialWith: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <const Options extends { readonly exact: true }>(options: Options): <A, I, R>(\n    self: Schema<A, I, R>\n  ) => SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, const Options extends { readonly exact: true } | undefined>(self: Schema<A, I, R>, options: Options): SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n} = dual((args) => isSchema(args[0]), <A, I, R>(\n  self: Schema<A, I, R>,\n  options: { readonly exact: true }\n): SchemaClass<Partial<A>, Partial<I>, R> => make(AST.partial(self.ast, options)))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const required = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]-?: A[K] }, { [K in keyof I]-?: I[K] }, R> => make(AST.required(self.ast))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface mutable<S extends Schema.Any> extends\n  AnnotableClass<\n    mutable<S>,\n    SimplifyMutable<Schema.Type<S>>,\n    SimplifyMutable<Schema.Encoded<S>>,\n    Schema.Context<S>\n  >\n{}\n\n/**\n * Creates a new schema with shallow mutability applied to its properties.\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const mutable = <S extends Schema.Any>(schema: S): mutable<S> => make(AST.mutable(schema.ast))\n\nconst intersectTypeLiterals = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.TypeLiteral => {\n  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {\n    const propertySignatures = [...x.propertySignatures]\n    for (const ps of y.propertySignatures) {\n      const name = ps.name\n      const i = propertySignatures.findIndex((ps) => ps.name === name)\n      if (i === -1) {\n        propertySignatures.push(ps)\n      } else {\n        const { isOptional, type } = propertySignatures[i]\n        propertySignatures[i] = new AST.PropertySignature(\n          name,\n          extendAST(type, ps.type, path.concat(name)),\n          isOptional,\n          true\n        )\n      }\n    }\n    return new AST.TypeLiteral(\n      propertySignatures,\n      x.indexSignatures.concat(y.indexSignatures)\n    )\n  }\n  throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n}\n\nconst preserveRefinementAnnotations = AST.omitAnnotations([AST.IdentifierAnnotationId])\n\nconst addRefinementToMembers = (refinement: AST.Refinement, asts: ReadonlyArray<AST.AST>): Array<AST.Refinement> =>\n  asts.map((ast) => new AST.Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)))\n\nconst extendAST = (x: AST.AST, y: AST.AST, path: ReadonlyArray<PropertyKey>): AST.AST =>\n  AST.Union.make(intersectUnionMembers([x], [y], path))\n\nconst getTypes = (ast: AST.AST): ReadonlyArray<AST.AST> => AST.isUnion(ast) ? ast.types : [ast]\n\nconst intersectUnionMembers = (\n  xs: ReadonlyArray<AST.AST>,\n  ys: ReadonlyArray<AST.AST>,\n  path: ReadonlyArray<PropertyKey>\n): Array<AST.AST> =>\n  array_.flatMap(xs, (x) =>\n    array_.flatMap(ys, (y) => {\n      switch (y._tag) {\n        case \"Literal\": {\n          if (\n            (Predicate.isString(y.literal) && AST.isStringKeyword(x) ||\n              (Predicate.isNumber(y.literal) && AST.isNumberKeyword(x)) ||\n              (Predicate.isBoolean(y.literal) && AST.isBooleanKeyword(x)))\n          ) {\n            return [y]\n          }\n          break\n        }\n        case \"StringKeyword\": {\n          if (y === AST.stringKeyword) {\n            if (AST.isStringKeyword(x) || (AST.isLiteral(x) && Predicate.isString(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.stringKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"NumberKeyword\": {\n          if (y === AST.numberKeyword) {\n            if (AST.isNumberKeyword(x) || (AST.isLiteral(x) && Predicate.isNumber(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.numberKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"BooleanKeyword\": {\n          if (y === AST.booleanKeyword) {\n            if (AST.isBooleanKeyword(x) || (AST.isLiteral(x) && Predicate.isBoolean(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.booleanKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"Union\":\n          return intersectUnionMembers(getTypes(x), y.types, path)\n        case \"Suspend\":\n          return [new AST.Suspend(() => extendAST(x, y.f(), path))]\n        case \"Refinement\":\n          return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path))\n        case \"TypeLiteral\": {\n          switch (x._tag) {\n            case \"Union\":\n              return intersectUnionMembers(x.types, [y], path)\n            case \"Suspend\":\n              return [new AST.Suspend(() => extendAST(x.f(), y, path))]\n            case \"Refinement\":\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            case \"TypeLiteral\":\n              return [intersectTypeLiterals(x, y, path)]\n            case \"Transformation\": {\n              const transformation = x.transformation\n              const from = intersectTypeLiterals(x.from, y, path)\n              const to = intersectTypeLiterals(x.to, AST.typeAST(y), path)\n              switch (transformation._tag) {\n                case \"TypeLiteralTransformation\":\n                  return [\n                    new AST.Transformation(\n                      from,\n                      to,\n                      new AST.TypeLiteralTransformation(transformation.propertySignatureTransformations)\n                    )\n                  ]\n                case \"ComposeTransformation\":\n                  return [new AST.Transformation(from, to, AST.composeTransformation)]\n                case \"FinalTransformation\":\n                  return [\n                    new AST.Transformation(\n                      from,\n                      to,\n                      new AST.FinalTransformation(\n                        (fromA, options, ast, fromI) =>\n                          ParseResult.map(\n                            transformation.decode(fromA, options, ast, fromI),\n                            (partial) => ({ ...fromA, ...partial })\n                          ),\n                        (toI, options, ast, toA) =>\n                          ParseResult.map(\n                            transformation.encode(toI, options, ast, toA),\n                            (partial) => ({ ...toI, ...partial })\n                          )\n                      )\n                    )\n                  ]\n              }\n            }\n          }\n          break\n        }\n        case \"Transformation\": {\n          if (AST.isTransformation(x)) {\n            if (\n              AST.isTypeLiteralTransformation(y.transformation) && AST.isTypeLiteralTransformation(x.transformation)\n            ) {\n              return [\n                new AST.Transformation(\n                  intersectTypeLiterals(x.from, y.from, path),\n                  intersectTypeLiterals(x.to, y.to, path),\n                  new AST.TypeLiteralTransformation(\n                    y.transformation.propertySignatureTransformations.concat(\n                      x.transformation.propertySignatureTransformations\n                    )\n                  )\n                )\n              ]\n            }\n          } else {\n            return intersectUnionMembers([y], [x], path)\n          }\n          break\n        }\n      }\n      throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n    }))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface extend<Self extends Schema.Any, That extends Schema.Any> extends\n  AnnotableClass<\n    extend<Self, That>,\n    Schema.Type<Self> & Schema.Type<That>,\n    Schema.Encoded<Self> & Schema.Encoded<That>,\n    Schema.Context<Self> | Schema.Context<That>\n  >\n{}\n\n/**\n * Extends a schema with another schema.\n *\n * Not all extensions are supported, and their support depends on the nature of\n * the involved schemas.\n *\n * Possible extensions include:\n * - `Schema.String` with another `Schema.String` refinement or a string literal\n * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean\n *   literal\n * - A struct with another struct where overlapping fields support extension\n * - A struct with in index signature\n * - A struct with a union of supported schemas\n * - A refinement of a struct with a supported schema\n * - A suspend of a struct with a supported schema\n * - A transformation between structs where the “from” and “to” sides have no\n *   overlapping fields with the target struct\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const schema = Schema.Struct({\n *   a: Schema.String,\n *   b: Schema.String\n * })\n *\n * // const extended: Schema<\n * //   {\n * //     readonly a: string\n * //     readonly b: string\n * //   } & {\n * //     readonly c: string\n * //   } & {\n * //     readonly [x: string]: string\n * //   }\n * // >\n * const extended = Schema.asSchema(schema.pipe(\n *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n * ))\n * ```\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const extend: {\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of\n   * the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean\n   *   literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   * - A transformation between structs where the “from” and “to” sides have no\n   *   overlapping fields with the target struct\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of\n   * the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean\n   *   literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   * - A transformation between structs where the “from” and “to” sides have no\n   *   overlapping fields with the target struct\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>\n} = dual(\n  2,\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That) => make(extendAST(self.ast, that.ast, []))\n)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const compose: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, C extends Schema.Type<From>>(to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): (from: From) => transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <To extends Schema.Any>(to: To): <From extends Schema.Any, B extends Schema.Encoded<To>>(\n    from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>\n  ) => transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <To extends Schema.Any>(to: To, options?: { readonly strict: true }): <From extends Schema.Any>(\n    from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>\n  ) => transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <To extends Schema.Any>(to: To, options: { readonly strict: false }): <From extends Schema.Any>(from: From) => transform<From, To>\n\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <From extends Schema.Any, To extends Schema.Any, C extends Schema.Type<From>>(from: From, to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <From extends Schema.Any, B extends Schema.Encoded<To>, To extends Schema.Any>(from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>, to: To): transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <From extends Schema.Any, To extends Schema.Any>(\n    from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>,\n    to: To,\n    options?: { readonly strict: true }\n  ): transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <From extends Schema.Any, To extends Schema.Any>(from: From, to: To, options: { readonly strict: false }): transform<From, To>\n} = dual(\n  (args) => isSchema(args[1]),\n  <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2> =>\n    makeTransformationClass(from, to, AST.compose(from.ast, to.ast))\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const suspend = <A, I, R>(f: () => Schema<A, I, R>): suspend<A, I, R> => make(new AST.Suspend(() => f().ast))\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const RefineSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Refine\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type RefineSchemaId = typeof RefineSchemaId\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface refine<A, From extends Schema.Any>\n  extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>>\n{\n  /** The following is required for {@link HasFields} to work */\n  readonly [RefineSchemaId]: From\n  readonly from: From\n  readonly filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>\n  make(a: Schema.Type<From>, options?: MakeOptions): A\n}\n\nfunction makeRefineClass<From extends Schema.Any, A>(\n  from: From,\n  filter: (a: Schema.Type<From>, options: ParseOptions, self: AST.Refinement) => option_.Option<ParseResult.ParseIssue>,\n  ast: AST.AST\n): refine<A, From> {\n  return class RefineClass extends make<A, Schema.Encoded<From>, Schema.Context<From>>(ast) {\n    static override annotations(annotations: Annotations.Schema<A>): refine<A, From> {\n      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static [RefineSchemaId] = from\n\n    static from = from\n\n    static filter = filter\n\n    static make = (a: Schema.Type<From>, options?: MakeOptions): A => {\n      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n    }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {}\n\nconst fromFilterPredicateReturnTypeItem = (\n  item: FilterOutput,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (Predicate.isBoolean(item)) {\n    return item\n      ? option_.none()\n      : option_.some(new ParseResult.Type(ast, input))\n  }\n  if (Predicate.isString(item)) {\n    return option_.some(new ParseResult.Type(ast, input, item))\n  }\n  if (item !== undefined) {\n    if (\"_tag\" in item) {\n      return option_.some(item)\n    }\n    const issue = new ParseResult.Type(ast, input, item.message)\n    return option_.some(\n      array_.isNonEmptyReadonlyArray(item.path) ? new ParseResult.Pointer(item.path, input, issue) : issue\n    )\n  }\n  return option_.none()\n}\n\nconst toFilterParseIssue = (\n  out: FilterReturnType,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (util_.isSingle(out)) {\n    return fromFilterPredicateReturnTypeItem(out, ast, input)\n  }\n  if (array_.isNonEmptyReadonlyArray(out)) {\n    const issues = array_.filterMap(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input))\n    if (array_.isNonEmptyReadonlyArray(issues)) {\n      return option_.some(issues.length === 1 ? issues[0] : new ParseResult.Composite(ast, input, issues))\n    }\n  }\n  return option_.none()\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport interface FilterIssue {\n  readonly path: ReadonlyArray<PropertyKey>\n  readonly message: string\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue\n\ntype FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport function filter<C extends A, B extends A, A = C>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<C & B, C>\n): <I, R>(self: Schema<C, I, R>) => refine<C & B, Schema<A, I, R>>\nexport function filter<A, B extends A>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<B, A>\n): <I, R>(self: Schema<A, I, R>) => refine<B, Schema<A, I, R>>\nexport function filter<S extends Schema.Any>(\n  predicate: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<Types.NoInfer<Schema.Type<S>>>\n): (self: S) => filter<S>\nexport function filter<A>(\n  predicate: (\n    a: A,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => refine<A, Schema<A, I, R>> {\n  return <I, R>(self: Schema<A, I, R>) => {\n    function filter(input: A, options: AST.ParseOptions, ast: AST.Refinement) {\n      return toFilterParseIssue(predicate(input, options, ast), ast, input)\n    }\n    const ast = new AST.Refinement(\n      self.ast,\n      filter,\n      toASTAnnotations(annotations)\n    )\n    return makeRefineClass(self, filter, ast)\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filterEffect<S extends Schema.Any, FD = never>\n  extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD>\n{}\n\n/**\n * @category transformations\n * @since 3.10.0\n */\nexport const filterEffect: {\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, FD>(\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, FD>\n  ): (self: S) => filterEffect<S, FD>\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, RD>(\n    self: S,\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, RD>\n  ): filterEffect<S, RD>\n} = dual(2, <S extends Schema.Any, FD>(\n  self: S,\n  f: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Transformation\n  ) => Effect.Effect<FilterReturnType, never, FD>\n): filterEffect<S, FD> =>\n  transformOrFail(\n    self,\n    typeSchema(self),\n    {\n      strict: true,\n      decode: (i, options, ast) =>\n        ParseResult.flatMap(\n          f(i, options, ast),\n          (filterReturnType) =>\n            option_.match(toFilterParseIssue(filterReturnType, ast, i), {\n              onNone: () => ParseResult.succeed(i),\n              onSome: ParseResult.fail\n            })\n        ),\n      encode: (a) => ParseResult.succeed(a)\n    }\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformOrFail<From extends Schema.All, To extends Schema.All, R = never> extends\n  AnnotableClass<\n    transformOrFail<From, To, R>,\n    Schema.Type<To>,\n    Schema.Encoded<From>,\n    Schema.Context<From> | Schema.Context<To> | R\n  >\n{\n  readonly from: From\n  readonly to: To\n}\n\nfunction makeTransformationClass<From extends Schema.Any, To extends Schema.Any, R>(\n  from: From,\n  to: To,\n  ast: AST.AST\n): transformOrFail<From, To, R> {\n  return class TransformationClass\n    extends make<Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R>(ast)\n  {\n    static override annotations(annotations: Annotations.Schema<Schema.Type<To>>) {\n      return makeTransformationClass<From, To, R>(\n        this.from,\n        this.to,\n        mergeSchemaAnnotations(this.ast, annotations)\n      )\n    }\n\n    static from = from\n\n    static to = to\n  }\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided decoding functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transformOrFail: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): (from: From) => transformOrFail<From, To, RD | RE>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): transformOrFail<From, To, RD | RE>\n} = dual((args) => isSchema(args[0]) && isSchema(args[1]), <FromA, FromI, FromR, ToA, ToI, ToR, RD, RE>(\n  from: Schema<FromA, FromI, FromR>,\n  to: Schema<ToA, ToI, ToR>,\n  options: {\n    readonly decode: (\n      fromA: FromA,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      fromI: FromI\n    ) => Effect.Effect<ToI, ParseResult.ParseIssue, RD>\n    readonly encode: (\n      toI: ToI,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      toA: ToA\n    ) => Effect.Effect<FromA, ParseResult.ParseIssue, RE>\n  }\n): Schema<ToA, FromI, FromR | ToR | RD | RE> =>\n  makeTransformationClass(\n    from,\n    to,\n    new AST.Transformation(\n      from.ast,\n      to.ast,\n      new AST.FinalTransformation(options.decode, options.encode)\n    )\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transform<From extends Schema.All, To extends Schema.All> extends transformOrFail<From, To> {\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided mapping functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transform: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): (from: From) => transform<From, To>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): transform<From, To>\n} = dual(\n  (args) => isSchema(args[0]) && isSchema(args[1]),\n  <FromA, FromI, FromR, ToA, ToI, ToR>(\n    from: Schema<FromA, FromI, FromR>,\n    to: Schema<ToA, ToI, ToR>,\n    options: {\n      readonly decode: (fromA: FromA, fromI: FromI) => ToI\n      readonly encode: (toI: ToI, toA: ToA) => FromA\n    }\n  ): Schema<ToA, FromI, FromR | ToR> =>\n    transformOrFail(\n      from,\n      to,\n      {\n        strict: true,\n        decode: (fromA, _options, _ast, toA) => ParseResult.succeed(options.decode(fromA, toA)),\n        encode: (toI, _options, _ast, toA) => ParseResult.succeed(options.encode(toI, toA))\n      }\n    )\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformLiteral<Type extends AST.LiteralValue, Encoded extends AST.LiteralValue>\n  extends transform<Literal<[Encoded]>, Literal<[Type]>>\n{\n  annotations(annotations: Annotations.Schema<Type>): transformLiteral<Type, Encoded>\n}\n\n/**\n * Creates a new `Schema` which transforms literal values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as S from \"effect/Schema\"\n *\n * const schema = S.transformLiteral(0, \"a\")\n *\n * assert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport function transformLiteral<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  from: Encoded,\n  to: Type\n): transformLiteral<Type, Encoded> {\n  return transform(Literal(from), Literal(to), {\n    strict: true,\n    decode: () => to,\n    encode: () => from\n  })\n}\n\n/**\n * Creates a new `Schema` which maps between corresponding literal values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as S from \"effect/Schema\"\n *\n * const Animal = S.transformLiterals(\n *   [0, \"cat\"],\n *   [1, \"dog\"],\n *   [2, \"cow\"]\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Animal)(1), \"dog\")\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport function transformLiterals<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(\n  ...pairs: A\n): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]> }>\nexport function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  pairs: [Encoded, Type]\n): transformLiteral<Type, Encoded>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]> {\n  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)))\n}\n\n/**\n * Attaches a property signature with the specified key and value to the schema.\n * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as S from \"effect/Schema\"\n * import { pipe } from \"effect/Function\"\n *\n * const Circle = S.Struct({ radius: S.Number })\n * const Square = S.Struct({ sideLength: S.Number })\n * const Shape = S.Union(\n *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n *   kind: \"circle\",\n *   radius: 10\n * })\n * ```\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const attachPropertySignature: {\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<A & { readonly [k in K]: V }>\n  ): <I, R>(\n    schema: Schema<A, I, R>\n  ) => SchemaClass<A & { readonly [k in K]: V }, I, R>\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<A & { readonly [k in K]: V }>\n  ): SchemaClass<A & { readonly [k in K]: V }, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<A & { readonly [k in K]: V }>\n  ): SchemaClass<A & { readonly [k in K]: V }, I, R> => {\n    const ast = extend(\n      typeSchema(schema),\n      Struct({ [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value) })\n    ).ast\n    return make(\n      new AST.Transformation(\n        schema.ast,\n        annotations ? mergeSchemaAnnotations(ast, annotations) : ast,\n        new AST.TypeLiteralTransformation(\n          [\n            new AST.PropertySignatureTransformation(\n              key,\n              key,\n              () => option_.some(value),\n              () => option_.none()\n            )\n          ]\n        )\n      )\n    )\n  }\n)\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotations {\n  /**\n   * @category annotations\n   * @since 3.10.0\n   */\n  export interface Doc<A> extends AST.Annotations {\n    readonly title?: AST.TitleAnnotation\n    readonly description?: AST.DescriptionAnnotation\n    readonly documentation?: AST.DocumentationAnnotation\n    readonly examples?: AST.ExamplesAnnotation<A>\n    readonly default?: AST.DefaultAnnotation<A>\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {\n    readonly typeConstructor?: AST.TypeConstructorAnnotation\n    readonly identifier?: AST.IdentifierAnnotation\n    readonly message?: AST.MessageAnnotation\n    readonly schemaId?: AST.SchemaIdAnnotation\n    readonly jsonSchema?: AST.JSONSchemaAnnotation\n    readonly arbitrary?: ArbitraryAnnotation<A, TypeParameters>\n    readonly pretty?: pretty_.PrettyAnnotation<A, TypeParameters>\n    readonly equivalence?: AST.EquivalenceAnnotation<A, TypeParameters>\n    readonly concurrency?: AST.ConcurrencyAnnotation\n    readonly batching?: AST.BatchingAnnotation\n    readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation\n    readonly parseOptions?: AST.ParseOptions\n    readonly decodingFallback?: AST.DecodingFallbackAnnotation<A>\n  }\n\n  /**\n   * @since 3.11.6\n   */\n  export interface GenericSchema<A> extends Schema<A> {\n    readonly arbitrary?: (..._: any) => LazyArbitrary<A>\n    readonly pretty?: (..._: any) => pretty_.Pretty<A>\n    readonly equivalence?: (..._: any) => Equivalence.Equivalence<A>\n  }\n\n  // TODO(4.0): replace `readonly [P]` with `readonly []`\n  /**\n   * @since 3.10.0\n   */\n  export interface Filter<A, P = A> extends Schema<A, readonly [P]> {}\n}\n\n/**\n * Merges a set of new annotations with existing ones, potentially overwriting\n * any duplicates.\n *\n * @category annotations\n * @since 3.10.0\n */\nexport const annotations: {\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>\n} = dual(\n  2,\n  <A, I, R>(self: Schema<A, I, R>, annotations: Annotations.GenericSchema<A>): Schema<A, I, R> =>\n    self.annotations(annotations)\n)\n\ntype Rename<A, M> = {\n  [\n    K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K]\n      : never\n      : K\n  ]: A[K]\n}\n\n/**\n * @category renaming\n * @since 3.10.0\n */\nexport const rename: {\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(mapping: M): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(self: Schema<A, I, R>, mapping: M): SchemaClass<Simplify<Rename<A, M>>, I, R>\n} = dual(\n  2,\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    self: Schema<A, I, R>,\n    mapping: M\n  ): SchemaClass<Simplify<Rename<A, M>>, I, R> => make(AST.rename(self.ast, mapping))\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const TrimmedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Trimmed\")\n\n/**\n * Verifies that a string contains no leading or trailing whitespaces.\n *\n * Note. This combinator does not make any transformations, it only validates.\n * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const trimmed = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a === a.trim(), {\n      schemaId: TrimmedSchemaId,\n      title: \"trimmed\",\n      description: \"a string with no leading or trailing whitespace\",\n      jsonSchema: { pattern: \"^\\\\S[\\\\s\\\\S]*\\\\S$|^\\\\S$|^$\" },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxLengthSchemaId: unique symbol = schemaId_.MaxLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxLengthSchemaId = typeof MaxLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const maxLength =\n  <S extends Schema.Any>(maxLength: number, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter(\n        (a) => a.length <= maxLength,\n        {\n          schemaId: MaxLengthSchemaId,\n          title: `maxLength(${maxLength})`,\n          description: `a string at most ${maxLength} character(s) long`,\n          jsonSchema: { maxLength },\n          ...annotations\n        }\n      )\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinLengthSchemaId: unique symbol = schemaId_.MinLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinLengthSchemaId = typeof MinLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const minLength = <S extends Schema.Any>(\n  minLength: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter(\n      (a) => a.length >= minLength,\n      {\n        schemaId: MinLengthSchemaId,\n        title: `minLength(${minLength})`,\n        description: `a string at least ${minLength} character(s) long`,\n        jsonSchema: { minLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LengthSchemaId: unique symbol = schemaId_.LengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LengthSchemaId = typeof LengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const length = <S extends Schema.Any>(\n  length: number | { readonly min: number; readonly max: number },\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length))\n  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength\n  if (minLength !== maxLength) {\n    return self.pipe(\n      filter((a) => a.length >= minLength && a.length <= maxLength, {\n        schemaId: LengthSchemaId,\n        title: `length({ min: ${minLength}, max: ${maxLength})`,\n        description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,\n        jsonSchema: { minLength, maxLength },\n        ...annotations\n      })\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length === minLength, {\n      schemaId: LengthSchemaId,\n      title: `length(${minLength})`,\n      description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,\n      jsonSchema: { minLength, maxLength: minLength },\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PatternSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Pattern\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const pattern = <S extends Schema.Any>(\n  regex: RegExp,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const source = regex.source\n  return self.pipe(\n    filter(\n      (a) => {\n        // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag\n        regex.lastIndex = 0\n        return regex.test(a)\n      },\n      {\n        schemaId: PatternSchemaId,\n        [PatternSchemaId]: { regex },\n        // title: `pattern(/${source}/)`, // avoiding this because it can be very long\n        description: `a string matching the pattern ${source}`,\n        jsonSchema: { pattern: source },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const StartsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/StartsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const startsWith = <S extends Schema.Any>(\n  startsWith: string,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const formatted = JSON.stringify(startsWith)\n  return self.pipe(\n    filter(\n      (a) => a.startsWith(startsWith),\n      {\n        schemaId: StartsWithSchemaId,\n        [StartsWithSchemaId]: { startsWith },\n        title: `startsWith(${formatted})`,\n        description: `a string starting with ${formatted}`,\n        jsonSchema: { pattern: `^${startsWith}` },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const EndsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/EndsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const endsWith = <S extends Schema.Any>(\n  endsWith: string,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const formatted = JSON.stringify(endsWith)\n  return self.pipe(\n    filter(\n      (a) => a.endsWith(endsWith),\n      {\n        schemaId: EndsWithSchemaId,\n        [EndsWithSchemaId]: { endsWith },\n        title: `endsWith(${formatted})`,\n        description: `a string ending with ${formatted}`,\n        jsonSchema: { pattern: `^.*${endsWith}$` },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IncludesSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Includes\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const includes = <S extends Schema.Any>(\n  searchString: string,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const formatted = JSON.stringify(searchString)\n  return self.pipe(\n    filter(\n      (a) => a.includes(searchString),\n      {\n        schemaId: IncludesSchemaId,\n        [IncludesSchemaId]: { includes: searchString },\n        title: `includes(${formatted})`,\n        description: `a string including ${formatted}`,\n        jsonSchema: { pattern: `.*${searchString}.*` },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LowercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Lowercased\")\n\n/**\n * Verifies that a string is lowercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const lowercased =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a === a.toLowerCase(), {\n        schemaId: LowercasedSchemaId,\n        title: \"lowercased\",\n        description: \"a lowercase string\",\n        jsonSchema: { pattern: \"^[^A-Z]*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Lowercased extends String$.pipe(\n  lowercased({ identifier: \"Lowercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UppercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uppercased\")\n\n/**\n * Verifies that a string is uppercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uppercased =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a === a.toUpperCase(), {\n        schemaId: UppercasedSchemaId,\n        title: \"uppercased\",\n        description: \"an uppercase string\",\n        jsonSchema: { pattern: \"^[^a-z]*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uppercased extends String$.pipe(\n  uppercased({ identifier: \"Uppercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const CapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Capitalized\")\n\n/**\n * Verifies that a string is capitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const capitalized =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a[0]?.toUpperCase() === a[0], {\n        schemaId: CapitalizedSchemaId,\n        title: \"capitalized\",\n        description: \"a capitalized string\",\n        jsonSchema: { pattern: \"^[^a-z]?.*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Capitalized extends String$.pipe(\n  capitalized({ identifier: \"Capitalized\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UncapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uncapitalized\")\n\n/**\n * Verifies that a string is uncapitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uncapitalized =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a[0]?.toLowerCase() === a[0], {\n        schemaId: UncapitalizedSchemaId,\n        title: \"uncapitalized\",\n        description: \"a uncapitalized string\",\n        jsonSchema: { pattern: \"^[^A-Z]?.*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uncapitalized extends String$.pipe(\n  uncapitalized({ identifier: \"Uncapitalized\" })\n) {}\n\n/**\n * A schema representing a single character.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class Char extends String$.pipe(length(1, { identifier: \"Char\" })) {}\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const nonEmptyString = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  minLength(1, {\n    title: \"nonEmptyString\",\n    description: \"a non empty string\",\n    ...annotations\n  })\n\n/**\n * This schema converts a string to lowercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Lowercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to lowercase\" }),\n  Lowercased,\n  {\n    strict: true,\n    decode: (i) => i.toLowerCase(),\n    encode: identity\n  }\n).annotations({ identifier: \"Lowercase\" }) {}\n\n/**\n * This schema converts a string to uppercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uppercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to uppercase\" }),\n  Uppercased,\n  {\n    strict: true,\n    decode: (i) => i.toUpperCase(),\n    encode: identity\n  }\n).annotations({ identifier: \"Uppercase\" }) {}\n\n/**\n * This schema converts a string to capitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Capitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to a capitalized format\" }),\n  Capitalized,\n  {\n    strict: true,\n    decode: (i) => string_.capitalize(i),\n    encode: identity\n  }\n).annotations({ identifier: \"Capitalize\" }) {}\n\n/**\n * This schema converts a string to uncapitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uncapitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to an uncapitalized format\" }),\n  Uncapitalized,\n  {\n    strict: true,\n    decode: (i) => string_.uncapitalize(i),\n    encode: identity\n  }\n).annotations({ identifier: \"Uncapitalize\" }) {}\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Trimmed extends String$.pipe(\n  trimmed({ identifier: \"Trimmed\" })\n) {}\n\n/**\n * Useful for validating strings that must contain meaningful characters without\n * leading or trailing whitespace.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\" a \")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n * ```\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyTrimmedString extends Trimmed.pipe(\n  nonEmptyString({ identifier: \"NonEmptyTrimmedString\" })\n) {}\n\n/**\n * This schema allows removing whitespaces from the beginning and end of a string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Trim extends transform(\n  String$.annotations({ description: \"a string that will be trimmed\" }),\n  Trimmed,\n  {\n    strict: true,\n    decode: (i) => i.trim(),\n    encode: identity\n  }\n).annotations({ identifier: \"Trim\" }) {}\n\n/**\n * Returns a schema that allows splitting a string into an array of strings.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const split = (separator: string): transform<SchemaClass<string>, Array$<typeof String$>> =>\n  transform(\n    String$.annotations({ description: \"a string that will be split\" }),\n    Array$(String$),\n    {\n      strict: true,\n      decode: (i) => i.split(separator),\n      encode: (a) => a.join(separator)\n    }\n  )\n\n/**\n * @since 3.10.0\n */\nexport type ParseJsonOptions = {\n  readonly reviver?: Parameters<typeof JSON.parse>[1]\n  readonly replacer?: Parameters<typeof JSON.stringify>[1]\n  readonly space?: Parameters<typeof JSON.stringify>[2]\n}\n\nconst getErrorMessage = (e: unknown): string => e instanceof Error ? e.message : String(e)\n\nconst getParseJsonTransformation = (options?: ParseJsonOptions): SchemaClass<unknown, string> =>\n  transformOrFail(\n    String$.annotations({ description: \"a string to be decoded into JSON\" }),\n    Unknown,\n    {\n      strict: true,\n      decode: (i, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.parse(i, options?.reviver),\n          catch: (e) => new ParseResult.Type(ast, i, getErrorMessage(e))\n        }),\n      encode: (a, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.stringify(a, options?.replacer, options?.space),\n          catch: (e) => new ParseResult.Type(ast, a, getErrorMessage(e))\n        })\n    }\n  ).annotations({\n    title: \"parseJson\",\n    schemaId: AST.ParseJsonSchemaId\n  })\n\n/**\n * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n *\n * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n *\n * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as Schema from \"effect/Schema\"\n *\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n * ```\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const parseJson: {\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   * ```\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any>(schema: S, options?: ParseJsonOptions): transform<SchemaClass<unknown, string>, S>\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   * ```\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  (options?: ParseJsonOptions): SchemaClass<unknown, string>\n} = <A, I, R>(schemaOrOptions?: Schema<A, I, R> | ParseJsonOptions, o?: ParseJsonOptions) =>\n  isSchema(schemaOrOptions)\n    ? compose(parseJson(o), schemaOrOptions) as any\n    : getParseJsonTransformation(schemaOrOptions as ParseJsonOptions | undefined)\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyString extends String$.pipe(\n  nonEmptyString({ identifier: \"NonEmptyString\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UUIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/UUID\")\n\nconst uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i\n\n/**\n * Represents a Universally Unique Identifier (UUID).\n *\n * This schema ensures that the provided string adheres to the standard UUID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class UUID extends String$.pipe(\n  pattern(uuidRegexp, {\n    schemaId: UUIDSchemaId,\n    identifier: \"UUID\",\n    jsonSchema: {\n      format: \"uuid\",\n      pattern: uuidRegexp.source\n    },\n    description: \"a Universally Unique Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.uuid()\n  })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ULIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ULID\")\n\nconst ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i\n\n/**\n * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).\n *\n * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.\n * This schema ensures that the provided string adheres to the standard ULID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class ULID extends String$.pipe(\n  pattern(ulidRegexp, {\n    schemaId: ULIDSchemaId,\n    identifier: \"ULID\",\n    description: \"a Universally Unique Lexicographically Sortable Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.ulid()\n  })\n) {}\n\n/**\n * Defines a schema that represents a `URL` object.\n *\n * @category URL constructors\n * @since 3.11.0\n */\nexport class URLFromSelf extends instanceOf(URL, {\n  typeConstructor: { _tag: \"URL\" },\n  identifier: \"URLFromSelf\",\n  arbitrary: (): LazyArbitrary<URL> => (fc) => fc.webUrl().map((s) => new URL(s)),\n  pretty: () => (url) => url.toString()\n}) {}\n\n/** @ignore */\nclass URL$ extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a URL\" }),\n  URLFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      ParseResult.try({\n        try: () => new URL(i),\n        catch: (e) =>\n          new ParseResult.Type(\n            ast,\n            i,\n            `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage(e)}`\n          )\n      }),\n    encode: (a) => ParseResult.succeed(a.toString())\n  }\n).annotations({\n  identifier: \"URL\",\n  pretty: () => (url) => url.toString()\n}) {}\n\nexport {\n  /**\n   * Defines a schema that attempts to convert a `string` to a `URL` object using\n   * the `new URL` constructor.\n   *\n   * @category URL transformations\n   * @since 3.11.0\n   */\n  URL$ as URL\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const FiniteSchemaId: unique symbol = schemaId_.FiniteSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type FiniteSchemaId = typeof FiniteSchemaId\n\n/**\n * Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const finite =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter(Number.isFinite, {\n        schemaId: FiniteSchemaId,\n        title: \"finite\",\n        description: \"a finite number\",\n        jsonSchema: {},\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanSchemaId: unique symbol = schemaId_.GreaterThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanSchemaId = typeof GreaterThanSchemaId\n\n/**\n * This filter checks whether the provided number is greater than the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThan = <S extends Schema.Any>(\n  exclusiveMinimum: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a > exclusiveMinimum, {\n      schemaId: GreaterThanSchemaId,\n      title: `greaterThan(${exclusiveMinimum})`,\n      description: exclusiveMinimum === 0 ? \"a positive number\" : `a number greater than ${exclusiveMinimum}`,\n      jsonSchema: { exclusiveMinimum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToSchemaId: unique symbol = schemaId_.GreaterThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToSchemaId = typeof GreaterThanOrEqualToSchemaId\n\n/**\n * This filter checks whether the provided number is greater than or equal to the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualTo = <S extends Schema.Any>(\n  minimum: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a >= minimum, {\n      schemaId: GreaterThanOrEqualToSchemaId,\n      title: `greaterThanOrEqualTo(${minimum})`,\n      description: minimum === 0 ? \"a non-negative number\" : `a number greater than or equal to ${minimum}`,\n      jsonSchema: { minimum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MultipleOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/MultipleOf\")\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const multipleOf = <S extends Schema.Any>(\n  divisor: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const positiveDivisor = Math.abs(divisor) // spec requires positive divisor\n  return self.pipe(\n    filter((a) => number_.remainder(a, divisor) === 0, {\n      schemaId: MultipleOfSchemaId,\n      title: `multipleOf(${positiveDivisor})`,\n      description: `a number divisible by ${positiveDivisor}`,\n      jsonSchema: { multipleOf: positiveDivisor },\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IntSchemaId: unique symbol = schemaId_.IntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type IntSchemaId = typeof IntSchemaId\n\n/**\n * Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity).\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const int =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => Number.isSafeInteger(a), {\n        schemaId: IntSchemaId,\n        title: \"int\",\n        description: \"an integer\",\n        jsonSchema: { type: \"integer\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanSchemaId: unique symbol = schemaId_.LessThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanSchemaId = typeof LessThanSchemaId\n\n/**\n * This filter checks whether the provided number is less than the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThan =\n  <S extends Schema.Any>(exclusiveMaximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a < exclusiveMaximum, {\n        schemaId: LessThanSchemaId,\n        title: `lessThan(${exclusiveMaximum})`,\n        description: exclusiveMaximum === 0 ? \"a negative number\" : `a number less than ${exclusiveMaximum}`,\n        jsonSchema: { exclusiveMaximum },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToSchemaId: unique symbol = schemaId_.LessThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToSchemaId = typeof LessThanOrEqualToSchemaId\n\n/**\n * This schema checks whether the provided number is less than or equal to the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualTo = <S extends Schema.Any>(\n  maximum: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a <= maximum, {\n      schemaId: LessThanOrEqualToSchemaId,\n      title: `lessThanOrEqualTo(${maximum})`,\n      description: maximum === 0 ? \"a non-positive number\" : `a number less than or equal to ${maximum}`,\n      jsonSchema: { maximum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenSchemaId: unique symbol = schemaId_.BetweenSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenSchemaId = typeof BetweenSchemaId\n\n/**\n * This filter checks whether the provided number falls within the specified minimum and maximum values.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const between = <S extends Schema.Any>(\n  minimum: number,\n  maximum: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a >= minimum && a <= maximum, {\n      schemaId: BetweenSchemaId,\n      title: `between(${minimum}, ${maximum})`,\n      description: `a number between ${minimum} and ${maximum}`,\n      jsonSchema: { minimum, maximum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNaNSchemaId: unique symbol = schemaId_.NonNaNSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type NonNaNSchemaId = typeof NonNaNSchemaId\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNaN =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a), {\n        schemaId: NonNaNSchemaId,\n        title: \"nonNaN\",\n        description: \"a number excluding NaN\",\n        ...annotations\n      })\n    )\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const positive = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  greaterThan(0, { title: \"positive\", ...annotations })\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const negative = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  lessThan(0, { title: \"negative\", ...annotations })\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonPositive = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  lessThanOrEqualTo(0, { title: \"nonPositive\", ...annotations })\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNegative = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  greaterThanOrEqualTo(0, { title: \"nonNegative\", ...annotations })\n\n/**\n * Clamps a number between a minimum and a maximum value.\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport const clamp = (minimum: number, maximum: number) =>\n<S extends Schema.Any, A extends number>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transform<S, filter<SchemaClass<A>>> => {\n  return transform(\n    self,\n    typeSchema(self).pipe(between(minimum, maximum)),\n    {\n      strict: false,\n      decode: (i) => number_.clamp(i, { minimum, maximum }),\n      encode: identity\n    }\n  )\n}\n\n/**\n * Transforms a `string` into a `number` by parsing the string using the `parse`\n * function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when\n * non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\",\n * \"-Infinity\".\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport function parseNumber<S extends Schema.Any, A extends string>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transformOrFail<S, typeof Number$> {\n  return transformOrFail(\n    self,\n    Number$,\n    {\n      strict: false,\n      decode: (i, _, ast) =>\n        ParseResult.fromOption(\n          number_.parse(i),\n          () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)\n        ),\n      encode: (a) => ParseResult.succeed(String(a))\n    }\n  )\n}\n\n/**\n * This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport class NumberFromString extends parseNumber(String$.annotations({\n  description: \"a string to be decoded into a number\"\n})).annotations({ identifier: \"NumberFromString\" }) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Finite extends Number$.pipe(finite({ identifier: \"Finite\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Int extends Number$.pipe(int({ identifier: \"Int\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNaN extends Number$.pipe(nonNaN({ identifier: \"NonNaN\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Positive extends Number$.pipe(\n  positive({ identifier: \"Positive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Negative extends Number$.pipe(\n  negative({ identifier: \"Negative\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonPositive extends Number$.pipe(\n  nonPositive({ identifier: \"NonPositive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNegative extends Number$.pipe(\n  nonNegative({ identifier: \"NonNegative\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const JsonNumberSchemaId: unique symbol = schemaId_.JsonNumberSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type JsonNumberSchemaId = typeof JsonNumberSchemaId\n\n/**\n * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\n * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\n * format.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as Schema from \"effect/Schema\"\n *\n * const is = Schema.is(S.JsonNumber)\n *\n * assert.deepStrictEqual(is(42), true)\n * assert.deepStrictEqual(is(Number.NaN), false)\n * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\n * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n * ```\n *\n * @category number constructors\n * @since 3.10.0\n */\nexport class JsonNumber extends Number$.pipe(\n  finite({\n    schemaId: JsonNumberSchemaId,\n    identifier: \"JsonNumber\"\n  })\n) {}\n\n/**\n * @category boolean transformations\n * @since 3.10.0\n */\nexport class Not extends transform(Boolean$.annotations({ description: \"a boolean that will be negated\" }), Boolean$, {\n  strict: true,\n  decode: (i) => boolean_.not(i),\n  encode: (a) => boolean_.not(a)\n}) {}\n\nconst encodeSymbol = (sym: symbol, ast: AST.AST) => {\n  const key = Symbol.keyFor(sym)\n  return key === undefined\n    ? ParseResult.fail(\n      new ParseResult.Type(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)\n    )\n    : ParseResult.succeed(key)\n}\n\nconst decodeSymbol = (s: string) => ParseResult.succeed(Symbol.for(s))\n\n/** @ignore */\nclass Symbol$ extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a globally shared symbol\" }),\n  SymbolFromSelf,\n  {\n    strict: false,\n    decode: (i) => decodeSymbol(i),\n    encode: (a, _, ast) => encodeSymbol(a, ast)\n  }\n).annotations({ identifier: \"Symbol\" }) {}\n\nexport {\n  /**\n   * Converts a string key into a globally shared symbol.\n   *\n   * @category symbol transformations\n   * @since 3.10.0\n   */\n  Symbol$ as Symbol\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigIntSchemaId: unique symbol = schemaId_.GreaterThanBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanBigIntSchemaId = typeof GreaterThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanBigInt = <S extends Schema.Any>(\n  min: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanBigIntSchemaId,\n      [GreaterThanBigIntSchemaId]: { min },\n      title: `greaterThanBigInt(${min})`,\n      description: min === 0n ? \"a positive bigint\" : `a bigint greater than ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigIntSchemaId: unique symbol = schemaId_.GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToBigIntSchemaId = typeof GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigInt = <S extends Schema.Any>(\n  min: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToBigIntSchemaId,\n      [GreaterThanOrEqualToBigIntSchemaId]: { min },\n      title: `greaterThanOrEqualToBigInt(${min})`,\n      description: min === 0n\n        ? \"a non-negative bigint\"\n        : `a bigint greater than or equal to ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigIntSchemaId: unique symbol = schemaId_.LessThanBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanBigIntSchemaId = typeof LessThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanBigInt = <S extends Schema.Any>(\n  max: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a < max, {\n      schemaId: LessThanBigIntSchemaId,\n      [LessThanBigIntSchemaId]: { max },\n      title: `lessThanBigInt(${max})`,\n      description: max === 0n ? \"a negative bigint\" : `a bigint less than ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigIntSchemaId: unique symbol = schemaId_.LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToBigIntSchemaId = typeof LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigInt = <S extends Schema.Any>(\n  max: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanOrEqualToBigIntSchemaId,\n      [LessThanOrEqualToBigIntSchemaId]: { max },\n      title: `lessThanOrEqualToBigInt(${max})`,\n      description: max === 0n ? \"a non-positive bigint\" : `a bigint less than or equal to ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigIntSchemaId: unique symbol = schemaId_.BetweenBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenBigIntSchemaId = typeof BetweenBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const betweenBigInt = <S extends Schema.Any>(\n  min: bigint,\n  max: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a >= min && a <= max, {\n      schemaId: BetweenBigIntSchemaId,\n      [BetweenBigIntSchemaId]: { min, max },\n      title: `betweenBigInt(${min}, ${max})`,\n      description: `a bigint between ${min}n and ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const positiveBigInt = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  greaterThanBigInt(0n, { title: \"positiveBigInt\", ...annotations })\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const negativeBigInt = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  lessThanBigInt(0n, { title: \"negativeBigInt\", ...annotations })\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonNegativeBigInt = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  greaterThanOrEqualToBigInt(0n, { title: \"nonNegativeBigInt\", ...annotations })\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonPositiveBigInt = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  lessThanOrEqualToBigInt(0n, { title: \"nonPositiveBigInt\", ...annotations })\n\n/**\n * Clamps a bigint between a minimum and a maximum value.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport const clampBigInt = (minimum: bigint, maximum: bigint) =>\n<S extends Schema.Any, A extends bigint>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transform<S, filter<SchemaClass<A>>> =>\n  transform(\n    self,\n    self.pipe(typeSchema, betweenBigInt(minimum, maximum)),\n    {\n      strict: false,\n      decode: (i) => bigInt_.clamp(i, { minimum, maximum }),\n      encode: identity\n    }\n  )\n\n/** @ignore */\nclass BigInt$ extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a bigint\" }),\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.fromString(i),\n        () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)\n      ),\n    encode: (a) => ParseResult.succeed(String(a))\n  }\n).annotations({ identifier: \"BigInt\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n   *\n   * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n   *\n   * @category bigint transformations\n   * @since 3.10.0\n   */\n  BigInt$ as BigInt\n}\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  positiveBigInt({ identifier: \"PositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  positiveBigInt({ identifier: \"PositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  negativeBigInt({ identifier: \"NegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  negativeBigInt({ identifier: \"NegativeBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigint\" })\n)\n\n/**\n * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n *\n * It returns an error if the value can't be safely encoded as a `number` due to being out of range.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport class BigIntFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number to be decoded into a bigint\" }),\n  BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))),\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.fromNumber(i),\n        () => new ParseResult.Type(ast, i, `Unable to decode ${i} into a bigint`)\n      ),\n    encode: (a, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.toNumber(a),\n        () => new ParseResult.Type(ast, a, `Unable to encode ${a}n into a number`)\n      )\n  }\n).annotations({ identifier: \"BigIntFromNumber\" }) {}\n\nconst redactedArbitrary = <A>(value: LazyArbitrary<A>): LazyArbitrary<redacted_.Redacted<A>> => (fc) =>\n  value(fc).map(redacted_.make)\n\nconst toComposite = <A, R, B>(\n  eff: Effect.Effect<A, ParseResult.ParseIssue, R>,\n  onSuccess: (a: A) => B,\n  ast: AST.AST,\n  actual: unknown\n): Effect.Effect<B, ParseResult.Composite, R> =>\n  ParseResult.mapBoth(eff, {\n    onFailure: (e) => new ParseResult.Composite(ast, actual, e),\n    onSuccess\n  })\n\nconst redactedParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<redacted_.Redacted<A>, R> =>\n(u, options, ast) =>\n  redacted_.isRedacted(u) ?\n    toComposite(decodeUnknown(redacted_.value(u), options), redacted_.make, ast, u) :\n    ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface RedactedFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    RedactedFromSelf<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    redacted_.Redacted<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category Redacted constructors\n * @since 3.10.0\n */\nexport const RedactedFromSelf = <Value extends Schema.Any>(value: Value): RedactedFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (value) => redactedParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => redactedParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      typeConstructor: { _tag: \"effect/Redacted\" },\n      description: \"Redacted(<redacted>)\",\n      pretty: () => () => \"Redacted(<redacted>)\",\n      arbitrary: redactedArbitrary,\n      equivalence: redacted_.getEquivalence\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Redacted<Value extends Schema.Any>\n  extends transform<Value, RedactedFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * A transformation that transform a `Schema<A, I, R>` into a\n * `RedactedFromSelf<A>`.\n *\n * @category Redacted transformations\n * @since 3.10.0\n */\nexport function Redacted<Value extends Schema.Any>(value: Value): Redacted<Value> {\n  return transform(\n    value,\n    RedactedFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => redacted_.make(i),\n      encode: (a) => redacted_.value(a)\n    }\n  )\n}\n\n/**\n * @category Duration constructors\n * @since 3.10.0\n */\nexport class DurationFromSelf extends declare(\n  duration_.isDuration,\n  {\n    typeConstructor: { _tag: \"effect/Duration\" },\n    identifier: \"DurationFromSelf\",\n    pretty: (): pretty_.Pretty<duration_.Duration> => String,\n    arbitrary: (): LazyArbitrary<duration_.Duration> => (fc) =>\n      fc.oneof(\n        fc.constant(duration_.infinity),\n        fc.bigInt({ min: 0n }).map((_) => duration_.nanos(_)),\n        fc.maxSafeNat().map((_) => duration_.millis(_))\n      ),\n    equivalence: (): Equivalence.Equivalence<duration_.Duration> => duration_.Equivalence\n  }\n) {}\n\n/**\n * A schema that transforms a non negative `bigint` into a `Duration`. Treats\n * the value as the number of nanoseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromNanos extends transformOrFail(\n  NonNegativeBigIntFromSelf.annotations({ description: \"a bigint to be decoded into a Duration\" }),\n  DurationFromSelf.pipe(filter((duration) => duration_.isFinite(duration), { description: \"a finite duration\" })),\n  {\n    strict: true,\n    decode: (i) => ParseResult.succeed(duration_.nanos(i)),\n    encode: (a, _, ast) =>\n      option_.match(duration_.toNanos(a), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, a, `Unable to encode ${a} into a bigint`)),\n        onSome: (nanos) => ParseResult.succeed(nanos)\n      })\n  }\n).annotations({ identifier: \"DurationFromNanos\" }) {}\n\n/**\n * A non-negative integer. +Infinity is excluded.\n *\n * @category number constructors\n * @since 3.11.10\n */\nexport const NonNegativeInt = NonNegative.pipe(int()).annotations({ identifier: \"NonNegativeInt\" })\n\n/**\n * A schema that transforms a (possibly Infinite) non negative number into a\n * `Duration`. Treats the value as the number of milliseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromMillis extends transform(\n  NonNegative.annotations({\n    description: \"a non-negative number to be decoded into a Duration\"\n  }),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: (i) => duration_.millis(i),\n    encode: (a) => duration_.toMillis(a)\n  }\n).annotations({ identifier: \"DurationFromMillis\" }) {}\n\nconst DurationValueMillis = TaggedStruct(\"Millis\", { millis: NonNegativeInt })\nconst DurationValueNanos = TaggedStruct(\"Nanos\", { nanos: BigInt$ })\nconst DurationValueInfinity = TaggedStruct(\"Infinity\", {})\nconst durationValueInfinity = DurationValueInfinity.make({})\n\n/**\n * @category Duration utils\n * @since 3.12.8\n */\nexport type DurationEncoded =\n  | {\n    readonly _tag: \"Millis\"\n    readonly millis: number\n  }\n  | {\n    readonly _tag: \"Nanos\"\n    readonly nanos: string\n  }\n  | {\n    readonly _tag: \"Infinity\"\n  }\n\nconst DurationValue: Schema<duration_.DurationValue, DurationEncoded> = Union(\n  DurationValueMillis,\n  DurationValueNanos,\n  DurationValueInfinity\n).annotations({\n  identifier: \"DurationValue\",\n  description: \"an JSON-compatible tagged union to be decoded into a Duration\"\n})\n\nconst FiniteHRTime = Tuple(\n  element(NonNegativeInt).annotations({ title: \"seconds\" }),\n  element(NonNegativeInt).annotations({ title: \"nanos\" })\n).annotations({ identifier: \"FiniteHRTime\" })\n\nconst InfiniteHRTime = Tuple(Literal(-1), Literal(0)).annotations({ identifier: \"InfiniteHRTime\" })\n\nconst HRTime: Schema<readonly [seconds: number, nanos: number]> = Union(FiniteHRTime, InfiniteHRTime).annotations({\n  identifier: \"HRTime\",\n  description: \"a tuple of seconds and nanos to be decoded into a Duration\"\n})\n\nconst isDurationValue = (u: duration_.DurationValue | typeof HRTime.Type): u is duration_.DurationValue =>\n  typeof u === \"object\"\n\n// TODO(4.0): remove HRTime union member\n/**\n * A schema that converts a JSON-compatible tagged union into a `Duration`.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class Duration extends transform(\n  Union(DurationValue, HRTime),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: (i) => {\n      if (isDurationValue(i)) {\n        switch (i._tag) {\n          case \"Millis\":\n            return duration_.millis(i.millis)\n          case \"Nanos\":\n            return duration_.nanos(i.nanos)\n          case \"Infinity\":\n            return duration_.infinity\n        }\n      }\n      const [seconds, nanos] = i\n      return seconds === -1 ? duration_.infinity : duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos))\n    },\n    encode: (a) => {\n      switch (a.value._tag) {\n        case \"Millis\":\n          return DurationValueMillis.make({ millis: a.value.millis })\n        case \"Nanos\":\n          return DurationValueNanos.make({ nanos: a.value.nanos })\n        case \"Infinity\":\n          return durationValueInfinity\n      }\n    }\n  }\n).annotations({ identifier: \"Duration\" }) {}\n\n/**\n * Clamps a `Duration` between a minimum and a maximum value.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport const clampDuration =\n  (minimum: duration_.DurationInput, maximum: duration_.DurationInput) =>\n  <S extends Schema.Any, A extends duration_.Duration>(\n    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n  ): transform<S, filter<SchemaClass<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenDuration(minimum, maximum)),\n      {\n        strict: false,\n        decode: (i) => duration_.clamp(i, { minimum, maximum }),\n        encode: identity\n      }\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanDuration = <S extends Schema.Any>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.lessThan(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      title: `lessThanDuration(${max})`,\n      description: `a Duration less than ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDuration = <S extends Schema.Any>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.lessThanOrEqualTo(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      title: `lessThanOrEqualToDuration(${max})`,\n      description: `a Duration less than or equal to ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanDuration = <S extends Schema.Any>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.greaterThan(a, min), {\n      schemaId: GreaterThanDurationSchemaId,\n      [GreaterThanDurationSchemaId]: { min },\n      title: `greaterThanDuration(${min})`,\n      description: `a Duration greater than ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDuration = <S extends Schema.Any>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.greaterThanOrEqualTo(a, min), {\n      schemaId: GreaterThanOrEqualToDurationSchemaId,\n      [GreaterThanOrEqualToDurationSchemaId]: { min },\n      title: `greaterThanOrEqualToDuration(${min})`,\n      description: `a Duration greater than or equal to ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const betweenDuration = <S extends Schema.Any>(\n  minimum: duration_.DurationInput,\n  maximum: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.between(a, { minimum, maximum }), {\n      schemaId: BetweenDurationSchemaId,\n      [BetweenDurationSchemaId]: { maximum, minimum },\n      title: `betweenDuration(${minimum}, ${maximum})`,\n      description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category Uint8Array constructors\n * @since 3.10.0\n */\nexport class Uint8ArrayFromSelf extends declare(\n  Predicate.isUint8Array,\n  {\n    typeConstructor: { _tag: \"Uint8Array\" },\n    identifier: \"Uint8ArrayFromSelf\",\n    pretty: (): pretty_.Pretty<Uint8Array> => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,\n    arbitrary: (): LazyArbitrary<Uint8Array> => (fc) => fc.uint8Array(),\n    equivalence: (): Equivalence.Equivalence<Uint8Array> => array_.getEquivalence(Equal.equals) as any\n  }\n) {}\n\n/**\n * @category number constructors\n * @since 3.11.10\n */\nexport class Uint8 extends Number$.pipe(\n  between(0, 255, {\n    identifier: \"Uint8\",\n    description: \"a 8-bit unsigned integer\"\n  })\n) {}\n\n/** @ignore */\nclass Uint8Array$ extends transform(\n  Array$(Uint8).annotations({\n    description: \"an array of 8-bit unsigned integers to be decoded into a Uint8Array\"\n  }),\n  Uint8ArrayFromSelf,\n  {\n    strict: true,\n    decode: (i) => Uint8Array.from(i),\n    encode: (a) => Array.from(a)\n  }\n).annotations({ identifier: \"Uint8Array\" }) {}\n\nexport {\n  /**\n   * A schema that transforms an array of numbers into a `Uint8Array`.\n   *\n   * @category Uint8Array transformations\n   * @since 3.10.0\n   */\n  Uint8Array$ as Uint8Array\n}\n\nconst makeUint8ArrayTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<Uint8Array, Encoding.DecodeException>,\n  encode: (u: Uint8Array) => string\n) =>\n  transformOrFail(\n    String$.annotations({ description: \"a string to be decoded into a Uint8Array\" }),\n    Uint8ArrayFromSelf,\n    {\n      strict: true,\n      decode: (i, _, ast) =>\n        either_.mapLeft(\n          decode(i),\n          (decodeException) => new ParseResult.Type(ast, i, decodeException.message)\n        ),\n      encode: (a) => ParseResult.succeed(encode(a))\n    }\n  ).annotations({ identifier: id })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64\",\n  Encoding.decodeBase64,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64Url: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64Url\",\n  Encoding.decodeBase64Url,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromHex: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromHex\",\n  Encoding.decodeHex,\n  Encoding.encodeHex\n)\n\nconst makeEncodingTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<string, Encoding.DecodeException>,\n  encode: (u: string) => string\n) =>\n  transformOrFail(\n    String$.annotations({\n      description: `A string that is interpreted as being ${id}-encoded and will be decoded into a UTF-8 string`\n    }),\n    String$,\n    {\n      strict: true,\n      decode: (i, _, ast) =>\n        either_.mapLeft(\n          decode(i),\n          (decodeException) => new ParseResult.Type(ast, i, decodeException.message)\n        ),\n      encode: (a) => ParseResult.succeed(encode(a))\n    }\n  ).annotations({ identifier: `StringFrom${id}` })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64: Schema<string> = makeEncodingTransformation(\n  \"Base64\",\n  Encoding.decodeBase64String,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64Url: Schema<string> = makeEncodingTransformation(\n  \"Base64Url\",\n  Encoding.decodeBase64UrlString,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromHex: Schema<string> = makeEncodingTransformation(\n  \"Hex\",\n  Encoding.decodeHexString,\n  Encoding.encodeHex\n)\n\n/**\n * Decodes a URI component encoded string into a UTF-8 string.\n * Can be used to store data in a URL.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * const PaginationSchema = Schema.Struct({\n *   maxItemPerPage: Schema.Number,\n *   page: Schema.Number\n * })\n *\n * const UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))\n *\n * console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))\n * // Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D\n * ```\n *\n * @category string transformations\n * @since 3.12.0\n */\nexport const StringFromUriComponent = transformOrFail(\n  String$.annotations({\n    description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`\n  }),\n  String$,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      either_.mapLeft(\n        Encoding.decodeUriComponent(i),\n        (decodeException) => new ParseResult.Type(ast, i, decodeException.message)\n      ),\n    encode: (a, _, ast) =>\n      either_.mapLeft(\n        Encoding.encodeUriComponent(a),\n        (encodeException) => new ParseResult.Type(ast, a, encodeException.message)\n      )\n  }\n).annotations({ identifier: `StringFromUriComponent` })\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinItemsSchemaId: unique symbol = schemaId_.MinItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinItemsSchemaId = typeof MinItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const minItems = <S extends Schema.Any>(\n  n: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const minItems = Math.floor(n)\n  if (minItems < 1) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter(\n      (a) => a.length >= minItems,\n      {\n        schemaId: MinItemsSchemaId,\n        title: `minItems(${minItems})`,\n        description: `an array of at least ${minItems} item(s)`,\n        jsonSchema: { minItems },\n        [AST.StableFilterAnnotationId]: true,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxItemsSchemaId: unique symbol = schemaId_.MaxItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxItemsSchemaId = typeof MaxItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const maxItems = <S extends Schema.Any>(\n  n: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const maxItems = Math.floor(n)\n  if (maxItems < 1) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length <= maxItems, {\n      schemaId: MaxItemsSchemaId,\n      title: `maxItems(${maxItems})`,\n      description: `an array of at most ${maxItems} item(s)`,\n      jsonSchema: { maxItems },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ItemsCountSchemaId: unique symbol = schemaId_.ItemsCountSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type ItemsCountSchemaId = typeof ItemsCountSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const itemsCount = <S extends Schema.Any>(\n  n: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const itemsCount = Math.floor(n)\n  if (itemsCount < 0) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length === itemsCount, {\n      schemaId: ItemsCountSchemaId,\n      title: `itemsCount(${itemsCount})`,\n      description: `an array of exactly ${itemsCount} item(s)`,\n      jsonSchema: { minItems: itemsCount, maxItems: itemsCount },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const getNumberIndexedAccess = <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(\n  self: Schema<A, I, R>\n): SchemaClass<A[number], I[number], R> => make(AST.getNumberIndexedAccess(self.ast))\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport function head<S extends Schema.Any, A extends ReadonlyArray<unknown>>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transform<S, OptionFromSelf<SchemaClass<A[number]>>> {\n  return transform(\n    self,\n    OptionFromSelf(getNumberIndexedAccess(typeSchema(self))),\n    {\n      strict: false,\n      decode: (i) => array_.head(i),\n      encode: (a) =>\n        option_.match(a, {\n          onNone: () => [],\n          onSome: array_.of\n        })\n    }\n  )\n}\n\n/**\n * Get the first element of a `NonEmptyReadonlyArray`.\n *\n * @category NonEmptyReadonlyArray transformations\n * @since 3.12.0\n */\nexport function headNonEmpty<S extends Schema.Any, A extends array_.NonEmptyReadonlyArray<unknown>>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transform<S, SchemaClass<A[number]>> {\n  return transform(\n    self,\n    getNumberIndexedAccess(typeSchema(self)),\n    {\n      strict: false,\n      decode: (i) => array_.headNonEmpty(i),\n      encode: (a) => array_.of(a)\n    }\n  )\n}\n\n/**\n * Retrieves the first element of a `ReadonlyArray`.\n *\n * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const headOrElse: {\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, A extends ReadonlyArray<unknown>>(fallback?: LazyArg<A[number]>): (\n    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n  ) => transform<S, SchemaClass<A[number]>>\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, A extends ReadonlyArray<unknown>>(\n    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>,\n    fallback?: LazyArg<A[number]>\n  ): transform<S, SchemaClass<A[number]>>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R>(\n    self: Schema<ReadonlyArray<A>, I, R>,\n    fallback?: LazyArg<A>\n  ): transform<Schema<ReadonlyArray<A>, I, R>, SchemaClass<A>> =>\n    transformOrFail(\n      self,\n      getNumberIndexedAccess(typeSchema(self)),\n      {\n        strict: true,\n        decode: (i, _, ast) =>\n          i.length > 0\n            ? ParseResult.succeed(i[0])\n            : fallback\n            ? ParseResult.succeed(fallback())\n            : ParseResult.fail(new ParseResult.Type(ast, i, \"Unable to retrieve the first element of an empty array\")),\n        encode: (a) => ParseResult.succeed(array_.of(a))\n      }\n    )\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ValidDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ValidDate\")\n\n/**\n * Defines a filter that specifically rejects invalid dates, such as `new\n * Date(\"Invalid Date\")`. This filter ensures that only properly formatted and\n * valid date objects are accepted, enhancing data integrity by preventing\n * erroneous date values from being processed.\n *\n * @category Date filters\n * @since 3.10.0\n */\nexport const validDate =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a.getTime()), {\n        schemaId: ValidDateSchemaId,\n        [ValidDateSchemaId]: { noInvalidDate: true },\n        title: \"validDate\",\n        description: \"a valid Date\",\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanDate = <S extends Schema.Any>(\n  max: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a < max, {\n      schemaId: LessThanDateSchemaId,\n      [LessThanDateSchemaId]: { max },\n      title: `lessThanDate(${Inspectable.formatDate(max)})`,\n      description: `a date before ${Inspectable.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDate = <S extends Schema.Any>(\n  max: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a <= max, {\n      schemaId: LessThanOrEqualToDateSchemaId,\n      [LessThanOrEqualToDateSchemaId]: { max },\n      title: `lessThanOrEqualToDate(${Inspectable.formatDate(max)})`,\n      description: `a date before or equal to ${Inspectable.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanDate = <S extends Schema.Any>(\n  min: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a > min, {\n      schemaId: GreaterThanDateSchemaId,\n      [GreaterThanDateSchemaId]: { min },\n      title: `greaterThanDate(${Inspectable.formatDate(min)})`,\n      description: `a date after ${Inspectable.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDate = <S extends Schema.Any>(\n  min: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a >= min, {\n      schemaId: GreaterThanOrEqualToDateSchemaId,\n      [GreaterThanOrEqualToDateSchemaId]: { min },\n      title: `greaterThanOrEqualToDate(${Inspectable.formatDate(min)})`,\n      description: `a date after or equal to ${Inspectable.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const betweenDate = <S extends Schema.Any>(\n  min: Date,\n  max: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a <= max && a >= min, {\n      schemaId: BetweenDateSchemaId,\n      [BetweenDateSchemaId]: { max, min },\n      title: `betweenDate(${Inspectable.formatDate(min)}, ${Inspectable.formatDate(max)})`,\n      description: `a date between ${Inspectable.formatDate(min)} and ${Inspectable.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.11.8\n */\nexport const DateFromSelfSchemaId: unique symbol = schemaId_.DateFromSelfSchemaId\n\n/**\n * @category schema id\n * @since 3.11.8\n */\nexport type DateFromSelfSchemaId = typeof DateFromSelfSchemaId\n\n/**\n * Describes a schema that accommodates potentially invalid `Date` instances,\n * such as `new Date(\"Invalid Date\")`, without rejection.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class DateFromSelf extends declare(\n  Predicate.isDate,\n  {\n    typeConstructor: { _tag: \"Date\" },\n    identifier: \"DateFromSelf\",\n    schemaId: DateFromSelfSchemaId,\n    [DateFromSelfSchemaId]: { noInvalidDate: false },\n    description: \"a potentially invalid Date instance\",\n    pretty: () => (date) => `new Date(${JSON.stringify(date)})`,\n    arbitrary: () => (fc) => fc.date({ noInvalidDate: false }),\n    equivalence: () => Equivalence.Date\n  }\n) {}\n\n/**\n * Defines a schema that ensures only valid dates are accepted. This schema\n * rejects values like `new Date(\"Invalid Date\")`, which, despite being a `Date`\n * instance, represents an invalid date. Such stringent validation ensures that\n * all date objects processed through this schema are properly formed and\n * represent real dates.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class ValidDateFromSelf extends DateFromSelf.pipe(\n  validDate({\n    identifier: \"ValidDateFromSelf\",\n    description: \"a valid Date instance\"\n  })\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `Date` object using\n * the `new Date` constructor. This conversion is lenient, meaning it does not\n * reject strings that do not form valid dates (e.g., using `new Date(\"Invalid\n * Date\")` results in a `Date` object, despite being invalid).\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromString extends transform(\n  String$.annotations({ description: \"a string to be decoded into a Date\" }),\n  DateFromSelf,\n  {\n    strict: true,\n    decode: (i) => new Date(i),\n    encode: (a) => Inspectable.formatDate(a)\n  }\n).annotations({ identifier: \"DateFromString\" }) {}\n\n/** @ignore */\nclass Date$ extends DateFromString.pipe(\n  validDate({ identifier: \"Date\" })\n) {}\n\nexport {\n  /**\n   * This schema converts a `string` into a `Date` object using the `new Date`\n   * constructor. It ensures that only valid date strings are accepted,\n   * rejecting any strings that would result in an invalid date, such as `new\n   * Date(\"Invalid Date\")`.\n   *\n   * @category Date transformations\n   * @since 3.10.0\n   */\n  Date$ as Date\n}\n\n/**\n * Defines a schema that converts a `number` into a `Date` object using the `new\n * Date` constructor. This schema does not validate the numerical input,\n * allowing potentially invalid values such as `NaN`, `Infinity`, and\n * `-Infinity` to be converted into `Date` objects. During the encoding process,\n * any invalid `Date` object will be encoded to `NaN`.\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromNumber extends transform(\n  Number$.annotations({ description: \"a number to be decoded into a Date\" }),\n  DateFromSelf,\n  {\n    strict: true,\n    decode: (i) => new Date(i),\n    encode: (a) => a.getTime()\n  }\n).annotations({ identifier: \"DateFromNumber\" }) {}\n\n/**\n * Describes a schema that represents a `DateTime.Utc` instance.\n *\n * @category DateTime.Utc constructors\n * @since 3.10.0\n */\nexport class DateTimeUtcFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isUtc(u),\n  {\n    typeConstructor: { _tag: \"effect/DateTime.Utc\" },\n    identifier: \"DateTimeUtcFromSelf\",\n    description: \"a DateTime.Utc instance\",\n    pretty: (): pretty_.Pretty<dateTime.Utc> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Utc> => (fc) =>\n      fc.date({ noInvalidDate: true }).map((date) => dateTime.unsafeFromDate(date)),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\nconst decodeDateTimeUtc = <A extends dateTime.DateTime.Input>(input: A, ast: AST.AST) =>\n  ParseResult.try({\n    try: () => dateTime.unsafeMake(input),\n    catch: () =>\n      new ParseResult.Type(ast, input, `Unable to decode ${Inspectable.formatUnknown(input)} into a DateTime.Utc`)\n  })\n\n/**\n * Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtcFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number to be decoded into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) => decodeDateTimeUtc(i, ast),\n    encode: (a) => ParseResult.succeed(dateTime.toEpochMillis(a))\n  }\n).annotations({ identifier: \"DateTimeUtcFromNumber\" }) {}\n\n/**\n * Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.12.0\n */\nexport class DateTimeUtcFromDate extends transformOrFail(\n  DateFromSelf.annotations({ description: \"a Date to be decoded into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) => decodeDateTimeUtc(i, ast),\n    encode: (a) => ParseResult.succeed(dateTime.toDateUtc(a))\n  }\n).annotations({ identifier: \"DateTimeUtcFromDate\" }) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtc extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) => decodeDateTimeUtc(i, ast),\n    encode: (a) => ParseResult.succeed(dateTime.formatIso(a))\n  }\n).annotations({ identifier: \"DateTimeUtc\" }) {}\n\nconst timeZoneOffsetArbitrary = (): LazyArbitrary<dateTime.TimeZone.Offset> => (fc) =>\n  fc.integer({ min: -12 * 60 * 60 * 1000, max: 14 * 60 * 60 * 1000 }).map(dateTime.zoneMakeOffset)\n\n/**\n * Describes a schema that represents a `TimeZone.Offset` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneOffsetFromSelf extends declare(\n  dateTime.isTimeZoneOffset,\n  {\n    typeConstructor: { _tag: \"effect/DateTime.TimeZone.Offset\" },\n    identifier: \"TimeZoneOffsetFromSelf\",\n    description: \"a TimeZone.Offset instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Offset> => (zone) => zone.toString(),\n    arbitrary: timeZoneOffsetArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneOffset extends transform(\n  Number$.annotations({ description: \"a number to be decoded into a TimeZone.Offset\" }),\n  TimeZoneOffsetFromSelf,\n  {\n    strict: true,\n    decode: (i) => dateTime.zoneMakeOffset(i),\n    encode: (a) => a.offset\n  }\n).annotations({ identifier: \"TimeZoneOffset\" }) {}\n\nconst timeZoneNamedArbitrary = (): LazyArbitrary<dateTime.TimeZone.Named> => (fc) =>\n  fc.constantFrom(...Intl.supportedValuesOf(\"timeZone\")).map(dateTime.zoneUnsafeMakeNamed)\n\n/**\n * Describes a schema that represents a `TimeZone.Named` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneNamedFromSelf extends declare(\n  dateTime.isTimeZoneNamed,\n  {\n    typeConstructor: { _tag: \"effect/DateTime.TimeZone.Named\" },\n    identifier: \"TimeZoneNamedFromSelf\",\n    description: \"a TimeZone.Named instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Named> => (zone) => zone.toString(),\n    arbitrary: timeZoneNamedArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneNamed extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a TimeZone.Named\" }),\n  TimeZoneNamedFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      ParseResult.try({\n        try: () => dateTime.zoneUnsafeMakeNamed(i),\n        catch: () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)\n      }),\n    encode: (a) => ParseResult.succeed(a.id)\n  }\n).annotations({ identifier: \"TimeZoneNamed\" }) {}\n\n/**\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneFromSelf extends Union(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZone extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a TimeZone\" }),\n  TimeZoneFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      option_.match(dateTime.zoneFromString(i), {\n        onNone: () =>\n          ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (a) => ParseResult.succeed(dateTime.zoneToString(a))\n  }\n).annotations({ identifier: \"TimeZone\" }) {}\n\nconst timeZoneArbitrary: LazyArbitrary<dateTime.TimeZone> = (fc) =>\n  fc.oneof(\n    timeZoneOffsetArbitrary()(fc),\n    timeZoneNamedArbitrary()(fc)\n  )\n\n/**\n * Describes a schema that represents a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned constructors\n * @since 3.10.0\n */\nexport class DateTimeZonedFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isZoned(u),\n  {\n    typeConstructor: { _tag: \"effect/DateTime.Zoned\" },\n    identifier: \"DateTimeZonedFromSelf\",\n    description: \"a DateTime.Zoned instance\",\n    pretty: (): pretty_.Pretty<dateTime.Zoned> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Zoned> => (fc) =>\n      fc.tuple(\n        fc.integer({\n          // time zone db supports +/- 1000 years or so\n          min: -31536000000000,\n          max: 31536000000000\n        }),\n        timeZoneArbitrary(fc)\n      ).map(([millis, timeZone]) => dateTime.unsafeMakeZoned(millis, { timeZone })),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned transformations\n * @since 3.10.0\n */\nexport class DateTimeZoned extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a DateTime.Zoned\" }),\n  DateTimeZonedFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      option_.match(dateTime.makeZonedFromString(i), {\n        onNone: () =>\n          ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (a) => ParseResult.succeed(dateTime.formatIsoZoned(a))\n  }\n).annotations({ identifier: \"DateTimeZoned\" }) {}\n\n/**\n * @category Option utils\n * @since 3.10.0\n */\nexport type OptionEncoded<I> =\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Some\"\n    readonly value: I\n  }\n\nconst OptionNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ description: \"NoneEncoded\" })\n\nconst optionSomeEncoded = <Value extends Schema.Any>(value: Value) =>\n  Struct({\n    _tag: Literal(\"Some\"),\n    value\n  }).annotations({ description: `SomeEncoded<${format(value)}>` })\n\nconst optionEncoded = <Value extends Schema.Any>(value: Value) =>\n  Union(\n    OptionNoneEncoded,\n    optionSomeEncoded(value)\n  ).annotations({\n    description: `OptionEncoded<${format(value)}>`\n  })\n\nconst optionDecode = <A>(input: OptionEncoded<A>): option_.Option<A> =>\n  input._tag === \"None\" ? option_.none() : option_.some(input.value)\n\nconst optionArbitrary =\n  <A>(value: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<option_.Option<A>> => (fc) =>\n    fc.oneof(\n      ctx,\n      fc.record({ _tag: fc.constant(\"None\" as const) }),\n      fc.record({ _tag: fc.constant(\"Some\" as const), value: value(fc) })\n    ).map(optionDecode)\n\nconst optionPretty = <A>(value: pretty_.Pretty<A>): pretty_.Pretty<option_.Option<A>> =>\n  option_.match({\n    onNone: () => \"none()\",\n    onSome: (a) => `some(${value(a)})`\n  })\n\nconst optionParse =\n  <A, R>(decodeUnknown: ParseResult.DecodeUnknown<A, R>): ParseResult.DeclarationDecodeUnknown<option_.Option<A>, R> =>\n  (u, options, ast) =>\n    option_.isOption(u) ?\n      option_.isNone(u) ?\n        ParseResult.succeed(option_.none())\n        : toComposite(decodeUnknown(u.value, options), option_.some, ast, u)\n      : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    OptionFromSelf<Value>,\n    option_.Option<Schema.Type<Value>>,\n    option_.Option<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\nconst OptionFromSelf_ = <Value extends Schema.Any>(value: Value): OptionFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (value) => optionParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => optionParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      typeConstructor: { _tag: \"effect/Option\" },\n      pretty: optionPretty,\n      arbitrary: optionArbitrary,\n      equivalence: option_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromSelf = <Value extends Schema.Any>(value: Value): OptionFromSelf<Value> => {\n  return OptionFromSelf_(value).annotations({ description: `Option<${format(value)}>` })\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Option<Value extends Schema.Any> extends\n  transform<\n    Union<[\n      Struct<{ _tag: Literal<[\"None\"]> }>,\n      Struct<{ _tag: Literal<[\"Some\"]>; value: Value }>\n    ]>,\n    OptionFromSelf<SchemaClass<Schema.Type<Value>>>\n  >\n{}\n\nconst makeNoneEncoded = {\n  _tag: \"None\"\n} as const\n\nconst makeSomeEncoded = <A>(value: A) => ({\n  _tag: \"Some\",\n  value\n} as const)\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport function Option<Value extends Schema.Any>(value: Value): Option<Value> {\n  const value_ = asSchema(value)\n  const out = transform(\n    optionEncoded(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: (i) => optionDecode(i),\n      encode: (a) =>\n        option_.match(a, {\n          onNone: () => makeNoneEncoded,\n          onSome: makeSomeEncoded\n        })\n    }\n  )\n  return out as any\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullOr<Value extends Schema.Any>\n  extends transform<NullOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport function OptionFromNullOr<Value extends Schema.Any>(value: Value): OptionFromNullOr<Value> {\n  return transform(NullOr(value), OptionFromSelf(typeSchema(asSchema(value))), {\n    strict: true,\n    decode: (i) => option_.fromNullable(i),\n    encode: (a) => option_.getOrNull(a)\n  })\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullishOr<Value extends Schema.Any>\n  extends transform<NullishOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport function OptionFromNullishOr<Value extends Schema.Any>(\n  value: Value,\n  onNoneEncoding: null | undefined\n): OptionFromNullishOr<Value> {\n  return transform(\n    NullishOr(value),\n    OptionFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => option_.fromNullable(i),\n      encode: onNoneEncoding === null ?\n        (a) => option_.getOrNull(a) :\n        (a) => option_.getOrUndefined(a)\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromUndefinedOr<Value extends Schema.Any>\n  extends transform<UndefinedOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport function OptionFromUndefinedOr<Value extends Schema.Any>(value: Value): OptionFromUndefinedOr<Value> {\n  return transform(UndefinedOr(value), OptionFromSelf(typeSchema(asSchema(value))), {\n    strict: true,\n    decode: (i) => option_.fromNullable(i),\n    encode: (a) => option_.getOrUndefined(a)\n  })\n}\n\n/**\n * Transforms strings into an Option type, effectively filtering out empty or\n * whitespace-only strings by trimming them and checking their length. Returns\n * `none` for invalid inputs and `some` for valid non-empty strings.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\" a \")) // Option.some(\"a\")\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n * ```\n *\n * @category Option transformations\n * @since 3.10.0\n */\nexport class OptionFromNonEmptyTrimmedString extends transform(String$, OptionFromSelf(NonEmptyTrimmedString), {\n  strict: true,\n  decode: (i) => option_.filter(option_.some(i.trim()), string_.isNonEmpty),\n  encode: (a) => option_.getOrElse(a, () => \"\")\n}) {}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type RightEncoded<IA> = {\n  readonly _tag: \"Right\"\n  readonly right: IA\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type LeftEncoded<IE> = {\n  readonly _tag: \"Left\"\n  readonly left: IE\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>\n\nconst rightEncoded = <Right extends Schema.All>(right: Right) =>\n  Struct({\n    _tag: Literal(\"Right\"),\n    right\n  }).annotations({ description: `RightEncoded<${format(right)}>` })\n\nconst leftEncoded = <Left extends Schema.All>(left: Left) =>\n  Struct({\n    _tag: Literal(\"Left\"),\n    left\n  }).annotations({ description: `LeftEncoded<${format(left)}>` })\n\nconst eitherEncoded = <Right extends Schema.All, Left extends Schema.All>(\n  right: Right,\n  left: Left\n) =>\n  Union(rightEncoded(right), leftEncoded(left)).annotations({\n    description: `EitherEncoded<${format(left)}, ${format(right)}>`\n  })\n\nconst eitherDecode = <R, L>(input: EitherEncoded<R, L>): either_.Either<R, L> =>\n  input._tag === \"Left\" ? either_.left(input.left) : either_.right(input.right)\n\nconst eitherArbitrary = <R, L>(\n  right: LazyArbitrary<R>,\n  left: LazyArbitrary<L>\n): LazyArbitrary<either_.Either<R, L>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Left\" as const), left: left(fc) }),\n    fc.record({ _tag: fc.constant(\"Right\" as const), right: right(fc) })\n  ).map(eitherDecode)\n\nconst eitherPretty = <R, L>(\n  right: pretty_.Pretty<R>,\n  left: pretty_.Pretty<L>\n): pretty_.Pretty<either_.Either<R, L>> =>\n  either_.match({\n    onLeft: (e) => `left(${left(e)})`,\n    onRight: (a) => `right(${right(a)})`\n  })\n\nconst eitherParse = <RR, R, LR, L>(\n  parseRight: ParseResult.DecodeUnknown<R, RR>,\n  decodeUnknownLeft: ParseResult.DecodeUnknown<L, LR>\n): ParseResult.DeclarationDecodeUnknown<either_.Either<R, L>, LR | RR> =>\n(u, options, ast) =>\n  either_.isEither(u) ?\n    either_.match(u, {\n      onLeft: (left) => toComposite(decodeUnknownLeft(left, options), either_.left, ast, u),\n      onRight: (right) => toComposite(parseRight(right, options), either_.right, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromSelf<R extends Schema.All, L extends Schema.All> extends\n  AnnotableDeclare<\n    EitherFromSelf<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,\n    [R, L]\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromSelf = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromSelf<R, L> => {\n  return declare(\n    [right, left],\n    {\n      decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),\n      encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))\n    },\n    {\n      typeConstructor: { _tag: \"effect/Either\" },\n      description: `Either<${format(right)}, ${format(left)}>`,\n      pretty: eitherPretty,\n      arbitrary: eitherArbitrary,\n      equivalence: (right, left) => either_.getEquivalence({ left, right })\n    }\n  )\n}\n\nconst makeLeftEncoded = <E>(left: E) => (({\n  _tag: \"Left\",\n  left\n}) as const)\nconst makeRightEncoded = <A>(right: A) => (({\n  _tag: \"Right\",\n  right\n}) as const)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Either<Right extends Schema.All, Left extends Schema.All> extends\n  transform<\n    Union<[\n      Struct<{\n        _tag: Literal<[\"Right\"]>\n        right: Right\n      }>,\n      Struct<{\n        _tag: Literal<[\"Left\"]>\n        left: Left\n      }>\n    ]>,\n    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const Either = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): Either<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  const out = transform(\n    eitherEncoded(right_, left_),\n    EitherFromSelf({ left: typeSchema(left_), right: typeSchema(right_) }),\n    {\n      strict: true,\n      decode: (i) => eitherDecode(i),\n      encode: (a) =>\n        either_.match(a, {\n          onLeft: makeLeftEncoded,\n          onRight: makeRightEncoded\n        })\n    }\n  )\n  return out as any\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromUnion<Right extends Schema.All, Left extends Schema.All> extends\n  transform<\n    Union<[\n      transform<Right, Struct<{ _tag: Literal<[\"Right\"]>; right: SchemaClass<Schema.Type<Right>> }>>,\n      transform<Left, Struct<{ _tag: Literal<[\"Left\"]>; right: SchemaClass<Schema.Type<Left>> }>>\n    ]>,\n    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>\n  >\n{}\n\n/**\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * // Schema<string | number, Either<string, number>>\n * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })\n * ```\n *\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromUnion = <Right extends Schema.All, Left extends Schema.All>({ left, right }: {\n  readonly left: Left\n  readonly right: Right\n}): EitherFromUnion<Right, Left> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  const toright = typeSchema(right_)\n  const toleft = typeSchema(left_)\n  const fromRight = transform(right_, rightEncoded(toright), {\n    strict: true,\n    decode: (i) => makeRightEncoded(i),\n    encode: (a) => a.right\n  })\n  const fromLeft = transform(left_, leftEncoded(toleft), {\n    strict: true,\n    decode: (i) => makeLeftEncoded(i),\n    encode: (a) => a.left\n  })\n  const out = transform(\n    Union(fromRight, fromLeft),\n    EitherFromSelf({ left: toleft, right: toright }),\n    {\n      strict: true,\n      decode: (i) => i._tag === \"Left\" ? either_.left(i.left) : either_.right(i.right),\n      encode: (a) =>\n        either_.match(a, {\n          onLeft: makeLeftEncoded,\n          onRight: makeRightEncoded\n        })\n    }\n  )\n  return out as any\n}\n\nconst mapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<Map<K, V>> => {\n  return (fc) => {\n    const items = fc.array(fc.tuple(key(fc), value(fc)))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Map(as))\n  }\n}\n\nconst readonlyMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<ReadonlyMap<K, V>> =>\n(map) =>\n  `new Map([${\n    Array.from(map.entries())\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst readonlyMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<ReadonlyMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())))\n}\n\nconst readonlyMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlyMap<K, V>, R> =>\n(u, options, ast) =>\n  Predicate.isMap(u) ?\n    toComposite(decodeUnknown(Array.from(u.entries()), options), (as) => new Map(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    ReadonlyMapFromSelf<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}\n\nconst mapFromSelf_ = <K extends Schema.Any, V extends Schema.Any>(\n  key: K,\n  value: V,\n  description: string\n): ReadonlyMapFromSelf<K, V> =>\n  declare(\n    [key, value],\n    {\n      decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown(Array$(Tuple(Key, Value)))),\n      encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown(Array$(Tuple(Key, Value))))\n    },\n    {\n      typeConstructor: { _tag: \"ReadonlyMap\" },\n      description,\n      pretty: readonlyMapPretty,\n      arbitrary: mapArbitrary,\n      equivalence: readonlyMapEquivalence\n    }\n  )\n\n/**\n * @category ReadonlyMap\n * @since 3.10.0\n */\nexport const ReadonlyMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMapFromSelf<K, V> => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    MapFromSelf<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}\n\n/**\n * @category Map\n * @since 3.10.0\n */\nexport const MapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): MapFromSelf<K, V> => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, ReadonlyMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport function ReadonlyMap<K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMap$<K, V> {\n  return transform(\n    Array$(Tuple(key, value)),\n    ReadonlyMapFromSelf({ key: typeSchema(asSchema(key)), value: typeSchema(asSchema(value)) }),\n    {\n      strict: true,\n      decode: (i) => new Map(i),\n      encode: (a) => Array.from(a.entries())\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Map$<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, MapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}\n\n/** @ignore */\nfunction map<K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): Map$<K, V> {\n  return transform(\n    Array$(Tuple(key, value)),\n    MapFromSelf({ key: typeSchema(asSchema(key)), value: typeSchema(asSchema(value)) }),\n    {\n      strict: true,\n      decode: (i) => new Map(i),\n      encode: (a) => Array.from(a.entries())\n    }\n  )\n}\n\nexport {\n  /**\n   * @category Map transformations\n   * @since 3.10.0\n   */\n  map as Map\n}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport const ReadonlyMapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): SchemaClass<ReadonlyMap<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record to be decoded into a ReadonlyMap\"\n    }),\n    ReadonlyMapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (i) => new Map(Object.entries(i)),\n      encode: (a) => Object.fromEntries(a)\n    }\n  )\n\n/**\n * @category Map transformations\n * @since 3.10.0\n */\nexport const MapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): SchemaClass<Map<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record to be decoded into a Map\"\n    }),\n    MapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (i) => new Map(Object.entries(i)),\n      encode: (a) => Object.fromEntries(a)\n    }\n  )\n\nconst setArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<ReadonlySet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Set(as))\n  }\n\nconst readonlySetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<ReadonlySet<A>> => (set) =>\n  `new Set([${Array.from(set.values()).map((a) => item(a)).join(\", \")}])`\n\nconst readonlySetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<ReadonlySet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())))\n}\n\nconst readonlySetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlySet<A>, R> =>\n(u, options, ast) =>\n  Predicate.isSet(u) ?\n    toComposite(decodeUnknown(Array.from(u.values()), options), (as) => new Set(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ReadonlySetFromSelf<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\nconst setFromSelf_ = <Value extends Schema.Any>(value: Value, description: string): ReadonlySetFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (item) => readonlySetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => readonlySetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      typeConstructor: { _tag: \"ReadonlySet\" },\n      description,\n      pretty: readonlySetPretty,\n      arbitrary: setArbitrary,\n      equivalence: readonlySetEquivalence\n    }\n  )\n\n/**\n * @category ReadonlySet\n * @since 3.10.0\n */\nexport const ReadonlySetFromSelf = <Value extends Schema.Any>(value: Value): ReadonlySetFromSelf<Value> =>\n  setFromSelf_(value, `ReadonlySet<${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    SetFromSelf<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category Set\n * @since 3.10.0\n */\nexport const SetFromSelf = <Value extends Schema.Any>(value: Value): SetFromSelf<Value> =>\n  setFromSelf_(value, `Set<${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySet$<Value extends Schema.Any>\n  extends transform<Array$<Value>, ReadonlySetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category ReadonlySet transformations\n * @since 3.10.0\n */\nexport function ReadonlySet<Value extends Schema.Any>(value: Value): ReadonlySet$<Value> {\n  return transform(\n    Array$(value),\n    ReadonlySetFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => new Set(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Set$<Value extends Schema.Any>\n  extends transform<Array$<Value>, SetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/** @ignore */\nfunction set<Value extends Schema.Any>(value: Value): Set$<Value> {\n  return transform(\n    Array$(value),\n    SetFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => new Set(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\nexport {\n  /**\n   * @category Set transformations\n   * @since 3.10.0\n   */\n  set as Set\n}\n\nconst bigDecimalPretty = (): pretty_.Pretty<bigDecimal_.BigDecimal> => (val) =>\n  `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`\n\nconst bigDecimalArbitrary = (): LazyArbitrary<bigDecimal_.BigDecimal> => (fc) =>\n  fc.tuple(fc.bigInt(), fc.integer({ min: -18, max: 18 }))\n    .map(([value, scale]) => bigDecimal_.make(value, scale))\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport class BigDecimalFromSelf extends declare(\n  bigDecimal_.isBigDecimal,\n  {\n    typeConstructor: { _tag: \"effect/BigDecimal\" },\n    identifier: \"BigDecimalFromSelf\",\n    pretty: bigDecimalPretty,\n    arbitrary: bigDecimalArbitrary,\n    equivalence: () => bigDecimal_.Equivalence\n  }\n) {}\n\n/**\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimal extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      bigDecimal_.fromString(i).pipe(option_.match({\n        onNone: () =>\n          ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),\n        onSome: (val) => ParseResult.succeed(bigDecimal_.normalize(val))\n      })),\n    encode: (a) => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(a)))\n  }\n).annotations({ identifier: \"BigDecimal\" }) {}\n\n/**\n * A schema that transforms a `number` into a `BigDecimal`.\n * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimalFromNumber extends transform(\n  Number$.annotations({ description: \"a number to be decoded into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (i) => bigDecimal_.unsafeFromNumber(i),\n    encode: (a) => bigDecimal_.unsafeToNumber(a)\n  }\n).annotations({ identifier: \"BigDecimalFromNumber\" }) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanBigDecimal =\n  <S extends Schema.Any>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n    const formatted = bigDecimal_.format(min)\n    return self.pipe(\n      filter((a) => bigDecimal_.greaterThan(a, min), {\n        schemaId: GreaterThanBigDecimalSchemaId,\n        [GreaterThanBigDecimalSchemaId]: { min },\n        title: `greaterThanBigDecimal(${formatted})`,\n        description: `a BigDecimal greater than ${formatted}`,\n        ...annotations\n      })\n    )\n  }\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigDecimal =\n  <S extends Schema.Any>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n    const formatted = bigDecimal_.format(min)\n    return self.pipe(\n      filter((a) => bigDecimal_.greaterThanOrEqualTo(a, min), {\n        schemaId: GreaterThanOrEqualToBigDecimalSchemaId,\n        [GreaterThanOrEqualToBigDecimalSchemaId]: { min },\n        title: `greaterThanOrEqualToBigDecimal(${formatted})`,\n        description: `a BigDecimal greater than or equal to ${formatted}`,\n        ...annotations\n      })\n    )\n  }\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanBigDecimal =\n  <S extends Schema.Any>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n    const formatted = bigDecimal_.format(max)\n    return self.pipe(\n      filter((a) => bigDecimal_.lessThan(a, max), {\n        schemaId: LessThanBigDecimalSchemaId,\n        [LessThanBigDecimalSchemaId]: { max },\n        title: `lessThanBigDecimal(${formatted})`,\n        description: `a BigDecimal less than ${formatted}`,\n        ...annotations\n      })\n    )\n  }\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigDecimal =\n  <S extends Schema.Any>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n    const formatted = bigDecimal_.format(max)\n    return self.pipe(\n      filter((a) => bigDecimal_.lessThanOrEqualTo(a, max), {\n        schemaId: LessThanOrEqualToBigDecimalSchemaId,\n        [LessThanOrEqualToBigDecimalSchemaId]: { max },\n        title: `lessThanOrEqualToBigDecimal(${formatted})`,\n        description: `a BigDecimal less than or equal to ${formatted}`,\n        ...annotations\n      })\n    )\n  }\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/PositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const positiveBigDecimal =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => bigDecimal_.isPositive(a), {\n        schemaId: PositiveBigDecimalSchemaId,\n        title: \"positiveBigDecimal\",\n        description: `a positive BigDecimal`,\n        ...annotations\n      })\n    )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  positiveBigDecimal({ identifier: \"PositiveBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonNegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonNegativeBigDecimal =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a.value >= 0n, {\n        schemaId: NonNegativeBigDecimalSchemaId,\n        title: \"nonNegativeBigDecimal\",\n        description: `a non-negative BigDecimal`,\n        ...annotations\n      })\n    )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonNegativeBigDecimal({ identifier: \"NonNegativeBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const negativeBigDecimal =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => bigDecimal_.isNegative(a), {\n        schemaId: NegativeBigDecimalSchemaId,\n        title: \"negativeBigDecimal\",\n        description: `a negative BigDecimal`,\n        ...annotations\n      })\n    )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  negativeBigDecimal({ identifier: \"NegativeBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonPositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonPositiveBigDecimal =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a.value <= 0n, {\n        schemaId: NonPositiveBigDecimalSchemaId,\n        title: \"nonPositiveBigDecimal\",\n        description: `a non-positive BigDecimal`,\n        ...annotations\n      })\n    )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonPositiveBigDecimal({ identifier: \"NonPositiveBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const betweenBigDecimal = <S extends Schema.Any>(\n  minimum: bigDecimal_.BigDecimal,\n  maximum: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const formattedMinimum = bigDecimal_.format(minimum)\n  const formattedMaximum = bigDecimal_.format(maximum)\n  return self.pipe(\n    filter((a) => bigDecimal_.between(a, { minimum, maximum }), {\n      schemaId: BetweenBigDecimalSchemaId,\n      [BetweenBigDecimalSchemaId]: { maximum, minimum },\n      title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,\n      description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,\n      ...annotations\n    })\n  )\n}\n\n/**\n * Clamps a `BigDecimal` between a minimum and a maximum value.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport const clampBigDecimal =\n  (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) =>\n  <S extends Schema.Any, A extends bigDecimal_.BigDecimal>(\n    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n  ): transform<S, filter<SchemaClass<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)),\n      {\n        strict: false,\n        decode: (i) => bigDecimal_.clamp(i, { minimum, maximum }),\n        encode: identity\n      }\n    )\n\nconst chunkArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<chunk_.Chunk<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(chunk_.fromIterable)\n  }\n\nconst chunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.Chunk<A>> => (c) =>\n  `Chunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst chunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.Chunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) ?\n    chunk_.isEmpty(u) ?\n      ParseResult.succeed(chunk_.empty())\n      : toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ChunkFromSelf<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    chunk_.Chunk<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const ChunkFromSelf = <Value extends Schema.Any>(value: Value): ChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => chunkParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => chunkParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      typeConstructor: { _tag: \"effect/Chunk\" },\n      description: `Chunk<${format(value)}>`,\n      pretty: chunkPretty,\n      arbitrary: chunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Chunk<Value extends Schema.Any>\n  extends transform<Array$<Value>, ChunkFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport function Chunk<Value extends Schema.Any>(value: Value): Chunk<Value> {\n  return transform(\n    Array$(value),\n    ChunkFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => i.length === 0 ? chunk_.empty() : chunk_.fromIterable(i),\n      encode: (a) => chunk_.toReadonlyArray(a)\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    NonEmptyChunkFromSelf<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    chunk_.NonEmptyChunk<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\nconst nonEmptyChunkArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<chunk_.NonEmptyChunk<A>> => (fc) =>\n  fastCheck_.array(item(fc), { minLength: 1 }).map((as) => chunk_.unsafeFromNonEmptyArray(as as any))\n\nconst nonEmptyChunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.NonEmptyChunk<A>> => (c) =>\n  `NonEmptyChunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst nonEmptyChunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<array_.NonEmptyReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.NonEmptyChunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) && chunk_.isNonEmpty(u)\n    ? toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.unsafeFromNonEmptyArray, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const NonEmptyChunkFromSelf = <Value extends Schema.Any>(value: Value): NonEmptyChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => nonEmptyChunkParse(ParseResult.decodeUnknown(NonEmptyArray(item))),\n      encode: (item) => nonEmptyChunkParse(ParseResult.encodeUnknown(NonEmptyArray(item)))\n    },\n    {\n      typeConstructor: { _tag: \"effect/Chunk.NonEmptyChunk\" },\n      description: `NonEmptyChunk<${format(value)}>`,\n      pretty: nonEmptyChunkPretty,\n      arbitrary: nonEmptyChunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunk<Value extends Schema.Any>\n  extends transform<NonEmptyArray<Value>, NonEmptyChunkFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport function NonEmptyChunk<Value extends Schema.Any>(value: Value): NonEmptyChunk<Value> {\n  return transform(\n    NonEmptyArray(value),\n    NonEmptyChunkFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => chunk_.unsafeFromNonEmptyArray(i),\n      encode: (a) => chunk_.toReadonlyArray(a)\n    }\n  )\n}\n\nconst decodeData = <A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(a: A): A =>\n  Array.isArray(a) ? data_.array(a) : data_.struct(a)\n\nconst dataArbitrary = <A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(\n  item: LazyArbitrary<A>\n): LazyArbitrary<A> =>\n(fc) => item(fc).map(decodeData)\n\nconst dataPretty = <A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(\n  item: pretty_.Pretty<A>\n): pretty_.Pretty<A> =>\n(d) => `Data(${item(d)})`\n\nconst dataParse = <R, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<A, R> =>\n(u, options, ast) =>\n  Equal.isEqual(u) ?\n    toComposite(decodeUnknown(u, options), decodeData, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface DataFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    DataFromSelf<Value>,\n    Schema.Type<Value>,\n    Schema.Encoded<Value>,\n    [Value]\n  >\n{}\n\n/**\n * Type and Encoded must extend `Readonly<Record<string, any>> |\n * ReadonlyArray<any>` to be compatible with this API.\n *\n * @category Data transformations\n * @since 3.10.0\n */\nexport const DataFromSelf = <\n  S extends Schema.Any,\n  A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>,\n  I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>\n>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>): DataFromSelf<S> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => dataParse(ParseResult.decodeUnknown(item)),\n      encode: (item) => dataParse(ParseResult.encodeUnknown(item))\n    },\n    {\n      description: `Data<${format(value)}>`,\n      pretty: dataPretty,\n      arbitrary: dataArbitrary\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface Data<Value extends Schema.Any>\n  extends transform<Value, DataFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * Type and Encoded must extend `Readonly<Record<string, any>> |\n * ReadonlyArray<any>` to be compatible with this API.\n *\n * @category Data transformations\n * @since 3.10.0\n */\nexport const Data = <\n  S extends Schema.Any,\n  A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>,\n  I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>\n>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>): Data<S> => {\n  return transform(\n    value,\n    DataFromSelf(typeSchema(value)),\n    {\n      strict: false,\n      decode: (i) => decodeData(i),\n      encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)\n    }\n  )\n}\n\ntype MissingSelfGeneric<Usage extends string, Params extends string = \"\"> =\n  `Missing \\`Self\\` generic - use \\`class Self extends ${Usage}<Self>()(${Params}{ ... })\\``\n\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\n\ntype ClassAnnotations<Self, A> =\n  | Annotations.Schema<Self>\n  | readonly [\n    // Annotations for the \"to\" schema\n    Annotations.Schema<Self> | undefined,\n    // Annotations for the \"transformation schema\n    (Annotations.Schema<Self> | undefined)?,\n    // Annotations for the \"from\" schema\n    Annotations.Schema<A>?\n  ]\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto>\n  extends Schema<Self, Simplify<I>, R>\n{\n  new(\n    props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>,\n    options?: MakeOptions\n  ): Struct.Type<Fields> & Inherited & Proto\n\n  /** @since 3.10.0 */\n  readonly ast: AST.Transformation\n\n  make<C extends new(...args: Array<any>) => any>(this: C, ...args: ConstructorParameters<C>): InstanceType<C>\n\n  annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>\n\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n\n  readonly identifier: string\n\n  /**\n   * @example\n   * ```ts\n   * import { Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *  myField: Schema.String\n   * }) {\n   *  myMethod() {\n   *    return this.myField + \"my\"\n   *  }\n   * }\n   *\n   * class NextClass extends MyClass.extend<NextClass>(\"NextClass\")({\n   *  nextField: Schema.Number\n   * }) {\n   *  nextMethod() {\n   *    return this.myMethod() + this.myField + this.nextField\n   *  }\n   * }\n   * ```\n   */\n  extend<Extended = never>(identifier: string): <NewFields extends Struct.Fields>(\n    fields: NewFields | HasFields<NewFields>,\n    annotations?: ClassAnnotations<Extended, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Extended] extends [never] ? MissingSelfGeneric<\"Base.extend\">\n    : Class<\n      Extended,\n      Fields & NewFields,\n      I & Struct.Encoded<NewFields>,\n      R | Struct.Context<NewFields>,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFail<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFail<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<Struct.Type<Fields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<Struct.Type<Fields & NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<Struct.Type<Fields & NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFail\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFailFrom<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFailFrom<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<I>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<I & Struct.Encoded<NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<I & Struct.Encoded<NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFailFrom\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n}\n\ntype HasFields<Fields extends Struct.Fields> = Struct<Fields> | {\n  readonly [RefineSchemaId]: HasFields<Fields>\n}\n\nconst isField = (u: unknown) => isSchema(u) || isPropertySignature(u)\n\nconst isFields = <Fields extends Struct.Fields>(fields: object): fields is Fields =>\n  Reflect.ownKeys(fields).every((key) => isField((fields as any)[key]))\n\nconst getFields = <Fields extends Struct.Fields>(hasFields: HasFields<Fields>): Fields =>\n  \"fields\" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId])\n\nconst getSchemaFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Schema.Any =>\n  isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr))\n\nconst getFieldsFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Fields =>\n  isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr)\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n *  someField: Schema.String\n * }) {\n *  someMethod() {\n *    return this.someField + \"bar\"\n *  }\n * }\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const Class = <Self = never>(identifier: string) =>\n<Fields extends Struct.Fields>(\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: ClassAnnotations<Self, Simplify<Struct.Type<Fields>>>\n): [Self] extends [never] ? MissingSelfGeneric<\"Class\">\n  : Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Fields>,\n    {},\n    {}\n  > =>\n  makeClass({\n    kind: \"Class\",\n    identifier,\n    schema: getSchemaFromFieldsOr(fieldsOr),\n    fields: getFieldsFromFieldsOr(fieldsOr),\n    Base: data_.Class,\n    annotations\n  })\n\n/** @internal */\nexport const getClassTag = <Tag extends string>(tag: Tag) =>\n  withConstructorDefault(propertySignature(Literal(tag)), () => tag)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    {}\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyClass extends Schema.TaggedClass<MyClass>(\"MyClass\")(\"MyClass\", {\n *  a: Schema.String\n * }) {}\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedClass = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag> } & Fields>>>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedClass\", `\"Tag\", `>\n  : TaggedClass<Self, Tag, { readonly _tag: tag<Tag> } & Fields> =>\n{\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedClass extends makeClass({\n    kind: \"TaggedClass\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base: data_.Class,\n    annotations\n  }) {\n    static _tag = tag\n  } as any\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    cause_.YieldableError\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyError extends Schema.TaggedError<MyError>(\"MyError\")(\n *   \"MyError\",\n *   {\n *     module: Schema.String,\n *     method: Schema.String,\n *     description: Schema.String\n *   }\n * ) {\n *   get message(): string {\n *     return `${this.module}.${this.method}: ${this.description}`\n *   }\n * }\n * ```\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedError = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag> } & Fields>>>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedError\", `\"Tag\", `>\n  : TaggedErrorClass<\n    Self,\n    Tag,\n    { readonly _tag: tag<Tag> } & Fields\n  > =>\n{\n  class Base extends data_.Error {}\n  ;(Base.prototype as any).name = tag\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  const hasMessageField = \"message\" in taggedFields\n  class TaggedErrorClass extends makeClass({\n    kind: \"TaggedError\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base,\n    annotations,\n    disableToString: true\n  }) {\n    static _tag = tag\n  }\n\n  if (!hasMessageField) {\n    Object.defineProperty(TaggedErrorClass.prototype, \"message\", {\n      get() {\n        return `{ ${\n          Reflect.ownKeys(fields)\n            .map((p: any) => `${Inspectable.formatPropertyKey(p)}: ${Inspectable.formatUnknown((this)[p])}`)\n            .join(\", \")\n        } }`\n      },\n      enumerable: false, // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable\n      configurable: true\n    })\n  }\n\n  return TaggedErrorClass as any\n}\n\nconst extendFields = (a: Struct.Fields, b: Struct.Fields): Struct.Fields => {\n  const out = { ...a }\n  for (const key of Reflect.ownKeys(b)) {\n    if (key in a) {\n      throw new Error(errors_.getASTDuplicatePropertySignatureErrorMessage(key))\n    }\n    out[key] = b[key]\n  }\n  return out\n}\n\n/**\n * @category Constructor utils\n * @since 3.13.4\n */\nexport type MakeOptions = boolean | {\n  readonly disableValidation?: boolean | undefined\n}\n\nfunction getDisableValidationMakeOption(options: MakeOptions | undefined): boolean {\n  return Predicate.isBoolean(options) ? options : options?.disableValidation ?? false\n}\n\nconst astCache = globalValue(\"effect/Schema/astCache\", () => new WeakMap<any, AST.AST>())\n\nconst getClassAnnotations = <Self, A>(\n  annotations: ClassAnnotations<Self, A> | undefined\n): [Annotations.Schema<Self>?, Annotations.Schema<Self>?, Annotations.Schema<A>?] => {\n  if (annotations === undefined) {\n    return []\n  } else if (Array.isArray(annotations)) {\n    return annotations as any\n  } else {\n    return [annotations] as any\n  }\n}\n\nconst makeClass = <Fields extends Struct.Fields>(\n  { Base, annotations, disableToString, fields, identifier, kind, schema }: {\n    kind: \"Class\" | \"TaggedClass\" | \"TaggedError\" | \"TaggedRequest\"\n    identifier: string\n    schema: Schema.Any\n    fields: Fields\n    Base: new(...args: ReadonlyArray<any>) => any\n    annotations?: ClassAnnotations<any, any> | undefined\n    disableToString?: boolean | undefined\n  }\n): any => {\n  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier}`)\n\n  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations)\n\n  const typeSchema_ = typeSchema(schema)\n\n  const declarationSurrogate = typeSchema_.annotations({\n    identifier,\n    ...typeAnnotations\n  })\n\n  const typeSide = typeSchema_.annotations({\n    [AST.AutoTitleAnnotationId]: `${identifier} (Type side)`,\n    ...typeAnnotations\n  })\n\n  const constructorSchema = schema.annotations({\n    [AST.AutoTitleAnnotationId]: `${identifier} (Constructor)`,\n    ...typeAnnotations\n  })\n\n  const encodedSide = schema.annotations({\n    [AST.AutoTitleAnnotationId]: `${identifier} (Encoded side)`,\n    ...encodedAnnotations\n  })\n\n  const transformationSurrogate = schema.annotations({\n    ...encodedAnnotations,\n    ...typeAnnotations,\n    ...transformationAnnotations\n  })\n\n  const fallbackInstanceOf = (u: unknown) => Predicate.hasProperty(u, classSymbol) && ParseResult.is(typeSide)(u)\n\n  const klass = class extends Base {\n    constructor(\n      props: { [x: string | symbol]: unknown } = {},\n      options: MakeOptions = false\n    ) {\n      props = { ...props }\n      if (kind !== \"Class\") {\n        delete props[\"_tag\"]\n      }\n      props = lazilyMergeDefaults(fields, props)\n      if (!getDisableValidationMakeOption(options)) {\n        props = ParseResult.validateSync(constructorSchema)(props)\n      }\n      super(props, true)\n    }\n\n    // ----------------\n    // Schema interface\n    // ----------------\n\n    static [TypeId] = variance\n\n    static get ast(): AST.AST {\n      let out = astCache.get(this)\n      if (out) {\n        return out\n      }\n\n      const declaration: Schema.Any = declare(\n        [schema],\n        {\n          decode: () => (input, _, ast) =>\n            input instanceof this || fallbackInstanceOf(input)\n              ? ParseResult.succeed(input)\n              : ParseResult.fail(new ParseResult.Type(ast, input)),\n          encode: () => (input, options) =>\n            input instanceof this\n              ? ParseResult.succeed(input)\n              : ParseResult.map(\n                ParseResult.encodeUnknown(typeSide)(input, options),\n                (props) => new this(props, true)\n              )\n        },\n        {\n          identifier,\n          pretty: (pretty) => (self: any) => `${identifier}(${pretty(self)})`,\n          // @ts-expect-error\n          arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),\n          equivalence: identity,\n          [AST.SurrogateAnnotationId]: declarationSurrogate.ast,\n          ...typeAnnotations\n        }\n      )\n\n      out = transform(\n        encodedSide,\n        declaration,\n        {\n          strict: true,\n          decode: (i) => new this(i, true),\n          encode: identity\n        }\n      ).annotations({\n        [AST.SurrogateAnnotationId]: transformationSurrogate.ast,\n        ...transformationAnnotations\n      }).ast\n\n      astCache.set(this, out)\n\n      return out\n    }\n\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n\n    static annotations(annotations: Annotations.Schema<any>) {\n      return make(this.ast).annotations(annotations)\n    }\n\n    static toString() {\n      return `(${String(encodedSide)} <-> ${identifier})`\n    }\n\n    // ----------------\n    // Class interface\n    // ----------------\n\n    static make(...args: Array<any>) {\n      return new this(...args)\n    }\n\n    static fields = { ...fields }\n\n    static identifier = identifier\n\n    static extend<Extended, NewFields extends Struct.Fields>(identifier: string) {\n      return (\n        newFieldsOr: NewFields | HasFields<NewFields>,\n        annotations?: ClassAnnotations<Extended, Simplify<Struct.Type<Fields & NewFields>>>\n      ) => {\n        const newFields = getFieldsFromFieldsOr(newFieldsOr)\n        const newSchema = getSchemaFromFieldsOr(newFieldsOr)\n        const extendedFields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: extend(schema, newSchema),\n          fields: extendedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFail<Transformed, NewFields extends Struct.Fields>(identifier: string) {\n      return (\n        newFieldsOr: NewFields,\n        options: any,\n        annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n      ) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFieldsOr)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            schema,\n            typeSchema(Struct(transformedFields)),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFailFrom<Transformed, NewFields extends Struct.Fields>(identifier: string) {\n      return (\n        newFields: NewFields,\n        options: any,\n        annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n      ) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            encodedSchema(schema),\n            Struct(transformedFields),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    // ----------------\n    // other\n    // ----------------\n\n    get [classSymbol]() {\n      return classSymbol\n    }\n  }\n  if (disableToString !== true) {\n    Object.defineProperty(klass.prototype, \"toString\", {\n      value() {\n        return `${identifier}({ ${\n          Reflect.ownKeys(fields).map((p: any) =>\n            `${Inspectable.formatPropertyKey(p)}: ${Inspectable.formatUnknown(this[p])}`\n          )\n            .join(\", \")\n        } })`\n      },\n      configurable: true,\n      writable: true\n    })\n  }\n  return klass\n}\n\n/**\n * @category FiberId\n * @since 3.10.0\n */\nexport type FiberIdEncoded =\n  | {\n    readonly _tag: \"Composite\"\n    readonly left: FiberIdEncoded\n    readonly right: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Runtime\"\n    readonly id: number\n    readonly startTimeMillis: number\n  }\n\nconst FiberIdNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ identifier: \"FiberIdNoneEncoded\" })\n\nconst FiberIdRuntimeEncoded = Struct({\n  _tag: Literal(\"Runtime\"),\n  id: Int,\n  startTimeMillis: Int\n}).annotations({ identifier: \"FiberIdRuntimeEncoded\" })\n\nconst FiberIdCompositeEncoded = Struct({\n  _tag: Literal(\"Composite\"),\n  left: suspend(() => FiberIdEncoded),\n  right: suspend(() => FiberIdEncoded)\n}).annotations({ identifier: \"FiberIdCompositeEncoded\" })\n\nconst FiberIdEncoded: Schema<FiberIdEncoded> = Union(\n  FiberIdNoneEncoded,\n  FiberIdRuntimeEncoded,\n  FiberIdCompositeEncoded\n).annotations({ identifier: \"FiberIdEncoded\" })\n\nconst fiberIdArbitrary: LazyArbitrary<fiberId_.FiberId> = (fc) =>\n  fc.letrec((tie) => ({\n    None: fc.record({ _tag: fc.constant(\"None\" as const) }),\n    Runtime: fc.record({ _tag: fc.constant(\"Runtime\" as const), id: fc.integer(), startTimeMillis: fc.integer() }),\n    Composite: fc.record({ _tag: fc.constant(\"Composite\" as const), left: tie(\"FiberId\"), right: tie(\"FiberId\") }),\n    FiberId: fc.oneof(tie(\"None\"), tie(\"Runtime\"), tie(\"Composite\")) as any as fastCheck_.Arbitrary<fiberId_.FiberId>\n  })).FiberId.map(fiberIdDecode)\n\nconst fiberIdPretty: pretty_.Pretty<fiberId_.FiberId> = (fiberId) => {\n  switch (fiberId._tag) {\n    case \"None\":\n      return \"FiberId.none\"\n    case \"Runtime\":\n      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`\n    case \"Composite\":\n      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`\n  }\n}\n\n/**\n * @category FiberId constructors\n * @since 3.10.0\n */\nexport class FiberIdFromSelf extends declare(\n  fiberId_.isFiberId,\n  {\n    typeConstructor: { _tag: \"effect/FiberId\" },\n    identifier: \"FiberIdFromSelf\",\n    pretty: () => fiberIdPretty,\n    arbitrary: () => fiberIdArbitrary\n  }\n) {}\n\nconst fiberIdDecode = (input: FiberIdEncoded): fiberId_.FiberId => {\n  switch (input._tag) {\n    case \"None\":\n      return fiberId_.none\n    case \"Runtime\":\n      return fiberId_.runtime(input.id, input.startTimeMillis)\n    case \"Composite\":\n      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right))\n  }\n}\n\nconst fiberIdEncode = (input: fiberId_.FiberId): FiberIdEncoded => {\n  switch (input._tag) {\n    case \"None\":\n      return { _tag: \"None\" }\n    case \"Runtime\":\n      return { _tag: \"Runtime\", id: input.id, startTimeMillis: input.startTimeMillis }\n    case \"Composite\":\n      return {\n        _tag: \"Composite\",\n        left: fiberIdEncode(input.left),\n        right: fiberIdEncode(input.right)\n      }\n  }\n}\n\n/**\n * @category FiberId transformations\n * @since 3.10.0\n */\nexport class FiberId extends transform(\n  FiberIdEncoded,\n  FiberIdFromSelf,\n  {\n    strict: true,\n    decode: (i) => fiberIdDecode(i),\n    encode: (a) => fiberIdEncode(a)\n  }\n).annotations({ identifier: \"FiberId\" }) {}\n\n/**\n * @category Cause utils\n * @since 3.10.0\n */\nexport type CauseEncoded<E, D> =\n  | {\n    readonly _tag: \"Empty\"\n  }\n  | {\n    readonly _tag: \"Fail\"\n    readonly error: E\n  }\n  | {\n    readonly _tag: \"Die\"\n    readonly defect: D\n  }\n  | {\n    readonly _tag: \"Interrupt\"\n    readonly fiberId: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"Sequential\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Parallel\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n\nconst causeDieEncoded = <Defect extends Schema.Any>(defect: Defect) =>\n  Struct({\n    _tag: Literal(\"Die\"),\n    defect\n  })\n\nconst CauseEmptyEncoded = Struct({\n  _tag: Literal(\"Empty\")\n})\n\nconst causeFailEncoded = <E extends Schema.Any>(error: E) =>\n  Struct({\n    _tag: Literal(\"Fail\"),\n    error\n  })\n\nconst CauseInterruptEncoded = Struct({\n  _tag: Literal(\"Interrupt\"),\n  fiberId: FiberIdEncoded\n})\n\nlet causeEncodedId = 0\n\nconst causeEncoded = <E extends Schema.All, D extends Schema.All>(\n  error: E,\n  defect: D\n): SchemaClass<\n  CauseEncoded<Schema.Type<E>, Schema.Type<D>>,\n  CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n  Schema.Context<E> | Schema.Context<D>\n> => {\n  const error_ = asSchema(error)\n  const defect_ = asSchema(defect)\n  const suspended = suspend((): Schema<\n    CauseEncoded<Schema.Type<E>, Schema.Type<D>>,\n    CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n    Schema.Context<E> | Schema.Context<D>\n  > => out)\n  const out = Union(\n    CauseEmptyEncoded,\n    causeFailEncoded(error_),\n    causeDieEncoded(defect_),\n    CauseInterruptEncoded,\n    Struct({\n      _tag: Literal(\"Sequential\"),\n      left: suspended,\n      right: suspended\n    }),\n    Struct({\n      _tag: Literal(\"Parallel\"),\n      left: suspended,\n      right: suspended\n    })\n  ).annotations({\n    title: `CauseEncoded<${format(error)}>`,\n    [AST.JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`\n  })\n  return out\n}\n\nconst causeArbitrary = <E>(\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<cause_.Cause<E>> =>\n(fc) =>\n  fc.letrec((tie) => ({\n    Empty: fc.record({ _tag: fc.constant(\"Empty\" as const) }),\n    Fail: fc.record({ _tag: fc.constant(\"Fail\" as const), error: error(fc) }),\n    Die: fc.record({ _tag: fc.constant(\"Die\" as const), defect: defect(fc) }),\n    Interrupt: fc.record({ _tag: fc.constant(\"Interrupt\" as const), fiberId: fiberIdArbitrary(fc) }),\n    Sequential: fc.record({ _tag: fc.constant(\"Sequential\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Parallel: fc.record({ _tag: fc.constant(\"Parallel\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Cause: fc.oneof(\n      tie(\"Empty\"),\n      tie(\"Fail\"),\n      tie(\"Die\"),\n      tie(\"Interrupt\"),\n      tie(\"Sequential\"),\n      tie(\"Parallel\")\n    ) as any as fastCheck_.Arbitrary<cause_.Cause<E>>\n  })).Cause.map(causeDecode)\n\nconst causePretty = <E>(error: pretty_.Pretty<E>): pretty_.Pretty<cause_.Cause<E>> => (cause) => {\n  const f = (cause: cause_.Cause<E>): string => {\n    switch (cause._tag) {\n      case \"Empty\":\n        return \"Cause.empty\"\n      case \"Fail\":\n        return `Cause.fail(${error(cause.error)})`\n      case \"Die\":\n        return `Cause.die(${cause_.pretty(cause)})`\n      case \"Interrupt\":\n        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`\n      case \"Sequential\":\n        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`\n      case \"Parallel\":\n        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`\n    }\n  }\n  return f(cause)\n}\n\nconst causeParse = <A, D, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<CauseEncoded<A, D>, R>\n): ParseResult.DeclarationDecodeUnknown<cause_.Cause<A>, R> =>\n(u, options, ast) =>\n  cause_.isCause(u) ?\n    toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface CauseFromSelf<E extends Schema.All, D extends Schema.All> extends\n  AnnotableDeclare<\n    CauseFromSelf<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    cause_.Cause<Schema.Encoded<E>>,\n    [E, D]\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const CauseFromSelf = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): CauseFromSelf<E, D> => {\n  return declare(\n    [error, defect],\n    {\n      decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),\n      encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))\n    },\n    {\n      typeConstructor: { _tag: \"effect/Cause\" },\n      title: `Cause<${error.ast}>`,\n      pretty: causePretty,\n      arbitrary: causeArbitrary\n    }\n  )\n}\n\nfunction causeDecode<E>(cause: CauseEncoded<E, unknown>): cause_.Cause<E> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return cause_.empty\n    case \"Fail\":\n      return cause_.fail(cause.error)\n    case \"Die\":\n      return cause_.die(cause.defect)\n    case \"Interrupt\":\n      return cause_.interrupt(fiberIdDecode(cause.fiberId))\n    case \"Sequential\":\n      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right))\n    case \"Parallel\":\n      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right))\n  }\n}\n\nfunction causeEncode<E>(cause: cause_.Cause<E>): CauseEncoded<E, unknown> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return { _tag: \"Empty\" }\n    case \"Fail\":\n      return { _tag: \"Fail\", error: cause.error }\n    case \"Die\":\n      return { _tag: \"Die\", defect: cause.defect }\n    case \"Interrupt\":\n      return { _tag: \"Interrupt\", fiberId: cause.fiberId }\n    case \"Sequential\":\n      return {\n        _tag: \"Sequential\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n    case \"Parallel\":\n      return {\n        _tag: \"Parallel\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Cause<E extends Schema.All, D extends Schema.All> extends\n  transform<\n    SchemaClass<\n      CauseEncoded<Schema.Type<E>, Schema.Type<Defect>>,\n      CauseEncoded<Schema.Encoded<E>, Schema.Encoded<Defect>>,\n      Schema.Context<E> | Schema.Context<D>\n    >,\n    CauseFromSelf<SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const Cause = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): Cause<E, D> => {\n  const error_ = asSchema(error)\n  const defect_ = asSchema(defect)\n  const out = transform(\n    causeEncoded(error_, defect_),\n    CauseFromSelf({ error: typeSchema(error_), defect: typeSchema(defect_) }),\n    {\n      strict: false,\n      decode: (i) => causeDecode(i),\n      encode: (a) => causeEncode(a)\n    }\n  )\n  return out as any\n}\n\n/**\n * Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.\n * It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),\n * or converts other values to their string representations.\n *\n * When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,\n * or other values into their string forms.\n *\n * This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.\n *\n * @category defect\n * @since 3.10.0\n */\nexport class Defect extends transform(\n  Unknown,\n  Unknown,\n  {\n    strict: true,\n    decode: (i) => {\n      if (Predicate.isObject(i) && \"message\" in i && typeof i.message === \"string\") {\n        const err = new Error(i.message, { cause: i })\n        if (\"name\" in i && typeof i.name === \"string\") {\n          err.name = i.name\n        }\n        err.stack = \"stack\" in i && typeof i.stack === \"string\" ? i.stack : \"\"\n        return err\n      }\n      return internalCause_.prettyErrorMessage(i)\n    },\n    encode: (a) => {\n      if (a instanceof Error) {\n        return {\n          name: a.name,\n          message: a.message\n          // no stack because of security reasons\n        }\n      }\n      return internalCause_.prettyErrorMessage(a)\n    }\n  }\n).annotations({ identifier: \"Defect\" }) {}\n\n/**\n * @category Exit utils\n * @since 3.10.0\n */\nexport type ExitEncoded<A, E, D> =\n  | {\n    readonly _tag: \"Failure\"\n    readonly cause: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }\n\nconst exitFailureEncoded = <E extends Schema.All, D extends Schema.All>(\n  error: E,\n  defect: D\n) =>\n  Struct({\n    _tag: Literal(\"Failure\"),\n    cause: causeEncoded(error, defect)\n  })\n\nconst exitSuccessEncoded = <A extends Schema.All>(\n  value: A\n) =>\n  Struct({\n    _tag: Literal(\"Success\"),\n    value\n  })\n\nconst exitEncoded = <A extends Schema.All, E extends Schema.All, D extends Schema.Any>(\n  value: A,\n  error: E,\n  defect: D\n) => {\n  return Union(\n    exitFailureEncoded(error, defect),\n    exitSuccessEncoded(value)\n  ).annotations({\n    title: `ExitEncoded<${format(value)}, ${format(error)}, ${format(defect)}>`\n  })\n}\n\nconst exitDecode = <A, E>(input: ExitEncoded<A, E, unknown>): exit_.Exit<A, E> => {\n  switch (input._tag) {\n    case \"Failure\":\n      return exit_.failCause(causeDecode(input.cause))\n    case \"Success\":\n      return exit_.succeed(input.value)\n  }\n}\n\nconst exitArbitrary = <A, E>(\n  value: LazyArbitrary<A>,\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<exit_.Exit<A, E>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Failure\" as const), cause: causeArbitrary(error, defect)(fc) }),\n    fc.record({ _tag: fc.constant(\"Success\" as const), value: value(fc) })\n  ).map(exitDecode)\n\nconst exitPretty =\n  <A, E>(value: pretty_.Pretty<A>, error: pretty_.Pretty<E>): pretty_.Pretty<exit_.Exit<A, E>> => (exit) =>\n    exit._tag === \"Failure\"\n      ? `Exit.failCause(${causePretty(error)(exit.cause)})`\n      : `Exit.succeed(${value(exit.value)})`\n\nconst exitParse = <A, R, E, ER>(\n  decodeUnknownValue: ParseResult.DecodeUnknown<A, R>,\n  decodeUnknownCause: ParseResult.DecodeUnknown<cause_.Cause<E>, ER>\n): ParseResult.DeclarationDecodeUnknown<exit_.Exit<A, E>, ER | R> =>\n(u, options, ast) =>\n  exit_.isExit(u) ?\n    exit_.match(u, {\n      onFailure: (cause) => toComposite(decodeUnknownCause(cause, options), exit_.failCause, ast, u),\n      onSuccess: (value) => toComposite(decodeUnknownValue(value, options), exit_.succeed, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ExitFromSelf<A extends Schema.All, E extends Schema.All, D extends Schema.All>\n  extends\n    AnnotableDeclare<\n      ExitFromSelf<A, E, D>,\n      exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n      exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,\n      [A, E, D]\n    >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const ExitFromSelf = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): ExitFromSelf<A, E, D> =>\n  declare(\n    [success, failure, defect],\n    {\n      decode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.decodeUnknown(success),\n          ParseResult.decodeUnknown(CauseFromSelf({ error: failure, defect }))\n        ),\n      encode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.encodeUnknown(success),\n          ParseResult.encodeUnknown(CauseFromSelf({ error: failure, defect }))\n        )\n    },\n    {\n      typeConstructor: { _tag: \"effect/Exit\" },\n      title: `Exit<${success.ast}, ${failure.ast}>`,\n      pretty: exitPretty,\n      arbitrary: exitArbitrary\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Exit<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  transform<\n    Union<[\n      Struct<{\n        _tag: Literal<[\"Failure\"]>\n        cause: SchemaClass<\n          CauseEncoded<Schema.Type<E>, Schema.Type<D>>,\n          CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n          Schema.Context<E> | Schema.Context<D>\n        >\n      }>,\n      Struct<{\n        _tag: Literal<[\"Success\"]>\n        value: A\n      }>\n    ]>,\n    ExitFromSelf<SchemaClass<Schema.Type<A>>, SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const Exit = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): Exit<A, E, D> => {\n  const success_ = asSchema(success)\n  const failure_ = asSchema(failure)\n  const defect_ = asSchema(defect)\n  const out = transform(\n    exitEncoded(success_, failure_, defect_),\n    ExitFromSelf({ failure: typeSchema(failure_), success: typeSchema(success_), defect: typeSchema(defect_) }),\n    {\n      strict: false,\n      decode: (i) => exitDecode(i),\n      encode: (a) =>\n        a._tag === \"Failure\"\n          ? { _tag: \"Failure\", cause: a.cause } as const\n          : { _tag: \"Success\", value: a.value } as const\n    }\n  )\n  return out as any\n}\n\nconst hashSetArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<hashSet_.HashSet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(\n      hashSet_.fromIterable\n    )\n  }\n\nconst hashSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<hashSet_.HashSet<A>> => (set) =>\n  `HashSet(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst hashSetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<hashSet_.HashSet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<hashSet_.HashSet<A>, R> =>\n(u, options, ast) =>\n  hashSet_.isHashSet(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashSet_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    HashSetFromSelf<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    hashSet_.HashSet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport const HashSetFromSelf = <Value extends Schema.Any>(\n  value: Value\n): HashSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => hashSetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => hashSetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      typeConstructor: { _tag: \"effect/HashSet\" },\n      description: `HashSet<${format(value)}>`,\n      pretty: hashSetPretty,\n      arbitrary: hashSetArbitrary,\n      equivalence: hashSetEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSet<Value extends Schema.Any>\n  extends transform<Array$<Value>, HashSetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport function HashSet<Value extends Schema.Any>(value: Value): HashSet<Value> {\n  return transform(\n    Array$(value),\n    HashSetFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => hashSet_.fromIterable(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\nconst hashMapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<hashMap_.HashMap<K, V>> =>\n(fc) => {\n  const items = fc.array(fc.tuple(key(fc), value(fc)))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(hashMap_.fromIterable)\n}\n\nconst hashMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<hashMap_.HashMap<K, V>> =>\n(map) =>\n  `HashMap([${\n    Array.from(map)\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst hashMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<hashMap_.HashMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<hashMap_.HashMap<K, V>, R> =>\n(u, options, ast) =>\n  hashMap_.isHashMap(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashMap_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    HashMapFromSelf<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMapFromSelf<K, V> => {\n  return declare(\n    [key, value],\n    {\n      decode: (key, value) => hashMapParse(ParseResult.decodeUnknown(Array$(Tuple(key, value)))),\n      encode: (key, value) => hashMapParse(ParseResult.encodeUnknown(Array$(Tuple(key, value))))\n    },\n    {\n      typeConstructor: { _tag: \"effect/HashMap\" },\n      description: `HashMap<${format(key)}, ${format(value)}>`,\n      pretty: hashMapPretty,\n      arbitrary: hashMapArbitrary,\n      equivalence: hashMapEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMap<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, HashMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMap<K, V> => {\n  return transform(\n    Array$(Tuple(key, value)),\n    HashMapFromSelf({ key: typeSchema(asSchema(key)), value: typeSchema(asSchema(value)) }),\n    {\n      strict: true,\n      decode: (i) => hashMap_.fromIterable(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\nconst listArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<list_.List<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(list_.fromIterable)\n  }\n\nconst listPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<list_.List<A>> => (set) =>\n  `List(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst listEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<list_.List<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst listParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<list_.List<A>, R> =>\n(u, options, ast) =>\n  list_.isList(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), list_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ListFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ListFromSelf<Value>,\n    list_.List<Schema.Type<Value>>,\n    list_.List<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport const ListFromSelf = <Value extends Schema.Any>(\n  value: Value\n): ListFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => listParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => listParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      typeConstructor: { _tag: \"effect/List\" },\n      description: `List<${format(value)}>`,\n      pretty: listPretty,\n      arbitrary: listArbitrary,\n      equivalence: listEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface List<Value extends Schema.Any>\n  extends transform<Array$<Value>, ListFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport function List<Value extends Schema.Any>(value: Value): List<Value> {\n  return transform(\n    Array$(value),\n    ListFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => list_.fromIterable(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\nconst sortedSetArbitrary = <A>(\n  item: LazyArbitrary<A>,\n  ord: Order.Order<A>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<sortedSet_.SortedSet<A>> =>\n(fc) => {\n  const items = fc.array(item(fc))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) =>\n    sortedSet_.fromIterable(as, ord)\n  )\n}\n\nconst sortedSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<sortedSet_.SortedSet<A>> => (set) =>\n  `new SortedSet([${Array.from(sortedSet_.values(set)).map((a) => item(a)).join(\", \")}])`\n\nconst sortedSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>,\n  ord: Order.Order<A>\n): ParseResult.DeclarationDecodeUnknown<sortedSet_.SortedSet<A>, R> =>\n(u, options, ast) =>\n  sortedSet_.isSortedSet(u) ?\n    toComposite(\n      decodeUnknown(Array.from(sortedSet_.values(u)), options),\n      (as): sortedSet_.SortedSet<A> => sortedSet_.fromIterable(as, ord),\n      ast,\n      u\n    )\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    SortedSetFromSelf<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    sortedSet_.SortedSet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport const SortedSetFromSelf = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>,\n  ordI: Order.Order<Schema.Encoded<Value>>\n): SortedSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => sortedSetParse(ParseResult.decodeUnknown(Array$(item)), ordA),\n      encode: (item) => sortedSetParse(ParseResult.encodeUnknown(Array$(item)), ordI)\n    },\n    {\n      typeConstructor: { _tag: \"effect/SortedSet\" },\n      description: `SortedSet<${format(value)}>`,\n      pretty: sortedSetPretty,\n      arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),\n      equivalence: () => sortedSet_.getEquivalence<Schema.Type<Value>>()\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSet<Value extends Schema.Any>\n  extends transform<Array$<Value>, SortedSetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport function SortedSet<Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>\n): SortedSet<Value> {\n  const to = typeSchema(asSchema(value))\n  return transform(\n    Array$(value),\n    SortedSetFromSelf<typeof to>(to, ordA, ordA),\n    {\n      strict: true,\n      decode: (i) => sortedSet_.fromIterable(i, ordA),\n      encode: (a) => Array.from(sortedSet_.values(a))\n    }\n  )\n}\n\n/**\n * Converts an arbitrary value to a `boolean` by testing whether it is truthy.\n * Uses `!!val` to coerce the value to a `boolean`.\n *\n * @see https://developer.mozilla.org/docs/Glossary/Truthy\n *\n * @category boolean constructors\n * @since 3.10.0\n */\nexport class BooleanFromUnknown extends transform(\n  Unknown,\n  Boolean$,\n  {\n    strict: true,\n    decode: (i) => Predicate.isTruthy(i),\n    encode: identity\n  }\n).annotations({ identifier: \"BooleanFromUnknown\" }) {}\n\n/**\n * Converts an `string` value into its corresponding `boolean`\n * (\"true\" as `true` and \"false\" as `false`).\n *\n * @category boolean transformations\n * @since 3.11.0\n */\nexport class BooleanFromString extends transform(\n  Literal(\"true\", \"false\").annotations({ description: \"a string to be decoded into a boolean\" }),\n  Boolean$,\n  {\n    strict: true,\n    decode: (i) => i === \"true\",\n    encode: (a) => a ? \"true\" : \"false\"\n  }\n).annotations({ identifier: \"BooleanFromString\" }) {}\n\n/**\n * @category Config validations\n * @since 3.10.0\n */\nexport const Config = <A, I extends string>(name: string, schema: Schema<A, I>): config_.Config<A> => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema)\n  return config_.string(name).pipe(\n    config_.mapOrFail((s) =>\n      decodeUnknownEither(s).pipe(\n        either_.mapLeft((error) => configError_.InvalidData([], ParseResult.TreeFormatter.formatIssueSync(error)))\n      )\n    )\n  )\n}\n\n// ---------------------------------------------\n// Serializable\n// ---------------------------------------------\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolSerializable: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbol\"\n)\n\n/**\n * The `Serializable` trait allows objects to define their own schema for\n * serialization.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface Serializable<A, I, R> {\n  readonly [symbolSerializable]: Schema<A, I, R>\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace Serializable {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<T> = T extends Serializable<infer A, infer _I, infer _R> ? A : never\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<T> = T extends Serializable<infer _A, infer I, infer _R> ? I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends Serializable<infer _A, infer _I, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Serializable<any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Serializable<any, never, unknown>\n    | Serializable<never, any, unknown>\n    | Serializable<never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializable = <S extends Serializable.All>(\n  serializable: S\n): Serializable<Serializable.Type<S>, Serializable.Encoded<S>, Serializable.Context<S>> => serializable as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const serializableSchema = <A, I, R>(self: Serializable<A, I, R>): Schema<A, I, R> => self[symbolSerializable]\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serialize = <A, I, R>(self: Serializable<A, I, R>): Effect.Effect<I, ParseResult.ParseError, R> =>\n  encodeUnknown(self[symbolSerializable])(self)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserialize: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <A, I, R>(self: Serializable<A, I, R>) => Effect.Effect<A, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R> =>\n    decodeUnknown(self[symbolSerializable])(value)\n)\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolWithResult: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbolResult\"\n)\n\n/**\n * The `WithResult` trait is designed to encapsulate the outcome of an\n * operation, distinguishing between success and failure cases. Each case is\n * associated with a schema that defines the structure and types of the success\n * or failure data.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {\n  readonly [symbolWithResult]: {\n    readonly success: Schema<Success, SuccessEncoded, ResultR>\n    readonly failure: Schema<Failure, FailureEncoded, ResultR>\n  }\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace WithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Success<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _A : never\n  /**\n   * @since 3.10.0\n   */\n  export type SuccessEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Failure<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _E : never\n  /**\n   * @since 3.10.0\n   */\n  export type FailureEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _EI : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends WithResult<infer _SA, infer _SI, infer _FA, infer _FI, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = WithResult<any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | WithResult<any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asWithResult = <WR extends WithResult.All>(\n  withExit: WR\n): WithResult<\n  WithResult.Success<WR>,\n  WithResult.SuccessEncoded<WR>,\n  WithResult.Failure<WR>,\n  WithResult.FailureEncoded<WR>,\n  WithResult.Context<WR>\n> => withExit as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const failureSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<FA, FI, R> =>\n  self[symbolWithResult].failure\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const successSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<SA, SI, R> =>\n  self[symbolWithResult].success\n\nconst exitSchemaCache = globalValue(\n  \"effect/Schema/Serializable/exitSchemaCache\",\n  () => new WeakMap<object, Schema<any, any, any>>()\n)\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const exitSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<\n  exit_.Exit<SA, FA>,\n  ExitEncoded<SI, FI, unknown>,\n  R\n> => {\n  const proto = Object.getPrototypeOf(self)\n  if (!(symbolWithResult in proto)) {\n    return Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n  }\n  let schema = exitSchemaCache.get(proto)\n  if (schema === undefined) {\n    schema = Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n    exitSchemaCache.set(proto, schema)\n  }\n  return schema\n}\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <FA>(value: FA): <SA, SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<FI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<FA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<FA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<FA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA>(value: SA): <SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<SA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<SA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeExit: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, FA>(value: exit_.Exit<SA, FA>): <SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: exit_.Exit<SA, FA>): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: exit_.Exit<SA, FA>\n): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R> => encode(exitSchema(self))(value))\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeExit: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: unknown\n): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R> => decodeUnknown(exitSchema(self))(value))\n\n// ---------------------------------------------\n// SerializableWithResult\n// ---------------------------------------------\n\n/**\n * The `SerializableWithResult` trait is specifically designed to model remote\n * procedures that require serialization of their input and output, managing\n * both successful and failed outcomes.\n *\n * This trait combines functionality from both the `Serializable` and `WithResult`\n * traits to handle data serialization and the bifurcation of operation results\n * into success or failure categories.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface SerializableWithResult<\n  A,\n  I,\n  R,\n  Success,\n  SuccessEncoded,\n  Failure,\n  FailureEncoded,\n  ResultR\n> extends Serializable<A, I, R>, WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace SerializableWithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Context<P> = P extends\n    SerializableWithResult<infer _S, infer _SI, infer SR, infer _A, infer _AI, infer _E, infer _EI, infer RR> ? SR | RR\n    : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = SerializableWithResult<any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | SerializableWithResult<any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializableWithResult = <SWR extends SerializableWithResult.All>(\n  procedure: SWR\n): SerializableWithResult<\n  Serializable.Type<SWR>,\n  Serializable.Encoded<SWR>,\n  Serializable.Context<SWR>,\n  WithResult.Success<SWR>,\n  WithResult.SuccessEncoded<SWR>,\n  WithResult.Failure<SWR>,\n  WithResult.FailureEncoded<SWR>,\n  WithResult.Context<SWR>\n> => procedure as any\n\n/**\n * @since 3.10.0\n */\nexport interface TaggedRequest<\n  Tag extends string,\n  A,\n  I,\n  R,\n  SuccessType,\n  SuccessEncoded,\n  FailureType,\n  FailureEncoded,\n  ResultR\n> extends\n  Request.Request<SuccessType, FailureType>,\n  SerializableWithResult<\n    A,\n    I,\n    R,\n    SuccessType,\n    SuccessEncoded,\n    FailureType,\n    FailureEncoded,\n    ResultR\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TaggedRequest {\n  /**\n   * @since 3.10.0\n   */\n  export type Any = TaggedRequest<string, any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | TaggedRequest<string, any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedRequestClass<\n  Self,\n  Tag extends string,\n  Payload extends Struct.Fields,\n  Success extends Schema.All,\n  Failure extends Schema.All\n> extends\n  Class<\n    Self,\n    Payload,\n    Struct.Encoded<Payload>,\n    Struct.Context<Payload>,\n    Struct.Constructor<Omit<Payload, \"_tag\">>,\n    TaggedRequest<\n      Tag,\n      Self,\n      Struct.Encoded<Payload>,\n      Struct.Context<Payload>,\n      Schema.Type<Success>,\n      Schema.Encoded<Success>,\n      Schema.Type<Failure>,\n      Schema.Encoded<Failure>,\n      Schema.Context<Success> | Schema.Context<Failure>\n    >,\n    {}\n  >\n{\n  readonly _tag: Tag\n  readonly success: Success\n  readonly failure: Failure\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyRequest extends Schema.TaggedRequest<MyRequest>(\"MyRequest\")(\"MyRequest\", {\n *  failure: Schema.String,\n *  success: Schema.Number,\n *  payload: { id: Schema.String }\n * }) {}\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedRequest =\n  <Self = never>(identifier?: string) =>\n  <Tag extends string, Payload extends Struct.Fields, Success extends Schema.All, Failure extends Schema.All>(\n    tag: Tag,\n    options: {\n      failure: Failure\n      success: Success\n      payload: Payload\n    },\n    annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag> } & Payload>>>\n  ): [Self] extends [never] ? MissingSelfGeneric<\"TaggedRequest\", `\"Tag\", SuccessSchema, FailureSchema, `>\n    : TaggedRequestClass<\n      Self,\n      Tag,\n      { readonly _tag: tag<Tag> } & Payload,\n      Success,\n      Failure\n    > =>\n  {\n    const taggedFields = extendFields({ _tag: getClassTag(tag) }, options.payload)\n    return class TaggedRequestClass extends makeClass({\n      kind: \"TaggedRequest\",\n      identifier: identifier ?? tag,\n      schema: Struct(taggedFields),\n      fields: taggedFields,\n      Base: Request.Class<any, any, { readonly _tag: string }>,\n      annotations\n    }) {\n      static _tag = tag\n      static success = options.success\n      static failure = options.failure\n      get [symbolSerializable]() {\n        return this.constructor\n      }\n      get [symbolWithResult]() {\n        return {\n          failure: options.failure,\n          success: options.success\n        }\n      }\n    } as any\n  }\n\n// -------------------------------------------------------------------------------------------------\n// Equivalence compiler\n// -------------------------------------------------------------------------------------------------\n\n/**\n * Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.\n *\n * @category Equivalence\n * @since 3.10.0\n */\nexport const equivalence = <A, I, R>(schema: Schema<A, I, R>): Equivalence.Equivalence<A> => go(schema.ast, [])\n\nconst getEquivalenceAnnotation = AST.getAnnotation<AST.EquivalenceAnnotation<any, any>>(AST.EquivalenceAnnotationId)\n\nconst go = (ast: AST.AST, path: ReadonlyArray<PropertyKey>): Equivalence.Equivalence<any> => {\n  const hook = getEquivalenceAnnotation(ast)\n  if (option_.isSome(hook)) {\n    switch (ast._tag) {\n      case \"Declaration\":\n        return hook.value(...ast.typeParameters.map((tp) => go(tp, path)))\n      case \"Refinement\":\n        return hook.value(go(ast.from, path))\n      default:\n        return hook.value()\n    }\n  }\n  switch (ast._tag) {\n    case \"NeverKeyword\":\n      throw new Error(errors_.getEquivalenceUnsupportedErrorMessage(ast, path))\n    case \"Transformation\":\n      return go(ast.to, path)\n    case \"Declaration\":\n    case \"Literal\":\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n    case \"UniqueSymbol\":\n    case \"SymbolKeyword\":\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"Enums\":\n    case \"ObjectKeyword\":\n      return Equal.equals\n    case \"Refinement\":\n      return go(ast.from, path)\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => go(ast.f(), path))\n      return (a, b) => get()(a, b)\n    }\n    case \"TupleType\": {\n      const elements = ast.elements.map((element, i) => go(element.type, path.concat(i)))\n      const rest = ast.rest.map((annotatedAST) => go(annotatedAST.type, path))\n      return Equivalence.make((a, b) => {\n        if (!Array.isArray(a) || !Array.isArray(b)) {\n          return false\n        }\n        const len = a.length\n        if (len !== b.length) {\n          return false\n        }\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        let i = 0\n        for (; i < Math.min(len, ast.elements.length); i++) {\n          if (!elements[i](a[i], b[i])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (array_.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          for (; i < len - tail.length; i++) {\n            if (!head(a[i], b[i])) {\n              return false\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            i += j\n            if (!tail[j](a[i], b[i])) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"TypeLiteral\": {\n      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n        return Equal.equals\n      }\n      const propertySignatures = ast.propertySignatures.map((ps) => go(ps.type, path.concat(ps.name)))\n      const indexSignatures = ast.indexSignatures.map((is) => go(is.type, path))\n      return Equivalence.make((a, b) => {\n        if (!Predicate.isRecord(a) || !Predicate.isRecord(b)) {\n          return false\n        }\n        const aStringKeys = Object.keys(a)\n        const aSymbolKeys = Object.getOwnPropertySymbols(a)\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < propertySignatures.length; i++) {\n          const ps = ast.propertySignatures[i]\n          const name = ps.name\n          const aHas = Object.prototype.hasOwnProperty.call(a, name)\n          const bHas = Object.prototype.hasOwnProperty.call(b, name)\n          if (ps.isOptional) {\n            if (aHas !== bHas) {\n              return false\n            }\n          }\n          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        let bSymbolKeys: Array<symbol> | undefined\n        let bStringKeys: Array<string> | undefined\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const is = ast.indexSignatures[i]\n          const encodedParameter = AST.getEncodedParameter(is.parameter)\n          const isSymbol = AST.isSymbolKeyword(encodedParameter)\n          if (isSymbol) {\n            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b)\n            if (aSymbolKeys.length !== bSymbolKeys.length) {\n              return false\n            }\n          } else {\n            bStringKeys = bStringKeys || Object.keys(b)\n            if (aStringKeys.length !== bStringKeys.length) {\n              return false\n            }\n          }\n          const aKeys = isSymbol ? aSymbolKeys : aStringKeys\n          for (let j = 0; j < aKeys.length; j++) {\n            const key = aKeys[j]\n            if (\n              !Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])\n            ) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"Union\": {\n      const searchTree = ParseResult.getSearchTree(ast.types, true)\n      const ownKeys = Reflect.ownKeys(searchTree.keys)\n      const len = ownKeys.length\n      return Equivalence.make((a, b) => {\n        let candidates: Array<AST.AST> = []\n        if (len > 0 && Predicate.isRecordOrArray(a)) {\n          for (let i = 0; i < len; i++) {\n            const name = ownKeys[i]\n            const buckets = searchTree.keys[name].buckets\n            if (Object.prototype.hasOwnProperty.call(a, name)) {\n              const literal = String(a[name])\n              if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                candidates = candidates.concat(buckets[literal])\n              }\n            }\n          }\n        }\n        if (searchTree.otherwise.length > 0) {\n          candidates = candidates.concat(searchTree.otherwise)\n        }\n        const tuples = candidates.map((ast) => [go(ast, path), ParseResult.is({ ast } as any)] as const)\n        for (let i = 0; i < tuples.length; i++) {\n          const [equivalence, is] = tuples[i]\n          if (is(a) && is(b)) {\n            if (equivalence(a, b)) {\n              return true\n            }\n          }\n        }\n        return false\n      })\n    }\n  }\n}\n\nconst SymbolStruct = TaggedStruct(\"symbol\", {\n  key: String$\n}).annotations({ description: \"an object to be decoded into a globally shared symbol\" })\n\nconst SymbolFromStruct = transformOrFail(\n  SymbolStruct,\n  SymbolFromSelf,\n  {\n    strict: true,\n    decode: (i) => decodeSymbol(i.key),\n    encode: (a, _, ast) => ParseResult.map(encodeSymbol(a, ast), (key) => SymbolStruct.make({ key }))\n  }\n)\n\n/** @ignore */\nclass PropertyKey$ extends Union(String$, Number$, SymbolFromStruct).annotations({ identifier: \"PropertyKey\" }) {}\n\nexport {\n  /**\n   * @since 3.12.5\n   */\n  PropertyKey$ as PropertyKey\n}\n\n/**\n * @category ArrayFormatter\n * @since 3.12.5\n */\nexport class ArrayFormatterIssue extends Struct({\n  _tag: propertySignature(Literal(\n    \"Pointer\",\n    \"Unexpected\",\n    \"Missing\",\n    \"Composite\",\n    \"Refinement\",\n    \"Transformation\",\n    \"Type\",\n    \"Forbidden\"\n  )).annotations({ description: \"The tag identifying the type of parse issue\" }),\n  path: propertySignature(Array$(PropertyKey$)).annotations({\n    description: \"The path to the property where the issue occurred\"\n  }),\n  message: propertySignature(String$).annotations({ description: \"A descriptive message explaining the issue\" })\n}).annotations({\n  identifier: \"ArrayFormatterIssue\",\n  description: \"Represents an issue returned by the ArrayFormatter formatter\"\n}) {}\n"],"names":["array_","bigDecimal_","bigInt_","boolean_","cause_","chunk_","config_","configError_","data_","dateTime","duration_","Effect","either_","Encoding","Equal","Equivalence","exit_","fastCheck_","fiberId_","dual","identity","globalValue","hashMap_","hashSet_","Inspectable","internalCause_","errors_","schemaId_","util_","list_","number_","option_","ParseResult","pipeArguments","Predicate","redacted_","Request","scheduler_","AST","sortedSet_","string_","struct_","TypeId","Symbol","for","make","ast","SchemaClass","variance","annotations","mergeSchemaAnnotations","pipe","arguments","toString","String","Type","Encoded","Context","_A","_","_I","_R","makeStandardResult","exit","isSuccess","value","makeStandardFailureResult","pretty","cause","message","issues","makeStandardFailureFromParseIssue","issue","map","ArrayFormatter","formatIssue","path","standardSchemaV1","schema","overrideOptions","decodeUnknown","errors","StandardSchemaV1Class","version","vendor","validate","scheduler","SyncScheduler","fiber","runFork","matchEffect","onFailure","onSuccess","succeed","flush","unsafePoll","Promise","resolve","addObserver","builtInAnnotations","typeConstructor","TypeConstructorAnnotationId","schemaId","SchemaIdAnnotationId","MessageAnnotationId","missingMessage","MissingMessageAnnotationId","identifier","IdentifierAnnotationId","title","TitleAnnotationId","description","DescriptionAnnotationId","examples","ExamplesAnnotationId","default","DefaultAnnotationId","documentation","DocumentationAnnotationId","jsonSchema","JSONSchemaAnnotationId","arbitrary","ArbitraryAnnotationId","PrettyAnnotationId","equivalence","EquivalenceAnnotationId","concurrency","ConcurrencyAnnotationId","batching","BatchingAnnotationId","parseIssueTitle","ParseIssueTitleAnnotationId","parseOptions","ParseOptionsAnnotationId","decodingFallback","DecodingFallbackAnnotationId","toASTAnnotations","out","key","id","asSchema","format","encodedSchema","encodedAST","encodedBoundSchema","encodedBoundAST","typeSchema","typeAST","asserts","decodeOption","decodeSync","decodeUnknownOption","decodeUnknownSync","encodeOption","encodeSync","encodeUnknownOption","encodeUnknownSync","is","validateOption","validateSync","encodeUnknown","options","u","mapError","parseError","encodeUnknownEither","mapLeft","encodeUnknownPromise","parser","runPromise","encode","encodeEither","encodePromise","decodeUnknownEither","decodeUnknownPromise","decode","decodeEither","decodePromise","validateEither","validatePromise","isSchema","hasProperty","isObject","getDefaultLiteralAST","literals","isMembers","Union","mapMembers","literal","Literal","makeLiteralClass","LiteralClass","isNonEmptyReadonlyArray","Never","pickLiteral","_schema","UniqueSymbolFromSelf","symbol","UniqueSymbol","getDefaultEnumsAST","enums","Enums","Object","keys","filter","makeEnumsClass","EnumsClass","TemplateLiteral","head","tail","spans","h","ts","isLiteral","i","length","item","next","push","TemplateLiteralSpan","isNonEmptyArray","getTemplateLiteralParserCoercedElement","encoded","_tag","isString","s","transform","strict","compose","NumberFromString","members","hasCoercions","member","types","coerced","TemplateLiteralParser","params","encodedSchemas","elements","schemas","param","element","from","re","getTemplateLiteralCapturingRegExp","to","Tuple","AutoTitleAnnotationId","TemplateLiteralParserClass","transformOrFail","match","exec","slice","fail","source","JSON","stringify","tuple","join","declareConstructor","typeParameters","makeDeclareClass","Declaration","tp","declarePrimitive","input","DeclareClass","declare","Array","isArray","BrandSchemaId","fromBrand","constructor","self","makeBrandClass","Refinement","predicate","a","either","isLeft","some","left","v","none","InstanceOfSchemaId","instanceOf","name","Undefined","undefinedKeyword","Void","voidKeyword","Null","null","neverKeyword","Unknown","unknownKeyword","Any","anyKeyword","BigIntFromSelf","bigIntKeyword","SymbolFromSelf","symbolKeyword","String$","stringKeyword","Number$","numberKeyword","Boolean$","booleanKeyword","Object$","objectKeyword","Boolean","Number","getDefaultUnionAST","m","makeUnionClass","UnionClass","NullOr","UndefinedOr","NullishOr","keyof","ElementImpl","OptionalType","optionalElement","_Token","type","isOptional","getDefaultTupleTypeAST","rest","TupleType","el","makeTupleTypeClass","TupleTypeClass","args","makeArrayClass","ArrayClass","Array$","makeNonEmptyArrayClass","NonEmptyArrayClass","NonEmptyArray","ArrayEnsure","ensure","NonEmptyArrayEnsure","of","formatPropertySignatureToken","PropertySignatureDeclaration","isReadonly","defaultValue","token","FromPropertySignature","fromKey","ToPropertySignature","formatPropertyKey","p","undefined","PropertySignatureTransformation","mergeSignatureAnnotations","PropertySignatureTypeId","isPropertySignature","PropertySignatureImpl","_TypeToken","_Key","_EncodedToken","_HasDefault","makePropertySignature","PropertySignatureWithFromImpl","propertySignature","withConstructorDefault","applyDefaultValue","o","onNone","onSome","pruneUndefined","pruned","Transformation","transformation","withDecodingDefault","withDefaults","defaults","decoding","optionalToRequired","flatMap","requiredToOptional","optionalToOptional","optionalPropertySignatureAST","isExact","exact","isNullable","nullable","asOption","as","asOptionEncode","onNoneEncoding","orElse","OptionFromSelf_","isNotNull","isNotUndefined","optional","optionalWith","preserveMissingMessageAnnotation","pickAnnotations","getDefaultTypeLiteralAST","fields","records","ownKeys","Reflect","pss","transformations","field","toAnnotations","PropertySignature","issFrom","issTo","r","indexSignatures","propertySignatures","record","forEach","ps","IndexSignature","parameter","TypeLiteral","TypeLiteralTransformation","iss","lazilyMergeDefaults","makeTypeLiteralClass","TypeLiteralClass","props","propsWithDefaults","getDisableValidationMakeOption","pick","Struct","omit","tag","TaggedStruct","makeRecordClass","RecordClass","Record","pluck","getPropertyKeyIndexedAccess","orUndefined","BrandClass","brand","annotation","getBrandAnnotation","brands","BrandAnnotationId","partial","partialWith","required","mutable","intersectTypeLiterals","x","y","isTypeLiteral","findIndex","extendAST","concat","Error","getSchemaExtendErrorMessage","preserveRefinementAnnotations","omitAnnotations","addRefinementToMembers","refinement","asts","intersectUnionMembers","getTypes","isUnion","xs","ys","isStringKeyword","isNumber","isNumberKeyword","isBoolean","isBooleanKeyword","isRefinement","Suspend","f","propertySignatureTransformations","composeTransformation","FinalTransformation","fromA","fromI","toI","toA","isTransformation","isTypeLiteralTransformation","extend","that","makeTransformationClass","suspend","RefineSchemaId","makeRefineClass","RefineClass","fromFilterPredicateReturnTypeItem","Pointer","toFilterParseIssue","isSingle","filterMap","Composite","filterEffect","filterReturnType","TransformationClass","_options","_ast","transformLiteral","transformLiterals","pairs","attachPropertySignature","isSymbol","rename","mapping","TrimmedSchemaId","trimmed","trim","pattern","MaxLengthSchemaId","maxLength","MinLengthSchemaId","minLength","LengthSchemaId","Math","max","floor","min","PatternSchemaId","regex","lastIndex","test","StartsWithSchemaId","startsWith","formatted","EndsWithSchemaId","endsWith","IncludesSchemaId","includes","searchString","LowercasedSchemaId","lowercased","toLowerCase","Lowercased","UppercasedSchemaId","uppercased","toUpperCase","Uppercased","CapitalizedSchemaId","capitalized","Capitalized","UncapitalizedSchemaId","uncapitalized","Uncapitalized","Char","nonEmptyString","Lowercase","Uppercase","Capitalize","capitalize","Uncapitalize","uncapitalize","Trimmed","NonEmptyTrimmedString","Trim","split","separator","getErrorMessage","e","getParseJsonTransformation","try","parse","reviver","catch","replacer","space","ParseJsonSchemaId","parseJson","schemaOrOptions","NonEmptyString","UUIDSchemaId","uuidRegexp","UUID","fc","uuid","ULIDSchemaId","ulidRegexp","ULID","ulid","URLFromSelf","URL","webUrl","url","URL$","FiniteSchemaId","finite","isFinite","GreaterThanSchemaId","greaterThan","exclusiveMinimum","GreaterThanOrEqualToSchemaId","greaterThanOrEqualTo","minimum","MultipleOfSchemaId","multipleOf","divisor","positiveDivisor","abs","remainder","IntSchemaId","int","isSafeInteger","LessThanSchemaId","lessThan","exclusiveMaximum","LessThanOrEqualToSchemaId","lessThanOrEqualTo","maximum","BetweenSchemaId","between","NonNaNSchemaId","nonNaN","isNaN","positive","negative","nonPositive","nonNegative","clamp","parseNumber","fromOption","Finite","Int","NonNaN","Positive","Negative","NonPositive","NonNegative","JsonNumberSchemaId","JsonNumber","Not","not","encodeSymbol","sym","keyFor","decodeSymbol","Symbol$","GreaterThanBigIntSchemaId","GreaterThanBigintSchemaId","greaterThanBigInt","GreaterThanOrEqualToBigIntSchemaId","greaterThanOrEqualToBigInt","LessThanBigIntSchemaId","lessThanBigInt","LessThanOrEqualToBigIntSchemaId","lessThanOrEqualToBigInt","BetweenBigIntSchemaId","BetweenBigintSchemaId","betweenBigInt","positiveBigInt","negativeBigInt","nonNegativeBigInt","nonPositiveBigInt","clampBigInt","BigInt$","fromString","BigInt","PositiveBigIntFromSelf","PositiveBigInt","NegativeBigIntFromSelf","NegativeBigInt","NonPositiveBigIntFromSelf","NonPositiveBigInt","NonNegativeBigIntFromSelf","NonNegativeBigInt","BigIntFromNumber","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","fromNumber","toNumber","redactedArbitrary","toComposite","eff","actual","mapBoth","redactedParse","isRedacted","RedactedFromSelf","getEquivalence","Redacted","DurationFromSelf","isDuration","oneof","constant","infinity","bigInt","nanos","maxSafeNat","millis","DurationFromNanos","duration","toNanos","NonNegativeInt","DurationFromMillis","toMillis","DurationValueMillis","DurationValueNanos","DurationValueInfinity","durationValueInfinity","DurationValue","FiniteHRTime","InfiniteHRTime","HRTime","isDurationValue","Duration","seconds","clampDuration","betweenDuration","LessThanDurationSchemaId","lessThanDuration","LessThanOrEqualToDurationSchemaId","lessThanOrEqualToDuration","GreaterThanDurationSchemaId","greaterThanDuration","GreaterThanOrEqualToDurationSchemaId","greaterThanOrEqualToDuration","BetweenDurationSchemaId","Uint8ArrayFromSelf","isUint8Array","u8arr","uint8Array","equals","Uint8","Uint8Array$","Uint8Array","makeUint8ArrayTransformation","decodeException","Uint8ArrayFromBase64","decodeBase64","encodeBase64","Uint8ArrayFromBase64Url","decodeBase64Url","encodeBase64Url","Uint8ArrayFromHex","decodeHex","encodeHex","makeEncodingTransformation","StringFromBase64","decodeBase64String","StringFromBase64Url","decodeBase64UrlString","StringFromHex","decodeHexString","StringFromUriComponent","decodeUriComponent","encodeUriComponent","encodeException","MinItemsSchemaId","minItems","n","getInvalidArgumentErrorMessage","StableFilterAnnotationId","MaxItemsSchemaId","maxItems","ItemsCountSchemaId","itemsCount","getNumberIndexedAccess","OptionFromSelf","headNonEmpty","headOrElse","fallback","ValidDateSchemaId","validDate","getTime","noInvalidDate","LessThanDateSchemaId","lessThanDate","formatDate","LessThanOrEqualToDateSchemaId","lessThanOrEqualToDate","GreaterThanDateSchemaId","greaterThanDate","GreaterThanOrEqualToDateSchemaId","greaterThanOrEqualToDate","BetweenDateSchemaId","betweenDate","DateFromSelfSchemaId","DateFromSelf","isDate","date","Date","ValidDateFromSelf","DateFromString","Date$","DateFromNumber","DateTimeUtcFromSelf","isDateTime","isUtc","unsafeFromDate","decodeDateTimeUtc","unsafeMake","formatUnknown","DateTimeUtcFromNumber","toEpochMillis","DateTimeUtcFromDate","toDateUtc","DateTimeUtc","formatIso","timeZoneOffsetArbitrary","integer","zoneMakeOffset","TimeZoneOffsetFromSelf","isTimeZoneOffset","zone","TimeZoneOffset","offset","timeZoneNamedArbitrary","constantFrom","Intl","supportedValuesOf","zoneUnsafeMakeNamed","TimeZoneNamedFromSelf","isTimeZoneNamed","TimeZoneNamed","TimeZoneFromSelf","TimeZone","zoneFromString","zoneToString","timeZoneArbitrary","DateTimeZonedFromSelf","isZoned","timeZone","unsafeMakeZoned","DateTimeZoned","makeZonedFromString","formatIsoZoned","OptionNoneEncoded","optionSomeEncoded","optionEncoded","optionDecode","optionArbitrary","ctx","optionPretty","optionParse","isOption","isNone","makeNoneEncoded","makeSomeEncoded","Option","value_","OptionFromNullOr","fromNullable","getOrNull","OptionFromNullishOr","getOrUndefined","OptionFromUndefinedOr","OptionFromNonEmptyTrimmedString","isNonEmpty","getOrElse","rightEncoded","right","leftEncoded","eitherEncoded","eitherDecode","eitherArbitrary","eitherPretty","onLeft","onRight","eitherParse","parseRight","decodeUnknownLeft","isEither","EitherFromSelf","makeLeftEncoded","makeRightEncoded","Either","right_","left_","EitherFromUnion","toright","toleft","fromRight","fromLeft","mapArbitrary","items","array","depthIdentifier","Map","readonlyMapPretty","entries","k","readonlyMapEquivalence","arrayEquivalence","ka","va","kb","vb","b","readonlyMapParse","isMap","mapFromSelf_","Key","Value","ReadonlyMapFromSelf","MapFromSelf","ReadonlyMap","ReadonlyMapFromRecord","fromEntries","MapFromRecord","setArbitrary","Set","readonlySetPretty","set","values","readonlySetEquivalence","readonlySetParse","isSet","setFromSelf_","ReadonlySetFromSelf","SetFromSelf","ReadonlySet","bigDecimalPretty","val","normalize","bigDecimalArbitrary","scale","BigDecimalFromSelf","isBigDecimal","BigDecimal","BigDecimalFromNumber","unsafeFromNumber","unsafeToNumber","GreaterThanBigDecimalSchemaId","greaterThanBigDecimal","GreaterThanOrEqualToBigDecimalSchemaId","greaterThanOrEqualToBigDecimal","LessThanBigDecimalSchemaId","lessThanBigDecimal","LessThanOrEqualToBigDecimalSchemaId","lessThanOrEqualToBigDecimal","PositiveBigDecimalSchemaId","positiveBigDecimal","isPositive","PositiveBigDecimalFromSelf","NonNegativeBigDecimalSchemaId","nonNegativeBigDecimal","NonNegativeBigDecimalFromSelf","NegativeBigDecimalSchemaId","negativeBigDecimal","isNegative","NegativeBigDecimalFromSelf","NonPositiveBigDecimalSchemaId","nonPositiveBigDecimal","NonPositiveBigDecimalFromSelf","BetweenBigDecimalSchemaId","betweenBigDecimal","formattedMinimum","formattedMaximum","clampBigDecimal","chunkArbitrary","fromIterable","chunkPretty","c","toReadonlyArray","chunkParse","isChunk","isEmpty","empty","ChunkFromSelf","Chunk","nonEmptyChunkArbitrary","unsafeFromNonEmptyArray","nonEmptyChunkPretty","nonEmptyChunkParse","NonEmptyChunkFromSelf","NonEmptyChunk","decodeData","struct","dataArbitrary","dataPretty","d","dataParse","isEqual","DataFromSelf","Data","assign","isField","isFields","every","getFields","hasFields","getSchemaFromFieldsOr","fieldsOr","getFieldsFromFieldsOr","Class","makeClass","kind","Base","getClassTag","TaggedClass","newFields","taggedFields","extendFields","TaggedError","prototype","hasMessageField","TaggedErrorClass","disableToString","defineProperty","get","enumerable","configurable","getASTDuplicatePropertySignatureErrorMessage","disableValidation","astCache","WeakMap","getClassAnnotations","classSymbol","typeAnnotations","transformationAnnotations","encodedAnnotations","typeSchema_","declarationSurrogate","typeSide","constructorSchema","encodedSide","transformationSurrogate","fallbackInstanceOf","klass","declaration","arb","SurrogateAnnotationId","newFieldsOr","newSchema","extendedFields","transformedFields","transformOrFailFrom","writable","FiberIdNoneEncoded","FiberIdRuntimeEncoded","startTimeMillis","FiberIdCompositeEncoded","FiberIdEncoded","fiberIdArbitrary","letrec","tie","None","Runtime","FiberId","fiberIdDecode","fiberIdPretty","fiberId","FiberIdFromSelf","isFiberId","runtime","composite","fiberIdEncode","causeDieEncoded","defect","CauseEmptyEncoded","causeFailEncoded","error","CauseInterruptEncoded","causeEncodedId","causeEncoded","error_","defect_","suspended","JSONIdentifierAnnotationId","causeArbitrary","Empty","Fail","Die","Interrupt","Sequential","Parallel","Cause","causeDecode","causePretty","causeParse","isCause","causeEncode","CauseFromSelf","die","interrupt","sequential","parallel","Defect","err","stack","prettyErrorMessage","exitFailureEncoded","exitSuccessEncoded","exitEncoded","exitDecode","failCause","exitArbitrary","exitPretty","exitParse","decodeUnknownValue","decodeUnknownCause","isExit","ExitFromSelf","failure","success","Exit","success_","failure_","hashSetArbitrary","hashSetPretty","hashSetEquivalence","hashSetParse","isHashSet","HashSetFromSelf","HashSet","hashMapArbitrary","hashMapPretty","hashMapEquivalence","hashMapParse","isHashMap","HashMapFromSelf","HashMap","listArbitrary","listPretty","listEquivalence","listParse","isList","ListFromSelf","List","sortedSetArbitrary","ord","sortedSetPretty","sortedSetParse","isSortedSet","SortedSetFromSelf","ordA","ordI","SortedSet","BooleanFromUnknown","isTruthy","BooleanFromString","Config","string","mapOrFail","InvalidData","TreeFormatter","formatIssueSync","symbolSerializable","asSerializable","serializable","serializableSchema","serialize","deserialize","symbolWithResult","asWithResult","withExit","failureSchema","successSchema","exitSchemaCache","exitSchema","proto","getPrototypeOf","serializeFailure","deserializeFailure","serializeSuccess","deserializeSuccess","serializeExit","deserializeExit","asSerializableWithResult","procedure","TaggedRequest","payload","TaggedRequestClass","go","getEquivalenceAnnotation","getAnnotation","hook","isSome","getEquivalenceUnsupportedErrorMessage","memoizeThunk","annotatedAST","len","j","isRecord","aStringKeys","aSymbolKeys","getOwnPropertySymbols","aHas","hasOwnProperty","call","bHas","bSymbolKeys","bStringKeys","encodedParameter","getEncodedParameter","isSymbolKeyword","aKeys","searchTree","getSearchTree","candidates","isRecordOrArray","buckets","otherwise","tuples","SymbolStruct","SymbolFromStruct","PropertyKey$","PropertyKey","ArrayFormatterIssue"],"mappings":"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","ignoreList":[]}}]
}